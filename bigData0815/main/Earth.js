(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Earth = {}));
})(this, (function (exports) { 'use strict';

  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s,
        _e,
        _x,
        _r,
        _arr = [],
        _n = !0,
        _d = !1;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i) return;
          _n = !1;
        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        var F = function () {};
        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
  function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
  function _classPrivateMethodInitSpec(obj, privateSet) {
    _checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }

  /**
   * @function
   *
   * @param {*} value The object.
   * @returns {Boolean} Returns true if the object is defined, returns false otherwise.
   *
   * @example
   * if (Earth.defined(positions)) {
   *      doSomething();
   * } else {
   *      doSomethingElse();
   * }
   */
  function defined$1(value) {
    return value !== undefined && value !== null;
  }

  /**
   * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
   * argument out of range, etc.  This exception should only be thrown during development;
   * it usually indicates a bug in the calling code.  This exception should never be
   * caught; instead the calling code should strive not to generate it.
   * <br /><br />
   * On the other hand, a {@link RuntimeError} indicates an exception that may
   * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
   * to catch.
   *
   * @alias DeveloperError
   * @constructor
   * @extends Error
   *
   * @param {String} [message] The error message for this exception.
   *
   * @see RuntimeError
   */
  function DeveloperError$1(message) {
    /**
     * 'DeveloperError' indicating that this exception was thrown due to a developer error.
     * @type {String}
     * @readonly
     */
    this.name = "DeveloperError";

    /**
     * The explanation for why this exception was thrown.
     * @type {String}
     * @readonly
     */
    this.message = message;

    //Browsers such as IE don't have a stack property until you actually throw the error.
    var stack;
    try {
      throw new Error();
    } catch (e) {
      stack = e.stack;
    }

    /**
     * The stack trace of this exception, if available.
     * @type {String}
     * @readonly
     */
    this.stack = stack;
  }
  if (defined$1(Object.create)) {
    DeveloperError$1.prototype = Object.create(Error.prototype);
    DeveloperError$1.prototype.constructor = DeveloperError$1;
  }
  DeveloperError$1.prototype.toString = function () {
    var str = "".concat(this.name, ": ").concat(this.message);
    if (defined$1(this.stack)) {
      str += "\n".concat(this.stack.toString());
    }
    return str;
  };

  /**
   * @private
   */
  DeveloperError$1.throwInstantiationError = function () {
    throw new DeveloperError$1("This function defines an interface and should not be called directly.");
  };

  /**
   * Contains functions for checking that supplied arguments are of a specified type
   * or meet specified conditions
   * @private
   */
  var Check = {};

  /**
   * Contains type checking functions, all using the typeof operator
   */
  Check.typeOf = {};
  function getUndefinedErrorMessage(name) {
    return "".concat(name, " is required, actual value was undefined");
  }
  function getFailedTypeErrorMessage(actual, expected, name) {
    return "Expected ".concat(name, " to be typeof ").concat(expected, ", actual typeof was ").concat(actual);
  }

  /**
   * Throws if test is not defined
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value that is to be checked
   * @exception {DeveloperError} test must be defined
   */
  Check.defined = function (name, test) {
    if (!defined$1(test)) {
      throw new DeveloperError$1(getUndefinedErrorMessage(name));
    }
  };

  /**
   * Throws if test is not typeof 'function'
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @exception {DeveloperError} test must be typeof 'function'
   */
  Check.typeOf.func = function (name, test) {
    if (typeof test !== "function") {
      throw new DeveloperError$1(getFailedTypeErrorMessage(_typeof(test), "function", name));
    }
  };

  /**
   * Throws if test is not typeof 'string'
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @exception {DeveloperError} test must be typeof 'string'
   */
  Check.typeOf.string = function (name, test) {
    if (typeof test !== "string") {
      throw new DeveloperError$1(getFailedTypeErrorMessage(_typeof(test), "string", name));
    }
  };

  /**
   * Throws if test is not typeof 'number'
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @exception {DeveloperError} test must be typeof 'number'
   */
  Check.typeOf.number = function (name, test) {
    if (typeof test !== "number") {
      throw new DeveloperError$1(getFailedTypeErrorMessage(_typeof(test), "number", name));
    }
  };

  /**
   * Throws if test is not typeof 'number' and less than limit
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @param {Number} limit The limit value to compare against
   * @exception {DeveloperError} test must be typeof 'number' and less than limit
   */
  Check.typeOf.number.lessThan = function (name, test, limit) {
    Check.typeOf.number(name, test);
    if (test >= limit) {
      throw new DeveloperError$1("Expected ".concat(name, " to be less than ").concat(limit, ", actual value was ").concat(test));
    }
  };

  /**
   * Throws if test is not typeof 'number' and less than or equal to limit
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @param {Number} limit The limit value to compare against
   * @exception {DeveloperError} test must be typeof 'number' and less than or equal to limit
   */
  Check.typeOf.number.lessThanOrEquals = function (name, test, limit) {
    Check.typeOf.number(name, test);
    if (test > limit) {
      throw new DeveloperError$1("Expected ".concat(name, " to be less than or equal to ").concat(limit, ", actual value was ").concat(test));
    }
  };

  /**
   * Throws if test is not typeof 'number' and greater than limit
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @param {Number} limit The limit value to compare against
   * @exception {DeveloperError} test must be typeof 'number' and greater than limit
   */
  Check.typeOf.number.greaterThan = function (name, test, limit) {
    Check.typeOf.number(name, test);
    if (test <= limit) {
      throw new DeveloperError$1("Expected ".concat(name, " to be greater than ").concat(limit, ", actual value was ").concat(test));
    }
  };

  /**
   * Throws if test is not typeof 'number' and greater than or equal to limit
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @param {Number} limit The limit value to compare against
   * @exception {DeveloperError} test must be typeof 'number' and greater than or equal to limit
   */
  Check.typeOf.number.greaterThanOrEquals = function (name, test, limit) {
    Check.typeOf.number(name, test);
    if (test < limit) {
      throw new DeveloperError$1("Expected ".concat(name, " to be greater than or equal to ").concat(limit, ", actual value was ").concat(test));
    }
  };

  /**
   * Throws if test is not typeof 'object'
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @exception {DeveloperError} test must be typeof 'object'
   */
  Check.typeOf.object = function (name, test) {
    if (_typeof(test) !== "object") {
      throw new DeveloperError$1(getFailedTypeErrorMessage(_typeof(test), "object", name));
    }
  };

  /**
   * Throws if test is not typeof 'boolean'
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @exception {DeveloperError} test must be typeof 'boolean'
   */
  Check.typeOf.bool = function (name, test) {
    if (typeof test !== "boolean") {
      throw new DeveloperError$1(getFailedTypeErrorMessage(_typeof(test), "boolean", name));
    }
  };

  /**
   * Throws if test is not typeof 'bigint'
   *
   * @param {String} name The name of the variable being tested
   * @param {*} test The value to test
   * @exception {DeveloperError} test must be typeof 'bigint'
   */
  Check.typeOf.bigint = function (name, test) {
    if (typeof test !== "bigint") {
      throw new DeveloperError$1(getFailedTypeErrorMessage(_typeof(test), "bigint", name));
    }
  };

  /**
   * Throws if test1 and test2 is not typeof 'number' and not equal in value
   *
   * @param {String} name1 The name of the first variable being tested
   * @param {String} name2 The name of the second variable being tested against
   * @param {*} test1 The value to test
   * @param {*} test2 The value to test against
   * @exception {DeveloperError} test1 and test2 should be type of 'number' and be equal in value
   */
  Check.typeOf.number.equals = function (name1, name2, test1, test2) {
    Check.typeOf.number(name1, test1);
    Check.typeOf.number(name2, test2);
    if (test1 !== test2) {
      throw new DeveloperError$1("".concat(name1, " must be equal to ").concat(name2, ", the actual values are ").concat(test1, " and ").concat(test2));
    }
  };

  /**
   * Returns the first parameter if not undefined, otherwise the second parameter.
   * Useful for setting a default value for a parameter.
   *
   * @function
   *
   * @param {*} a
   * @param {*} b
   * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.
   *
   * @example
   * param = Earth.defaultValue(param, 'default');
   */
  function defaultValue$1(a, b) {
    if (a !== undefined && a !== null) {
      return a;
    }
    return b;
  }

  /**
   * A frozen empty object that can be used as the default value for options passed as
   * an object literal.
   * @type {Object}
   * @memberof defaultValue
   */
  defaultValue$1.EMPTY_OBJECT = Object.freeze({});

  /* This file is automatically rebuilt by the Cesium build process. */
  /*
    https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
    so it's better encapsulated. Now you can have multiple random number generators
    and they won't stomp all over eachother's state.

    If you want to use this as a substitute for Math.random(), use the random()
    method like so:

    var m = new MersenneTwister();
    var randomNumber = m.random();

    You can also call the other genrand_{foo}() methods on the instance.

    If you want to use a specific seed in order to get a repeatable random
    sequence, pass an integer into the constructor:

    var m = new MersenneTwister(123);

    and that will always produce the same random sequence.

    Sean McCullough (banksean@gmail.com)
  */

  /*
     A C-program for MT19937, with initialization improved 2002/1/26.
     Coded by Takuji Nishimura and Makoto Matsumoto.

     Before using, initialize the state by using init_seed(seed)
     or init_by_array(init_key, key_length).

     Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

       1. Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.

       2. Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.

       3. The names of its contributors may not be used to endorse or promote
          products derived from this software without specific prior written
          permission.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


     Any feedback is very welcome.
     http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
     email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
  */

  var MersenneTwister = function MersenneTwister(seed) {
    if (seed == undefined) {
      seed = new Date().getTime();
    }

    /* Period parameters */
    this.N = 624;
    this.M = 397;
    this.MATRIX_A = 0x9908b0df; /* constant vector a */
    this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
    this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

    this.mt = new Array(this.N); /* the array for the state vector */
    this.mti = this.N + 1; /* mti==N+1 means mt[N] is not initialized */

    if (seed.constructor == Array) {
      this.init_by_array(seed, seed.length);
    } else {
      this.init_seed(seed);
    }
  };

  /* initializes mt[N] with a seed */
  /* origin name init_genrand */
  MersenneTwister.prototype.init_seed = function (s) {
    this.mt[0] = s >>> 0;
    for (this.mti = 1; this.mti < this.N; this.mti++) {
      var s = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
      this.mt[this.mti] = (((s & 0xffff0000) >>> 16) * 1812433253 << 16) + (s & 0x0000ffff) * 1812433253 + this.mti;
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array mt[].                        */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      this.mt[this.mti] >>>= 0;
      /* for >32 bit machines */
    }
  };

  /* initialize by an array with array-length */
  /* init_key is the array for initializing keys */
  /* key_length is its length */
  /* slight change for C++, 2004/2/26 */
  MersenneTwister.prototype.init_by_array = function (init_key, key_length) {
    var i, j, k;
    this.init_seed(19650218);
    i = 1;
    j = 0;
    k = this.N > key_length ? this.N : key_length;
    for (; k; k--) {
      var s = this.mt[i - 1] ^ this.mt[i - 1] >>> 30;
      this.mt[i] = (this.mt[i] ^ (((s & 0xffff0000) >>> 16) * 1664525 << 16) + (s & 0x0000ffff) * 1664525) + init_key[j] + j; /* non linear */
      this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
      i++;
      j++;
      if (i >= this.N) {
        this.mt[0] = this.mt[this.N - 1];
        i = 1;
      }
      if (j >= key_length) j = 0;
    }
    for (k = this.N - 1; k; k--) {
      var s = this.mt[i - 1] ^ this.mt[i - 1] >>> 30;
      this.mt[i] = (this.mt[i] ^ (((s & 0xffff0000) >>> 16) * 1566083941 << 16) + (s & 0x0000ffff) * 1566083941) - i; /* non linear */
      this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
      i++;
      if (i >= this.N) {
        this.mt[0] = this.mt[this.N - 1];
        i = 1;
      }
    }
    this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
  };

  /* generates a random number on [0,0xffffffff]-interval */
  /* origin name genrand_int32 */
  MersenneTwister.prototype.random_int = function () {
    var y;
    var mag01 = new Array(0x0, this.MATRIX_A);
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (this.mti >= this.N) {
      /* generate N words at one time */
      var kk;
      if (this.mti == this.N + 1) /* if init_seed() has not been called, */
        this.init_seed(5489); /* a default initial seed is used */

      for (kk = 0; kk < this.N - this.M; kk++) {
        y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
        this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ mag01[y & 0x1];
      }
      for (; kk < this.N - 1; kk++) {
        y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
        this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ mag01[y & 0x1];
      }
      y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
      this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ mag01[y & 0x1];
      this.mti = 0;
    }
    y = this.mt[this.mti++];

    /* Tempering */
    y ^= y >>> 11;
    y ^= y << 7 & 0x9d2c5680;
    y ^= y << 15 & 0xefc60000;
    y ^= y >>> 18;
    return y >>> 0;
  };

  /* generates a random number on [0,0x7fffffff]-interval */
  /* origin name genrand_int31 */
  MersenneTwister.prototype.random_int31 = function () {
    return this.random_int() >>> 1;
  };

  /* generates a random number on [0,1]-real-interval */
  /* origin name genrand_real1 */
  MersenneTwister.prototype.random_incl = function () {
    return this.random_int() * (1.0 / 4294967295.0);
    /* divided by 2^32-1 */
  };

  /* generates a random number on [0,1)-real-interval */
  MersenneTwister.prototype.random = function () {
    return this.random_int() * (1.0 / 4294967296.0);
    /* divided by 2^32 */
  };

  /* generates a random number on (0,1)-real-interval */
  /* origin name genrand_real3 */
  MersenneTwister.prototype.random_excl = function () {
    return (this.random_int() + 0.5) * (1.0 / 4294967296.0);
    /* divided by 2^32 */
  };

  /* generates a random number on [0,1) with 53-bit resolution*/
  /* origin name genrand_res53 */
  MersenneTwister.prototype.random_long = function () {
    var a = this.random_int() >>> 5,
      b = this.random_int() >>> 6;
    return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
  };

  /* These real versions are due to Isaku Wada, 2002/01/09 added */

  var mersenneTwister = MersenneTwister;

  function PIEString$1(value) {
    var type = _typeof(value);
    if (type == 'string') {
      //this.handle = Module.allocate(intArrayFromString(value), 1);
      this.handle = Module.allocateUTF8(value);
    } else if (type == 'number') {
      this.handle = Module._malloc(value);
    } else {
      this.handle = null;
    }
  }
  Object.assign(PIEString$1.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.handle != null) {
        Module._free(this.handle);
        this.handle = null;
      }
    },
    toString: function toString() {
      if (this.handle != null) {
        return Module.UTF8ToString(this.handle);
      }
      return null;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建回调事件
   * @name Event
   * @class Event
   * 回调事件操作函数
   * @example
   * MyObject.prototype.myListener = function(arg1, arg2) {
   *   this.myArg1Copy = arg1;
   *   this.myArg2Copy = arg2;
   * }
   * const myObjectInstance = new MyObject();
   * const evt = new PIE.Event();
   * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
   * evt.raiseEvent('1', '2');
   * evt.removeEventListener(MyObject.prototype.myListener);
   */
  function PIEEvent() {
    this._listeners = [];
    this._scopes = [];
    this._toRemove = [];
    this._insideRaiseEvent = false;
  }
  function compareNumber$1(a, b) {
    return b - a;
  }
  Object.assign(PIEEvent.prototype, {
    /**
     * 添加监听器
     * @param {Function} listener -监听函数
     * @param {Object} scope -一个可选的对象范围，用作this指针，监听器函数在其中执行
     * @returns {Function} 返回removeEventListener，调用则删除事件监听器
     * @memberOf Event#
     *
     */
    addEventListener: function addEventListener(listener, scope) {
      this._listeners.push(listener);
      this._scopes.push(scope);
      var event = this;
      return function () {
        event.removeEventListener(listener, scope);
      };
    },
    /**
     * 删除监听器
     * @param {Function} listener 要注销的监听器
     * @param {Object} scope 最初传递给addEventListener 的范围
     * @returns {Boolean} true如果监听器被移除；false如果监听器和范围未在事件中注册
     * @memberOf Event#
     *
     */
    removeEventListener: function removeEventListener(listener, scope) {
      var listeners = this._listeners;
      var scopes = this._scopes;
      var index = -1;
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener && scopes[i] === scope) {
          index = i;
          break;
        }
      }
      if (index !== -1) {
        if (this._insideRaiseEvent) {
          this._toRemove.push(index);
          listeners[index] = undefined;
          scopes[index] = undefined;
        } else {
          listeners.splice(index, 1);
          scopes.splice(index, 1);
        }
        return true;
      }
      return false;
    },
    /**
     * 通过使用所有提供的参数调用每个已注册的监听器来引发事件
     * @param {Object} arguments 此方法接受任意数量的参数并将它们传递给监听器函数
     * @memberOf Event#
     *
     */
    raiseEvent: function raiseEvent() {
      this._insideRaiseEvent = true;
      var i;
      var listeners = this._listeners;
      var scopes = this._scopes;
      var length = listeners.length;
      for (i = 0; i < length; i++) {
        var listener = listeners[i];
        if (listener != null && listener != undefined) {
          listeners[i].apply(scopes[i], arguments);
        }
      }
      var toRemove = this._toRemove;
      length = toRemove.length;
      if (length > 0) {
        toRemove.sort(compareNumber$1);
        for (i = 0; i < length; i++) {
          var index = toRemove[i];
          listeners.splice(index, 1);
          scopes.splice(index, 1);
        }
        toRemove.length = 0;
      }
      this._insideRaiseEvent = false;
    },
    /**
     * 获取监听器个数
     * @memberOf Event#
     * @returns {Number} 返回监听器个数
     */
    getListenerCount: function getListenerCount() {
      return this._listeners.length - this._toRemove.length;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 几何对象类型枚举
   * @readonly
   * @enum {number}
   */
  var PIEGeometryType$1 = {
    Null: 0,
    /** 点类型 */
    Point: 1,
    /** 线类型 */
    Line: 3,
    /** 面类型 */
    Region: 5,
    /**复杂面类型*/
    MultiRegion: 8,
    /** 文本类型 */
    Text: 7,
    /**复合对象*/
    Compound: 1000,
    /**三维点*/
    Point3D: 2049,
    /**三维线*/
    Line3D: 2051,
    /**三维面*/
    Region3D: 2053,
    /**三维文本*/
    Text3D: 2055,
    /**三维模型*/
    Model3D: 2176,
    /** 标绘类型 */
    GeoPlot: 1042,
    /** 贴地标绘类型 */
    GeoPlotSurface: 1046,
    /** 三维标绘类型 */
    GeoPlot3D: 1047
  };

  var PIEArrayType = {
    Int8: 0,
    UInt8: 1,
    UInt16: 2,
    Int16: 3,
    UInt32: 4,
    Int32: 5,
    Float32: 6,
    Float64: 7
  };

  function PIEArray(value, type) {
    var array = value;
    this.type = type;
    if (value instanceof Array) {
      if (type == PIEArrayType.Int8) {
        array = new Int8Array(value);
      } else if (type == PIEArrayType.UInt8) {
        array = new Uint8Array(value);
      } else if (type == PIEArrayType.UInt16) {
        array = new Uint16Array(value);
      } else if (type == PIEArrayType.Int16) {
        array = new Int16Array(value);
      } else if (type == PIEArrayType.UInt32) {
        array = new Uint32Array(value);
      } else if (type == PIEArrayType.Int32) {
        array = new Int32Array(value);
      } else if (type == PIEArrayType.Float32) {
        array = new Float32Array(value);
      } else if (type == PIEArrayType.Float64) {
        array = new Float64Array(value);
      }
    } else if (value instanceof Number || typeof value == "number") {
      if (type == PIEArrayType.Int8) {
        array = new Int8Array(value);
      } else if (type == PIEArrayType.UInt8) {
        array = new Uint8Array(value);
      } else if (type == PIEArrayType.UInt16) {
        array = new Uint16Array(value);
      } else if (type == PIEArrayType.Int16) {
        array = new Int16Array(value);
      } else if (type == PIEArrayType.UInt32) {
        array = new Uint32Array(value);
      } else if (type == PIEArrayType.Int32) {
        array = new Int32Array(value);
      } else if (type == PIEArrayType.Float32) {
        array = new Float32Array(value);
      } else if (type == PIEArrayType.Float64) {
        array = new Float64Array(value);
      }
    }
    if (array != null) {
      this.array = array;
      // this.handle = Module._malloc(this.array.length * this.array.BYTES_PER_ELEMENT);
      this.handle = Module._Array_Create(this.array, this.array.length, type);
    }
    if (array instanceof Int8Array) {
      //Module.HEAP8.set(this.array, this.handle);
      Module.GROWABLE_HEAP_I8().set(this.array, this.handle);
      // Module.heapObjectForWebGLType(5120).set(this.array, this.handle);
    } else if (array instanceof Uint8Array) {
      //Module.HEAPU8.set(this.array, this.handle);
      Module.GROWABLE_HEAP_U8().set(this.array, this.handle);
      // Module.heapObjectForWebGLType(5121).set(this.array, this.handle);
    } else if (array instanceof Int16Array) {
      //Module.HEAP16.set(this.array, this.handle >> 1);
      Module.GROWABLE_HEAP_I16().set(this.array, this.handle >> 1);
      // Module.heapObjectForWebGLType(5122).set(this.array, this.handle >> 1);
    } else if (array instanceof Uint16Array) {
      //Module.HEAPU16.set(this.array, this.handle >> 1);
      Module.GROWABLE_HEAP_U16().set(this.array, this.handle >> 1);
      // Module.heapObjectForWebGLType(0).set(this.array, this.handle >> 1);
    } else if (array instanceof Int32Array) {
      //Module.HEAP32.set(this.array, this.handle >> 2);
      Module.GROWABLE_HEAP_I32().set(this.array, this.handle >> 2);
      // Module.heapObjectForWebGLType(5124).set(this.array, this.handle >> 2);
    } else if (array instanceof Uint32Array) {
      //Module.HEAPU32.set(this.array, this.handle >> 2);
      Module.GROWABLE_HEAP_U32().set(this.array, this.handle >> 2);
      // Module.heapObjectForWebGLType(5125).set(this.array, this.handle >> 2);
    } else if (array instanceof Float32Array) {
      //Module.HEAPF32.set(this.array, this.handle >> 2);
      Module.GROWABLE_HEAP_F32().set(this.array, this.handle >> 2);
      // Module.heapObjectForWebGLType(5126).set(this.array, this.handle >> 2);
    } else if (array instanceof Float64Array) {
      //Module.HEAPF64.set(this.array, this.handle >> 3);
      Module.GROWABLE_HEAP_F64().set(this.array, this.handle >> 3);
      // Module.heapObjectForWebGLType(5127).set(this.array, this.handle >> 3);
    }
  }

  Object.assign(PIEArray.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.handle != null) {
        // Module._free(this.handle);
        Module._Array_Delete(this.handle, this.type);
        this.handle = null;
      }
    },
    toArrayBuffer: function toArrayBuffer() {
      return this.array;
    },
    toArray: function toArray() {
      var array = Array.prototype.slice.call(this.array);
      return array;
      //return Array.apply([], this.array);
    },

    updateData: function updateData() {
      var type = this.type;
      if (type == PIEArrayType.Int8) {
        var ptr = this.getHandle();
        var buffer = Module.HEAP8.subarray(ptr, ptr + this.array.length);
        this.array = new Int8Array(buffer);
      } else if (type == PIEArrayType.UInt8) {
        var ptr = this.getHandle();
        var buffer = Module.HEAPU8.subarray(ptr, ptr + this.array.length);
        this.array = new Uint8Array(buffer);
      } else if (type == PIEArrayType.UInt16) {
        var ptr = this.getHandle() >> 1;
        var buffer = Module.HEAPU16.subarray(ptr, ptr + this.array.length);
        this.array = new Uint16Array(buffer);
      } else if (type == PIEArrayType.Int16) {
        var ptr = this.getHandle() >> 1;
        var buffer = Module.HEAP16.subarray(ptr, ptr + this.array.length);
        this.array = new Int16Array(buffer);
      } else if (type == PIEArrayType.UInt32) {
        var ptr = this.getHandle() >> 2;
        var buffer = Module.HEAPU32.subarray(ptr, ptr + this.array.length);
        this.array = new Uint32Array(buffer);
      } else if (type == PIEArrayType.Int32) {
        var ptr = this.getHandle() >> 2;
        var buffer = Module.HEAP32.subarray(ptr, ptr + this.array.length);
        this.array = new Int32Array(buffer);
      } else if (type == PIEArrayType.Float32) {
        var ptr = this.getHandle() >> 3;
        var buffer = Module.HEAPF32.subarray(ptr, ptr + this.array.length);
        this.array = new Float32Array(buffer);
      } else if (type == PIEArrayType.Float64) {
        var ptr = this.getHandle() >> 3;
        var buffer = Module.HEAPF64.subarray(ptr, ptr + this.array.length);
        this.array = new Float64Array(buffer);
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 二维向量类
   * @name Vector2
   * @class Vector2
   *
   * @param {Number} x -x值
   * @param {Number} y -y值
   */
  function PIEVector2(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  }
  Object.assign(PIEVector2.prototype, {
    /**
     * 进行规格化
     * @memberOf Vector2#
     *
     */
    normalize: function normalize() {
      var length = this.length();
      if (length != 0) {
        this.x /= length;
        this.y /= length;
      }
    },
    /**
     * 进行归一化
     *
     * @memberOf Vector2#
     * @returns {PIEVector2} 返回归一化后的向量
     *
     */
    normalized: function normalized() {
      var v = new PIEVector2(this.x, this.y);
      v.normalize();
      return v;
    },
    /**
     * 求向量的长度
     *
     * @memberOf Vector2#
     * @returns {number} 返回向量的长度
     *
     */
    length: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    /**
     * 自身缩放
     * @param {Number} s -value
     * @memberOf Vector2#
     *
     * @returns {PIEVector2} 返回缩放后的向量
     *
     */
    scale: function scale(s) {
      return new PIEVector2(this.x * s, this.y * s);
    },
    /**
     * 向量相减
     * @param {PIEVector2} vec -二维向量
     * @memberOf Vector2#
     *
     * @returns {PIEVector2} 返回相减后的向量
     */
    sub: function sub(vec) {
      return new PIEVector2(this.x - vec.x, this.y - vec.y);
    },
    /**
     * 向量相加
     * @param {PIEVector2} vec -二维向量
     * @memberOf Vector2#
     *
     * @returns {PIEVector2} 返回相加后的向量
     *
     */
    add: function add(vec) {
      return new PIEVector2(this.x + vec.x, this.y + vec.y);
    },
    /**
     * 向量相乘
     * @param {PIEVector2} vec -二维向量
     * @memberOf Vector2#
     *
     * @returns {PIEVector2} 返回相加后的向量
     *
     */
    multiply: function multiply(vec) {
      this.x *= vec.x;
      this.y *= vec.y;
      return this;
    },
    /**
     * 克隆向量
     *
     * @memberOf Vector2#
     * @returns {PIEVector2} 返回克隆后的向量
     *
     */
    clone: function clone() {
      return new PIEVector2(this.x, this.y);
    },
    toArray: function toArray() {
      return [this.x, this.y];
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 数学模块
   * @name Math
   * @interface
   */
  function PIEMath() {}
  /**
   * 极小值定义
   *
   * @memberOf Math
   */
  PIEMath.EP = 1e-13;
  /**
   * 弧度转角度
   *
   * @memberOf Math
   */
  PIEMath.RTOD = 57.295779513082320876798154814;
  /**
   * 角度转弧度
   *
   * @memberOf Math
   */
  PIEMath.DTOR = 0.0174532925199432957692369077;
  /**
   * 地球半径
   *
   * @memberOf Math
   */
  PIEMath.EARTH_RADIUS = 6378137;
  /**
   * 地球周长
   *
   * @memberOf Math
   */
  PIEMath.EARTH_CIRCUM = 2 * Math.PI * PIEMath.EARTH_RADIUS;
  PIEMath.EARTH_LTOWRATIO = 0.762; // (423.0 / 555.0)
  /**
   * double最大值
   *
   * @memberOf Math
   */
  PIEMath.DBLMAX = 1.7976931348623158e+308;
  /**
   * double最小值
   *
   * @memberOf Math
   */
  PIEMath.DBLMIN = 2.2250738585072014e-308;
  /**
   * float 最大值
   *
   * @memberOf Math
   */
  PIEMath.FLTMAX = 3.402823466e+38;
  /**
   * float 最小值
   *
   * @memberOf Math
   */
  PIEMath.FLTMIN = 1.175494351e-38;
  PIEMath.round = function (value) {
    return value > 0 ? value + 0.5 : value - 0.5;
  };
  /**
   * 给出弧度计算点旋转(逆时针方向)
   * @param {PIEVector2} pntAnchor -中心点
   * @param {Number} dRadian -顺时针旋转角度
   * @param {PIEVector2} pntSource -待旋转坐标点
   *
   * @memberOf Math
   */
  PIEMath.rotateRadian = function (pntAnchor, dRadian, pntSource) {
    var dCos = Math.cos(dRadian);
    var dSin = Math.sin(dRadian);
    var xx = pntSource.x - pntAnchor.x;
    var yy = pntSource.y - pntAnchor.y;
    pntSource.x = xx * dCos - yy * dSin + pntAnchor.x;
    pntSource.y = xx * dSin + yy * dCos + pntAnchor.y;
    return pntSource;
  };

  /**
   * 给出圆心和半径求圆周上的坐标
   * @param {array} center -圆心点
   * @param {Number} radius -半径
   * @param {Number} count -点个数
   * @returns {array} 返回坐标数组
   * @memberOf Math
   */
  PIEMath.circularPoints = function (center, radius, count) {
    var pointsCircle = [];
    for (var times = 0; times < count; times++) {
      var radian = 2 * Math.PI / count * times;
      var x = center[0] + Math.sin(radian) * radius;
      var y = center[1] - Math.cos(radian) * radius;
      pointsCircle.push(x);
      pointsCircle.push(y);
    }
    return pointsCircle;
  };

  /**
   * 判断是否是零值
   * @param {Number} value -value值
   * @memberOf Math
   * @returns {Boolean} 返回判断结果
   */
  PIEMath.isZero = function (value) {
    return value < 1e-13 && value > -1e-13;
  };

  /**
   * 判断是否相等
   * @param {Number} value1 -value1值
   * @param {Number} value2 -value2值
   * @memberOf Math
   * @returns {Boolean} 返回是否相等
   */
  PIEMath.isEqual = function (value1, value2) {
    if (value1 == 0) {
      return PIEMath.isZero(value2);
    } else if (value2 == 0) {
      return PIEMath.isZero(value1);
    }
    var dMaxValue = Math.max(Math.abs(value1), Math.abs(value2));
    var dAbsolute = value1 - value2;
    return dAbsolute >= -1e-13 * dMaxValue && dAbsolute <= 1e-13 * dMaxValue;
  };
  PIEMath.isEq = function (dValue1, dValue2, dTolerance) {
    if (dTolerance > 0) {
      var dTemp = dValue1 - dValue2;
      return dTemp > -dTolerance && dTemp < dTolerance;
    }
    return false;
  };
  // /**
  //  * 矩阵和矩阵相乘
  //  * @param {Number} lhs -左矩阵
  //  * @param {Number} rhs -右矩阵
  //  * @param {Number} out -结果矩阵
  //  *
  //  * @memberOf Math
  //  */
  // PIEMath.multiplyMM = function (lhs, rhs, out) {
  //     var i = 0;
  //     var j = 0;
  //     for (i = 0; i < 4; i++) {
  //         var rhs_i0 = rhs[4 * i];
  //         var ri0 = lhs[0] * rhs_i0;
  //         var ri1 = lhs[1] * rhs_i0;
  //         var ri2 = lhs[2] * rhs_i0;
  //         var ri3 = lhs[3] * rhs_i0;
  //
  //         for (j = 1; j < 4; j++) {
  //             var rhs_ij = rhs[4 * i + j];
  //             ri0 += lhs[4 * j] * rhs_ij;
  //             ri1 += lhs[4 * j + 1] * rhs_ij;
  //             ri2 += lhs[4 * j + 2] * rhs_ij;
  //             ri3 += lhs[4 * j + 3] * rhs_ij;
  //         }
  //
  //         out[4 * i] = ri0;
  //         out[4 * i + 1] = ri1;
  //         out[4 * i + 2] = ri2;
  //         out[4 * i + 3] = ri3;
  //     }
  // }

  PIEMath.compute2DAngleFromY = function (x, y) {
    if (PIEMath.isZero(x)) {
      return 0;
    }
    var dAngle = 0.0;
    if (x < 0 && y > 0) {
      dAngle = Math.PI / 2 - Math.atan(Math.abs(y / x));
    } else if (x < 0 && y < 0) {
      dAngle = Math.atan(Math.abs(y / x)) + Math.PI / 2;
    } else if (x > 0 && y < 0) {
      dAngle = 3 * Math.PI / 2 - Math.atan(Math.abs(y / x));
    } else if (x > 0 && y > 0) {
      dAngle = 3 * Math.PI / 2 + Math.atan(Math.abs(y / x));
    } else if (PIEMath.isZero(y) && x < 0) {
      dAngle = Math.PI / 2;
    } else if (PIEMath.isZero(x) && y < 0) {
      dAngle = Math.PI;
    } else if (PIEMath.isZero(y) && x > 0) {
      dAngle = 3 * Math.PI / 2;
    } else if (PIEMath.isZero(x) && y > 0) {
      dAngle = 0;
    }
    return dAngle;
  };
  /**
   * 球面两点间的距离
   * @param {PIEVector2|Array} pntFrom -经纬坐标
   * @param {PIEVector2|Array} pntTo -经纬坐标
   *
   * @memberOf Math
   */
  PIEMath.sphereDistance = function (pntFrom, pntTo) {
    if (pntFrom instanceof Array) {
      pntFrom = new PIEVector2(pntFrom[0], pntFrom[1]);
    }
    if (pntTo instanceof Array) {
      pntTo = new PIEVector2(pntTo[0], pntTo[1]);
    }
    if (pntFrom.x > 180 || pntFrom.x < -180 || pntTo.x > 180 || pntTo.x < -180 || pntFrom.y > 180 / 2 || pntFrom.y < -180 / 2 || pntTo.y > 180 / 2 || pntTo.y < -180 / 2) {
      return 0;
    }
    var dLongDist = pntFrom.x - pntTo.x;
    if (dLongDist < -180) {
      dLongDist += 2 * 180;
    } else if (dLongDist > 180) {
      dLongDist = 2 * 180 - dLongDist;
    }
    var dPnt1Latitude = pntFrom.y;
    var dPnt2Latitude = pntTo.y;
    var dCospnt1 = Math.cos(dPnt1Latitude * (Math.PI / 180));
    var dCospnt2 = Math.cos(dPnt2Latitude * (Math.PI / 180));
    var dSinpnt1 = Math.sin(dPnt1Latitude * (Math.PI / 180));
    var dSinpnt2 = Math.sin(dPnt2Latitude * (Math.PI / 180));
    var dSinDist = dSinpnt1 - dSinpnt2;
    var dValue = dSinDist * dSinDist + dCospnt1 * dCospnt1 + dCospnt2 * dCospnt2 - 2 * dCospnt1 * dCospnt2 * Math.cos(dLongDist * (Math.PI / 180));
    if (dValue < 0) {
      dValue = 0;
    }
    //这是以pnt1和pnt2所在大圆最短圆弧长
    var dLength = 2 * Math.asin(Math.sqrt(dValue) / 2) * 6371118;
    return dLength;
  };
  /**
   * 返回范围内的一个数值
   * @param {Number} x -要钳制在范围内的属性或变量
   * @param {Number} lowerlimit -最小数值
   * @param {Number} upperlimit -最大数值
   *
   * @memberOf Math
   * @returns {Number} 如果参数大于范围，将返回最大数值，如果参数小于范围，该函数将返回最小数值
   *
   *
   */
  PIEMath.clamp = function (x, lowerlimit, upperlimit) {
    if (x < lowerlimit) {
      x = lowerlimit;
    } else if (x > upperlimit) {
      x = upperlimit;
    }
    return x;
  };

  // /**
  //  * 求解两个值之间的样条插值
  //  * @param {Number} edge0 -样条插值函数的下界
  //  * @param {Number} edge1 -样条插值函数的上界
  //  * @param {Number} x -插值的源输入
  //  *
  //  * @memberOf math#
  //  * @returns {number}
  //  */
  PIEMath.smoothstep = function (edge0, edge1, x) {
    x = PIEMath.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * x * (x * (x * 6 - 15) + 10);
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建四至范围
   * @name Bounds
   * @class Bounds
   * 四至范围类
   *
   * @param {Number} left -左值
   * @param {Number} top -上值
   * @param {Number} right -右值
   * @param {Number} bottom -下值
   */
  function PIEBounds(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  Object.assign(PIEBounds.prototype, {
    /**
     * 设置为空
     * @memberOf Bounds#
     *
     */
    setEmpty: function setEmpty() {
      this.left = this.top = this.right = this.bottom = 0;
    },
    /**
     * 判断是否为空
     * @memberOf Bounds#
     * @returns {Boolean} 返回是否为空
     *
     */
    isEmpty: function isEmpty() {
      return this.left >= this.right || this.bottom >= this.top;
    },
    /**
     * 判断是否为空
     * @memberOf Bounds#
     * @returns {Boolean} 返回是否为空
     */
    isNull: function isNull() {
      return PIEMath.isZero(this.left) && PIEMath.isZero(this.right) && PIEMath.isZero(this.bottom) && PIEMath.isZero(this.top);
    },
    /**
     * 获取宽度
     * @memberOf Bounds#
     * @returns {Number} 返回宽度
     */
    getWidth: function getWidth() {
      return this.right - this.left;
    },
    /**
     * 获取高度
     * @memberOf Bounds#
     * @returns {Number} 返回高度
     *
     */
    getHeight: function getHeight() {
      return this.top - this.bottom;
    },
    /**
     * 点扩充
     * @param {PIEVector2} point -点
     * @memberOf Bounds#
     *
     */
    unionPoint: function unionPoint(point) {
      if (this.left > point.x) {
        this.left = point.x;
      }
      if (this.right < point.x) {
        this.right = point.x;
      }
      if (this.top < point.y) {
        this.top = point.y;
      }
      if (this.bottom > point.y) {
        this.bottom = point.y;
      }
    },
    /**
     * 范围扩充
     * @param {PIEBounds} bounds -范围
     * @memberOf Bounds#
     *
     */
    unionBounds: function unionBounds(bounds) {
      if (this.left > bounds.left) {
        this.left = bounds.left;
      }
      if (this.right < bounds.right) {
        this.right = bounds.right;
      }
      if (this.top < bounds.top) {
        this.top = bounds.top;
      }
      if (this.bottom > bounds.bottom) {
        this.bottom = bounds.bottom;
      }
    },
    /**
     * 范围扩大
     * @param {Number} leftmargin -左值的膨胀尺寸
     * @param {Number} topmargin -上值的膨胀尺寸
     * @param {Number} rightmargin -右值的膨胀尺寸
     * @param {Number} bottommargin -下值的膨胀尺寸
     * @memberOf Bounds#
     *
     */
    inflate: function inflate(leftmargin, topmargin, rightmargin, bottommargin) {
      this.left -= leftmargin;
      this.top += topmargin;
      this.right += rightmargin;
      this.bottom -= bottommargin;
    },
    /**
     * 范围缩小
     * @param {Number} leftmargin -左值的收缩尺寸
     * @param {Number} topmargin -上值的收缩尺寸
     * @param {Number} rightmargin -右值的收缩尺寸
     * @param {Number} bottommargin -下值的收缩尺寸
     * @memberOf Bounds#
     *
     */
    deflate: function deflate(leftmargin, topmargin, rightmargin, bottommargin) {
      this.inflate(-leftmargin, -topmargin, -rightmargin, -bottommargin);
    },
    /**
     * 范围是否相交
     * @param {PIEBounds} bounds -范围
     * @memberOf Bounds#
     * @returns {Boolean} 返回是否相交
     *
     */
    isIntersect: function isIntersect(bounds) {
      return this.right >= bounds.left && this.left <= bounds.right && this.top >= bounds.bottom && this.bottom <= bounds.top;
    },
    /**
     * 获取中心点
     * @memberOf Bounds#
     * @returns {PIEVector2} 返回中心点
     *
     */
    getCenter: function getCenter() {
      return new PIEVector2((this.right + this.left) / 2, (this.top + this.bottom) / 2);
    },
    /**
     * 拷贝数据
     * @param {PIEBounds} bounds -范围
     * @memberOf Bounds#
     *
     */
    copy: function copy(bounds) {
      this.left = bounds.left;
      this.top = bounds.top;
      this.right = bounds.right;
      this.bottom = bounds.bottom;
    },
    toArray: function toArray() {
      var array = [this.left, this.top, this.right, this.bottom];
      return array;
    }
  });
  PIEBounds.fromArray = function (array) {
    var arrayBuffer = null;
    if (array instanceof PIEArray) {
      arrayBuffer = array.toArrayBuffer();
    } else if (array instanceof Array) {
      arrayBuffer = array;
    }
    return new PIEBounds(arrayBuffer[0], arrayBuffer[1], arrayBuffer[2], arrayBuffer[3]);
  };
  PIEBounds.toArray = function (rect) {
    return new PIEArray([rect.left, rect.top, rect.right, rect.bottom], PIEArrayType.Float64);
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 风格类型枚举
   * @readonly
   * @enum {number}
   */
  var PIEStyleType = {
    /**空类型*/
    Null: 0,
    /**矢量风格类型*/
    Vector: 1,
    /**文本风格类型*/
    Text: 2,
    /**复合风格类型*/
    Symbol: 3
    // /**模型风格类型*/
    // Model: 4
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 风格基类操作函数
   * @name Style
   *
   */
  function PIEStyle(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEStyle.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 删除对象
     * @memberOf Style#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._Style_Delete(this.handle);
      }
      this.handle = null;
    },
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    /**
     * 获取风格类型
     *
     * @memberOf Style#
     * @returns {PIEStyleType} 返回风格类型
     */
    getType: function getType() {
      return Module._Style_GetType(this.handle);
    },
    /**
     * 获取风格名称
     *
     * @memberOf Style#
     * @returns {String} 返回的风格名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Style_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置风格名称
     * @param {String} name -风格名称
     * @memberOf Style#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._Style_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取是否避让
    //  *
    //  * @memberOf Style#
    //  * @returns {Boolean} 是否避让
    //  */
    isCollision: function isCollision() {
      return Module._Style_IsCollision(this.handle);
    },
    // /**
    //  * 设置是否避让
    //  * @param {Boolean} isCollision -是否避让
    //  * @memberOf Style#
    //  *
    //  */
    setIsCollision: function setIsCollision(isCollision) {
      Module._Style_SetIsCollision(this.handle, isCollision);
    },
    /**
     * 克隆风格
     *
     * @memberOf Style#
     * @returns {PIEStyle} 风格对象
     */
    cloneStyle: function cloneStyle() {
      var hStyle = Module._Style_CloneStyle(this.handle);
      return PIEStyleFactory.CreateInstance(hStyle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 尺寸类
   * @name Size
   * @class Size
   *
   * @param {Number} cx -x值
   * @param {Number} cy -y值
   */
  function PIESize(cx, cy) {
    this.cx = cx;
    this.cy = cy;
  }
  Object.assign(PIESize.prototype, {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 新添加颜色对象
   * @name Color
   * @class Color
   * 颜色类
   *
   * @param {Number} r -红 -范围(0~255)
   * @param {Number} g -绿 -范围(0~255)
   * @param {Number} b -蓝 -范围(0~255)
   * @param {Number} a -透明 -范围(0~255)
   * @example
   * let color = new PIE.Color(255,0,0,255);//红色
   */
  function PIEColor(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  Object.assign(PIEColor.prototype, {
    /**
     * color对象克隆
     * @memberOf Color#
     * @returns {PIEColor} 返回克隆的color对象
     *
     */
    clone: function clone() {
      return new PIEColor(this.r, this.g, this.b, this.a);
    },
    toArray: function toArray() {
      var array = [this.r, this.g, this.b, this.a];
      return array;
    }
  });
  function defined(value) {
    return value !== undefined && value !== null;
  }
  function defaultValue(a, b) {
    if (a !== undefined && a !== null) {
      return a;
    }
    return b;
  }
  function hue2rgb$2(m1, m2, h) {
    if (h < 0) {
      h += 1;
    }
    if (h > 1) {
      h -= 1;
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * 6 * h;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  }

  //#rgba
  var rgbaMatcher$1 = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i;
  //#rrggbbaa
  var rrggbbaaMatcher$1 = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
  //rgb(), rgba(), or rgb%()
  var rgbParenthesesMatcher$1 = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
  //hsl() or hsla()
  var hslParenthesesMatcher$1 = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
  PIEColor.clone = function (color, result) {
    if (!defined(color)) {
      return undefined;
    }
    if (!defined(result)) {
      return new PIEColor(color.r, color.g, color.b, color.a);
    }
    result.r = color.r;
    result.g = color.g;
    result.b = color.b;
    result.a = color.a;
    return result;
  };
  PIEColor.fromHsl = function (hue, saturation, lightness, alpha, result) {
    hue = defaultValue(hue, 0.0) % 1.0;
    saturation = defaultValue(saturation, 0.0);
    lightness = defaultValue(lightness, 0.0);
    alpha = defaultValue(alpha, 1.0);
    var red = lightness;
    var green = lightness;
    var blue = lightness;
    if (saturation !== 0) {
      var m2;
      if (lightness < 0.5) {
        m2 = lightness * (1 + saturation);
      } else {
        m2 = lightness + saturation - lightness * saturation;
      }
      var m1 = 2.0 * lightness - m2;
      red = hue2rgb$2(m1, m2, hue + 1 / 3);
      green = hue2rgb$2(m1, m2, hue);
      blue = hue2rgb$2(m1, m2, hue - 1 / 3);
    }
    if (!defined(result)) {
      return new PIEColor(red * 255, green * 255, blue * 255, alpha * 255);
    }
    result.r = red * 255;
    result.g = green * 255;
    result.b = blue * 255;
    result.a = alpha * 255;
    return result;
  };
  PIEColor.fromCssColorString = function (color, result) {
    //>>includeStart('debug', pragmas.debug);
    // Check.typeOf.string("color", color);
    //>>includeEnd('debug');

    if (!defined(result)) {
      result = new PIEColor();
    }

    // Remove all whitespaces from the color string
    color = color.replace(/\s/g, "");
    var namedColor = PIEColor[color.toUpperCase()];
    if (defined(namedColor)) {
      PIEColor.clone(namedColor, result);
      return result;
    }
    var matches = rgbaMatcher$1.exec(color);
    if (matches !== null) {
      result.r = parseInt(matches[1], 16) / 15.0 * 255;
      result.g = parseInt(matches[2], 16) / 15.0 * 255;
      result.b = parseInt(matches[3], 16) / 15.0 * 255;
      result.a = parseInt(defaultValue(matches[4], "f"), 16) / 15.0 * 255;
      return result;
    }
    matches = rrggbbaaMatcher$1.exec(color);
    if (matches !== null) {
      result.r = parseInt(matches[1], 16);
      result.g = parseInt(matches[2], 16);
      result.b = parseInt(matches[3], 16);
      result.a = parseInt(defaultValue(matches[4], "ff"), 16);
      return result;
    }
    matches = rgbParenthesesMatcher$1.exec(color);
    if (matches !== null) {
      result.r = parseFloat(matches[1]) * ("%" === matches[1].substring(-1) ? 2.55 : 1);
      result.g = parseFloat(matches[2]) * ("%" === matches[2].substring(-1) ? 2.55 : 1);
      result.b = parseFloat(matches[3]) * ("%" === matches[3].substring(-1) ? 2.55 : 1);
      result.a = parseFloat(defaultValue(matches[4], "1.0")) * 255;
      return result;
    }
    matches = hslParenthesesMatcher$1.exec(color);
    if (matches !== null) {
      return PIEColor.fromHsl(parseFloat(matches[1]) / 360.0, parseFloat(matches[2]) / 100.0, parseFloat(matches[3]) / 100.0, parseFloat(defaultValue(matches[4], "1.0")), result);
    }
    result = undefined;
    return result;
  };

  /**
   * An immutable Color instance initialized to CSS color #F0F8FF
   * <span class="colorSwath" style="background: #F0F8FF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.ALICEBLUE = Object.freeze(PIEColor.fromCssColorString("#F0F8FF"));

  /**
   * An immutable Color instance initialized to CSS color #FAEBD7
   * <span class="colorSwath" style="background: #FAEBD7;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.ANTIQUEWHITE = Object.freeze(PIEColor.fromCssColorString("#FAEBD7"));

  /**
   * An immutable Color instance initialized to CSS color #00FFFF
   * <span class="colorSwath" style="background: #00FFFF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.AQUA = Object.freeze(PIEColor.fromCssColorString("#00FFFF"));

  /**
   * An immutable Color instance initialized to CSS color #7FFFD4
   * <span class="colorSwath" style="background: #7FFFD4;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.AQUAMARINE = Object.freeze(PIEColor.fromCssColorString("#7FFFD4"));

  /**
   * An immutable Color instance initialized to CSS color #F0FFFF
   * <span class="colorSwath" style="background: #F0FFFF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.AZURE = Object.freeze(PIEColor.fromCssColorString("#F0FFFF"));

  /**
   * An immutable Color instance initialized to CSS color #F5F5DC
   * <span class="colorSwath" style="background: #F5F5DC;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BEIGE = Object.freeze(PIEColor.fromCssColorString("#F5F5DC"));

  /**
   * An immutable Color instance initialized to CSS color #FFE4C4
   * <span class="colorSwath" style="background: #FFE4C4;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BISQUE = Object.freeze(PIEColor.fromCssColorString("#FFE4C4"));

  /**
   * An immutable Color instance initialized to CSS color #000000
   * <span class="colorSwath" style="background: #000000;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BLACK = Object.freeze(PIEColor.fromCssColorString("#000000"));

  /**
   * An immutable Color instance initialized to CSS color #FFEBCD
   * <span class="colorSwath" style="background: #FFEBCD;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BLANCHEDALMOND = Object.freeze(PIEColor.fromCssColorString("#FFEBCD"));

  /**
   * An immutable Color instance initialized to CSS color #0000FF
   * <span class="colorSwath" style="background: #0000FF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BLUE = Object.freeze(PIEColor.fromCssColorString("#0000FF"));

  /**
   * An immutable Color instance initialized to CSS color #8A2BE2
   * <span class="colorSwath" style="background: #8A2BE2;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BLUEVIOLET = Object.freeze(PIEColor.fromCssColorString("#8A2BE2"));

  /**
   * An immutable Color instance initialized to CSS color #A52A2A
   * <span class="colorSwath" style="background: #A52A2A;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BROWN = Object.freeze(PIEColor.fromCssColorString("#A52A2A"));

  /**
   * An immutable Color instance initialized to CSS color #DEB887
   * <span class="colorSwath" style="background: #DEB887;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.BURLYWOOD = Object.freeze(PIEColor.fromCssColorString("#DEB887"));

  /**
   * An immutable Color instance initialized to CSS color #5F9EA0
   * <span class="colorSwath" style="background: #5F9EA0;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CADETBLUE = Object.freeze(PIEColor.fromCssColorString("#5F9EA0"));
  /**
   * An immutable Color instance initialized to CSS color #7FFF00
   * <span class="colorSwath" style="background: #7FFF00;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CHARTREUSE = Object.freeze(PIEColor.fromCssColorString("#7FFF00"));

  /**
   * An immutable Color instance initialized to CSS color #D2691E
   * <span class="colorSwath" style="background: #D2691E;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CHOCOLATE = Object.freeze(PIEColor.fromCssColorString("#D2691E"));

  /**
   * An immutable Color instance initialized to CSS color #FF7F50
   * <span class="colorSwath" style="background: #FF7F50;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CORAL = Object.freeze(PIEColor.fromCssColorString("#FF7F50"));

  /**
   * An immutable Color instance initialized to CSS color #6495ED
   * <span class="colorSwath" style="background: #6495ED;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CORNFLOWERBLUE = Object.freeze(PIEColor.fromCssColorString("#6495ED"));

  /**
   * An immutable Color instance initialized to CSS color #FFF8DC
   * <span class="colorSwath" style="background: #FFF8DC;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CORNSILK = Object.freeze(PIEColor.fromCssColorString("#FFF8DC"));

  /**
   * An immutable Color instance initialized to CSS color #DC143C
   * <span class="colorSwath" style="background: #DC143C;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CRIMSON = Object.freeze(PIEColor.fromCssColorString("#DC143C"));

  /**
   * An immutable Color instance initialized to CSS color #00FFFF
   * <span class="colorSwath" style="background: #00FFFF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.CYAN = Object.freeze(PIEColor.fromCssColorString("#00FFFF"));

  /**
   * An immutable Color instance initialized to CSS color #00008B
   * <span class="colorSwath" style="background: #00008B;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKBLUE = Object.freeze(PIEColor.fromCssColorString("#00008B"));

  /**
   * An immutable Color instance initialized to CSS color #008B8B
   * <span class="colorSwath" style="background: #008B8B;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKCYAN = Object.freeze(PIEColor.fromCssColorString("#008B8B"));

  /**
   * An immutable Color instance initialized to CSS color #B8860B
   * <span class="colorSwath" style="background: #B8860B;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKGOLDENROD = Object.freeze(PIEColor.fromCssColorString("#B8860B"));

  /**
   * An immutable Color instance initialized to CSS color #A9A9A9
   * <span class="colorSwath" style="background: #A9A9A9;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKGRAY = Object.freeze(PIEColor.fromCssColorString("#A9A9A9"));

  /**
   * An immutable Color instance initialized to CSS color #006400
   * <span class="colorSwath" style="background: #006400;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKGREEN = Object.freeze(PIEColor.fromCssColorString("#006400"));

  /**
   * An immutable Color instance initialized to CSS color #A9A9A9
   * <span class="colorSwath" style="background: #A9A9A9;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKGREY = PIEColor.DARKGRAY;

  /**
   * An immutable Color instance initialized to CSS color #BDB76B
   * <span class="colorSwath" style="background: #BDB76B;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKKHAKI = Object.freeze(PIEColor.fromCssColorString("#BDB76B"));

  /**
   * An immutable Color instance initialized to CSS color #8B008B
   * <span class="colorSwath" style="background: #8B008B;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKMAGENTA = Object.freeze(PIEColor.fromCssColorString("#8B008B"));

  /**
   * An immutable Color instance initialized to CSS color #556B2F
   * <span class="colorSwath" style="background: #556B2F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKOLIVEGREEN = Object.freeze(PIEColor.fromCssColorString("#556B2F"));

  /**
   * An immutable Color instance initialized to CSS color #FF8C00
   * <span class="colorSwath" style="background: #FF8C00;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKORANGE = Object.freeze(PIEColor.fromCssColorString("#FF8C00"));

  /**
   * An immutable Color instance initialized to CSS color #9932CC
   * <span class="colorSwath" style="background: #9932CC;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKORCHID = Object.freeze(PIEColor.fromCssColorString("#9932CC"));

  /**
   * An immutable Color instance initialized to CSS color #8B0000
   * <span class="colorSwath" style="background: #8B0000;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKRED = Object.freeze(PIEColor.fromCssColorString("#8B0000"));

  /**
   * An immutable Color instance initialized to CSS color #E9967A
   * <span class="colorSwath" style="background: #E9967A;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKSALMON = Object.freeze(PIEColor.fromCssColorString("#E9967A"));

  /**
   * An immutable Color instance initialized to CSS color #8FBC8F
   * <span class="colorSwath" style="background: #8FBC8F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKSEAGREEN = Object.freeze(PIEColor.fromCssColorString("#8FBC8F"));

  /**
   * An immutable Color instance initialized to CSS color #483D8B
   * <span class="colorSwath" style="background: #483D8B;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKSLATEBLUE = Object.freeze(PIEColor.fromCssColorString("#483D8B"));

  /**
   * An immutable Color instance initialized to CSS color #2F4F4F
   * <span class="colorSwath" style="background: #2F4F4F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKSLATEGRAY = Object.freeze(PIEColor.fromCssColorString("#2F4F4F"));

  /**
   * An immutable Color instance initialized to CSS color #2F4F4F
   * <span class="colorSwath" style="background: #2F4F4F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKSLATEGREY = PIEColor.DARKSLATEGRAY;

  /**
   * An immutable Color instance initialized to CSS color #00CED1
   * <span class="colorSwath" style="background: #00CED1;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKTURQUOISE = Object.freeze(PIEColor.fromCssColorString("#00CED1"));

  /**
   * An immutable Color instance initialized to CSS color #9400D3
   * <span class="colorSwath" style="background: #9400D3;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DARKVIOLET = Object.freeze(PIEColor.fromCssColorString("#9400D3"));

  /**
   * An immutable Color instance initialized to CSS color #FF1493
   * <span class="colorSwath" style="background: #FF1493;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DEEPPINK = Object.freeze(PIEColor.fromCssColorString("#FF1493"));

  /**
   * An immutable Color instance initialized to CSS color #00BFFF
   * <span class="colorSwath" style="background: #00BFFF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DEEPSKYBLUE = Object.freeze(PIEColor.fromCssColorString("#00BFFF"));

  /**
   * An immutable Color instance initialized to CSS color #696969
   * <span class="colorSwath" style="background: #696969;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DIMGRAY = Object.freeze(PIEColor.fromCssColorString("#696969"));

  /**
   * An immutable Color instance initialized to CSS color #696969
   * <span class="colorSwath" style="background: #696969;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DIMGREY = PIEColor.DIMGRAY;

  /**
   * An immutable Color instance initialized to CSS color #1E90FF
   * <span class="colorSwath" style="background: #1E90FF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.DODGERBLUE = Object.freeze(PIEColor.fromCssColorString("#1E90FF"));

  /**
   * An immutable Color instance initialized to CSS color #B22222
   * <span class="colorSwath" style="background: #B22222;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.FIREBRICK = Object.freeze(PIEColor.fromCssColorString("#B22222"));

  /**
   * An immutable Color instance initialized to CSS color #FFFAF0
   * <span class="colorSwath" style="background: #FFFAF0;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.FLORALWHITE = Object.freeze(PIEColor.fromCssColorString("#FFFAF0"));

  /**
   * An immutable Color instance initialized to CSS color #228B22
   * <span class="colorSwath" style="background: #228B22;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.FORESTGREEN = Object.freeze(PIEColor.fromCssColorString("#228B22"));

  /**
   * An immutable Color instance initialized to CSS color #FF00FF
   * <span class="colorSwath" style="background: #FF00FF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.FUCHSIA = Object.freeze(PIEColor.fromCssColorString("#FF00FF"));

  /**
   * An immutable Color instance initialized to CSS color #DCDCDC
   * <span class="colorSwath" style="background: #DCDCDC;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GAINSBORO = Object.freeze(PIEColor.fromCssColorString("#DCDCDC"));

  /**
   * An immutable Color instance initialized to CSS color #F8F8FF
   * <span class="colorSwath" style="background: #F8F8FF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GHOSTWHITE = Object.freeze(PIEColor.fromCssColorString("#F8F8FF"));

  /**
   * An immutable Color instance initialized to CSS color #FFD700
   * <span class="colorSwath" style="background: #FFD700;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GOLD = Object.freeze(PIEColor.fromCssColorString("#FFD700"));

  /**
   * An immutable Color instance initialized to CSS color #DAA520
   * <span class="colorSwath" style="background: #DAA520;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GOLDENROD = Object.freeze(PIEColor.fromCssColorString("#DAA520"));

  /**
   * An immutable Color instance initialized to CSS color #808080
   * <span class="colorSwath" style="background: #808080;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GRAY = Object.freeze(PIEColor.fromCssColorString("#808080"));

  /**
   * An immutable Color instance initialized to CSS color #008000
   * <span class="colorSwath" style="background: #008000;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GREEN = Object.freeze(PIEColor.fromCssColorString("#008000"));

  /**
   * An immutable Color instance initialized to CSS color #ADFF2F
   * <span class="colorSwath" style="background: #ADFF2F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GREENYELLOW = Object.freeze(PIEColor.fromCssColorString("#ADFF2F"));

  /**
   * An immutable Color instance initialized to CSS color #808080
   * <span class="colorSwath" style="background: #808080;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.GREY = PIEColor.GRAY;

  /**
   * An immutable Color instance initialized to CSS color #F0FFF0
   * <span class="colorSwath" style="background: #F0FFF0;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.HONEYDEW = Object.freeze(PIEColor.fromCssColorString("#F0FFF0"));

  /**
   * An immutable Color instance initialized to CSS color #FF69B4
   * <span class="colorSwath" style="background: #FF69B4;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.HOTPINK = Object.freeze(PIEColor.fromCssColorString("#FF69B4"));

  /**
   * An immutable Color instance initialized to CSS color #CD5C5C
   * <span class="colorSwath" style="background: #CD5C5C;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.INDIANRED = Object.freeze(PIEColor.fromCssColorString("#CD5C5C"));

  /**
   * An immutable Color instance initialized to CSS color #4B0082
   * <span class="colorSwath" style="background: #4B0082;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.INDIGO = Object.freeze(PIEColor.fromCssColorString("#4B0082"));

  /**
   * An immutable Color instance initialized to CSS color #FFFFF0
   * <span class="colorSwath" style="background: #FFFFF0;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.IVORY = Object.freeze(PIEColor.fromCssColorString("#FFFFF0"));

  /**
   * An immutable Color instance initialized to CSS color #F0E68C
   * <span class="colorSwath" style="background: #F0E68C;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.KHAKI = Object.freeze(PIEColor.fromCssColorString("#F0E68C"));

  /**
   * An immutable Color instance initialized to CSS color #E6E6FA
   * <span class="colorSwath" style="background: #E6E6FA;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LAVENDER = Object.freeze(PIEColor.fromCssColorString("#E6E6FA"));

  /**
   * An immutable Color instance initialized to CSS color #FFF0F5
   * <span class="colorSwath" style="background: #FFF0F5;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LAVENDAR_BLUSH = Object.freeze(PIEColor.fromCssColorString("#FFF0F5"));

  /**
   * An immutable Color instance initialized to CSS color #7CFC00
   * <span class="colorSwath" style="background: #7CFC00;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LAWNGREEN = Object.freeze(PIEColor.fromCssColorString("#7CFC00"));

  /**
   * An immutable Color instance initialized to CSS color #FFFACD
   * <span class="colorSwath" style="background: #FFFACD;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LEMONCHIFFON = Object.freeze(PIEColor.fromCssColorString("#FFFACD"));

  /**
   * An immutable Color instance initialized to CSS color #ADD8E6
   * <span class="colorSwath" style="background: #ADD8E6;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTBLUE = Object.freeze(PIEColor.fromCssColorString("#ADD8E6"));

  /**
   * An immutable Color instance initialized to CSS color #F08080
   * <span class="colorSwath" style="background: #F08080;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTCORAL = Object.freeze(PIEColor.fromCssColorString("#F08080"));

  /**
   * An immutable Color instance initialized to CSS color #E0FFFF
   * <span class="colorSwath" style="background: #E0FFFF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTCYAN = Object.freeze(PIEColor.fromCssColorString("#E0FFFF"));

  /**
   * An immutable Color instance initialized to CSS color #FAFAD2
   * <span class="colorSwath" style="background: #FAFAD2;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTGOLDENRODYELLOW = Object.freeze(PIEColor.fromCssColorString("#FAFAD2"));

  /**
   * An immutable Color instance initialized to CSS color #D3D3D3
   * <span class="colorSwath" style="background: #D3D3D3;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTGRAY = Object.freeze(PIEColor.fromCssColorString("#D3D3D3"));

  /**
   * An immutable Color instance initialized to CSS color #90EE90
   * <span class="colorSwath" style="background: #90EE90;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTGREEN = Object.freeze(PIEColor.fromCssColorString("#90EE90"));

  /**
   * An immutable Color instance initialized to CSS color #D3D3D3
   * <span class="colorSwath" style="background: #D3D3D3;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTGREY = PIEColor.LIGHTGRAY;

  /**
   * An immutable Color instance initialized to CSS color #FFB6C1
   * <span class="colorSwath" style="background: #FFB6C1;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTPINK = Object.freeze(PIEColor.fromCssColorString("#FFB6C1"));

  /**
   * An immutable Color instance initialized to CSS color #20B2AA
   * <span class="colorSwath" style="background: #20B2AA;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTSEAGREEN = Object.freeze(PIEColor.fromCssColorString("#20B2AA"));

  /**
   * An immutable Color instance initialized to CSS color #87CEFA
   * <span class="colorSwath" style="background: #87CEFA;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTSKYBLUE = Object.freeze(PIEColor.fromCssColorString("#87CEFA"));

  /**
   * An immutable Color instance initialized to CSS color #778899
   * <span class="colorSwath" style="background: #778899;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTSLATEGRAY = Object.freeze(PIEColor.fromCssColorString("#778899"));

  /**
   * An immutable Color instance initialized to CSS color #778899
   * <span class="colorSwath" style="background: #778899;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTSLATEGREY = PIEColor.LIGHTSLATEGRAY;

  /**
   * An immutable Color instance initialized to CSS color #B0C4DE
   * <span class="colorSwath" style="background: #B0C4DE;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTSTEELBLUE = Object.freeze(PIEColor.fromCssColorString("#B0C4DE"));

  /**
   * An immutable Color instance initialized to CSS color #FFFFE0
   * <span class="colorSwath" style="background: #FFFFE0;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIGHTYELLOW = Object.freeze(PIEColor.fromCssColorString("#FFFFE0"));

  /**
   * An immutable Color instance initialized to CSS color #00FF00
   * <span class="colorSwath" style="background: #00FF00;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIME = Object.freeze(PIEColor.fromCssColorString("#00FF00"));

  /**
   * An immutable Color instance initialized to CSS color #32CD32
   * <span class="colorSwath" style="background: #32CD32;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LIMEGREEN = Object.freeze(PIEColor.fromCssColorString("#32CD32"));

  /**
   * An immutable Color instance initialized to CSS color #FAF0E6
   * <span class="colorSwath" style="background: #FAF0E6;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.LINEN = Object.freeze(PIEColor.fromCssColorString("#FAF0E6"));

  /**
   * An immutable Color instance initialized to CSS color #FF00FF
   * <span class="colorSwath" style="background: #FF00FF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MAGENTA = Object.freeze(PIEColor.fromCssColorString("#FF00FF"));

  /**
   * An immutable Color instance initialized to CSS color #800000
   * <span class="colorSwath" style="background: #800000;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MAROON = Object.freeze(PIEColor.fromCssColorString("#800000"));

  /**
   * An immutable Color instance initialized to CSS color #66CDAA
   * <span class="colorSwath" style="background: #66CDAA;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMAQUAMARINE = Object.freeze(PIEColor.fromCssColorString("#66CDAA"));

  /**
   * An immutable Color instance initialized to CSS color #0000CD
   * <span class="colorSwath" style="background: #0000CD;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMBLUE = Object.freeze(PIEColor.fromCssColorString("#0000CD"));

  /**
   * An immutable Color instance initialized to CSS color #BA55D3
   * <span class="colorSwath" style="background: #BA55D3;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMORCHID = Object.freeze(PIEColor.fromCssColorString("#BA55D3"));

  /**
   * An immutable Color instance initialized to CSS color #9370DB
   * <span class="colorSwath" style="background: #9370DB;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMPURPLE = Object.freeze(PIEColor.fromCssColorString("#9370DB"));

  /**
   * An immutable Color instance initialized to CSS color #3CB371
   * <span class="colorSwath" style="background: #3CB371;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMSEAGREEN = Object.freeze(PIEColor.fromCssColorString("#3CB371"));

  /**
   * An immutable Color instance initialized to CSS color #7B68EE
   * <span class="colorSwath" style="background: #7B68EE;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMSLATEBLUE = Object.freeze(PIEColor.fromCssColorString("#7B68EE"));

  /**
   * An immutable Color instance initialized to CSS color #00FA9A
   * <span class="colorSwath" style="background: #00FA9A;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMSPRINGGREEN = Object.freeze(PIEColor.fromCssColorString("#00FA9A"));

  /**
   * An immutable Color instance initialized to CSS color #48D1CC
   * <span class="colorSwath" style="background: #48D1CC;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMTURQUOISE = Object.freeze(PIEColor.fromCssColorString("#48D1CC"));

  /**
   * An immutable Color instance initialized to CSS color #C71585
   * <span class="colorSwath" style="background: #C71585;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MEDIUMVIOLETRED = Object.freeze(PIEColor.fromCssColorString("#C71585"));

  /**
   * An immutable Color instance initialized to CSS color #191970
   * <span class="colorSwath" style="background: #191970;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MIDNIGHTBLUE = Object.freeze(PIEColor.fromCssColorString("#191970"));

  /**
   * An immutable Color instance initialized to CSS color #F5FFFA
   * <span class="colorSwath" style="background: #F5FFFA;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MINTCREAM = Object.freeze(PIEColor.fromCssColorString("#F5FFFA"));

  /**
   * An immutable Color instance initialized to CSS color #FFE4E1
   * <span class="colorSwath" style="background: #FFE4E1;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MISTYROSE = Object.freeze(PIEColor.fromCssColorString("#FFE4E1"));

  /**
   * An immutable Color instance initialized to CSS color #FFE4B5
   * <span class="colorSwath" style="background: #FFE4B5;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.MOCCASIN = Object.freeze(PIEColor.fromCssColorString("#FFE4B5"));

  /**
   * An immutable Color instance initialized to CSS color #FFDEAD
   * <span class="colorSwath" style="background: #FFDEAD;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.NAVAJOWHITE = Object.freeze(PIEColor.fromCssColorString("#FFDEAD"));

  /**
   * An immutable Color instance initialized to CSS color #000080
   * <span class="colorSwath" style="background: #000080;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.NAVY = Object.freeze(PIEColor.fromCssColorString("#000080"));

  /**
   * An immutable Color instance initialized to CSS color #FDF5E6
   * <span class="colorSwath" style="background: #FDF5E6;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.OLDLACE = Object.freeze(PIEColor.fromCssColorString("#FDF5E6"));

  /**
   * An immutable Color instance initialized to CSS color #808000
   * <span class="colorSwath" style="background: #808000;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.OLIVE = Object.freeze(PIEColor.fromCssColorString("#808000"));

  /**
   * An immutable Color instance initialized to CSS color #6B8E23
   * <span class="colorSwath" style="background: #6B8E23;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.OLIVEDRAB = Object.freeze(PIEColor.fromCssColorString("#6B8E23"));

  /**
   * An immutable Color instance initialized to CSS color #FFA500
   * <span class="colorSwath" style="background: #FFA500;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.ORANGE = Object.freeze(PIEColor.fromCssColorString("#FFA500"));

  /**
   * An immutable Color instance initialized to CSS color #FF4500
   * <span class="colorSwath" style="background: #FF4500;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.ORANGERED = Object.freeze(PIEColor.fromCssColorString("#FF4500"));

  /**
   * An immutable Color instance initialized to CSS color #DA70D6
   * <span class="colorSwath" style="background: #DA70D6;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.ORCHID = Object.freeze(PIEColor.fromCssColorString("#DA70D6"));

  /**
   * An immutable Color instance initialized to CSS color #EEE8AA
   * <span class="colorSwath" style="background: #EEE8AA;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PALEGOLDENROD = Object.freeze(PIEColor.fromCssColorString("#EEE8AA"));

  /**
   * An immutable Color instance initialized to CSS color #98FB98
   * <span class="colorSwath" style="background: #98FB98;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PALEGREEN = Object.freeze(PIEColor.fromCssColorString("#98FB98"));

  /**
   * An immutable Color instance initialized to CSS color #AFEEEE
   * <span class="colorSwath" style="background: #AFEEEE;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PALETURQUOISE = Object.freeze(PIEColor.fromCssColorString("#AFEEEE"));

  /**
   * An immutable Color instance initialized to CSS color #DB7093
   * <span class="colorSwath" style="background: #DB7093;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PALEVIOLETRED = Object.freeze(PIEColor.fromCssColorString("#DB7093"));

  /**
   * An immutable Color instance initialized to CSS color #FFEFD5
   * <span class="colorSwath" style="background: #FFEFD5;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PAPAYAWHIP = Object.freeze(PIEColor.fromCssColorString("#FFEFD5"));

  /**
   * An immutable Color instance initialized to CSS color #FFDAB9
   * <span class="colorSwath" style="background: #FFDAB9;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PEACHPUFF = Object.freeze(PIEColor.fromCssColorString("#FFDAB9"));

  /**
   * An immutable Color instance initialized to CSS color #CD853F
   * <span class="colorSwath" style="background: #CD853F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PERU = Object.freeze(PIEColor.fromCssColorString("#CD853F"));

  /**
   * An immutable Color instance initialized to CSS color #FFC0CB
   * <span class="colorSwath" style="background: #FFC0CB;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PINK = Object.freeze(PIEColor.fromCssColorString("#FFC0CB"));

  /**
   * An immutable Color instance initialized to CSS color #DDA0DD
   * <span class="colorSwath" style="background: #DDA0DD;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PLUM = Object.freeze(PIEColor.fromCssColorString("#DDA0DD"));

  /**
   * An immutable Color instance initialized to CSS color #B0E0E6
   * <span class="colorSwath" style="background: #B0E0E6;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.POWDERBLUE = Object.freeze(PIEColor.fromCssColorString("#B0E0E6"));

  /**
   * An immutable Color instance initialized to CSS color #800080
   * <span class="colorSwath" style="background: #800080;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.PURPLE = Object.freeze(PIEColor.fromCssColorString("#800080"));

  /**
   * An immutable Color instance initialized to CSS color #FF0000
   * <span class="colorSwath" style="background: #FF0000;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.RED = Object.freeze(PIEColor.fromCssColorString("#FF0000"));

  /**
   * An immutable Color instance initialized to CSS color #BC8F8F
   * <span class="colorSwath" style="background: #BC8F8F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.ROSYBROWN = Object.freeze(PIEColor.fromCssColorString("#BC8F8F"));

  /**
   * An immutable Color instance initialized to CSS color #4169E1
   * <span class="colorSwath" style="background: #4169E1;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.ROYALBLUE = Object.freeze(PIEColor.fromCssColorString("#4169E1"));

  /**
   * An immutable Color instance initialized to CSS color #8B4513
   * <span class="colorSwath" style="background: #8B4513;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SADDLEBROWN = Object.freeze(PIEColor.fromCssColorString("#8B4513"));

  /**
   * An immutable Color instance initialized to CSS color #FA8072
   * <span class="colorSwath" style="background: #FA8072;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SALMON = Object.freeze(PIEColor.fromCssColorString("#FA8072"));

  /**
   * An immutable Color instance initialized to CSS color #F4A460
   * <span class="colorSwath" style="background: #F4A460;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SANDYBROWN = Object.freeze(PIEColor.fromCssColorString("#F4A460"));

  /**
   * An immutable Color instance initialized to CSS color #2E8B57
   * <span class="colorSwath" style="background: #2E8B57;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SEAGREEN = Object.freeze(PIEColor.fromCssColorString("#2E8B57"));

  /**
   * An immutable Color instance initialized to CSS color #FFF5EE
   * <span class="colorSwath" style="background: #FFF5EE;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SEASHELL = Object.freeze(PIEColor.fromCssColorString("#FFF5EE"));

  /**
   * An immutable Color instance initialized to CSS color #A0522D
   * <span class="colorSwath" style="background: #A0522D;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SIENNA = Object.freeze(PIEColor.fromCssColorString("#A0522D"));

  /**
   * An immutable Color instance initialized to CSS color #C0C0C0
   * <span class="colorSwath" style="background: #C0C0C0;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SILVER = Object.freeze(PIEColor.fromCssColorString("#C0C0C0"));

  /**
   * An immutable Color instance initialized to CSS color #87CEEB
   * <span class="colorSwath" style="background: #87CEEB;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SKYBLUE = Object.freeze(PIEColor.fromCssColorString("#87CEEB"));

  /**
   * An immutable Color instance initialized to CSS color #6A5ACD
   * <span class="colorSwath" style="background: #6A5ACD;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SLATEBLUE = Object.freeze(PIEColor.fromCssColorString("#6A5ACD"));

  /**
   * An immutable Color instance initialized to CSS color #708090
   * <span class="colorSwath" style="background: #708090;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SLATEGRAY = Object.freeze(PIEColor.fromCssColorString("#708090"));

  /**
   * An immutable Color instance initialized to CSS color #708090
   * <span class="colorSwath" style="background: #708090;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SLATEGREY = PIEColor.SLATEGRAY;

  /**
   * An immutable Color instance initialized to CSS color #FFFAFA
   * <span class="colorSwath" style="background: #FFFAFA;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SNOW = Object.freeze(PIEColor.fromCssColorString("#FFFAFA"));

  /**
   * An immutable Color instance initialized to CSS color #00FF7F
   * <span class="colorSwath" style="background: #00FF7F;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.SPRINGGREEN = Object.freeze(PIEColor.fromCssColorString("#00FF7F"));

  /**
   * An immutable Color instance initialized to CSS color #4682B4
   * <span class="colorSwath" style="background: #4682B4;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.STEELBLUE = Object.freeze(PIEColor.fromCssColorString("#4682B4"));

  /**
   * An immutable Color instance initialized to CSS color #D2B48C
   * <span class="colorSwath" style="background: #D2B48C;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.TAN = Object.freeze(PIEColor.fromCssColorString("#D2B48C"));

  /**
   * An immutable Color instance initialized to CSS color #008080
   * <span class="colorSwath" style="background: #008080;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.TEAL = Object.freeze(PIEColor.fromCssColorString("#008080"));

  /**
   * An immutable Color instance initialized to CSS color #D8BFD8
   * <span class="colorSwath" style="background: #D8BFD8;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.THISTLE = Object.freeze(PIEColor.fromCssColorString("#D8BFD8"));

  /**
   * An immutable Color instance initialized to CSS color #FF6347
   * <span class="colorSwath" style="background: #FF6347;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.TOMATO = Object.freeze(PIEColor.fromCssColorString("#FF6347"));

  /**
   * An immutable Color instance initialized to CSS color #40E0D0
   * <span class="colorSwath" style="background: #40E0D0;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.TURQUOISE = Object.freeze(PIEColor.fromCssColorString("#40E0D0"));

  /**
   * An immutable Color instance initialized to CSS color #EE82EE
   * <span class="colorSwath" style="background: #EE82EE;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.VIOLET = Object.freeze(PIEColor.fromCssColorString("#EE82EE"));

  /**
   * An immutable Color instance initialized to CSS color #F5DEB3
   * <span class="colorSwath" style="background: #F5DEB3;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.WHEAT = Object.freeze(PIEColor.fromCssColorString("#F5DEB3"));

  /**
   * An immutable Color instance initialized to CSS color #FFFFFF
   * <span class="colorSwath" style="background: #FFFFFF;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.WHITE = Object.freeze(PIEColor.fromCssColorString("#FFFFFF"));

  /**
   * An immutable Color instance initialized to CSS color #F5F5F5
   * <span class="colorSwath" style="background: #F5F5F5;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.WHITESMOKE = Object.freeze(PIEColor.fromCssColorString("#F5F5F5"));

  /**
   * An immutable Color instance initialized to CSS color #FFFF00
   * <span class="colorSwath" style="background: #FFFF00;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.YELLOW = Object.freeze(PIEColor.fromCssColorString("#FFFF00"));

  /**
   * An immutable Color instance initialized to CSS color #9ACD32
   * <span class="colorSwath" style="background: #9ACD32;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.YELLOWGREEN = Object.freeze(PIEColor.fromCssColorString("#9ACD32"));

  /**
   * An immutable Color instance initialized to CSS transparent.
   * <span class="colorSwath" style="background: transparent;"></span>
   *
   * @constant
   * @type {PIEColor}
   */
  PIEColor.TRANSPARENT = Object.freeze(new PIEColor(0, 0, 0, 0));

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 线符号类型
   * @readonly
   * @enum {number}
   */
  var PIELineType = {
    /** 空类型*/
    Null: 0,
    /** 符号库类型*/
    Line: 3
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 填充符号类型
   * @readonly
   * @enum {number}
   */
  var PIEFillType = {
    /** 空类型*/
    Null: 0,
    /**符号库类型*/
    Fill: 5
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 创建几何风格对象
   * @name VectorStyle
   * @class VectorStyle
   * 几何风格操作函数
   *
   * @extends Style
   * @param {Object} options
   * @param {PIEPointType} options.pointType -点类型
   * @param {PIEVector2/Array} options.pointSize -点大小
   * @param {PIEColor/Array} options.pointColor -点颜色
   * @param {PIEPointAlignType} options.pointAlign -点对齐方式
   * @param {Number} options.pointStyle -点风格id(当type为PIE.PointType.Icon时，需要设置id)
   * @param {PIEPointAlignType} options.lineColor -线颜色
   * @param {Number} options.lineWidth -线宽
   * @param {PIEColor/Array} options.fillColor -面填充颜色
   * @param {PIEAltitudeMode} options.altitudeMode - 设置依地模式(默认为PIEAltitudeMode.ClampToGround)
   * @param {PIEClassifyMode} options.classifyMode - 设置分类显示模式(默认为PIEClassifyMode.ClassifyAll)
   */
  function PIEVectorStyle(options) {
    var handle = null;
    var autoRelease = false;
    if (options == null) {
      handle = Module._VectorStyle_Create();
      autoRelease = true;
    } else {
      if (options.handle == null) {
        handle = Module._VectorStyle_Create();
        this.handle = handle;
        autoRelease = true;
        if (options.pointColor) {
          this.setPointColor(options.pointColor);
        }
        if (options.pointSize) {
          this.setPointSize(options.pointSize);
        }
        if (options.pointType != null) {
          this.setPointType(options.pointType);
        }
        if (options.pointStyle != null) {
          this.setPointStyle(options.pointStyle);
        }
        if (options.pointAlign != null) {
          this.setPointAlign(options.pointAlign);
        }
        if (options.pointAngle != null) {
          this.setPointAngle(options.pointAngle);
        }
        if (options.lineColor) {
          this.setLineColor(options.lineColor);
        }
        if (options.lineWidth != null) {
          this.setLineWidth(options.lineWidth);
        }
        this.setLineType(PIELineType.Null);
        this.setLineStyle(0);
        if (options.fillColor) {
          this.setForeFillColor(options.fillColor);
        }
        this.setFillType(PIEFillType.Null);
        this.setFillStyle(0);
        if (options.altitudeMode != null) {
          this.setAltitudeMode(options.altitudeMode);
        }
        if (options.classifyMode != null) {
          this.setClassifyMode(options.classifyMode);
        }
      } else {
        handle = options.handle;
      }
    }
    PIEStyle.call(this, handle, autoRelease);
  }
  PIEVectorStyle.prototype = Object.assign(Object.create(PIEStyle.prototype), {
    /**
     * 获取点符号类型
     *
     * @memberOf VectorStyle#
     * @returns {PIEPointType} 返回点符号类型
     */
    getPointType: function getPointType() {
      return Module._VectorStyle_GetPointType(this.handle);
    },
    /**
     * 设置点符号类型
     * @param {PIEPointType} type -点符号类型
     * @memberOf VectorStyle#
     *
     */
    setPointType: function setPointType(type) {
      Module._VectorStyle_SetPointType(this.handle, type);
    },
    /**
     * 获取点符号风格ID
     *
     * @memberOf VectorStyle#
     * @returns {Number} 返回点符号风格ID
     *
     */
    getPointStyle: function getPointStyle() {
      return Module._VectorStyle_GetPointStyle(this.handle);
    },
    /**
     * 设置点符号风格ID
     * @param {Number} style -点符号风格ID
     * @memberOf VectorStyle#
     *
     */
    setPointStyle: function setPointStyle(style) {
      if (style != null) {
        Module._VectorStyle_SetPointStyle(this.handle, style);
      }
    },
    /**
     * 获取点符号标识角度
     *
     * @memberOf VectorStyle#
     * @returns {Number} 返回点符号标识角度
     *
     */
    getPointAngle: function getPointAngle() {
      return Module._VectorStyle_GetPointAngle(this.handle);
    },
    /**
     * 设置点符号标识角度
     * @param {Number} angle -点符号标识角度
     * @memberOf VectorStyle#
     *
     */
    setPointAngle: function setPointAngle(angle) {
      return Module._VectorStyle_SetPointAngle(this.handle, angle);
    },
    /**
     * 获取点符号标识大小
     *
     * @memberOf VectorStyle#
     * @returns {PIESize} 返回点符号标识大小
     */
    getPointSize: function getPointSize() {
      var sizeArray = new PIEArray(2, PIEArrayType.Float64);
      Module._VectorStyle_GetPointSize(this.handle, sizeArray.getHandle());
      sizeArray.updateData();
      var array = sizeArray.toArray();
      sizeArray.dispose();
      var size = new PIESize(array[0], array[1]);
      return size;
    },
    /**
     * 设置点符号标识大小
     * @param {(Array/PIESize)} size -点符号标识大小
     * @memberOf VectorStyle#
     *
     */
    setPointSize: function setPointSize(size) {
      var array = null;
      if (size instanceof Array) {
        array = size;
      } else if (size instanceof PIESize) {
        array = [size.cx, size.cy];
      }
      if (array) {
        var sizeArray = new PIEArray(array, PIEArrayType.Float64);
        Module._VectorStyle_SetPointSize(this.handle, sizeArray.getHandle());
        sizeArray.dispose();
      }
    },
    /**
     * 获取点符号对齐方式
     *
     * @memberOf VectorStyle#
     * @returns {PIEPointAlignType} 返回点符号对齐方式
     *
     */
    getPointAlign: function getPointAlign() {
      return Module._VectorStyle_GetPointAlign(this.handle);
    },
    /**
     * 设置点符号对齐方式
     * @param {PIEPointAlignType} type -点符号对齐方式
     * @memberOf VectorStyle#
     *
     */
    setPointAlign: function setPointAlign(type) {
      Module._VectorStyle_SetPointAlign(this.handle, type);
    },
    /**
     * 获取几何风格点符号颜色
     *
     * @memberOf VectorStyle#
     * @returns {PIEColor} 返回点符号颜色
     */
    getPointColor: function getPointColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._VectorStyle_GetPointColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var Color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return Color;
    },
    /**
     * 设置几何风格点符号颜色
     * @param {(PIEColor/Array)} color -点符号颜色
     * @memberOf VectorStyle#
     *
     */
    setPointColor: function setPointColor(color) {
      if (color == null) {
        return;
      }
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._VectorStyle_SetPointColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取几何风格点符号颜色是否可用
     *
     * @memberOf VectorStyle#
     * @returns {Boolean} 返回点符号颜色是否可用（true-可用，false-不可用）
     *
     */
    isEnablePointColor: function isEnablePointColor() {
      return Boolean(Module._VectorStyle_IsEnablePointColor(this.handle));
    },
    /**
     * 设置几何风格点符号颜色是否可用
     * @param {Boolean} enabled -点符号颜色是否可修改
     * @memberOf VectorStyle#
     */
    enablePointColor: function enablePointColor(enabled) {
      Module._VectorStyle_EnablePointColor(this.handle, enabled);
    },
    /**
     * 获取几何风格点符号颜色是否混合
     *
     * @memberOf VectorStyle#
     * @returns {Boolean} 返回点符号颜色是否混合
     *
     */
    isBlendPointColor: function isBlendPointColor() {
      return Boolean(Module._VectorStyle_IsBlendPointColor(this.handle));
    },
    /**
     * 设置几何风格点符号颜色是否混合
     * @param {Boolean} blend -点符号颜色是否混合
     * @memberOf VectorStyle#
     */
    setBlendPointColor: function setBlendPointColor(blend) {
      Module._VectorStyle_SetBlendPointColor(this.handle, blend);
    },
    /**
     * 设置点符号公告板模式
     * @param {PIEBillBoardModeType} type -点符号公告板模式
     * @memberOf VectorStyle#
     *
     */
    setBillBoardMode: function setBillBoardMode(type) {
      Module._VectorStyle_SetBillBoardMode(this.handle, type);
    },
    /**
     * 获取点符号公告板模式
     *
     * @memberOf VectorStyle#
     * @returns {PIEBillBoardModeType} 返回点符号公告板模式
     *
     */
    getBillBoardMode: function getBillBoardMode() {
      return Module._VectorStyle_GetBillBoardMode(this.handle);
    },
    /**
     * 设置线符号类型
     * @param {PIELineType} type -线符号类型
     * @memberOf VectorStyle#
     *
     */
    setLineType: function setLineType(type) {
      if (type != null) {
        Module._VectorStyle_SetLineType(this.handle, type);
      }
    },
    /**
     * 获取线符号类型
     *
     * @memberOf VectorStyle#
     * @returns {PIELineType} 返回线符号类型
     *
     */
    getLineType: function getLineType() {
      return Module._VectorStyle_GetLineType(this.handle);
    },
    /**
     * 设置线风格ID
     * @param {Number} style -线风格ID
     * @memberOf VectorStyle#
     *
     */
    setLineStyle: function setLineStyle(style) {
      if (style != null) {
        Module._VectorStyle_SetLineStyle(this.handle, style);
      }
    },
    /**
     * 获取线风格ID
     *
     * @memberOf VectorStyle#
     * @returns {Number} 返回线风格ID
     *
     */
    getLineStyle: function getLineStyle() {
      return Module._VectorStyle_GetLineStyle(this.handle);
    },
    /**
     * 获取几何风格线颜色
     *
     * @memberOf VectorStyle#
     * @returns {PIEColor} 返回线颜色
     */
    getLineColor: function getLineColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._VectorStyle_GetLineColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(array[0], array[1], array[2], array[3]);
    },
    /**
     * 设置几何风格线颜色
     * @param {(PIEColor/Array)} color -线颜色
     * @memberOf VectorStyle#
     *
     */
    setLineColor: function setLineColor(color) {
      if (color == null) {
        return;
      }
      var array = [];
      if (color instanceof PIEColor) {
        array = [color.r, color.g, color.b, color.a];
      } else if (color instanceof Array) {
        array = [color[0], color[1], color[2], color[3]];
      }
      if (array.length == 4) {
        var colorArray = new PIEArray(array, PIEArrayType.UInt8);
        Module._VectorStyle_SetLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 设置几何风格线宽
     * @param {Number} width -线宽
     * @memberOf VectorStyle#
     *
     */
    setLineWidth: function setLineWidth(width) {
      if (width != null) {
        Module._VectorStyle_SetLineWidth(this.handle, width);
      }
    },
    /**
     * 获取几何风格线宽
     *
     * @memberOf VectorStyle#
     * @returns {Number} 返回线宽
     */
    getLineWidth: function getLineWidth() {
      return Module._VectorStyle_GetLineWidth(this.handle);
    },
    // /**
    //  * 设置几何风格线段端口类型
    //  * @param {PIELineCapStyle} style -线段端口类型
    //  * @memberOf VectorStyle#
    //  */
    setLineCapStyle: function setLineCapStyle(style) {
      Module._VectorStyle_SetLineCapStyle(this.handle, style);
    },
    // /**
    //  * 获取几何风格线段端口类型
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {PIELineCapStyle} 返回线段端口类型
    //  */
    getLineCapStyle: function getLineCapStyle() {
      return Module._VectorStyle_GetLineCapStyle(this.handle);
    },
    // /**
    //  * 设置几何风格线段连接类型
    //  * @param {PIELineJoinStyle} style -线段连接类型
    //  * @memberOf VectorStyle#
    //  */
    setLineJoinStyle: function setLineJoinStyle(style) {
      Module._VectorStyle_SetLineJoinStyle(this.handle, style);
    },
    // /**
    //  * 获取几何风格线段连接类型
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {PIELineJoinStyle} 返回线段连接类型
    //  */
    getLineJoinStyle: function getLineJoinStyle() {
      return Module._VectorStyle_GetLineJoinStyle(this.handle);
    },
    // /**
    //  * 获取虚线偏移量
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {Number} 虚线偏移量
    //  */
    getDashOffset: function getDashOffset() {
      return Module._VectorStyle_GetDashOffset(this.handle);
    },
    // /**
    //  * 设置虚线偏移量
    //  * @param {Number} dashOffset -虚线偏移量
    //  * @memberOf VectorStyle#
    //  *
    //  */
    setDashOffset: function setDashOffset(dashOffset) {
      Module._VectorStyle_SetDashOffset(this.handle, dashOffset);
    },
    // /**
    //  * 获取矢量线型虚实数组数量
    //  * @memberOf VectorStyle#
    //  * @returns {Number} 返回数组数量
    //  */
    getDashCount: function getDashCount() {
      return Module._VectorStyle_GetDashCount(this.handle);
    },
    // /**
    //  * 获取线型虚实数组
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {Array} 返回线型虚实数组
    //  */
    getDashPattern: function getDashPattern() {
      var count = this.getDashCount();
      if (count > 0) {
        var dashArray = new PIEArray(count, PIEArrayType.Float32);
        Module._VectorStyle_GetDashPattern(this.handle, dashArray.getHandle());
        dashArray.updateData();
        var dashPattern = dashArray.toArray();
        dashArray.dispose();
        return dashPattern;
      }
      return null;
    },
    // /**
    //  * 设置线型虚实数组
    //  * @param {Array} dashPattern -线型虚实数组
    //  * @memberOf VectorStyle#
    //  */
    setDashPattern: function setDashPattern(dashPattern) {
      if (dashPattern instanceof Array && dashPattern.length) {
        var dashArray = new PIEArray(dashPattern, PIEArrayType.Float32);
        Module._VectorStyle_SetDashPattern(this.handle, dashArray.getHandle(), dashPattern.length);
        dashArray.dispose();
      }
    },
    /**
     * 设置几何风格填充符号类型
     * @param {PIEFillType} type -填充符号类型
     * @memberOf VectorStyle#
     *
     */
    setFillType: function setFillType(type) {
      if (type != null) {
        Module._VectorStyle_SetFillType(this.handle, type);
      }
    },
    /**
     * 获取几何风格填充符号类型
     *
     * @memberOf VectorStyle#
     * @returns {PIEFillType} 返回填充符号类型
     *
     */
    getFillType: function getFillType() {
      return Module._VectorStyle_GetFillType(this.handle);
    },
    /**
     * 设置几何风格填充风格ID
     * @param {Number} style -填充风格ID
     * @memberOf VectorStyle#
     *
     */
    setFillStyle: function setFillStyle(style) {
      if (style != null) {
        Module._VectorStyle_SetFillStyle(this.handle, style);
      }
    },
    /**
     * 获取几何风格填充ID
     *
     * @memberOf VectorStyle#
     * @returns {Number} 返回填充风格ID
     */
    getFillStyle: function getFillStyle() {
      return Module._VectorStyle_GetFillStyle(this.handle);
    },
    /**
     * 设置几何风格填充效果(三维面对象可设置)
     * @param {PIEFillEffect} effect -填充效果枚举
     * @memberOf VectorStyle#
     *
     */
    setFillEffect: function setFillEffect(effect) {
      Module._VectorStyle_SetFillEffect(this.handle, effect);
    },
    /**
     * 获取几何风格填充效果
     *
     * @memberOf VectorStyle#
     * @returns {PIEFillEffect} 返回填充效果枚举
     */
    getFillEffect: function getFillEffect() {
      return Module._VectorStyle_GetFillEffect(this.handle);
    },
    /**
     * 获取几何风格中填充前景颜色
     *
     * @memberOf VectorStyle#
     * @returns {PIEColor} 返回的填充前景颜色
     */
    getForeFillColor: function getForeFillColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._VectorStyle_GetForeFillColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(array[0], array[1], array[2], array[3]);
    },
    /**
     * 设置几何风格中填充前景颜色
     * @param {(PIEColor/Array)} color -填充前景颜色
     * @memberOf VectorStyle#
     *
     */
    setForeFillColor: function setForeFillColor(color) {
      if (color == null) {
        return;
      }
      var array = [];
      if (color instanceof PIEColor) {
        array = [color.r, color.g, color.b, color.a];
      } else if (color instanceof Array) {
        array = [color[0], color[1], color[2], color[3]];
      }
      if (array.length == 4) {
        var colorArray = new PIEArray(array, PIEArrayType.UInt8);
        Module._VectorStyle_SetForeFillColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取几何风格中填充背景颜色
     *
     * @memberOf VectorStyle#
     * @returns {PIEColor} 返回的填充背景颜色
     */
    getBackFillColor: function getBackFillColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._VectorStyle_GetBackFillColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(array[0], array[1], array[2], array[3]);
    },
    /**
     * 设置几何风格中填充背景颜色
     * @param {(PIEColor/Array)} color -填充背景颜色
     * @memberOf VectorStyle#
     *
     */
    setBackFillColor: function setBackFillColor(color) {
      var array = [];
      if (color instanceof PIEColor) {
        array = [color.r, color.g, color.b, color.a];
      } else if (color instanceof Array) {
        array = color;
      }
      if (array.length > 3) {
        var colorArray = new PIEArray(array, PIEArrayType.UInt8);
        Module._VectorStyle_SetBackFillColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    // /**
    //  * 获取几何风格中填充角度
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {Number} 返回填充角度
    //  */
    getFillAngle: function getFillAngle() {
      return Module._VectorStyle_GetFillAngle(this.handle);
    },
    // /**
    //  * 设置几何风格中填充角度
    //  * @param {Number} angle -填充角度
    //  * @memberOf VectorStyle#
    //  *
    //  */
    setFillAngle: function setFillAngle(angle) {
      Module._VectorStyle_SetFillAngle(this.handle, angle);
    },
    // /**
    //  * 获取几何风格填充渐变类型
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {PIEFillGradientType} 返回填充渐变类型
    //  */
    // getFillGradient: function () {
    //     return Module._VectorStyle_GetFillGradient(this.handle);
    // },
    //
    // /**
    //  * 设置几何风格填充渐变类型
    //  * @param {PIEFillGradientType} type -填充渐变类型
    //  * @memberOf VectorStyle#
    //  *
    //  */
    // setFillGradient: function (type) {
    //     Module._VectorStyle_SetFillGradient(this.handle, type);
    // },

    // /**
    //  * 获取几何风格中渐变填充中心点相对于填充范围中心点的水平偏移
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {Number} 返回水平偏移量
    //  */
    getFillOffsetX: function getFillOffsetX() {
      return Module._VectorStyle_GetFillOffsetX(this.handle);
    },
    // /**
    //  * 设置几何风格中渐变填充中心点相对于填充范围中心点的水平偏移
    //  * @param {Number} offsetX -水平偏移量
    //  * @memberOf VectorStyle#
    //  *
    //  */
    setFillOffsetX: function setFillOffsetX(offsetX) {
      Module._VectorStyle_SetFillOffsetX(this.handle, offsetX);
    },
    // /**
    //  * 获取几何风格中渐变填充中心点相对于填充范围中心点的垂直偏移
    //  *
    //  * @memberOf VectorStyle#
    //  * @returns {Number} 返回垂直偏移量
    //  */
    getFillOffsetY: function getFillOffsetY() {
      return Module._VectorStyle_GetFillOffsetY(this.handle);
    },
    // /**
    //  * 设置几何风格中渐变填充中心点相对于填充范围中心点的垂直偏移
    //  * @param {Number} offsetY -垂直偏移量
    //  * @memberOf VectorStyle#
    //  *
    //  */
    setFillOffsetY: function setFillOffsetY(offsetY) {
      Module._VectorStyle_SetFillOffsetY(this.handle, offsetY);
    },
    /**
     * 设置依地模式
     * @param {PIEAltitudeMode} mode -依地模式
     * @memberOf VectorStyle#
     *
     */
    setAltitudeMode: function setAltitudeMode(mode) {
      if (mode) {
        Module._VectorStyle_SetAltitudeMode(this.handle, mode);
      }
    },
    /**
     * 获取依地模式
     *
     * @memberOf VectorStyle#
     * @returns {PIEAltitudeMode} 返回依地模式
     */
    getAltitudeMode: function getAltitudeMode() {
      return Module._VectorStyle_GetAltitudeMode(this.handle);
    },
    /**
     * 设置分类模式
     * @param {PIEClassifyMode} mode -分类模式
     * @memberOf VectorStyle#
     *
     */
    setClassifyMode: function setClassifyMode(mode) {
      Module._VectorStyle_SetClassifyMode(this.handle, mode);
    },
    /**
     * 获取分类模式
     *
     * @memberOf VectorStyle#
     * @returns {PIEClassifyMode} 返回分类模式
     */
    getClassifyMode: function getClassifyMode() {
      return Module._VectorStyle_GetClassifyMode(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 创建几何文本风格对象
   * @name TextStyle
   * @class TextStyle
   * 文本风格操作函数
   *
   * @extends Style
   * @example
   * let textStyle = new PIE.TextStyle();
   */
  function PIETextStyle(handle, autoRelease) {
    if (handle == null) {
      handle = Module._TextStyle_Create();
      autoRelease = true;
    }
    PIEStyle.call(this, handle, autoRelease);
  }
  PIETextStyle.prototype = Object.assign(Object.create(PIEStyle.prototype), {
    /**
     * 获取文本风格字体名称
     *
     * @memberOf TextStyle#
     * @returns {String} 返回的文本字体名称
     */
    getFaceName: function getFaceName() {
      var strName = new PIEString$1(256);
      Module._TextStyle_GetFaceName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置文本风格字体名称
     * @param {String} name -文本字体名称 example "微软雅黑"
     * @memberOf TextStyle#
     *
     */
    setFaceName: function setFaceName(name) {
      var strName = new PIEString$1(name);
      Module._TextStyle_SetFaceName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取文本风格背景颜色
     *
     * @memberOf TextStyle#
     * @returns {PIEColor} 返回的文本风格背景颜色
     */
    getBackColor: function getBackColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._TextStyle_GetBackColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var color = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置文本风格背景颜色
     * @param {(PIEColor/Array)} color -文本风格背景颜色
     * @memberOf TextStyle#
     */
    setBackColor: function setBackColor(color) {
      var array = null;
      if (color instanceof PIEColor) {
        array = color.toArray();
      } else if (color instanceof Array) {
        array = color;
      }
      if (color) {
        var colorArray = new PIEArray(array, PIEArrayType.UInt8);
        Module._TextStyle_SetBackColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取文本风格前景颜色
     *
     * @memberOf TextStyle#
     * @returns {PIEColor} 如果成功返回文本前景颜色，如果失败返回NULL
     */
    getForeColor: function getForeColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._TextStyle_GetForeColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var color = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置文本风格前景颜色
     * @param {(PIEColor/Array)} color -文本前景颜色
     * @memberOf TextStyle#
     *
     */
    setForeColor: function setForeColor(color) {
      var array = null;
      if (color instanceof PIEColor) {
        array = color.toArray();
      } else if (color instanceof Array) {
        array = color;
      }
      if (color) {
        var colorArray = new PIEArray(array, PIEArrayType.UInt8);
        Module._TextStyle_SetForeColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取文本字体宽度
     *
     * @memberOf TextStyle#
     * @returns {Number} 返回的文本字体宽度
     */
    getWidth: function getWidth() {
      return Module._TextStyle_GetWidth(this.handle);
    },
    /**
     * 设置文本风格字体宽度
     * @param {Number} width -文本字体宽度
     * @memberOf TextStyle#
     *
     */
    setWidth: function setWidth(width) {
      Module._TextStyle_SetWidth(this.handle, width);
    },
    /**
     * 获取文本风格字体高度
     *
     * @memberOf TextStyle#
     * @returns {Number} 返回的文本字体高度
     */
    getHeight: function getHeight() {
      return Module._TextStyle_GetHeight(this.handle);
    },
    /**
     * 设置文本风格字体高度
     * @param {Number} height -文本字体高度
     * @memberOf TextStyle#
     */
    setHeight: function setHeight(height) {
      Module._TextStyle_SetHeight(this.handle, height);
    },
    /**
     * 获取文本对齐方式
     *
     * @memberOf TextStyle#
     * @returns {PIETextAlignType} 返回的文本对齐方式
     *
     */
    getAlign: function getAlign() {
      return Module._TextStyle_GetAlign(this.handle);
    },
    /**
     * 设置文本对齐方式
     * @param {PIETextAlignType} type -文本对齐方式
     * @memberOf TextStyle#
     *
     */
    setAlign: function setAlign(type) {
      Module._TextStyle_SetAlign(this.handle, type);
    },
    /**
     * 获取文本旋转角度
     *
     * @memberOf TextStyle#
     * @returns {Number} 返回的文本旋转角度
     */
    getAngle: function getAngle() {
      return Module._TextStyle_GetAngle(this.handle);
    },
    /**
     * 设置文本旋转角度
     * @param {Number} angle -旋转角度
     * @memberOf TextStyle#
     *
     */
    setAngle: function setAngle(angle) {
      Module._TextStyle_SetAngle(this.handle, angle);
    },
    /**
     * 获取文本偏移量
     *
     * @memberOf TextStyle#
     * @returns {PIESize} 返回的文本偏移量
     */
    getOffset: function getOffset() {
      var offsetArray = new PIEArray(2, PIEArrayType.Float64);
      Module._TextStyle_GetOffset(this.handle, offsetArray.getHandle());
      offsetArray.updateData();
      var offset = offsetArray.toArray();
      offsetArray.dispose();
      return new PIESize(offset[0], offset[1]);
    },
    /**
     * 设置文本偏移量
     * @param {(PIESize/Array)} offset -文本偏移量
     * @memberOf TextStyle#
     *
     */
    setOffset: function setOffset(offset) {
      var array = [];
      if (offset instanceof PIESize) {
        array = [offset.cx, offset.cy];
      } else if (offset instanceof Array) {
        array = offset;
      }
      var offsetArray = new PIEArray(array, PIEArrayType.Float64);
      Module._TextStyle_SetOffset(this.handle, offsetArray.getHandle());
      offsetArray.dispose();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 创建复合风格操作
   * @name SymbolStyle
   * @class SymbolStyle
   * 复合风格操作函数
   *
   * @extends Style
   * @example
   * let symbolStyle = new PIE.SymbolStyle();
   */
  function PIESymbolStyle(handle, autoRelease) {
    if (handle == null) {
      handle = Module._SymbolStyle_Create();
      autoRelease = true;
    }
    PIEStyle.call(this, handle, autoRelease);
  }
  PIESymbolStyle.prototype = Object.assign(Object.create(PIEStyle.prototype), {
    /**
     * 获取几何图形风格
     *
     * @memberOf SymbolStyle#
     * @returns {PIEVectorStyle} 获取成功返回几何图形风格对象，失败返回NULL
     *
     */
    getVectorStyle: function getVectorStyle() {
      var hVectorStyle = Module._SymbolStyle_GetVectorStyle(this.handle);
      if (hVectorStyle) {
        return new PIEVectorStyle({
          handle: hVectorStyle
        });
      }
      return null;
    },
    /**
     * 设置几何图形风格
     * @param {PIEVectorStyle} vectorStyle -几何图形风格对象(风格对象传入后内部会进行克隆，外部必须释放传入的风格对象，否则会出现内存泄露)
     * @memberOf SymbolStyle#
     *
     */
    setVectorStyle: function setVectorStyle(vectorStyle) {
      Module._SymbolStyle_SetVectorStyle(this.handle, vectorStyle.getHandle());
    },
    /**
     * 获取文本风格对象
     *
     * @memberOf SymbolStyle#
     * @returns {PIETextStyle} 如果成功返回文本风格对象,如果失败返回空
     *
     */
    getTextStyle: function getTextStyle() {
      var hTextStyle = Module._SymbolStyle_GetTextStyle(this.handle);
      if (hTextStyle) {
        return new PIETextStyle(hTextStyle);
      }
      return null;
    },
    /**
     * 设置文本风格对象
     *
     * @param {PIETextStyle} textStyle -文本风格对象(风格对象传入后内部会进行克隆，外部必须释放传入的风格对象，否则会出现内存泄露)
     * @memberOf SymbolStyle#
     *
     */
    setTextStyle: function setTextStyle(textStyle) {
      Module._SymbolStyle_SetTextStyle(this.handle, textStyle.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 三维4阶向量类
   * @name Vector4
   * @class Vector4
   *
   * @param {Number} x -x值
   * @param {Number} y -y值
   * @param {Number} z -z值
   * @param {Number} w -w值
   *
   */
  function PIEVector4(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  Object.assign(PIEVector4.prototype, {
    /**
     * 向量相乘
     * @param {PIEVector4} v -向量
     * @memberOf Vector4#
     *
     */
    multiply: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    },
    /**
     * 求向量乘以一个4*4矩阵
     * @param {PIEMatrix4} matrix -4*4矩阵
     * @memberOf Vector4#
     *
     */
    applyMatrix4: function applyMatrix4(m) {
      var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
      var e = m.m;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    },
    toArray: function toArray() {
      return [this.x, this.y, this.z, this.w];
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建四维矩阵
   * @name Matrix4
   * @class Matrix4
   * 四维矩阵操作函数
   */
  function PIEMatrix4() {
    this.m = new Float32Array(16);
    {
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = 1;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = 0;
      this.m[10] = 1;
      this.m[11] = 0;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = 0;
      this.m[15] = 1;
    }
  }
  Object.assign(PIEMatrix4.prototype, {
    /**
     * 创建矩阵
     * @param {Number} m0
     * @param {Number} m1
     * @param {Number} m2
     * @param {Number} m3
     * @param {Number} m4
     * @param {Number} m5
     * @param {Number} m6
     * @param {Number} m7
     * @param {Number} m8
     * @param {Number} m9
     * @param {Number} m10
     * @param {Number} m11
     * @param {Number} m12
     * @param {Number} m13
     * @param {Number} m14
     * @param {Number} m15
     *
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回创建的矩阵
     */
    create: function create(m0, m4, m8, m12, m1, m5, m9, m13, m2, m6, m10, m14, m3, m7, m11, m15) {
      this.m[0] = m0;
      this.m[1] = m1;
      this.m[2] = m2;
      this.m[3] = m3;
      this.m[4] = m4;
      this.m[5] = m5;
      this.m[6] = m6;
      this.m[7] = m7;
      this.m[8] = m8;
      this.m[9] = m9;
      this.m[10] = m10;
      this.m[11] = m11;
      this.m[12] = m12;
      this.m[13] = m13;
      this.m[14] = m14;
      this.m[15] = m15;
      return this;
    },
    /**
     * 构造float的4*4单位矩阵
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回单位矩阵
     */
    identity: function identity() {
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = 1;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = 0;
      this.m[10] = 1;
      this.m[11] = 0;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = 0;
      this.m[15] = 1;
      return this;
    },
    /**
     * 初始化4*4的单位矩阵
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回初始化的矩阵
     */
    zero: function zero() {
      this.m[0] = 0;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = 0;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = 0;
      this.m[10] = 0;
      this.m[11] = 0;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = 0;
      this.m[15] = 0;
      return this;
    },
    /**
     * 矩阵相乘
     * @param {PIEMatrix4} matrix -4*4矩阵对象
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回相乘后的矩阵
     */
    multiply: function multiply(matrix) {
      var ae = this.m;
      var be = matrix.m;
      var a11 = ae[0],
        a12 = ae[4],
        a13 = ae[8],
        a14 = ae[12];
      var a21 = ae[1],
        a22 = ae[5],
        a23 = ae[9],
        a24 = ae[13];
      var a31 = ae[2],
        a32 = ae[6],
        a33 = ae[10],
        a34 = ae[14];
      var a41 = ae[3],
        a42 = ae[7],
        a43 = ae[11],
        a44 = ae[15];
      var b11 = be[0],
        b12 = be[4],
        b13 = be[8],
        b14 = be[12];
      var b21 = be[1],
        b22 = be[5],
        b23 = be[9],
        b24 = be[13];
      var b31 = be[2],
        b32 = be[6],
        b33 = be[10],
        b34 = be[14];
      var b41 = be[3],
        b42 = be[7],
        b43 = be[11],
        b44 = be[15];
      this.m[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      this.m[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      this.m[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      this.m[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      this.m[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      this.m[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      this.m[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      this.m[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      this.m[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      this.m[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      this.m[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      this.m[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      this.m[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      this.m[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      this.m[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      this.m[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    },
    /**
     * 平移矩阵
     * @param {Number} x -x值
     * @param {Number} y -y值
     * @param {Number} z -z值
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回平移后的矩阵
     */
    translation: function translation(x, y, z) {
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = 1;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = 0;
      this.m[10] = 1;
      this.m[11] = 0;
      this.m[12] = x;
      this.m[13] = y;
      this.m[14] = z;
      this.m[15] = 1;
      return this;
    },
    /**
     * 缩放矩阵
     * @param {Number} x -x值
     * @param {Number} y -y值
     * @param {Number} z -z值
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回缩放后的矩阵
     */
    scaling: function scaling(x, y, z) {
      this.m[0] = x;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = y;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = 0;
      this.m[10] = z;
      this.m[11] = 0;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = 0;
      this.m[15] = 1;
      return this;
    },
    /**
     * 以X轴旋转
     * @param {Number} radian -顺时针旋转角度
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回旋转后的矩阵
     */
    rotationX: function rotationX(radian) {
      var s = Math.sin(radian);
      var c = Math.cos(radian);
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = c;
      this.m[6] = s;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = -s;
      this.m[10] = c;
      this.m[11] = 0;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = 0;
      this.m[15] = 1;
      return this;
    },
    /**
     * 以Y轴旋转
     * @param {Number} radian -顺时针旋转角度
     * @returns {PIEMatrix4} 返回旋转后的矩阵
     * @memberOf Matrix4#
     */
    rotationY: function rotationY(radian) {
      var s = Math.sin(radian);
      var c = Math.cos(radian);
      this.m[0] = c;
      this.m[1] = 0;
      this.m[2] = -s;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = 1;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = s;
      this.m[9] = 0;
      this.m[10] = c;
      this.m[11] = 0;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = 0;
      this.m[15] = 1;
      return this;
    },
    /**
     * 以Z轴旋转
     * @param {Number} radian -顺时针旋转角度
     *@returns {PIEMatrix4} 返回旋转后的矩阵
     * @memberOf Matrix4#
     */
    rotationZ: function rotationZ(radian) {
      var s = Math.sin(radian);
      var c = Math.cos(radian);
      this.m[0] = c;
      this.m[1] = s;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = -s;
      this.m[5] = c;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = 0;
      this.m[10] = 1;
      this.m[11] = 0;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = 0;
      this.m[15] = 1;
      return this;
    },
    /**
     * 计算逆矩阵
     * @returns {PIEMatrix4} 矩阵
     * @returns {PIEMatrix4} 返回逆矩阵
     * @memberOf Matrix4#
     */
    invert: function invert() {
      // transpose matrix
      var src0 = this.m[0];
      var src4 = this.m[1];
      var src8 = this.m[2];
      var src12 = this.m[3];
      var src1 = this.m[4];
      var src5 = this.m[5];
      var src9 = this.m[6];
      var src13 = this.m[7];
      var src2 = this.m[8];
      var src6 = this.m[9];
      var src10 = this.m[10];
      var src14 = this.m[11];
      var src3 = this.m[12];
      var src7 = this.m[13];
      var src11 = this.m[14];
      var src15 = this.m[15];

      // calculate pairs for first 8 elements (cofactors)
      var atmp0 = src10 * src15;
      var atmp1 = src11 * src14;
      var atmp2 = src9 * src15;
      var atmp3 = src11 * src13;
      var atmp4 = src9 * src14;
      var atmp5 = src10 * src13;
      var atmp6 = src8 * src15;
      var atmp7 = src11 * src12;
      var atmp8 = src8 * src14;
      var atmp9 = src10 * src12;
      var atmp10 = src8 * src13;
      var atmp11 = src9 * src12;

      // calculate first 8 elements (cofactors)
      var dst0 = atmp0 * src5 + atmp3 * src6 + atmp4 * src7 - (atmp1 * src5 + atmp2 * src6 + atmp5 * src7);
      var dst1 = atmp1 * src4 + atmp6 * src6 + atmp9 * src7 - (atmp0 * src4 + atmp7 * src6 + atmp8 * src7);
      var dst2 = atmp2 * src4 + atmp7 * src5 + atmp10 * src7 - (atmp3 * src4 + atmp6 * src5 + atmp11 * src7);
      var dst3 = atmp5 * src4 + atmp8 * src5 + atmp11 * src6 - (atmp4 * src4 + atmp9 * src5 + atmp10 * src6);
      var dst4 = atmp1 * src1 + atmp2 * src2 + atmp5 * src3 - (atmp0 * src1 + atmp3 * src2 + atmp4 * src3);
      var dst5 = atmp0 * src0 + atmp7 * src2 + atmp8 * src3 - (atmp1 * src0 + atmp6 * src2 + atmp9 * src3);
      var dst6 = atmp3 * src0 + atmp6 * src1 + atmp11 * src3 - (atmp2 * src0 + atmp7 * src1 + atmp10 * src3);
      var dst7 = atmp4 * src0 + atmp9 * src1 + atmp10 * src2 - (atmp5 * src0 + atmp8 * src1 + atmp11 * src2);

      // calculate pairs for second 8 elements (cofactors)
      var btmp0 = src2 * src7;
      var btmp1 = src3 * src6;
      var btmp2 = src1 * src7;
      var btmp3 = src3 * src5;
      var btmp4 = src1 * src6;
      var btmp5 = src2 * src5;
      var btmp6 = src0 * src7;
      var btmp7 = src3 * src4;
      var btmp8 = src0 * src6;
      var btmp9 = src2 * src4;
      var btmp10 = src0 * src5;
      var btmp11 = src1 * src4;

      // calculate second 8 elements (cofactors)
      var dst8 = btmp0 * src13 + btmp3 * src14 + btmp4 * src15 - (btmp1 * src13 + btmp2 * src14 + btmp5 * src15);
      var dst9 = btmp1 * src12 + btmp6 * src14 + btmp9 * src15 - (btmp0 * src12 + btmp7 * src14 + btmp8 * src15);
      var dst10 = btmp2 * src12 + btmp7 * src13 + btmp10 * src15 - (btmp3 * src12 + btmp6 * src13 + btmp11 * src15);
      var dst11 = btmp5 * src12 + btmp8 * src13 + btmp11 * src14 - (btmp4 * src12 + btmp9 * src13 + btmp10 * src14);
      var dst12 = btmp2 * src10 + btmp5 * src11 + btmp1 * src9 - (btmp4 * src11 + btmp0 * src9 + btmp3 * src10);
      var dst13 = btmp8 * src11 + btmp0 * src8 + btmp7 * src10 - (btmp6 * src10 + btmp9 * src11 + btmp1 * src8);
      var dst14 = btmp6 * src9 + btmp11 * src11 + btmp3 * src8 - (btmp10 * src11 + btmp2 * src8 + btmp7 * src9);
      var dst15 = btmp10 * src10 + btmp4 * src8 + btmp9 * src9 - (btmp8 * src9 + btmp11 * src10 + btmp5 * src8);

      // calculate determinant
      var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;
      if (det == 0) {
        return this.identity();
      }

      // calculate matrix inverse
      var invdet = 1.0 / det;
      this.m[0] = dst0 * invdet;
      this.m[1] = dst1 * invdet;
      this.m[2] = dst2 * invdet;
      this.m[3] = dst3 * invdet;
      this.m[4] = dst4 * invdet;
      this.m[5] = dst5 * invdet;
      this.m[6] = dst6 * invdet;
      this.m[7] = dst7 * invdet;
      this.m[8] = dst8 * invdet;
      this.m[9] = dst9 * invdet;
      this.m[10] = dst10 * invdet;
      this.m[11] = dst11 * invdet;
      this.m[12] = dst12 * invdet;
      this.m[13] = dst13 * invdet;
      this.m[14] = dst14 * invdet;
      this.m[15] = dst15 * invdet;
      return this;
    },
    // /**
    //  * 设置旋转矩阵
    //  * @param {PIEMatrix4d} matrix -矩阵
    //  *
    //  * @memberOf Matrix4#
    //  */
    // fromRotationMatrix: function (matrix) {
    //     this.m[0] = matrix.m[0];
    //     this.m[1] = matrix.m[1];
    //     this.m[2] = matrix.m[2];
    //     this.m[3] = matrix.m[4];
    //     this.m[4] = matrix.m[5];
    //     this.m[5] = matrix.m[6];
    //     this.m[6] = matrix.m[8];
    //     this.m[7] = matrix.m[9];
    //     this.m[8] = matrix.m[10];
    // },
    // /**
    //  * 取旋转矩阵
    //  * @returns {PIEMatrix3f} -矩阵
    //  *
    //  * @memberOf Matrix4#
    //  */
    // toRotationMatrix: function () {
    //     var matrix = new PIEMatrix3f();
    //     matrix.m[0] = this.m[0];
    //     matrix.m[1] = this.m[1];
    //     matrix.m[2] = this.m[2];
    //     matrix.m[3] = this.m[4];
    //     matrix.m[4] = this.m[5];
    //     matrix.m[5] = this.m[6];
    //     matrix.m[6] = this.m[8];
    //     matrix.m[7] = this.m[9];
    //     matrix.m[8] = this.m[10];
    //     return matrix;
    // },
    /**
     * 转置矩阵
     * @returns {PIEMatrix4} 矩阵
     * @returns {PIEMatrix4} 返回转置矩阵
     * @memberOf Matrix4#
     */
    transpose: function transpose() {
      var te = this.m;
      var tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    },
    /**
     * 采用施密特正交方法计算出正交矩阵
     * @param {Number} left -x的最小值
     * @param {Number} right -x的最大值
     * @param {Number} bottom -y的最小值
     * @param {Number} top -y的最大值
     * @param {Number} nearly -z的最小值
     * @param {Number} faraway -z的最大值
     *@returns {PIEMatrix4} 返回正交矩阵
     * @memberOf Matrix4#
     */
    ortho: function ortho(left, right, bottom, top, nearly, faraway) {
      var a = 2.0 / (right - left);
      var b = 2.0 / (top - bottom);
      var c = -2.0 / (faraway - nearly);
      var tx = (right + left) / (right - left);
      var ty = (top + bottom) / (top - bottom);
      var tz = (faraway + nearly) / (faraway - nearly);
      this.m[0] = a;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = b;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      this.m[9] = 0;
      this.m[10] = c;
      this.m[11] = 0;
      this.m[12] = tx;
      this.m[13] = ty;
      this.m[14] = tz;
      this.m[15] = 1;
      return this;
    },
    /**
     * 设置视图矩阵
     * @param {Number} left -设定相机视锥的左平面的值
     * @param {Number} right -设定相机视锥的右平面的值
     * @param {Number} bottom -设定相机视锥的底面的值
     * @param {Number} top -设定相机视锥的顶面的值
     * @param {Number} nearly -设置相机视锥台的近平面的值
     * @param {Number} faraway -设置相机视锥台接远平面的值
     * @returns {PIEMatrix4} 返回view矩阵
     * @memberOf Matrix4#
     */
    frustum: function frustum(left, right, bottom, top, nearly, faraway) {
      var a = 2 * nearly / (right - left);
      var b = 2 * nearly / (top - bottom);
      var c = (right + left) / (right - left);
      var d = (top + bottom) / (top - bottom);
      var e = -(faraway + nearly) / (faraway - nearly);
      var f = -2 * faraway * nearly / (faraway - nearly);
      this.m[0] = a;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = b;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = c;
      this.m[9] = d;
      this.m[10] = e;
      this.m[11] = -1;
      this.m[12] = 0;
      this.m[13] = 0;
      this.m[14] = f;
      this.m[15] = 1;
      return this;
    },
    /**
     * 设置视图矩阵
     * @param {Number} fovy -视角的大小
     * @param {Number} aspect -表示裁剪面的宽高比
     * @param {Number} zNear -近裁剪面到眼睛的距离
     * @param {Number} zFar -远裁剪面到眼睛的距离
     * @returns {PIEMatrix4} 返回视图矩阵
     * @memberOf Matrix4#
     */
    perspective: function perspective(fovy, aspect, zNear, zFar) {
      var f = 1.0 / Math.tan(fovy / 2);
      var rangeReciprocal = 1.0 / (zNear - zFar);
      this.m[0] = f / aspect;
      this.m[1] = 0.0;
      this.m[2] = 0.0;
      this.m[3] = 0.0;
      this.m[4] = 0.0;
      this.m[5] = f;
      this.m[6] = 0.0;
      this.m[7] = 0.0;
      this.m[8] = 0.0;
      this.m[9] = 0.0;
      this.m[10] = (zFar + zNear) * rangeReciprocal;
      this.m[11] = -1.0;
      this.m[12] = 0.0;
      this.m[13] = 0.0;
      this.m[14] = 2.0 * zFar * zNear * rangeReciprocal;
      this.m[15] = 0.0;
      return this;
    },
    /**
     * 克隆
     * @memberOf Matrix4#
     * @returns {PIEMatrix4} 返回克隆后的矩阵
     */
    clone: function clone() {
      var matrix = new PIEMatrix4();
      for (var i = 0; i < 16; i++) {
        matrix.m[i] = this.m[i];
      }
      return matrix;
    },
    toArray: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var te = this.m;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  });
  PIEMatrix4.fromArray = function (m) {
    if (m instanceof Array && m.length == 16) {
      var resMatrix = new PIEMatrix4();
      resMatrix.create(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
      return resMatrix;
    }
    return null;
  };

  /**
   * 矩阵和矩阵相乘
   * @param {PIEMatrix4} lhs -左矩阵
   * @param {PIEMatrix4} rhs -右矩阵
   *
   * @memberOf Matrix4
   * @returns {PIEMatrix4} 返回结果
   *
   *
   */
  PIEMatrix4.multiply = function (lhs, rhs) {
    var result = lhs.clone();
    return result.multiply(rhs);
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 三维向量类
   * @name Vector3
   * @class Vector3
   *
   * @param {Number} x -x值
   * @param {Number} y -y值
   * @param {Number} z -z值
   */
  function PIEVector3(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  }
  Object.assign(PIEVector3.prototype, {
    /**
     * 进行规格化
     * @memberOf Vector3#
     *
     */
    normalize: function normalize() {
      var length = this.length();
      if (length != 0) {
        this.x /= length;
        this.y /= length;
        this.z /= length;
      }
    },
    /**
     * 进行归一化
     *
     * @memberOf Vector3#
     * @returns {PIEVector3} 返回归一化后的向量
     *
     */
    normalized: function normalized() {
      var v = new PIEVector3(this.x, this.y, this.z);
      v.normalize();
      return v;
    },
    /**
     * 求向量的长度
     *
     * @memberOf Vector3#
     * @returns {number} 返回向量的长度
     *
     */
    length: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    /**
     * 自身缩放
     * @param {Number} s -value
     * @memberOf Vector3#
     *
     * @returns {PIEVector3} 返回缩放后的向量
     *
     */
    scale: function scale(s) {
      return new PIEVector3(this.x * s, this.y * s, this.z * s);
    },
    /**
     * 判断向量的长度是否为0
     *
     * @memberOf Vector3#
     * @returns {Boolean} 如果向量长度为0返回0，否则返回向量长度
     *
     */
    isZero: function isZero() {
      return PIEMath.isZero(this.length());
    },
    /**
     * 求两个向量的叉积
     * @param {PIEVector3} vec -三维向量
     * @memberOf Vector3#
     *
     * @returns {PIEVector3} 返回叉积结果
     *
     */
    cross: function cross(vec) {
      return new PIEVector3(this.y * vec.z - this.z * vec.y, this.z * vec.x - this.x * vec.z, this.x * vec.y - this.y * vec.x);
    },
    /**
     * 求两个向量的点积
     * @param {PIEVector3} vec -三维向量
     * @memberOf Vector3#
     *
     * @returns {Number} 返回点积结果
     *
     */
    dot: function dot(vec) {
      return this.x * vec.x + this.y * vec.y + this.z * vec.z;
    },
    /**
     * 向量相减
     * @param {PIEVector3} vec -三维向量
     * @memberOf Vector3#
     *
     * @returns {PIEVector3} 返回相减后的向量
     *
     */
    sub: function sub(vec) {
      return new PIEVector3(this.x - vec.x, this.y - vec.y, this.z - vec.z);
    },
    /**
     * 向量相加
     * @param {PIEVector3} vec -三维向量
     * @memberOf Vector3#
     *
     * @returns {PIEVector3} 返回相加后的向量
     *
     */
    add: function add(vec) {
      return new PIEVector3(this.x + vec.x, this.y + vec.y, this.z + vec.z);
    },
    /**
     * 向量克隆
     *
     * @memberOf Vector3#
     * @returns {PIEVector3} 返回克隆的向量
     *
     */
    clone: function clone() {
      return new PIEVector3(this.x, this.y, this.z);
    },
    // /**
    //  * 求向量乘以一个4*3的矩阵
    //  * @param {PIEVector4} v -向量
    //  * @param {PIEMatrix4} matrix -4*4矩阵
    //  * @memberOf Vector3#
    //  *
    //  * @returns {PIEVector4} 返回相乘后的结果
    //  *
    //  */
    // multiply: function (matrix) {
    //     var v = new PIEVector4(this.x, this.y, this.z, 1.0);
    //     var m11 = 0, m12 = 0, m13 = 0, ml4 = 0;
    //
    //     m11 = v.x * matrix.m[0] + v.y * matrix.m[4] + v.z * matrix.m[8] + v.w * matrix.m[12];
    //     m12 = v.x * matrix.m[1] + v.y * matrix.m[5] + v.z * matrix.m[9] + v.w * matrix.m[13];
    //     m13 = v.x * matrix.m[2] + v.y * matrix.m[6] + v.z * matrix.m[10] + v.w * matrix.m[14];
    //     ml4 = v.x * matrix.m[3] + v.y * matrix.m[7] + v.z * matrix.m[11] + v.w * matrix.m[15];
    //     return new PIEVector4(m11, m12, m13, ml4);
    // },
    /**
     * 向量相乘
     * @param {PIEVector3} v -向量
     * @memberOf Vector3#
     * @returns {PIEVector3} 返回相乘后的结果
     *
     */
    multiply: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    },
    /**
     * 将空间坐标转换成windows坐标
     * @param {PIEVector4} viewport -视口
     * @param {PIEMatrix4} projection -投影矩阵
     * @param {PIEMatrix4} view -视图矩阵
     * @param {PIEMatrix4} world -世界矩阵
     * @memberOf Vector3#
     *
     */
    project: function project(viewport, projection, view, world) {
      var m = PIEMatrix4.multiply(projection, view);
      m = PIEMatrix4.multiply(m, world);
      var v = new PIEVector4(this.x, this.y, this.z, 1.0);
      v.applyMatrix4(m);
      if (v.w == 0) {
        return;
      }
      v.x /= v.w;
      v.y /= v.w;
      v.z /= v.w;

      /* Map x, y and z to range 0-1 */
      v.x = v.x * 0.5 + 0.5;
      v.y = v.y * 0.5 + 0.5;
      v.z = v.z * 0.5 + 0.5;

      /* Map x,y to viewport */
      v.x = v.x * viewport.z + viewport.x;
      v.y = v.y * viewport.w + viewport.y;
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
    },
    /**
     * 将window坐标转换成空间坐标
     * @param {PIEVector4} viewport -视口
     * @param {PIEMatrix4} projection -投影矩阵
     * @param {PIEMatrix4} view -视图矩阵
     * @param {PIEMatrix4} world -世界矩阵
     * @memberOf Vector3#
     *
     */
    unProject: function unProject(viewport, projection, view, world) {
      var m = PIEMatrix4.multiply(projection, view);
      m = PIEMatrix4.multiply(m, world);
      m = m.invert();
      var v = new PIEVector4();
      v.x = 2.0 * (this.x - viewport.x) / viewport.z - 1.0;
      v.y = 2.0 * (this.y - viewport.y) / viewport.w - 1.0;
      v.z = 2.0 * this.z - 1.0;
      v.w = 1.0;
      v.applyMatrix4(m);
      if (v.w == 0.0) {
        return;
      }
      this.x = v.x / v.w;
      this.y = v.y / v.w;
      this.z = v.z / v.w;
    },
    toArray: function toArray() {
      var array = [this.x, this.y, this.z];
      return array;
    }
  });

  /**
   * 向量与矩阵相乘
   * @param {PIEVector3} v -向量
   * @param {PIEMatrix4} matrix -矩阵
   *
   * @memberOf Vector3
   * @returns {PIEVector3} 返回结果
   */
  PIEVector3.multiplyMatrix4 = function (v, matrix) {
    var w = 1;
    var m11 = 0,
      m12 = 0,
      m13 = 0,
      m14 = 0;
    m11 = v.x * matrix.m[0] + v.y * matrix.m[4] + v.z * matrix.m[8] + w * matrix.m[12];
    m12 = v.x * matrix.m[1] + v.y * matrix.m[5] + v.z * matrix.m[9] + w * matrix.m[13];
    m13 = v.x * matrix.m[2] + v.y * matrix.m[6] + v.z * matrix.m[10] + w * matrix.m[14];
    m14 = v.x * matrix.m[3] + v.y * matrix.m[7] + v.z * matrix.m[11] + w * matrix.m[15];
    return new PIEVector3(m11 / m14, m12 / m14, m13 / m14);
  };

  /**
   * 向量与矩阵相乘
   * @param {PIEVector3} v -向量
   * @param {PIEMatrix3d} matrix -矩阵
   *
   * @memberOf Vector3
   * @returns {PIEVector3} 返回结果
   */
  PIEVector3.multiplyMatrix3 = function (v, matrix) {
    var m11 = 0,
      m12 = 0,
      m13 = 0;
    m11 = v.x * matrix.m[0] + v.y * matrix.m[3] + v.z * matrix.m[6];
    m12 = v.x * matrix.m[1] + v.y * matrix.m[4] + v.z * matrix.m[7];
    m13 = v.x * matrix.m[2] + v.y * matrix.m[5] + v.z * matrix.m[8];
    return new PIEVector3(m11, m12, m13);
  };

  /**
   * 球面坐标转笛卡尔坐标
   * @param {Number} dLongitude -经度
   * @param {Number} dLatitude -纬度
   * @param {Number} dRadius -半径
   *
   * @memberOf Vector3
   * @returns {PIEVector3} 返回笛卡尔坐标
   */
  PIEVector3.sphericalToCartesian = function (dLongitude, dLatitude, dRadius) {
    var dRadCosLat = dRadius * Math.cos(dLatitude);
    return new PIEVector3(dRadCosLat * Math.sin(dLongitude), dRadius * Math.sin(dLatitude), dRadCosLat * Math.cos(dLongitude));
  };

  /**
   * 笛卡尔坐标转球面坐标
   * @param {Number} x -x值
   * @param {Number} y -y值
   * @param {Number} z -z值
   *
   * @memberOf Vector3
   * @returns {PIEVector3} 返回球面坐标
   */
  PIEVector3.cartesianToSpherical = function (x, y, z) {
    var rho = Math.sqrt(x * x + y * y + z * z);
    if (PIEMath.isZero(rho)) {
      return new PIEVector3(0, 0, 0);
    }
    var longitude = Math.atan2(x, z);
    var latitude = Math.asin(y / rho);
    return new PIEVector3(longitude, latitude, rho);
  };

  /**
   * 向量与平面的交点
   * @param {PIEVector3} vecStart -向量起点
   * @param {PIEVector3} vecEnd -向量终点
   *
   * @memberOf Vector3
   * @returns {PIEVector3} 返回交点
   */
  PIEVector3.rayIntersectionWithPlane = function (vecStart, vecEnd) {
    var vecLineVector = new PIEVector3();
    vecLineVector.x = vecEnd.x - vecStart.x;
    vecLineVector.y = vecEnd.y - vecStart.y;
    vecLineVector.z = vecEnd.z - vecStart.z;
    vecLineVector.normalize();
    var vecPlaneNormal = new PIEVector3();
    vecPlaneNormal.x = 0;
    vecPlaneNormal.y = 0;
    vecPlaneNormal.z = 1;
    var vecPlanePoint = new PIEVector3();
    vecPlanePoint.x = 0;
    vecPlanePoint.y = 0;
    vecPlanePoint.z = 0;
    new PIEVector3();
    var vp1, vp2, vp3, n1, n2, n3, v1, v2, v3, m1, m2, m3, t, vpt;
    vp1 = vecPlaneNormal.x;
    vp2 = vecPlaneNormal.y;
    vp3 = vecPlaneNormal.z;
    n1 = vecPlanePoint.x;
    n2 = vecPlanePoint.y;
    n3 = vecPlanePoint.z;
    v1 = vecLineVector.x;
    v2 = vecLineVector.y;
    v3 = vecLineVector.z;
    m1 = vecStart.x;
    m2 = vecStart.y;
    m3 = vecStart.z;
    vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
    if (vpt == 0) {
      return null;
    } else {
      t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
      var vecIntersect = new PIEVector3();
      vecIntersect.x = m1 + v1 * t;
      vecIntersect.y = m2 + v2 * t;
      vecIntersect.z = m3 + v3 * t;
      return vecIntersect;
    }
  };

  /**
   * 向量与球体的交点
   * @param {PIEVector3} vecStart -向量起点
   * @param {PIEVector3} vecEnd -向量终点
   * @param {Number} dRadius -半径
   *
   * @memberOf Vector3
   * @returns {PIEVector3} 返回交点
   */
  PIEVector3.rayIntersectionWithSphere = function (vecStart, vecEnd, dRadius) {
    var p1 = vecStart;
    var p2 = vecEnd;
    p2.x * p2.x + p2.y * p2.y + p2.z * p2.z;
    var a = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z);
    var b = 2.0 * ((p2.x - p1.x) * p1.x + (p2.y - p1.y) * p1.y + (p2.z - p1.z) * p1.z);
    var c = p1.x * p1.x + p1.y * p1.y + p1.z * p1.z - dRadius * dRadius;
    var discriminant = b * b - 4 * a * c;
    if (discriminant <= 0) {
      return null;
    }
    var t1 = (-1.0 * b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    var vecIntersect = new PIEVector3(p1.x + t1 * (p2.x - p1.x), p1.y + t1 * (p2.y - p1.y), p1.z + t1 * (p2.z - p1.z));
    return vecIntersect;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 创建模型风格对象
   * @name ModelStyle
   * @class ModelStyle
   * 模型风格操作函数
   *
   * @extends Style
   */
  function PIEModelStyle(handle, autoRelease) {
    if (handle == null) {
      handle = Module._ModelStyle_Create();
      autoRelease = true;
    }
    PIEStyle.call(this, handle, autoRelease);
  }
  PIEModelStyle.prototype = Object.assign(Object.create(PIEStyle.prototype), {
    /**
     * 设置模型类型
     * @param {Number} type -模型类型
     *
     * @memberOf ModelStyle#
     */
    setModelType: function setModelType(type) {
      Module._ModelStyle_SetModelType(this.handle, type);
    },
    /**
     * 获取模型类型
     *
     * @memberOf ModelStyle#
     * @returns {Number} 返回模型类型
     */
    getModelType: function getModelType() {
      return Module._ModelStyle_GetModelType(this.handle);
    },
    /**
     * 获取模型类型
     *
     * @memberOf ModelStyle#
     * @returns {Number} 返回模型类型
     */
    getModelStyle: function getModelStyle() {
      return Module._ModelStyle_GetModelStyle(this.handle);
    },
    /**
     * 设置模型ID
     * @param {Number} id -模型ID
     *
     * @memberOf ModelStyle#
     */
    setModelStyle: function setModelStyle(id) {
      Module._ModelStyle_SetModelStyle(this.handle, id);
    },
    /**
     * 设置旋转值
     * @param {(PIEVector3/Array)} rotation -旋转值
     *
     * @memberOf ModelStyle#
     */
    setRotation: function setRotation(rotation) {
      var array = null;
      if (rotation instanceof PIEVector3) {
        array = rotation.toArray();
      } else if (rotation instanceof Array) {
        array = rotation;
      }
      if (array) {
        var rotationArray = new PIEArray(array, PIEArrayType.Float64);
        Module._ModelStyle_SetRotation(this.handle, rotationArray.getHandle());
        rotationArray.dispose();
      }
    },
    /**
     * 获取旋转值
     *
     * @memberOf ModelStyle#
     * @returns {PIEVector3} 返回旋转值
     */
    getRotation: function getRotation() {
      var rotationArray = new PIEArray(3, PIEArrayType.Float64);
      Module._ModelStyle_GetRotation(this.handle, rotationArray.getHandle());
      rotationArray.updateData();
      var array = rotationArray.toArray();
      rotationArray.dispose();
      return new PIEVector3(array[0], array[1], array[2]);
    },
    /**
     * 设置缩放值
     * @param {(PIEVector3/Array)} scale -缩放值
     *
     * @memberOf ModelStyle#
     */
    setScale: function setScale(scale) {
      var array = null;
      if (scale instanceof PIEVector3) {
        array = scale.toArray();
      } else if (scale instanceof Array) {
        array = scale;
      }
      if (array) {
        var scaleArray = new PIEArray(array, PIEArrayType.Float64);
        Module._ModelStyle_SetScale(this.handle, scaleArray.getHandle());
        scaleArray.dispose();
      }
    },
    /**
     * 获取缩放值
     *
     * @memberOf ModelStyle#
     * @returns {PIEVector3} 返回缩放值
     */
    getScale: function getScale() {
      var scaleArray = new PIEArray(3, PIEArrayType.Float64);
      Module._ModelStyle_GetScale(this.handle, scaleArray.getHandle());
      scaleArray.updateData();
      var array = scaleArray.toArray();
      scaleArray.dispose();
      return new PIEVector3(array[0], array[1], array[2]);
    },
    /**
     * 设置平移值
     * @param {(PIEVector3/Array)} translation -平移值
     *
     * @memberOf ModelStyle#
     */
    setTranslation: function setTranslation(translation) {
      var array = null;
      if (translation instanceof PIEVector3) {
        array = translation.toArray();
      } else if (translation instanceof Array) {
        array = translation;
      }
      if (array) {
        var translationArray = new PIEArray(array, PIEArrayType.Float64);
        Module._ModelStyle_SetTranslation(this.handle, translationArray.getHandle());
        translationArray.dispose();
      }
    },
    /**
     * 获取平移值
     *
     * @memberOf ModelStyle#
     * @returns {PIEVector3} 返回平移值
     */
    getTranslation: function getTranslation() {
      var translationArray = new PIEArray(3, PIEArrayType.Float64);
      Module._ModelStyle_GetTranslation(this.handle, translationArray.getHandle());
      translationArray.updateData();
      var array = translationArray.toArray();
      translationArray.dispose();
      return new PIEVector3(array[0], array[1], array[2]);
    },
    /**
     * 设置依地模式
     * @param {PIEAltitudeMode} mode -依地模式
     * @memberOf ModelStyle#
     *
     */
    setAltitudeMode: function setAltitudeMode(mode) {
      Module._ModelStyle_SetAltitudeMode(this.handle, mode);
    },
    /**
     * 获取依地模式
     *
     * @memberOf ModelStyle#
     * @returns {PIEAltitudeMode} 返回依地模式
     */
    getAltitudeMode: function getAltitudeMode() {
      return Module._ModelStyle_GetAltitudeMode(this.handle);
    },
    /**
     * 设置是否固定大小
     * @param {Boolean} fixed -是否固定大小
     * @memberOf ModelStyle#
     *
     */
    setSizeFixed: function setSizeFixed(fixed) {
      Module._ModelStyle_SetSizeFixed(this.handle, fixed);
    },
    /**
     * 获取是否固定大小
     *
     * @memberOf ModelStyle#
     * @returns {Boolean} 返回是否固定大小
     */
    isSizeFixed: function isSizeFixed() {
      return Module._ModelStyle_IsSizeFixed(this.handle);
    }
  });

  function PIEStyleFactory() {}
  Object.assign(PIEStyleFactory.prototype, {});
  PIEStyleFactory.CreateInstance = function (hStyle) {
    var styleType = Module._Style_GetType(hStyle);
    if (styleType == PIEStyleType.Vector) {
      return new PIEVectorStyle({
        handle: hStyle
      });
    } else if (styleType == PIEStyleType.Text) {
      return new PIETextStyle(hStyle);
    } else if (styleType == PIEStyleType.Symbol) {
      return new PIESymbolStyle(hStyle);
    }
    // else if (styleType == PIEStyleType.Model) {
    //     return new PIEModelStyle(hStyle);
    // }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 依地模式
   * @readonly
   * @enum {number}
   */
  var PIEAltitudeMode = {
    /** 依地形*/
    ClampToGround: 0,
    /** 相对地形*/
    RelativeToGround: 1,
    /** 绝对高度*/
    AbsoluteAltitude: 2,
    /** 依模型*/
    ClampToModel: 3
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建简单线对象
   * @name Polyline
   * @class Polyline
   * 二维线操作函数
   * @param {Object} options -
   * @param {Array} options.points -点串数组
   * @param {Number} options.ID -线对象ID
   * @param {Array} options.subPoints -存放子对象点串数组的数组(与options.points参数选其一，当选择subPoints时，创建复杂线对象)
   *
   * @extends Geometry
   * @example
   * var point1 = [118, 42];
   * var point2 = [120, 42];
   * var point3 = [119, 41];
   * var point1SR = patialReference.forward(point1);
   * var point2SR = patialReference.forward(point2);
   * var point3SR = patialReference.forward(point3);
   * var points = [];
   * points.push.apply(points,point1SR);
   * points.push.apply(points,point2SR);
   * points.push.apply(points,point3SR);
   * var polyLine = new PIE.Polyline({points:points});
   */
  function PIEPolyline(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var points = options.points;
      var subPoints = options.subPoints;
      if (subPoints && subPoints.length > 0) {
        var subPntCounts = [];
        if (subPoints[0] instanceof Array) {
          var subCount = subPoints.length;
          var pointsX = [];
          var pointsY = [];
          for (var i = 0; i < subCount; i++) {
            var subPointsArr = subPoints[i];
            subPntCounts.push(subPoints[i].length / 2);
            for (var j = 0; j < subPointsArr.length; j++) {
              if ((j + 1) % 2 == 0) {
                pointsY.push(subPointsArr[j]);
              } else {
                pointsX.push(subPointsArr[j]);
              }
            }
          }
          var arrPointsX = new PIEArray(pointsX, PIEArrayType.Float64);
          var arrPointsY = new PIEArray(pointsY, PIEArrayType.Float64);
          var arrSubPointsCounts = new PIEArray(subPntCounts, PIEArrayType.Int32);
          handle = Module._Polyline_CreateWithSub(arrPointsX.getHandle(), arrPointsY.getHandle(), arrSubPointsCounts.getHandle(), subCount);
          autoRelease = true;
          arrPointsX.dispose();
          arrPointsY.dispose();
          arrSubPointsCounts.dispose();
        } else {
          var pointsArray = new PIEArray(subPoints, PIEArrayType.Float64);
          handle = Module._Polyline_Create_WithPoints(pointsArray.getHandle(), subPoints.length);
          pointsArray.dispose();
          autoRelease = true;
        }
      } else {
        if (points) {
          if (points instanceof Array) {
            var _pointsArray = new PIEArray(points, PIEArrayType.Float64);
            handle = Module._Polyline_Create_WithPoints(_pointsArray.getHandle(), points.length);
            _pointsArray.dispose();
            autoRelease = true;
          }
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEGeometry.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEPolyline.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 获取线对象的点数量
     *
     * @memberOf Polyline#
     * @returns {Number} 如果获取成功返回线对象个数
     */
    getPointCount: function getPointCount() {
      return Module._Polyline_GetPointCount(this.handle);
    },
    /**
     * 获取线对象中子对象的个数
     * @memberOf Polyline#
     * @returns {Number} 如果获取成功返回子对象个数
     *
     */
    getSubCount: function getSubCount() {
      return Module._Polyline_GetSubCount(this.handle);
    },
    /**
     * 获取指定序号子对象的点的个数
     * @param {Number} index -子对象的索引值
     * @memberOf Polyline#
     *
     * @returns {Number} 如果获取成功返回指定序号子对象的点的个数
     */
    getSubPointCount: function getSubPointCount(index) {
      return Module._Polyline_GetSubPointCount(this.handle, index);
    },
    /**
     * 获取线对象中指定子对象所包含点串数组
     * @param {Number} subIndex -子对象的索引值(默认为0)
     * @memberOf Polyline#
     * @returns {Array} 如果获取成功返回子对象所包含点串数组，否则返回null
     */
    getPoints: function getPoints() {
      var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = this.getSubPointCount(subIndex);
      if (count > 0) {
        var pointsRes = [];
        var pointsArr = new PIEArray(count * 2, PIEArrayType.Float64);
        Module._Polyline_GetPoints(this.handle, subIndex, pointsArr.getHandle());
        pointsArr.updateData();
        var points = pointsArr.toArray();
        pointsArr.dispose();
        for (var i = 0; i < count * 2; i += 2) {
          pointsRes.push(new PIEVector2(points[i], points[i + 1]));
        }
        return pointsRes;
      }
      return null;
    },
    /**
     * 获取线对象的长度
     *
     * @memberOf Polyline#
     * @returns {Number} 如果获取成功返回几何长度，否则返回0
     */
    getLength: function getLength() {
      return Module._Geometry_GetLength(this.handle);
    },
    /**
     * 获取指定空间参考系下的长度
     * @param {PIESpatialReference} spatialReference -指定空间参考系
     *
     * @memberOf Polyline#
     * @returns {Number} 如果获取成功返回长度，否则返回0
     */
    getLengthInSpatialReference: function getLengthInSpatialReference(spatialReference) {
      return Module._Geometry_GetLengthInSpatialReference(this.handle, spatialReference.getHandle());
    },
    /**
     * 设置线对象指定索引处点的坐标
     * @param {Number} index -指定的索引值
     * @param {PIEVector2|Array} point -指定的点坐标
     *
     * @memberOf Polyline#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setPoint: function setPoint(index, point) {
      var arrayPnt = null;
      if (point instanceof PIEVector2) {
        arrayPnt = point.toArray();
      } else if (point instanceof Array) {
        arrayPnt = point;
      }
      if (arrayPnt) {
        var pointArray = new PIEArray(arrayPnt, PIEArrayType.Float64);
        var res = Module._Polyline_SetPoint(this.handle, index, pointArray.getHandle());
        pointArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 在子对象指定的位置上设置点的坐标
     * @param {Number} subIndex -子对象索引
     * @param {Number} pointIndex -子对象点的位置索引
     * @param {PIEVector2|Array} point -点坐标
     *
     * @memberOf Polyline#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setSubPoint: function setSubPoint(subIndex, pointIndex, point) {
      var arrayPnt = null;
      if (point instanceof PIEVector2) {
        arrayPnt = point.toArray();
      } else if (point instanceof Array) {
        arrayPnt = point;
      }
      if (arrayPnt) {
        var pointArray = new PIEArray(arrayPnt, PIEArrayType.Float64);
        var res = Module._Polyline_SetSubPoint(this.handle, subIndex, pointIndex, pointArray.getHandle());
        pointArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 在线对象指定索引出插入的点坐标
     * @param {Number} subIndex -子对象索引号
     * @param {Number} pointIndex -子对象上插入点的索引号
     * @param {PIEVector2|Array} point -待插入的点坐标
     *
     * @memberOf Polyline#
     * @returns {Boolean} 如果插入成功返回true，否则返回false
     */
    insertPoint: function insertPoint(subIndex, pointIndex, point) {
      var arrayPnt = null;
      if (point instanceof PIEVector2) {
        arrayPnt = point.toArray();
      } else if (point instanceof Array) {
        arrayPnt = point;
      }
      if (arrayPnt) {
        var pointArray = new PIEArray(arrayPnt, PIEArrayType.Float64);
        var res = Module._Polyline_InsertPoint(this.handle, subIndex, pointIndex, pointArray.getHandle());
        pointArray.dispose();
        return Boolean(res);
      }
      return false;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建简单面对象
   * @name Polygon
   * @class Polygon
   * 二维面操作函数
   * @param {Object} options -
   * @param {Array} options.points - 面对象的顶点点串数组
   * @param {Number} options.ID - 面对象的ID
   * @extends Geometry
   * @example
   * var pointArray = [102, 31];
   * var pointSR = patialReference.forward(pointArray);
   *
   * var pointSR1 = patialReference.forward([104, 31]);
   * var pointSR2 = patialReference.forward([103, 30]);
   * var points = [];
   * points.push.apply(points,pointSR);
   * points.push.apply(points,pointSR1);
   * points.push.apply(points,pointSR2);
   * var pointColor = new PIE.Color(255, 0, 0, 255);
   * var polygon = new PIE.Polygon({points:points});
   */
  function PIEPolygon(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var points = options.points;
      if (points) {
        if (points instanceof Array) {
          var pointsArray = new PIEArray(points, PIEArrayType.Float64);
          handle = Module._Polygon_Create(pointsArray.getHandle(), points.length);
          pointsArray.dispose();
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEGeometry.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEPolygon.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 获取面对象的点数量
     *
     * @memberOf Polygon#
     * @returns {Number} 返回所有子对象点个数的总和
     *
     *
     */
    getPointCount: function getPointCount() {
      return Module._Polygon_GetPointCount(this.handle);
    },
    /**
     * 获取子对象的个数
     *
     * @memberOf Polygon#
     * @returns {Number} 返回所有子对象个数
     */
    getSubCount: function getSubCount() {
      return Module._Polygon_GetSubCount(this.handle);
    },
    /**
     * 获取某个子对象的点的个数
     * @param {Number} index -子对象索引
     * @memberOf Polygon#
     * @returns {Number} 返回该子对象的点个数
     */
    getSubPointCount: function getSubPointCount(index) {
      return Module._Polygon_GetSubPointCount(this.handle, index);
    },
    /**
     * 获取面对象中指定子对象所包含点串数组
     * @param {Number} subIndex -子对象的索引值(默认为0)
     * @memberOf Polygon#
     * @returns {Array} 如果获取成功返回子对象所包含点串数组，否则返回null
     */
    getPoints: function getPoints() {
      var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = this.getSubPointCount(subIndex);
      if (count > 0) {
        var pointsRes = [];
        var pointsArr = new PIEArray(count * 2, PIEArrayType.Float64);
        Module._Polygon_GetPoints(this.handle, subIndex, pointsArr.getHandle());
        pointsArr.updateData();
        var points = pointsArr.toArray();
        pointsArr.dispose();
        for (var i = 0; i < count * 2; i += 2) {
          pointsRes.push(new PIEVector2(points[i], points[i + 1]));
        }
        return pointsRes;
      }
      return null;
    },
    /**
     * 获取面对象的面积
     *
     * @memberOf Polygon#
     * @returns {Number} 如果获取成功返回几何面积，否则返回0
     */
    getArea: function getArea() {
      return Module._Geometry_GetArea(this.handle);
    },
    /**
     * 获取指定空间参考系下的面积
     * @param {PIESpatialReference} spatialReference -指定空间参考系
     *
     * @memberOf Polygon#
     * @returns {Number} 如果获取成功返回面积，否则返回0
     */
    getAreaInSpatialReference: function getAreaInSpatialReference(spatialReference) {
      return Module._Geometry_GetAreaInSpatialReference(this.handle, spatialReference.getHandle());
    },
    /**
     * 判断子多边形的走向是否是顺时针
     * @param {Number} SubIndex -子对象索引号
     * @memberOf Polygon#
     *
     * @returns {Boolean} 如果是顺时针返回true，否则返回false
     */
    isCounterClockwise: function isCounterClockwise(SubIndex) {
      return Boolean(Module._Polygon_IsCounterClockwise(this.handle, SubIndex));
    },
    /**
     * 逆序子对象点串顺序
     * @param {Number} SubIndex -子对象索引号
     * @memberOf Polygon#
     *
     * @returns {Boolean} 如果是成功返回true，否则返回false
     */
    reverseSubPolygon: function reverseSubPolygon(SubIndex) {
      return Boolean(Module._Polygon_ReverseSubPolygon(this.handle, SubIndex));
    },
    /**
     * 判断点是否在面内
     * @param {Boolean} border -点在边线上时，算作面内设置为TRUE,算作面外设置为FALSE
     * @param {PIEVector2/Array} point -判断点
     * @memberOf Polygon#
     *
     * @returns {Boolean} 在面内返回TRUE，否则返回FALSE
     */
    ptInRegion: function ptInRegion(point, border) {
      var pPointsArray = null;
      if (point instanceof Array) {
        pPointsArray = point;
      } else if (point instanceof PIEVector2) {
        pPointsArray = point.toArray();
      }
      var arrayPoint = new PIEArray(pPointsArray, PIEArrayType.Float64);
      var res = Module._Polygon_PtInRegion(this.handle, arrayPoint.getHandle(), border);
      arrayPoint.dispose();
      return Boolean(res);
    },
    /**
     * 在面对象指定索引处插入一个点
     * @param {Number} subIndex -子对象索引号
     * @param {Number} pointIndex -子对象上插入点的索引号
     * @param {PIEVector2|Array} point -待插入的点坐标
     * @memberOf Polygon#
     *
     * @returns {Boolean} 如果插入成功返回true，否则返回false
     */
    insertPoint: function insertPoint(subIndex, pointIndex, point) {
      var arrayPnt = null;
      if (point instanceof PIEVector2) {
        arrayPnt = point.toArray();
      } else if (point instanceof Array) {
        arrayPnt = point;
      }
      if (arrayPnt) {
        var pointArray = new PIEArray(arrayPnt, PIEArrayType.Float64);
        var res = Module._Polygon_InsertPoint(this.handle, subIndex, pointIndex, pointArray.getHandle());
        pointArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 计算得到在某个投影系统下的对象长度
     * @param {PIESpatialReference} spatialReference -指定参考系
     *
     * @memberOf Polygon#
     * @return {Number} 返回长度
     */
    getLengthEx: function getLengthEx(spatialReference) {
      return Module._Polygon_GetLengthEx(this.handle, spatialReference.getHandle());
    },
    /**
     * 得到对象长度
     *
     * @memberOf Polygon#
     * @return {Number} 返回对象长度
     */
    getLength: function getLength() {
      return Module._Polygon_GetLength(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   *
   * 二维几何对象基类操作函数
   * @name Geometry
   *
   */
  function PIEGeometry(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEGeometry.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放几何对象
     * @memberOf Geometry#
     *
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._Geometry_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 获取几何对象的类型
     *
     * @memberOf Geometry#
     * @returns {PIEGeometryType} 返回几何对象类型
     */
    getType: function getType() {
      return Module._Geometry_GetType(this.handle);
    },
    /**
     * 获取几何对象维度(点为0维, 线或曲线等为1维, 面或曲面等为2维, 组合对象或文本等为-1)
     *
     * @memberOf Geometry#
     * @returns {Number} 返回几何对象维度
     */
    getDimension: function getDimension() {
      return Module._Geometry_GetDimension(this.handle);
    },
    /**
     *  判断是否是3D几何对象
     *
     *  @memberOf Geometry#
     * @returns {Boolean} 如果是3D几何对象返回true，否则返回false
     */
    is3D: function is3D() {
      return Boolean(Module._Geometry_Is3D(this.handle));
    },
    /**
     * 获取几何对象的ID
     *
     * @memberOf Geometry#
     * @returns {Number} 如果获取成功返回几何对象ID，否则返回0
     */
    getID: function getID() {
      return Module._Geometry_GetID(this.handle);
    },
    /**
     * 设置几何对象的ID
     * @param {Number} id -几何对象ID
     * @memberOf Geometry#
     *
     */
    setID: function setID(id) {
      return Module._Geometry_SetID(this.handle, id);
    },
    /**
     * 获取几何对象的内点
     *
     * @memberOf Geometry#
     * @returns {PIEVector2} 返回几何对象内点
     */
    getInnerPoint: function getInnerPoint() {
      var point = new PIEArray(2, PIEArrayType.Float64);
      Module._Geometry_GetInnerPoint(this.handle, point.getHandle());
      point.updateData();
      var array = point.toArray();
      point.dispose();
      return new PIEVector2(array[0], array[1]);
    },
    // /**
    //  * 获取几何对象的子对象个数
    //  *
    //  * @memberOf Geometry#
    //  * @returns {Number} 如果获取成功返回子对象个数，否则返回0
    //  */
    // getSubCount: function () {
    //     return Module._Geometry_GetSubCount(this.handle);
    // },
    /**
     * 获取几何对象的范围
     *
     * @memberOf Geometry#
     * @returns {PIEBounds} 返回几何对象的范围
     */
    getBounds: function getBounds() {
      var boundsArray = new PIEArray(4, PIEArrayType.Float64);
      Module._Geometry_GetBounds(this.handle, boundsArray.getHandle());
      boundsArray.updateData();
      var bounds = PIEBounds.fromArray(boundsArray);
      boundsArray.dispose();
      return bounds;
    },
    /**
     * 设置几何对象风格
     * @param {PIEVectorStyle} style -几何对象风格(风格对象传入后内部会进行克隆，外部必须释放传入的风格对象，否则会出现内存泄露)
     * @memberOf Geometry#
     *
     */
    setStyle: function setStyle(style) {
      Module._Geometry_SetStyle(this.handle, style.getHandle());
    },
    /**
     * 获取几何对象风格
     *
     * @memberOf Geometry#
     * @returns {PIEVectorStyle} 返回的几何对象风格
     */
    getStyle: function getStyle() {
      var handle = Module._Geometry_GetStyle(this.handle);
      return PIEStyleFactory.CreateInstance(handle);
    },
    /**
     * 不同空间参考系下几何对象的转换
     * @param {PIEReferenceTranslator} refTranslator -参考系转换器对象
     * @param {Boolean} forward -是否是正向转换
     * @memberOf Geometry#
     *
     */
    convert: function convert(refTranslator, forward) {
      Module._Geometry_Convert(this.handle, refTranslator.getHandle(), forward);
    },
    /**
     * 从经纬坐标系统转化为投影坐标系统
     * @param {PIESpatialReference} spatialReference -投影坐标系统对象
     * @memberOf Geometry#
     *
     */
    forward: function forward(spatialReference) {
      Module._Geometry_Forward(this.handle, spatialReference.getHandle());
    },
    /**
     * 从投影坐标系统转化为经纬坐标
     * @param {PIESpatialReference} spatialReference -投影坐标系统对象
     * @memberOf Geometry#
     *
     */
    inverse: function inverse(spatialReference) {
      Module._Geometry_Inverse(this.handle, spatialReference.getHandle());
    },
    // /**
    //  * 判断是否选中几何对象
    //  * @param {PIEVector2} pnt -点对象
    //  * @param {Number} tolerance -选择容限
    //  * @memberOf Geometry#
    //  *
    //  * @returns {Boolean} 如果选中几何对象返回true，否则返回false
    //  */
    // hitTest: function (pnt, tolerance) {
    //     var arrayPnt = new PIEArray(pnt, PIEArrayType.Float64);
    //     var res = Module._Geometry_HitTest(this.handle, arrayPnt.getHandle(), tolerance);
    //     arrayPnt.dispose();
    //     return res;
    // },
    // /**
    //  * 获取几何对象离点击最近一个节点坐标的索引
    //  * @param {PIEVector2} pnt -点对象
    //  * @memberOf Geometry#
    //  *
    //  * @returns {Number} 如果选中返回坐标索引，否则返回-1
    //  */
    // hitTestVertex: function (pnt) {
    //     var arrayPnt = new PIEArray(pnt, PIEArrayType.Float64);
    //     var res = Module._Geometry_HitTestVertex(this.handle, arrayPnt.getHandle());
    //     arrayPnt.dispose();
    //     return res;
    // },

    // /**
    //  * 平移几何对象
    //  * @param {(PIEVector2/Array)} point -点坐标
    //  * @memberOf Geometry#
    //  *
    //  */
    // offset: function (point) {
    //     var arrayPoint = [];
    //     if (point instanceof Array) {
    //         arrayPoint = point;
    //     } else if (point instanceof PIEVector2) {
    //         arrayPoint = [point.x, point.y];
    //     }
    //     if (arrayPoint.length) {
    //         var dx = arrayPoint[0];
    //         var dy = arrayPoint[1];
    //         Module._Geometry_Offset(this.handle, dx, dy);
    //     }
    // },
    // /**
    //  * 旋转几何对象
    //  * @param {PIEVector2} pnt -旋转点坐标
    //  * @param {Number} rotate -旋转角度
    //  * @memberOf Geometry#
    //  *
    //  */
    // rotate: function (pnt, rotate) {
    //     var arrayPnt = new PIEArray(pnt, PIEArrayType.Float64);
    //     Module._Geometry_Rotate(this.handle, arrayPnt.getHandle(), rotate);
    //     arrayPnt.dispose();
    // },
    // /**
    //  * 调整几何数据,限定在新的Bounds中
    //  * @param {(PIEBounds/Array)} newBounds -范围对象
    //  * @memberOf Geometry#
    //  *
    //  */
    // resize: function (newBounds) {
    //     var arrayNewBounds = [];
    //     if (newBounds instanceof Array) {
    //         arrayNewBounds = newBounds;
    //     } else if (newBounds instanceof PIEBounds) {
    //         arrayNewBounds = PIEBounds.toArray(newBounds);
    //     }
    //     if (arrayNewBounds.length) {
    //         var arrayBounds = new PIEArray(arrayNewBounds, PIEArrayType.Float64);
    //         Module._Geometry_Resize(this.handle, arrayBounds.getHandle());
    //         arrayBounds.dispose();
    //     }
    // },
    // /**
    //  * 平移几何对象控制点到指定坐标
    //  * @param {Number} handle -控制点编号
    //  * @param {(Array/PIEVector2)} point -控制点坐标
    //  * @memberOf Geometry#
    //  *
    //  */
    // moveHandle: function (handle, point) {
    //     var array = [];
    //     if (point instanceof Array) {
    //         array = point;
    //     } else if (point instanceof PIEVector2) {
    //         array = [point.x, point.y];
    //     }
    //     if (array.length) {
    //         var arrayPoint = new PIEArray(array, PIEArrayType.Float64);
    //         Module._Geometry_MoveHandle(this.handle, handle, arrayPoint.getHandle());
    //         arrayPoint.dispose();
    //     }
    // },
    /**
     * 获取空间参考系类型
     *
     * @memberOf Geometry#
     * @returns {PIESpatialRefType} 返回空间参考系类型
     */
    getSpatialRefType: function getSpatialRefType() {
      return Module._Geometry_GetSpatialRefType(this.handle);
    },
    /**
     * 设置空间参考系类型
     * @param {PIESpatialRefType} type -返回空间参考系类型
     * @memberOf Geometry#
     *
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._Geometry_SetSpatialRefType(this.handle, type);
    },
    /**
     * 克隆几何对象
     *
     * @memberOf Geometry#
     * @returns {PIEGeometry}返回克隆的几何对象
     */
    clone: function clone() {
      var handle = Module._Geometry_Clone(this.handle);
      if (handle) {
        return PIEGeometryFactory.CreateInstance(handle);
      }
    }
    // /**
    //  * 拷贝几何对象
    //  * @param {PIEGeometry} 目标几何对象句柄
    //  *
    //  * @returns {boolean}成功或失败
    //  *
    //  *
    //  */
    // copy: function (tagGeometry) {
    //     // Module._Geometry_Copy(this.handle, );
    //     // return PIEGeometry();
    // },
    // /**
    //  * 二进制数据流转换为几何对象
    //  * @param {String} stream -二进制数据流
    //  * @memberOf Geometry#
    //  *
    //  * @returns {PIEGeometry} 几何对象
    //  *
    //  */
    // fromStream: function (stream) {
    //     var strStream = new PIEString(stream);
    //     var res = Module._Geometry_FromStream(strStream.getHandle());
    //     strStream.dispose();
    //     return new PIEGeometry(res);
    // },
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建点对象
   * @name Point
   * @class Point
   * 二维点操作函数
   * @param {Object} options -
   * @param {(PIEVector2/Array)} options.point -点对象
   * @param {Number} options.ID -对象ID
   * @extends Geometry
   * @example
   * var pointArray = [116.39, 39.4];
   * var pointSR = patialReference.forward(pointArray);
   * var point = new PIE.Point({ID: 10, point:pointSR});
   */
  function PIEPoint(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var point = options.point;
      if (point != null) {
        if (point instanceof PIEVector2) {
          handle = Module._Point_C_Create(point.x, point.y);
        } else if (point instanceof Array) {
          handle = Module._Point_C_Create(point[0], point[1]);
        }
        autoRelease = true;
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEGeometry.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEPoint.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 设置点对象的坐标
     * @param {Number} x -X坐标
     *  @param {Number} y -y坐标
     *  @memberOf Point#
     *  @returns {Boolean} 是否设置成功
     *
     */
    setPoint: function setPoint(x, y) {
      return Module._Point_SetPoint(this.handle, x, y);
    },
    /**
     * 获取点对象的坐标。
     * @returns {PIEVector2} 返回的对象坐标的点
     *  @memberOf Point#
     */
    getPoint: function getPoint() {
      var arrPoint = new PIEArray(2, PIEArrayType.Float64);
      Module._Point_GetPoint(this.handle, arrPoint.getHandle());
      arrPoint.updateData();
      var point = arrPoint.toArray();
      arrPoint.dispose();
      return new PIEVector2(point[0], point[1]);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建复杂面对象
   * @name MultiPolygon
   * @class MultiPolygon
   * 二维复杂面操作函数
   *
   * @extends Geometry
   */
  function PIEMultiPolygon(options) {
    var handle = null;
    var autoRelease = false;
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    } else {
      handle = Module._MultiPolygon_Create();
      autoRelease = true;
    }
    PIEGeometry.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEMultiPolygon.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 向复杂面对象中添加一个面对象
     * @param {PIEPolygon} polygon -要添加的面对象
     * @memberOf MultiPolygon#
     */
    addPolygon: function addPolygon(polygon) {
      Module._MultiPolygon_AddPolygon(this.handle, polygon.getHandle());
    },
    /**
     * 获取复杂面对象的对象个数
     *
     * @memberOf MultiPolygon#
     * @returns {Number} 返回面对象的对象数目
     */
    getPolygonCount: function getPolygonCount() {
      return Module._MultiPolygon_GetPolygonCount(this.handle);
    },
    /**
     * 获取复杂面对象中的一个面对象
     * @param {Number} index -要获取的面对象的索引
     * @memberOf MultiPolygon#
     *
     
     * @returns {PIEPolygon} 返回需要获取的面对象
     */
    getPolygon: function getPolygon(index) {
      var handle = Module._MultiPolygon_GetPolygon(this.handle, index);
      if (handle) {
        return new PIEPolygon(handle);
      }
    },
    /**
     * 从复杂面对象中删除一个面对象
     * @param {Number} index -要删除的面对象的索引
     * @memberOf MultiPolygon#
     */
    removePolygon: function removePolygon(index) {
      Module._MultiPolygon_RemovePolygon(this.handle, index);
    },
    /**
     * 获取复杂面对象中一个面对象的子对象的个数
     * @param {Number} polygonIndex -面对象索引
     * @memberOf MultiPolygon#
     *
     * @returns {Number} 返回获取的面对象中子对象的个数
     */
    getSubCount: function getSubCount(polygonIndex) {
      return Module._MultiPolygon_GetSubCount(this.handle, polygonIndex);
    },
    /**
     * 获取复杂面对象中一个面对象的子对象
     * @param {Number} polygonIndex -要获取的面对象的索引
     * @param {Number} subIndex -要获取的面对象的子对象的索引
     * @memberOf MultiPolygon#
     *
     * @returns {PIEPolygon} 返回需要获取的面对象的子对象
     */
    getSub: function getSub(polygonIndex, subIndex) {
      var handle = Module._MultiPolygon_GetSub(this.handle, polygonIndex, subIndex);
      if (handle) {
        return new PIEPolygon(handle);
      }
    },
    /**
     * 获取某个子对象的点的个数
     * @param {Number} polygonIndex -要获取的面对象的索引
     * @param {Number} subIndex -要获取的面对象的子对象的索引
     * @memberOf MultiPolygon#
     *
     * @returns {Number} 子对象点的个数
     */
    getSubPntCount: function getSubPntCount(polygonIndex, subIndex) {
      return Module._MultiPolygon_GetSubPntCount(this.handle, polygonIndex, subIndex);
    },
    /**
     * 获取某个子对象的点
     * @param {Number} polygonIndex -要获取的面对象的索引
     * @param {Number} subIndex -要获取的面对象的子对象的索引
     * @memberOf MultiPolygon#
     *
     * @returns {Number} 子对象点的个数
     */
    getPoints: function getPoints(polygonIndex, subIndex) {
      var pointsRes = [];
      var SubPnt = this.getSubPntCount(polygonIndex, subIndex);
      var pointsArr = new PIEArray(SubPnt * 2, PIEArrayType.Float64);
      Module._MultiPolygon_GetPoints(this.handle, polygonIndex, subIndex, pointsArr.getHandle());
      pointsArr.updateData();
      var points = pointsArr.toArray();
      pointsArr.dispose();
      for (var i = 0; i < SubPnt * 2; i += 2) {
        pointsRes.push(new PIEVector2(points[i], points[i + 1]));
      }
      pointsArr.dispose();
      return pointsRes;
    },
    // /**
    //  * 获取某个面的点
    //  * @param {Number} polygonIndex -要获取的面对象的索引
    //  * @memberOf MultiPolygon#
    //  *
    //  * @returns {Array} 如果获取成功返回子对象所包含点串数组
    //  */
    // getPoints: function (polygonIndex){
    //     let count = this.getSubCount(polygonIndex);
    //     if(count>0) {
    //         let pointsRes = [];
    //         for (let num = 0; num < count; num++) {
    //             var SubPnt = this.getSubPntCount(polygonIndex,num);
    //             let pointsArr = new PIEArray(SubPnt *2, PIEArrayType.Float64);
    //             Module._MultiPolygon_GetPoints(this.handle, polygonIndex, num, pointsArr.getHandle());
    //             pointsArr.updateData();
    //             let points = pointsArr.toArray();
    //             pointsArr.dispose();
    //             for (let i = 0; i < SubPnt * 2; i += 2) {
    //                 pointsRes.push(new PIEVector2(points[i], points[i + 1]));
    //             }
    //         }
    //         return pointsRes;
    //     }
    //    return null;
    // },

    /**
     * 判断多边形指定子对象是岛还是洞
     * @param {Number} polygonIndex -子对象id
     * @param {Number} subID -对象id
     *
     * @memberOf MultiPolygon#
     * @return {Boolean} 返回是岛还是洞
     */
    checkSubPolygon: function checkSubPolygon(polygonIndex, subID) {
      return Boolean(Module._MultiPolygon_CheckSubPolygon(this.handle, polygonIndex, subID));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建文本对象
   * @name Text
   * @class Text
   * 二维文本对象操作函数
   * @param {Object} options -
   * @param {(PIEVector2/Array)} options.point -文本对象的坐标
   * @param {String} options.text -文本对象的字符串
   * @param {Number} options.ID -文本对象ID
   *
   * @extends Geometry
   * @example
   * var pointText = patialReference.forward([116.397228, 39.909604]);
   * var text = new PIE.Text({point:pointText, text: "中国-北京"});
   */
  function PIEText(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var point = options.point;
      var text = options.text;
      if (point && text) {
        var strText = new PIEString$1(text);
        if (point instanceof Array) {
          handle = Module._Text_Create(point[0], point[1], strText.getHandle());
          autoRelease = true;
        } else if (point instanceof PIEVector2) {
          handle = Module._Text_Create(point.x, point.y, strText.getHandle());
          autoRelease = true;
        }
        strText.dispose();
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEGeometry.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEText.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 获取文本对象的坐标
     *
     * @memberOf Text#
     *  @returns {PIEVector2} 返回文本对象的坐标点
     *
     */
    getPoint: function getPoint() {
      var pointArray = new PIEArray(2, PIEArrayType.Float64);
      Module._Text_GetPoint(this.handle, pointArray.getHandle());
      pointArray.updateData();
      var array = pointArray.toArray();
      pointArray.dispose();
      return new PIEVector2(array[0], array[1]);
    },
    /**
     * 设置文本对象的坐标
     * @param {(PIEVector2/Array)} point -文本对象的坐标点
     * @memberOf Text#
     *
     *  @returns {Boolean} 如果设置成功返回true，否则返回false
     *
     */
    setPoint: function setPoint(point) {
      var array = null;
      if (point instanceof PIEVector2) {
        array = [point.x, point.y];
      } else if (point instanceof Array) {
        array = point;
      }
      if (array) {
        var pointArray = new PIEArray(array, PIEArrayType.Float64);
        var res = Module._Text_SetPoint(this.handle, pointArray.getHandle());
        pointArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 获取文本对象的字符串值
     *
     * @memberOf Text#
     *  @returns {String} 返回文本对象的字符串值
     *
     */
    getText: function getText() {
      var strText = new PIEString$1(256);
      Module._Text_GetText(this.handle, strText.getHandle());
      var text = strText.toString();
      strText.dispose();
      return text;
    },
    /**
     * 设置文本对象的字符串值
     * @param {String} text -文本对象的字符串值
     * @memberOf Text#
     *
     *  @returns {Boolean} 如果设置成功返回true，否则返回false
     *
     */
    setText: function setText(text) {
      var strText = new PIEString$1(text);
      var res = Module._Text_SetText(this.handle, strText.getHandle());
      strText.dispose();
      return Boolean(res);
    },
    /**
     * 获取文本对象的对象风格
     *
     * @memberOf Text#
     *  @returns {PIETextStyle} 如果获取成功返回文本风格对象，否则返回NULL
     *
     */
    getTextStyle: function getTextStyle() {
      var hStyle = Module._Text_GetTextStyle(this.handle);
      if (hStyle) {
        return new PIETextStyle(hStyle);
      }
      return null;
    },
    /**
     * 设置文本对象的对象风格
     * @param {PIETextStyle} style -文本对象的对象风格对象(传入后内部会进行克隆，外部必须释放传入的风格对象，否则会出现内存泄露))
     * @memberOf Text#
     *
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setTextStyle: function setTextStyle(style) {
      return Boolean(Module._Text_SetTextStyle(this.handle, style.getHandle()));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 标绘模块
   * ---
   */

  /**
   * 创建标绘风格对象
   * @name PlotStyle
   * @class PlotStyle
   * 标绘风格操作函数
   *
   * @example
   * let plotStyle = new PIE.PlotStyle();
   */
  function PIEPlotStyle(handle, autoRelease) {
    if (handle == null) {
      handle = Module._PlotStyle_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEPlotStyle.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._PlotStyle_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置符号大小
     * @param {Array|PIESize} size 符号尺寸大小
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回是否设置成功
     */
    setSymbolSize: function setSymbolSize(size) {
      var arrSize = null;
      if (size instanceof PIESize) {
        arrSize = [size.cx, size.cy];
      } else if (size instanceof Array) {
        arrSize = size;
      }
      if (arrSize) {
        var sizeArray = new PIEArray(arrSize, PIEArrayType.Float64);
        var res = Module._PlotStyle_SetSymbolSize(this.handle, sizeArray.getHandle());
        sizeArray.dispose();
        return res;
      }
      return false;
    },
    /**
     * 获取符号大小
     * @memberOf PlotStyle#
     * @returns {PIESize} 返回符号尺寸大小
     */
    getSymbolSize: function getSymbolSize() {
      var arrSize = new PIEArray(2, PIEArrayType.Float64);
      Module._PlotStyle_GetSymbolSize(this.handle, arrSize.getHandle());
      arrSize.updateData();
      var sizeArray = arrSize.toArray();
      arrSize.dispose();
      return new PIESize(sizeArray[0], sizeArray[1]);
    },
    /**
     * 设置线风格
     * @param {Number} style -线风格
     * @memberOf PlotStyle#
     */
    setLineStyle: function setLineStyle(style) {
      if (style != null) {
        Module._PlotStyle_SetLineStyle(this.handle, style);
      }
    },
    /**
     * 获取线风格
     *
     * @memberOf PlotStyle#
     * @returns {Number} 返回线风格
     */
    getLineStyle: function getLineStyle() {
      return Module._PlotStyle_GetLineStyle(this.handle);
    },
    /**
     * 设置几何对象的宽度
     * @param {Number} width -几何对象的宽度
     * @memberOf PlotStyle#
     *
     * @returns {Boolean} 成功返回true，失败返回false
     */
    setLineWidth: function setLineWidth(width) {
      if (width != null) {
        return Module._PlotStyle_SetLineWidth(this.handle, width);
      }
    },
    /**
     * 获取几何对象的宽度
     *
     * @memberOf PlotStyle#
     * @returns {Number} 返回几何对象的宽度
     */
    getLineWidth: function getLineWidth() {
      return Module._PlotStyle_GetLineWidth(this.handle);
    },
    /**
     * 设置军标线符号颜色
     * @param {(Array/PIEColor)} color -颜色值
     * @memberOf PlotStyle#
     *
     * @returns {Boolean} 返回是否设置成功
     */
    setLineColor: function setLineColor(color) {
      var arrayColor = [];
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        var res = Module._PlotStyle_SetLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
        return res;
      }
    },
    /**
     * 获取军标线符号颜色
     *
     * @memberOf PlotStyle#
     * @returns {PIEColor} 返回军标线颜色值
     */
    getLineColor: function getLineColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetLineColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var color = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置军标衬线符号风格
     * @param {PIEOutLineStyleType} style -军标衬线线风格
     * @memberOf PlotStyle#
     */
    setOutLineStyle: function setOutLineStyle(style) {
      Module._PlotStyle_SetOutLineStyle(this.handle, style);
    },
    /**
     * 获取军标衬线符号风格
     *
     * @memberOf PlotStyle#
     * @returns {PIEOutLineStyleType} 返回军标衬线线风格
     */
    getOutLineStyle: function getOutLineStyle() {
      return Module._PlotStyle_GetOutLineStyle(this.handle);
    },
    /**
     * 设置军标衬线符号颜色
     * @param {(Array/PIEColor)} color -军标衬线颜色值
     * @memberOf PlotStyle#
     */
    setOutLineColor: function setOutLineColor(color) {
      var arrayColor = [];
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        Module._PlotStyle_SetOutLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取军标衬线符号颜色
     *
     * @memberOf PlotStyle#
     * @returns {PIEColor} 返回军标线颜色值
     */
    getOutLineColor: function getOutLineColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetOutLineColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var color = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置军标衬线符号宽度
     * @param {Number} width -军标衬线符号宽度
     * @memberOf PlotStyle#
     */
    setOutLineWidth: function setOutLineWidth(width) {
      Module._PlotStyle_SetOutLineWidth(this.handle, width);
    },
    /**
     * 获取军标衬线符号宽度
     *
     * @memberOf PlotStyle#
     * @returns {Number} 返回军标衬线符号宽度
     */
    getOutLineWidth: function getOutLineWidth() {
      return Module._PlotStyle_GetOutLineWidth(this.handle);
    },
    /**
     * 设置军标衬线符号位置
     * @param {PIEOutLinePosType} pos -军标衬线符号位置
     * @memberOf PlotStyle#
     */
    setOutLinePos: function setOutLinePos(pos) {
      Module._PlotStyle_SetOutLinePos(this.handle, pos);
    },
    /**
     * 获取军标衬线符号位置
     *
     * @memberOf PlotStyle#
     * @returns {PIEOutLinePosType} 返回军标衬线符号位置
     */
    getOutLinePos: function getOutLinePos() {
      return Module._PlotStyle_GetOutLinePos(this.handle);
    },
    /**
     * 设置几何对象的填充模式
     * @param {PIEFillModeType} mode -填充模式
     * @memberOf PlotStyle#
     *
     * @returns {Boolean} 返回是否设置成功
     */
    setFillMode: function setFillMode(mode) {
      return Module._PlotStyle_SetFillMode(this.handle, mode);
    },
    /**
     * 获取几何对象的填充模式
     * @memberOf PlotStyle#
     *
     * @returns {PIEFillModeType} 返回填充模式
     */
    getFillMode: function getFillMode() {
      return Module._PlotStyle_GetFillMode(this.handle);
    },
    // /**
    //  * 设置几何对象填充的透明度
    //  * @param {Number} opacity -填充的透明度
    //  * @memberOf PlotStyle#
    //  */
    // setFillOpacity: function (opacity) {
    //     Module._PlotStyle_SetFillOpacity(this.handle, opacity);
    // },

    // /**
    //  * 获取几何对象填充的透明度
    //  *
    //  * @memberOf PlotStyle#
    //  * @returns {Number} 返回填充的透明度
    //  */
    // getFillOpacity: function () {
    //     return Module._PlotStyle_GetFillOpacity(this.handle);
    // },

    /**
     * 设置几何对象的填充颜色
     * @param {(Array|PIEColor)} color -颜色值
     * @memberOf PlotStyle#
     *
     * @returns {Boolean} 返回是否设置成功
     */
    setFillForeColor: function setFillForeColor(color) {
      var arrayColor = null;
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        var res = Module._PlotStyle_SetFillForeColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
        return res;
      }
    },
    /**
     * 获取几何对象的背景填充颜色
     *
     * @memberOf PlotStyle#
     * @return {PIEColor} 返回背景填充颜色
     */
    getFillForeColor: function getFillForeColor() {
      var vecColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetFillForeColor(this.handle, vecColor.getHandle());
      vecColor.updateData();
      var color = vecColor.toArray();
      vecColor.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置几何对象的背景填充颜色
     * @param {Array|PIEColor} color -背景颜色
     *
     * @memberOf PlotStyle#
     * @return {Boolean} 返回是否设置成功
     */
    setFillBackColor: function setFillBackColor(color) {
      var arrayColor = null;
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        var res = Module._PlotStyle_SetFillBackColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
        return res;
      }
    },
    /**
     * 获取几何对象的背景填充颜色
     *
     * @memberOf PlotStyle#
     * @return {PIEColor} 返回填充颜色
     */
    getFillBackColor: function getFillBackColor() {
      var vecColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetFillBackColor(this.handle, vecColor.getHandle());
      vecColor.updateData();
      var color = vecColor.toArray();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置几何对象的填充角度
     * @param {Number} angle -填充角度
     * @memberOf PlotStyle#
     *
     * @returns {Boolean} 返回是否设置成功
     */
    setFillAngle: function setFillAngle(angle) {
      return Module._PlotStyle_SetFillAngle(this.handle, angle);
    },
    /**
     * 获取几何对象的填充角度
     * @memberOf PlotStyle#
     * @returns {Number} 返回填充角度
     */
    getFillAngle: function getFillAngle(angle) {
      return Module._PlotStyle_GetFillAngle(this.handle);
    },
    /**
     * 设置几何对象字体大小
     * @param {Number} size -几何对象字体大小
     * @memberOf PlotStyle#
     */
    setFontSize: function setFontSize(size) {
      Module._PlotStyle_SetFontSize(this.handle, size);
    },
    /**
     * 获取几何对象字体大小
     *
     * @memberOf PlotStyle#
     * @returns {Number} 返回对象字体大小
     */
    getFontSize: function getFontSize() {
      return Module._PlotStyle_GetFontSize(this.handle);
    },
    /**
     * 设置字体风格-倾斜
     * @param {Number} italix -对象字体风格(0-不倾斜，1-倾斜)
     * @memberOf PlotStyle#
     */
    setFontItalic: function setFontItalic(italix) {
      Module._PlotStyle_SetFontItalic(this.handle, italix);
    },
    /**
     * 获取字体风格-倾斜
     *
     * @memberOf PlotStyle#
     * @returns {Number} 返回对象字体风格(0-不倾斜，1-倾斜)
     */
    getFontItalic: function getFontItalic() {
      return Module._PlotStyle_GetFontItalic(this.handle);
    },
    /**
     * 设置字体风格是否加粗
     * @param {Boolean} isBold -对象字体是否加粗
     * @memberOf PlotStyle#
     */
    setFontBold: function setFontBold(isBold) {
      Module._PlotStyle_SetFontBold(this.handle, isBold);
    },
    /**
     * 获取字体风格是否加粗
     *
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回对象字体风格是否加粗
     */
    getFontBold: function getFontBold() {
      return Module._PlotStyle_GetFontBold(this.handle);
    },
    /**
     * 设置字体风格是否加下划线
     * @param {Boolean} underline - 对象字体是否加下划线
     * @memberOf PlotStyle#
     */
    setFontUnderline: function setFontUnderline(underline) {
      Module._PlotStyle_SetFontUnderline(this.handle, underline);
    },
    /**
     * 获取字体风格是否加下划线
     *
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回对象字体风格是否加下划线
     */
    getFontUnderline: function getFontUnderline() {
      return Module._PlotStyle_GetFontUnderline(this.handle);
    },
    /**
     * 设置几何对象字体风格-删除线
     * @param {Boolean} strikeOut - 对象字体风格是否加删除线
     * @memberOf PlotStyle#
     */
    setFontStrikeOut: function setFontStrikeOut(strikeOut) {
      Module._PlotStyle_SetFontStrikeOut(this.handle, strikeOut);
    },
    /**
     * 获取几何对象字体风格-删除线
     *
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回对象字体风格是否加删除线
     */
    getFontStrikeOut: function getFontStrikeOut() {
      return Module._PlotStyle_GetFontStrikeOut(this.handle);
    },
    /**
     * 设置几何对象字体风格-文字阴影
     * @param {Boolean} shadow - 对象字体风格是否加文字阴影
     * @memberOf PlotStyle#
     */
    setFontShadow: function setFontShadow(shadow) {
      Module._PlotStyle_SetFontShadow(this.handle, shadow);
    },
    /**
     * 获取几何对象字体风格-文字阴影
     *
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回对象字体风格是否加文字阴影
     */
    getFontShadow: function getFontShadow() {
      return Module._PlotStyle_GetFontStrikeOut(this.handle);
    },
    /**
     * 设置文字颜色
     * @param {Array|PIEColor} color -文字颜色
     *
     * @memberOf PlotStyle#
     * @return {Boolean} 返回是否设置成功
     */
    setFontTextColor: function setFontTextColor(color) {
      var arrayColor = null;
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        var res = Module._PlotStyle_SetFontTextColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
        return res;
      }
    },
    /**
     * 获取文字颜色
     *
     * @memberOf PlotStyle#
     * @return {PIEColor} 返回文字颜色
     */
    getFontTextColor: function getFontTextColor() {
      var vecColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetFontTextColor(this.handle, vecColor.getHandle());
      vecColor.updateData();
      var color = vecColor.toArray();
      vecColor.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置几何对象字体编号
     * @param {Number} code 字体编号
     * @memberOf PlotStyle#
     */
    setFontCode: function setFontCode(code) {
      Module._PlotStyle_SetFontCode(this.handle, code);
    },
    /**
     * 获取几何对象字体编号
     * @memberOf PlotStyle#
     */
    getFontCode: function getFontCode() {
      return Module._PlotStyle_GetFontCode(this.handle);
    },
    /**
     * 设置几何对象注记文字颜色
     * @param {Array|PIEColor} color -注记文字颜色
     *
     * @memberOf PlotStyle#
     */
    setFontLabelColor: function setFontLabelColor(color) {
      var arrayColor = null;
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        Module._PlotStyle_SetFontLabelColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取几何对象注记文字颜色
     * @memberOf PlotStyle#
     * @return {PIEColor} 返回文字颜色
     */
    getFontLabelColor: function getFontLabelColor() {
      var vecColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetFontLabelColor(this.handle, vecColor.getHandle());
      vecColor.updateData();
      var color = vecColor.toArray();
      vecColor.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置几何对象显示类型
     * @param {PIEDisplayType} displayType -显示类型
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回是否设置成功
     */
    setDisplayType: function setDisplayType(displayType) {
      return Module._PlotStyle_SetDisplayType(this.handle, displayType);
    },
    /**
     *获取几何对象显示类型
     *
     * @memberOf PlotStyle#
     * @returns {PIEDisplayType} 返回显示类型
     */
    getDisplayType: function getDisplayType() {
      return Module._PlotStyle_GetDisplayType(this.handle);
    },
    /**
     *设置符号大小模式
     * @param {PIESymbolSizeMode} mode -符号显示模式
     * @memberOf PlotStyle#
     */
    setSizeMode: function setSizeMode(mode) {
      Module._PlotStyle_SetSizeMode(this.handle, mode);
    },
    /**
     *获取符号大小模式
     *
     * @memberOf PlotStyle#
     * @returns {PIESymbolSizeMode} mode -符号显示模式
     */
    getSizeMode: function getSizeMode() {
      return Module._PlotStyle_GetSizeMode(this.handle);
    },
    /**
     *设置符号角度
     * @param {Number} angle -角度
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回是否设置成功
     */
    setAngle: function setAngle(angle) {
      return Module._PlotStyle_SetAngle(this.handle, angle);
    },
    /**
     *获取符号角度
     *
     * @memberOf PlotStyle#
     * @returns {Number}  返回符号角度
     */
    getAngle: function getAngle() {
      return Module._PlotStyle_GetAngle(this.handle);
    },
    /**
     *设置文本
     * @param {String} text -文本字符串
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回是否设置成功
     */
    setText: function setText(text) {
      var arrText = new PIEString$1(text);
      var res = Module._PlotStyle_SetText(this.handle, arrText.getHandle());
      arrText.dispose();
      return res;
    },
    /**
     *获取文本
     *
     * @memberOf PlotStyle#
     * @returns {String}  返回文本
     */
    getText: function getText() {
      var arrText = new PIEString$1(256);
      Module._PlotStyle_GetText(this.handle, arrText.getHandle());
      var text = arrText.toString();
      arrText.dispose();
      return text;
    },
    /**
     *设置点符号注记
     * @param {String} label -注记文本字符串
     * @memberOf PlotStyle#
     * @returns {Boolean} 返回是否设置成功
     */
    setLabel: function setLabel(label) {
      var arrText = new PIEString$1(label);
      var res = Module._PlotStyle_SetLabel(this.handle, arrText.getHandle());
      arrText.dispose();
      return res;
    },
    /**
     *获取点符号注记
     * @memberOf PlotStyle#
     * @returns {String}  返回文本
     */
    getLabel: function getLabel() {
      var arrText = new PIEString$1(256);
      Module._PlotStyle_GetLabel(this.handle, arrText.getHandle());
      var label = arrText.toString();
      arrText.dispose();
      return label;
    },
    /**
     *设置点符号注记位置
     * @param {PIELabelPosType} pos -注记位置
     * @memberOf PlotStyle#
     * @returns {Boolean}  返回是否设置成功
     */
    setLabelPos: function setLabelPos(pos) {
      return Module._PlotStyle_SetLabelPos(this.handle, pos);
    },
    /**
     *获取点符号注记
     * @memberOf PlotStyle#
     *@returns {PIELabelPosType} 返回符号位置
     */
    getLabelPos: function getLabelPos() {
      return Module._PlotStyle_GetLabelPos(this.handle);
    },
    /**
     *设置标绘符号是否有阴影
     * @param {Boolean} isShadow -是否显示阴影
     * @memberOf PlotStyle#
     */
    setPlotShadow: function setPlotShadow(isShadow) {
      return Module._PlotStyle_SetPlotShadow(this.handle, isShadow);
    },
    /**
     *获取标绘符号是否有阴影
     * @returns {Boolean}  返回是否显示阴影
     * @memberOf PlotStyle#
     */
    getPlotShadow: function getPlotShadow(isShadow) {
      return Module._PlotStyle_GetPlotShadow(this.handle);
    },
    /**
     * 设置标绘阴影颜色
     * @param {(Array/PIEColor)} color -颜色值
     * @memberOf PlotStyle#
     *
     * @returns {Boolean} 返回是否设置成功
     */
    setPlotShadowColor: function setPlotShadowColor(color) {
      var arrayColor = [];
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        Module._PlotStyle_SetPlotShadowColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取标绘阴影颜色
     *
     * @memberOf PlotStyle#
     * @returns {PIEColor} 返回标绘阴影颜色
     */
    getPlotShadowColor: function getPlotShadowColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetPlotShadowColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var color = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置字体阴影颜色
     * @param {(Array/PIEColor)} color -颜色值
     * @memberOf PlotStyle#
     */
    setFontShadowColor: function setFontShadowColor(color) {
      var arrayColor = [];
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        Module._PlotStyle_SetFontShadowColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取字体阴影颜色
     *
     * @memberOf PlotStyle#
     * @returns {PIEColor} 返回标字体影颜色
     */
    getFontShadowColor: function getFontShadowColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._PlotStyle_GetFontShadowColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var color = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 标绘模块
   * ---
   */

  /**
   * 创建标绘几何对象
   * @name GeoPlot
   * @class GeoPlot
   *标绘几何对象操作函数
   *
   * @param {Object} options
   * @param {Number} options.code -军标对象
   * @param {Array}  options.points -点坐标
   * @param {Number} options.unitLength -像素对应的地理长度
   *
   * @extends Geometry
   * @example
   * var plotPtsWgs84 = [118, 39.5];
   * var posGlobeSR = patialReference.forward(plotPtsWgs84);
   * var geoPlot = new PIE.GeoPlot({code:10107, points:posGlobeSR, unitLength:1});
   */
  function PIEGeoPlot(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      if (options.handle == null) {
        handle = Module._GeoPlot_Create();
        autoRelease = true;
      } else {
        handle = options.handle;
      }
      if (handle) {
        var code = options.code;
        var points = options.points;
        var unitLength = options.unitLength;
        if (unitLength == null) {
          unitLength = 1;
        }
        if (code && points && unitLength != null) {
          if (points instanceof Array) {
            var pointsArray = new PIEArray(points, PIEArrayType.Float64);
            points.length / 2;
            Module._GeoPlot_Make(handle, code, pointsArray.getHandle(), points.length / 2, unitLength);
            pointsArray.dispose();
          }
        }
      }
    }
    PIEGeometry.call(this, handle, autoRelease);
  }
  PIEGeoPlot.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 获取军标对象的风格
     *
     * @memberOf GeoPlot#
     * @returns {PIEPlotStyle}  返回军标对象的风格，异常返回NULL
     */
    getStyle: function getStyle() {
      var hStyle = Module._GeoPlot_GetStyle(this.handle);
      return new PIEPlotStyle(hStyle);
    },
    /**
     * 设置军标对象风格
     * @param {PIEPlotStyle} style -军标对象风格
     * @memberOf GeoPlot#
     */
    setStyle: function setStyle(style) {
      Module._GeoPlot_SetStyle(this.handle, style.getHandle());
    },
    /**
     * 获取军标类型
     * @memberOf GeoPlot#
     * @returns {PIESymbolPlotType} 返回军标类型
     */
    getSymbolType: function getSymbolType(style) {
      return Module._GeoPlot_GetSymbolType(this.handle);
    },
    // /**
    //  * 设置军标对象对象的Make。

    //  * @param {Number} code -军标对象
    //  * @param {(Array/PIEVector2)} pPoints -点坐标
    //  * @param {Number} nPntCount -个数
    //  * @param {Number} dUnitlength -像素对应的地理长度
    //  * @memberOf GeoPlot#
    //  */
    make: function make(code, pPoints, nPntCount, dUnitlength) {
      var pointArray = [];
      if (pPoints instanceof Array) {
        pointArray = pPoints;
      } else if (pPoints instanceof PIEVector2) {
        pointArray = [pPoints.x, pPoints.y];
      }
      if (pointArray) {
        var arrayPoint = new PIEArray(pPoints, PIEArrayType.Float64);
        Module._GeoPlot_Make(this.handle, code, arrayPoint.getHandle(), nPntCount, dUnitlength);
        arrayPoint.dispose();
      }
    },
    /**
     * 在指定的位置上设置点的坐标
     * @param {(Array/PIEVector2)} point -点坐标
     * @memberOf GeoPlot#
     *
     * @returns {Boolean} 设置成功返回true,设置失败返回false
     */
    setPoint: function setPoint(point) {
      var pointArray = [];
      if (point instanceof Array) {
        pointArray = point;
      } else if (point instanceof PIEVector2) {
        pointArray = [point.x, point.y];
      }
      if (pointArray) {
        var arrayPoint = new PIEArray(point, PIEArrayType.Float64);
        var res = Module._GeoPlot_SetPoint(this.handle, arrayPoint.getHandle());
        arrayPoint.dispose();
        return res;
      }
      return false;
    },
    /**
     * 设置几何点
     * @param {Array} points -点集
     * @memberOf GeoPlot#
     *
     * @returns {Boolean} 成功设置返回true,设置失败返回false
     */
    setPoints: function setPoints(points) {
      if (points instanceof Array && points.length > 2) {
        var arrayPoints = new PIEArray(points, PIEArrayType.Float64);
        var res = Module._GeoPlot_SetPoints(this.handle, arrayPoints.getHandle(), points.length);
        arrayPoints.dispose();
        return res;
      }
      return false;
    },
    /**
     * 获取所有子对象的点的个数总和
     *
     * @memberOf GeoPlot#
     * @returns {Number} 返回点个数
     */
    getPointCount: function getPointCount() {
      return Module._GeoPlot_GetPointCount(this.handle);
    },
    /**
     * 获取几何点集
     *
     * @memberOf GeoPlot#
     * @returns {PIEVector2} 返回几何点集
     */
    getPoints: function getPoints() {
      var count = this.getPointCount();
      if (count) {
        var arrayPoint = new PIEArray(count * 2, PIEArrayType.Float64);
        Module._GeoPlot_GetPoints(this.handle, arrayPoint.getHandle());
        arrayPoint.updateData();
        var points = arrayPoint.toArray();
        arrayPoint.dispose();
        return points;
      }
      return null;
    },
    /**
     *从指定的子对象的指定位置开始去掉节点
     *
     * @memberOf GeoPlot#
     * @returns {Boolean} 成功删除返回true,删除失败返回false
     */
    removePoints: function removePoints() {
      return Module._GeoPlot_RemovePoints(this.handle);
    },
    /**
     *清除Geometry内部数据
     * @memberOf GeoPlot#
     */
    clear: function clear() {
      Module._GeoPlot_Clear(this.handle);
    },
    // /**
    //  *设置符号显示模式
    //  * @param {PIESymbolSizeMode} mode -符号显示模式
    //  * @memberOf GeoPlot#
    //  */
    // setSymbolSizeMode: function (mode) {
    //     Module._GeoPlot_SetSymbolSizeMode(this.handle, mode);
    // },
    // /**
    //  *获取符号显示模式
    //  *
    //  * @memberOf GeoPlot#
    //  * @returns {PIESymbolSizeMode} mode -符号显示模式
    //  */
    // getSymbolSizeMode: function () {
    //     return Module._GeoPlot_GetSymbolSizeMode(this.handle);
    // },
    /**
     *设置符号ID
     * @param {Number} code -符号id
     * @memberOf GeoPlot#
     */
    setSymbolCode: function setSymbolCode(code) {
      Module._GeoPlot_SetSymbolCode(this.handle, code);
    },
    /**
     *获取符号ID
     *
     * @memberOf GeoPlot#
     *@returns {Number} 符号ID
     */
    getSymbolCode: function getSymbolCode() {
      return Module._GeoPlot_GetSymbolCode(this.handle);
    },
    /**
     * 获取几何对象维度
     *
     * @memberOf GeoPlot#
     * @returns {Number} 返回维度
     */
    getDimension: function getDimension() {
      return Module._GeoPlot_GetDimension(this.handle);
    },
    /**
     *点击测试, 用于对象点选
     * @param {(Array/PIEVector2)} testPoint -测试点选坐标
     * @param {Number} dTolerance -选择精度
     * @memberOf GeoPlot#
     *
     * @returns {Boolean} 点选测试是否成功
     */
    hitTest: function hitTest(testPoint, dTolerance) {
      var pointArray = [];
      if (testPoint instanceof Array) {
        pointArray = testPoint;
      } else if (testPoint instanceof PIEVector2) {
        pointArray = [testPoint.x, testPoint.y];
      }
      if (pointArray) {
        var arrayPoint = new PIEArray(pointArray, PIEArrayType.Float64);
        return Module._GeoPlot_HitTest(this.handle, arrayPoint.getHandle(), dTolerance);
      }
      return false;
    },
    /**
     * 判断几何对象是否有效
     * @memberOf GeoPlot#
     *
     * @returns {Boolean}几何对象是否有效
     */
    isValid: function isValid() {
      return Module._GeoPlot_IsValid(this.handle);
    },
    /**
     * 平移
     * @param {Number} dx -x方向
     * @param {Number} dy -y方向
     * @memberOf GeoPlot#
     */
    offset: function offset(dx, dy) {
      Module._GeoPlot_Offset(this.handle, dx, dy);
    },
    /**
     *旋转
     * @param {(Array/PIEVector2)} point -坐标
     * @param {Number} angle -角度
     * @memberOf GeoPlot#
     */
    rotate: function rotate(point, angle) {
      var pointArray = [];
      if (point instanceof Array) {
        pointArray = points;
      } else if (point instanceof PIEVector2) {
        pointArray = [point.x, point.y];
      }
      if (pointArray) {
        var arrayPoint = new PIEArray(pointArray, PIEArrayType.Float64);
        Module._GeoPlot_Rotate(this.handle, arrayPoint.getHandle(), angle);
        arrayPoint.dispose();
      }
    },
    /**
     * 调整几何数据,限定在新的Bounds中
     * @param {(Array/PIEBounds)} bounds -新的范围bounds
     * @memberOf GeoPlot#
     */
    resize: function resize(bounds) {
      var boundsArray = null;
      if (bounds instanceof Array) {
        boundsArray = new PIEArray(bounds, PIEArrayType.Float64);
      } else if (bounds instanceof PIEBounds) {
        boundsArray = PIEBounds.toArray(bounds);
      }
      if (boundsArray) {
        var res = Module._GeoPlot_Resize(this.handle, boundsArray.getHandle());
        boundsArray.dispose();
        return res;
      }
      return false;
    },
    /**
     * 判断几何对象是否有填充
     * @memberOf GeoPlot#
     * @returns {Boolean}几何对象是否有填充
     */
    isFill: function isFill() {
      return Boolean(Module._GeoPlot_IsFill(this.handle));
    },
    /**
     * 判断几何对象是否有文本
     * @memberOf GeoPlot#
     * @returns {Boolean}几何对象是否有文本
     */
    isText: function isText() {
      return Boolean(Module._GeoPlot_IsText(this.handle));
    },
    /**
     * 获取几何对象单位长度对应地理长度
     * @memberOf GeoPlot#
     * @returns {Number}返回单位长度对应地理长度
     */
    getUnitLength: function getUnitLength() {
      return Module._GeoPlot_GetUnitLength(this.handle);
    },
    /**
     * 设置几何对象单位长度对应地理长度
     * @memberOf GeoPlot#
     * @param {Number}单位长度对应地理长度
     */
    setUnitLength: function setUnitLength(unitLength) {
      return Module._GeoPlot_SetUnitLength(this.handle, unitLength);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建包围盒
   * @name BoundingBox
   * @class BoundingBox
   * 包围盒类
   *
   * @param {Number} minX -最小x
   * @param {Number} minY -最小y
   * @param {Number} minZ -最小z
   * @param {Number} maxX -最大x
   * @param {Number} MaxY -最大y
   * @param {Number} MaxZ -最大z
   */
  function PIEBoundingBox(minX, minY, minZ, maxX, MaxY, MaxZ) {
    this.mx = minX;
    this.my = minY;
    this.mz = minZ;
    this.Mx = maxX;
    this.My = MaxY;
    this.Mz = MaxZ;
  }
  Object.assign(PIEBoundingBox.prototype, {
    toArray: function toArray() {
      var array = [this.mx, this.my, this.mz, this.Mx, this.My, this.Mz];
      return array;
    },
    /**
     * 获取中心点
     * @memberOf BoundingBox#
     * @returns {PIEVector3} 返回中心点
     */
    getCenter: function getCenter() {
      return new PIEVector3((this.mx + this.Mx) / 2, (this.my + this.My) / 2, (this.mz + this.Mz) / 2);
    },
    /**
     * 获取半径
     * @memberOf BoundingBox#
     * @returns {Number} 返回半径
     */
    getRadius: function getRadius() {
      var x = this.Mx - this.mx;
      var y = this.My - this.my;
      var z = this.Mz - this.mz;
      return Math.sqrt(x * x + y * y + z * z) / 2;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 顶点数据对象操作函数
   * @name VertexData
   * @class VertexData
   * 创建顶点数据对象
   *
   */
  function PIEVertexData(handle, autoRelease) {
    if (handle == null) {
      handle = Module._VertexData_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEVertexData.prototype, {
    /**
     * 删除顶点数据对象
     * @memberOf VertexData#
     */
    "delete": function _delete() {
      Module._VertexData_Delete(this.handle);
    },
    /**
     * 设置顶点类型
     * @param {Number} type -顶点数据类型
     * @memberOf VertexData#
     */
    setVertexType: function setVertexType(type) {
      Module._VertexData_SetVertexType(this.handle, type);
    },
    /**
     * 获取顶点类型
     *
     * @memberOf VertexData#
     * @returns {Number} 返回顶点数据类型
     */
    getVertexType: function getVertexType() {
      return Module._VertexData_GetVertexType(this.handle);
    },
    /**
     * 设置顶点大小
     * @param {Number} size -顶点大小
     * @memberOf VertexData#
     */
    setVertexSize: function setVertexSize(size) {
      Module._VertexData_SetVertexSize(this.handle, size);
    },
    /**
     * 删除所有顶点数据
     * @memberOf VertexData#
     */
    removeAllElements: function removeAllElements() {
      Module._VertexData_RemoveAllElements(this.handle);
    },
    /**
     * 删除所有顶点元素说明
     * @memberOf VertexData#
     */
    removeAllVertexs: function removeAllVertexs() {
      Module._VertexData_RemoveAllVertexs(this.handle);
    },
    /**
     * 获取顶点大小
     *
     * @memberOf VertexData#
     * @returns {Number} 返回顶点大小
     */
    getVertexSize: function getVertexSize() {
      return Module._VertexData_GetVertexSize(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * Int索引数据对象操作函数
   * @name IntIndexData
   * @class IntIndexData
   * 创建索引数据对象
   *
   */
  function PIEIntIndexData(handle, autoRelease) {
    if (handle == null) {
      handle = Module._IntIndexData_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEIntIndexData.prototype, {
    /**
     * 删除索引数据对象
     * @memberOf IntIndexData#
     */
    "delete": function _delete() {
      Module._IntIndexData_Delete(this.handle);
    },
    /**
     * 删除所有索引数据
     * @memberOf IntIndexData#
     */
    removeAllIndexs: function removeAllIndexs() {
      Module._IntIndexData_RemoveAllIndexs(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * Short索引数据对象操作函数
   * @name ShortIndexData
   * @class ShortIndexData
   * 创建索引数据对象
   *
   */
  function PIEShortIndexData(handle, autoRelease) {
    if (handle == null) {
      handle = Module._ShortIndexData_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEShortIndexData.prototype, {
    /**
     * 删除索引数据对象
     * @memberOf IntIndexData#
     */
    "delete": function _delete() {
      Module._ShortIndexData_Delete(this.handle);
    },
    /**
     * 删除所有索引数据
     * @memberOf IntIndexData#
     */
    removeAllIndexs: function removeAllIndexs() {
      Module._ShortIndexData_RemoveAllIndexs(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建Mesh对象
   * @name Mesh
   * @class Mesh
   *
   * @example
   * let mesh = new PIE.Mesh()
   */
  function PIEMesh(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Mesh_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEMesh.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 销毁Mesh对象
     * @memberOf Mesh#
     *
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._Mesh_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置名称
     * @param {String} name -Mesh名称
     * @memberOf Mesh#
     *
     * @example
     * let mesh = new PIE.Mesh();
     * mesh.setName(name);
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._Mesh_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取名称
     *
     * @memberOf Mesh#
     * @returns {String} 返回Mesh名称
     *
     * @example
     * let mesh = new PIE.Mesh();
     * var name = mesh.getName();
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Mesh_GetName(this.handle);
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置图元渲染类型
     * @param {PIEOperationType} type -图元渲染类型
     * @memberOf Mesh#
     */
    setOperationType: function setOperationType(type) {
      Module._Mesh_SetOperationType(this.handle, type);
    },
    /**
     * 获取图元渲染类型
     *
     * @memberOf Mesh#
     * @returns {PIEOperationType} 返回图元渲染类型
     *
     */
    getOperationType: function getOperationType() {
      return Module._Mesh_GetOperationType(this.handle);
    },
    /**
     * 获取顶点数据对象类型
     *
     * @memberOf Mesh#
     * @returns {Number} 返回顶点数据对象类型
     *
     */
    getVertexType: function getVertexType() {
      return Module._Mesh_GetVertexType(this.handle);
    },
    /**
     * 获取顶点大小
     *
     * @memberOf Mesh#
     * @returns {Number} 返回顶点大小
     *
     */
    getVertexSize: function getVertexSize() {
      return Module._Mesh_GetVertexSize(this.handle);
    },
    /**
     * 获取索引大小
     *
     * @memberOf Mesh#
     * @returns {Number} 返回索引大小
     *
     */
    getIndexSize: function getIndexSize() {
      return Module._Mesh_GetIndexSize(this.handle);
    },
    /**
     * 添加顶点数据对象
     * @param {PIE.VertexData} vertexData -顶点数据对象
     * @memberOf Mesh#
     *
     */
    addVertexData: function addVertexData(vertexData) {
      Module._Mesh_AddVertexData(this.handle, vertexData.getHandle());
    },
    /**
     * 获取顶点数据对象
     * @param {Number} index -索引
     * @memberOf Mesh#
     *
     * @returns {PIEVertexData} 返回索引数据大小
     *
     */
    getVertexData: function getVertexData(index) {
      var hVertexData = Module._Mesh_GetVertexData(this.handle, index);
      //todo 等待vertexData封装
      return new PIEVertexData(hVertexData);
    },
    /**
     * 获取顶点数据对象大小
     *
     * @memberOf Mesh#
     * @returns {Number} 返回索引数据大小
     *
     */
    getVertexDataSize: function getVertexDataSize() {
      return Module._Mesh_GetVertexDataSize(this.handle);
    },
    /**
     * 移除所有顶点数据对象
     * @memberOf Mesh#
     */
    removeAllVertexData: function removeAllVertexData() {
      Module._Mesh_RemoveAllVertexData(this.handle);
    },
    /**
     * 设置short数据对象
     * @param {PIEShortIndexData} shortIndexData -索引数据对象
     * @memberOf Mesh#
     *
     */
    setShortIndexData: function setShortIndexData(shortIndexData) {
      Module._Mesh_SetShortIndexData(this.handle, shortIndexData.getHandle());
    },
    /**
     * 获取short索引数据对象
     * @memberOf Mesh#
     * @returns {PIEShortIndexData} 返回short索引数据对象
     *
     */
    getShortIndexData: function getShortIndexData() {
      var hIndexData = Module._Mesh_GetShortIndexData(this.handle);
      //todo   等待ShortIndexData封装
      return new PIEShortIndexData(hIndexData);
    },
    /**
     * 设置int索引数据对象
     * @param {PIEIntIndexData} intIndexData -int索引数据对象
     * @memberOf Mesh#
     *
     */
    setIntIndexData: function setIntIndexData(intIndexData) {
      Module._Mesh_SetIntIndexData(this.handle, intIndexData.getHandle());
    },
    /**
     * 获取int索引数据对象
     * @memberOf Mesh#
     * @returns {PIEIntIndexData} 返回int索引数据对象
     *
     */
    getIntIndexData: function getIntIndexData() {
      var hIndexData = Module._Mesh_GetIntIndexData(this.handle);
      //todo   等待IntIndexData封装
      return new PIEIntIndexData(hIndexData);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 文件操作
   * @name File
   *
   *
   */
  function PIEFile(value, type) {}
  Object.assign(PIEFile.prototype, {});
  /**
   * 创建目录
   * @param {String} file -文件路径
   * @memberOf File
   */
  PIEFile.makeFolder = function (file) {
    if (file != null) {
      var fileNames = file.split('/');
      if (fileNames.length > 0) {
        if (fileNames[0] == '.') {
          fileNames.splice(0, 1);
        }
        if (fileNames.length > 0) {
          var lastIndex = fileNames.length - 1;
          if (fileNames[lastIndex].indexOf('.') != -1) {
            fileNames.splice(lastIndex, 1);
          }
        }
        if (fileNames.length > 0) {
          var filePath = "";
          for (var i = 0; i < fileNames.length; i++) {
            filePath += fileNames[i];
            filePath += "/";
            try {
              Module.FS.mkdir(filePath);
            } catch (e) {}
          }
        }
      }
    }
  };
  function loadFile(handler, file, url) {
    var xhr = new XMLHttpRequest();
    xhr.timeout = 0;
    xhr.withCredentials = false;
    xhr.responseType = "arraybuffer";
    xhr.onload = function () {
      var content = this.response;
      if (content != null && this.status == 200) {
        PIEFile.makeFolder(file);
        var data = new Uint8Array(content);
        var stream = Module.FS.open(file, 'w+');
        Module.FS.write(stream, data, 0, data.length, 0);
        Module.FS.close(stream);
        handler.loaded(file, url, data);
      } else {
        handler.loaded(file, url, null);
      }
    };
    xhr.open("GET", url, true);
    xhr.send(null);
  }

  /**
   * 加载文件
   * @param {String} file -文件路径
   * @param {String} url -服务路径
   * @param {PIEEvent} callback -回调函数
   * @memberOf File
   */
  PIEFile.loadFile = function (file, url, callback) {
    if (file != null && url != null) {
      var handler = {};
      handler.callback = callback;
      handler.loaded = function (file, url, data) {
        this.callback(file, url, data);
      };
      loadFile(handler, file, url);
    }
  };
  /**
   * 加载文件
   * @param {String} files -文件路径
   * @param {String} urls -服务路径
   * @param {PIEEvent} callback -回调函数
   * @memberOf File
   */
  PIEFile.loadFiles = function (files, urls, callback) {
    if (files.length == urls.length) {
      var handler = {};
      handler.count = urls.length;
      handler.files = [];
      handler.urls = [];
      handler.fileMap = {};
      handler.datas = [];
      handler.callback = callback;
      for (var i = 0; i < files.length; i++) {
        handler.fileMap[files[i]] = i;
      }
      handler.loaded = function (file, url, data) {
        this.files[handler.fileMap[file]] = file;
        this.urls[handler.fileMap[file]] = url;
        this.datas[handler.fileMap[file]] = data;
        handler.count--;
        if (handler.count == 0) {
          this.callback(this.files, this.urls, this.datas);
        }
      };
      for (var _i = 0; _i < urls.length; _i++) {
        loadFile(handler, files[_i], urls[_i]);
      }
    }
  };
  PIEFile.uuid = function (len, radix) {
    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    var uuid = [],
      i;
    radix = radix || chars.length;
    if (len) {
      // Compact form
      for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random() * radix];
    } else {
      // rfc4122, version 4 form
      var r;
      // rfc4122 requires these characters
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
      uuid[14] = '4';

      // Fill in random data.  At i==19 set the high bits of clock sequence as
      // per rfc4122, sec. 4.1.5
      for (i = 0; i < 36; i++) {
        if (!uuid[i]) {
          r = 0 | Math.random() * 16;
          uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];
        }
      }
    }
    return uuid.join('');
  };
  PIEFile.getFileName = function (url) {
    if (url.indexOf('?') > -1) {
      var filePath = url.split('?');
      url = filePath[0];
    }
    var pos1 = url.lastIndexOf('/');
    var pos2 = url.lastIndexOf('\\');
    var pos = Math.max(pos1, pos2);
    if (pos < 0) return url;else return url.substring(pos + 1);
  };
  PIEFile.getExtFromName = function (fileName) {
    if (fileName.indexOf('.') > -1) {
      var fileMsg = fileName.split('.');
      var fileExt = fileMsg[fileMsg.length - 1];
      return fileExt;
    }
    return "";
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 纹理过滤模式
   * @readonly
   * @enum {Number}
   */

  var PIETextureFilterMode = {
    NEAREST: 0x2600,
    LINEAR: 0x2601,
    NEAREST_MIPMAP_NEAREST: 0x2700,
    LINEAR_MIPMAP_NEAREST: 0x2701,
    NEAREST_MIPMAP_LINEAR: 0x2702,
    LINEAR_MIPMAP_LINEAR: 0x2703
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 纹理覆盖模式
   * @readonly
   * @enum {Number}
   */
  var PIETextureWrapMode = {
    CLAMP: 0x2900,
    REPEAT: 0x2901,
    MIRRORED_REPEAT: 0x8370,
    CLAMP_TO_EDGE: 0x812F,
    CLAMP_TO_BORDER: 0x812D
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 纹理对象操作函数
   * @name Texture
   * @class Texture
   *
   */
  function PIETexture(handle, autoRelease) {
    if (!handle) {
      handle = Module._TEX_Generate();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIETexture.prototype, {
    // /**
    //  * 创建纹理对象
    //  * @memberOf Texture#
    //  * @param {PIETexture} context WebGL上下文环境
    //  */
    create: function create() {
      this.handle = Module._TEX_Generate();
      this.autoRelease = true;
    },
    /**
     * 删除纹理对象
     * @memberOf Texture#
     */
    dispose: function dispose() {
      Module._TEX_Delete(this.handle);
    },
    /**
     * 绑定纹理对象
     * @memberOf Texture#
     * @param {PIETexture} isBind 是否绑定纹理对象
     */
    bind: function bind(isBind) {
      Module._TEX_Bind(this.handle, isBind);
    },
    /**
     * 更新纹理对象
     * @memberOf Texture#
     * @param {PIETexture} isBind 是否绑定纹理对象
     */
    updateImage: function updateImage(context, image) {
      var gl = context;
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    },
    /**
     * 更新纹理对象像素
     * @param {Number} btBitsPixel -像素位深
     * @param {Number} width -像素宽
     * @param {Number} height -像素高
     * @param {String} buffer -纹理数据
     * @memberOf Texture
     */
    update: function update(btBitsPixel, width, height, buffer) {
      var strBuffer = new PIEString$1(buffer);
      Module._TEX_Update(this.handle, btBitsPixel, width, height, strBuffer.getHandle());
      strBuffer.dispose();
    },
    getHandle: function getHandle() {
      return this.handle;
    }
  });

  // /**
  //  * 通过纹理路径创建纹理对象
  //  * @param {String} filePath -创建纹理路径
  //  * @param {PIETextureWrapMode} wrapMode -纹理覆盖模式，默认REPEAT
  //  * @param {PIETextureFilterMode} filterMode -纹理过滤模式，默认LINEAR
  //  * @param {Number} pixelFormat -像素格式
  //  *
  //  * @memberOf Texture
  //  * @returns {PIETexture} 返回纹理对象
  //  */
  PIETexture.fromFile = function (filePath, wrapMode, filterMode) {
    var pixelFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;
    var strFilePath = new PIEString$1(filePath);
    if (!wrapMode) {
      wrapMode = PIETextureWrapMode.TWM_REPEAT;
    }
    if (!filterMode) {
      filterMode = PIETextureFilterMode.TFM_LINEAR;
    }
    var handle = Module._TEX_FromFile(strFilePath.getHandle(), wrapMode, filterMode, pixelFormat);
    strFilePath.dispose();
    if (handle) {
      return new PIETexture(handle, true);
    }
    return null;
  };

  /**
   * 通过纹理数据创建纹理对象
   * @param {Number} width -像素宽
   * @param {Number} height -像素高
   * @param {number} btBitsPixel -像素位深
   * @param {String} buffer -纹理数据
   * @param {PIETextureWrapMode} wrapMode -纹理覆盖模式，默认REPEAT
   * @param {PIETextureFilterMode} filterMode -纹理过滤模式，默认LINEAR
   *
   * @memberOf Texture
   * @returns {PIETexture} 纹理对象
   */
  PIETexture.fromBuffer = function (width, height, btBitsPixel, buffer, wrapMode, filterMode) {
    var strBuffer = new PIEString$1(buffer);
    var handle = Module._TEX_Create(strBuffer.getHandle(), width, height, btBitsPixel, wrapMode, filterMode);
    strBuffer.dispose();
    if (handle) {
      return new PIETexture(handle, true);
    }
    return null;
  };

  /**
   * 通过纹理路径加载纹理对象
   * @param {Object} options -
   * @param {String} options.file -从服务上获取的数据存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
   * @param {String} options.url -纹理路径
   * @param {PIETextureWrapMode} options.wrapMode -纹理覆盖模式，默认REPEAT
   * @param {PIETextureFilterMode} options.filterMode -纹理过滤模式，默认LINEAR
   * @param {Number} options.pixelFormat -像素格式
   * @memberOf Texture
   * @returns {Promise} 返回一个promise，在value中存放数据源数据
   * @example
   *  PIE.Texture.load({url:strRootUrl+"Resource/Icons/roadcross.jpg",wrapMode:PIE.TextureWrapMode.CLAMP_TO_EDGE, filterMode:PIE.TextureFilterMode.LINEAR, pixelFormat:24}).then((value) => {
   *          //vaule就是load之后创建的Texture, 可以用来添加到渲染对象中
   *          var myTexture = value;
   */
  PIETexture.load = function (options) {
    return new Promise(function (resolve, reject) {
      var wrapMode = options.wrapMode;
      var filterMode = options.filterMode;
      var pixelFormat = options.pixelFormat;
      var file = options.file;
      var url = options.url;
      if (url == null) {
        return null;
      }
      var name = PIEFile.getFileName(url);
      if (!file) {
        file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
      }
      var filesPicks = [];
      filesPicks.push(file);
      var urlsPicks = [];
      urlsPicks.push(url);
      function callBack(filelist, urllist, datalist) {
        var texture = PIETexture.fromFile(filesPicks[0], wrapMode, filterMode, pixelFormat);
        if (texture) {
          resolve(texture);
        }
      }
      PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
    });
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建模型格网对象
   * @name ModelMesh
   * @class ModelMesh
   * 模型格网操作函数
   * @param {Object} options -
   * @param {String} options.path -模型数据路径
   */
  function PIEModelMesh(options) {
    var handle = null;
    var autoRelease = false;
    if (options == null) ; else {
      var path = options.path;
      if (path) {
        var strPath = new PIEString$1(path);
        handle = Module._ModelMesh_CreateByPath(strPath.getHandle());
        strPath.dispose();
        autoRelease = true;
      }
      if (options.handle) {
        handle = options.handle;
      }
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEModelMesh.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 通过模型数据路径加载模型格网对象
     * @param {Object} options -
     * @param {Array} options.files -从服务上获取的数据存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {Array} options.urls -模型数据路径数组（包含贴图等数据,需要保证数组第一个值是模型路径）
     * @memberOf ModelMesh#
     * @returns {Promise} 返回一个promise，在value中存放创建好的ModelMesh对象
     * @example
     *    let modelRenderableLayer = new PIE.GlobeRenderableLayer();
     globe.addLayer(modelRenderableLayer, true);
     let urlsFBX = [];
     urlsFBX.push(strRootUrl + "data/Model3D/data.FBX");
     urlsFBX.push(strRootUrl + "data/Model3D/data1.jpg");
     urlsFBX.push(strRootUrl + "data/Model3D/data1_2.jpg");
     urlsFBX.push(strRootUrl + "data/Model3D/car.FBX");
     urlsFBX.push(strRootUrl + "data/Model3D/data_41.jpg");
     let sceneCenter = new PIE.Vector2(115.7, 39.4);
     let posGlobeSR = hGlobeSR.forward(sceneCenter);\
     let modelMesh = new PIE.ModelMesh();
     modelMesh.load({urls:urlsFBX}).then((value) =>{
          let geomModel = new PIE.Model3D({modelMesh: value});
          let position3d = new PIE.Vector3(posGlobeSR.x, posGlobeSR.y, 20000);
          let scale3d = new PIE.Vector3(0.1,0.1,0.1);
          let rotation3d = new PIE.Vector3(-Math.PI / 2, 0,-Math.PI/2);
          let renderModel3D = new PIE.RenderModel({
              model: geomModel,
              position: position3d,
              scale: scale3d,
              rotation: rotation3d
          });
          modelRenderableLayer.add(renderModel3D);
         })
     *
     */
    load: function load(options) {
      var _this = this;
      return new Promise(function (resolve, reject) {
        var that = _this;
        var files = options.files;
        var urls = options.urls;
        if (urls == null || !(urls instanceof Array)) {
          resolve(null);
        }
        var filesPicks = [];
        var urlsPicks = [];
        var path = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid();
        urls.forEach(function (url, index) {
          urlsPicks.push(url);
          if (files != null && files instanceof Array && files.length == urls.length && urls.length >= 1) {
            files.forEach(function (file, index) {
              filesPicks.push(file);
            });
          } else {
            var name = PIEFile.getFileName(url);
            var file = path + "/" + name;
            filesPicks.push(file);
          }
        });
        function callBack(filelist, urllist, datalist) {
          var path = filelist[0];
          var strPath = new PIEString$1(path);
          var handle = Module._ModelMesh_CreateByPath(strPath.getHandle());
          that.handle = handle;
          that.autoRelease = true;
          resolve(that);
        }
        if (urlsPicks.length > 0) {
          PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
        }
      });
    },
    /**
     * 销毁ModelMesh
     *
     * @memberOf ModelMesh#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._ModelMesh_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置广告牌模式
     * @param {PIEBillBoardModeType} mode -广告牌模式
     *
     * @memberOf ModelMesh#
     */
    setBillBoardMode: function setBillBoardMode(mode) {
      Module._ModelMesh_SetBillBoardMode(this.handle, mode);
    },
    /**
     * 获取广告牌模式
     *
     * @memberOf ModelMesh#
     * @returns {PIEBillBoardModeType} 返回广告牌模式
     */
    getBillBoardMode: function getBillBoardMode() {
      return Module._ModelMesh_GetBillBoardMode(this.handle);
    },
    /**
     * 设置模型坐标
     * @param {(Array/PIEVector3)} position -坐标位置
     * @memberOf ModelMesh#
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._ModelMesh_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取模型坐标
     *
     * @memberOf ModelMesh#
     * @returns {PIEVector3} 返回模型坐标
     */
    getPosition: function getPosition() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._ModelMesh_GetPosition(this.handle, arrayPos.getHandle());
      arrayPos.updateData();
      var position = arrayPos.toArray();
      arrayPos.dispose();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     * 设置平移系数
     * @param {(Array/PIEVector3)} translation -平移系数
     * @memberOf ModelMesh#
     */
    setTranslation: function setTranslation(translation) {
      var transArray = null;
      if (translation instanceof Array) {
        transArray = translation;
      } else if (translation instanceof PIEVector3) {
        transArray = translation.toArray();
      }
      if (transArray) {
        var arrayTrans = new PIEArray(transArray, PIEArrayType.Float64);
        Module._ModelMesh_SetTranslation(this.handle, arrayTrans.getHandle());
        arrayTrans.dispose();
      }
    },
    /**
     * 获取平移系数
     *
     * @memberOf ModelMesh#
     * @returns {PIEVector3} 返回平移系数
     */
    getTranslation: function getTranslation() {
      var arrayTrans = new PIEArray(3, PIEArrayType.Float64);
      Module._ModelMesh_GetTranslation(this.handle, arrayTrans.getHandle());
      arrayTrans.updateData();
      var translation = arrayTrans.toArray();
      arrayTrans.dispose();
      return new PIEVector3(translation[0], translation[1], translation[2]);
    },
    /**
     * 设置缩放系数
     * @param {(Array/PIEVector3)} scale -缩放系数
     * @memberOf ModelMesh#
     */
    setScaling: function setScaling(scale) {
      var scaleArray = null;
      if (scale instanceof Array) {
        scaleArray = scale;
      } else if (scale instanceof PIEVector3) {
        scaleArray = scale.toArray();
      }
      if (scaleArray) {
        var arrayScale = new PIEArray(scaleArray, PIEArrayType.Float64);
        Module._ModelMesh_SetScaling(this.handle, arrayScale.getHandle());
        arrayScale.dispose();
      }
    },
    /**
     * 获取缩放系数
     *
     * @memberOf ModelMesh#
     * @returns {PIEVector3} 返回缩放系数
     */
    getScaling: function getScaling() {
      var arrayScale = new PIEArray(3, PIEArrayType.Float64);
      Module._ModelMesh_GetScaling(this.handle, arrayScale.getHandle());
      arrayScale.updateData();
      var scale = arrayScale.toArray();
      arrayScale.dispose();
      return new PIEVector3(scale[0], scale[1], scale[2]);
    },
    /**
     * 设置旋转系数
     * @param {(Array/PIEVector3)} rotation -顺时针旋转角度
     * @memberOf ModelMesh#
     */
    setRotation: function setRotation(rotation) {
      var rotationArray = null;
      if (rotation instanceof Array) {
        rotationArray = rotation;
      } else if (rotation instanceof PIEVector3) {
        rotationArray = rotation.toArray();
      }
      if (rotationArray) {
        var arrayRotation = new PIEArray(rotationArray, PIEArrayType.Float64);
        Module._ModelMesh_SetRotation(this.handle, arrayRotation.getHandle());
        arrayRotation.dispose();
      }
    },
    /**
     * 获取旋转系数
     *
     * @memberOf ModelMesh#
     * @returns {PIEVector3} 返回旋转系数
     */
    getRotation: function getRotation() {
      var arrayRotation = new PIEArray(3, PIEArrayType.Float64);
      Module._ModelMesh_GetRotation(this.handle, arrayRotation.getHandle());
      arrayRotation.updateData();
      var rotation = arrayRotation.toArray();
      arrayRotation.dispose();
      return new PIEVector3(rotation[0], rotation[1], rotation[2]);
    },
    /**
     * 设置包围盒
     * @param {(Array/PIEBoundingBox)} boundingBox -包围盒
     * @memberOf ModelMesh#
     */
    setBoundingBox: function setBoundingBox(boundingBox) {
      var boxArray = null;
      if (boundingBox instanceof Array) {
        boxArray = boundingBox;
      } else if (boundingBox instanceof PIEBoundingBox) {
        boxArray = boundingBox.toArray();
      }
      if (boxArray) {
        var arrayBox = new PIEArray(boxArray, PIEArrayType.Float64);
        Module._ModelMesh_SetBoundingBox(this.handle, arrayBox.getHandle());
        arrayBox.dispose();
      }
    },
    /**
     * 获取包围盒
     *
     * @memberOf ModelMesh#
     * @returns {PIEBoundingBox} 返回包围盒
     */
    getBoundingBox: function getBoundingBox() {
      var arrayBox = new PIEArray(6, PIEArrayType.Float64);
      Module._ModelMesh_GetBoundingBox(this.handle, arrayBox.getHandle());
      arrayBox.updateData();
      var boundingBox = arrayBox.toArray();
      arrayBox.dispose();
      return new PIEBoundingBox(boundingBox[0], boundingBox[1], boundingBox[2], boundingBox[3], boundingBox[4], boundingBox[5]);
    }

    // /**
    //  * 添加材质
    //  * @param {PIEMaterial} material -材质对象
    //  * @memberOf ModelMesh#
    //  */
    // addMaterial: function (material) {
    //     Module._ModelMesh_AddMaterial(this.handle, material.getHandle());
    // },
    //
    // /**
    //  * 获取材质个数
    //  *
    //  * @memberOf ModelMesh#
    //  * @returns {Number} 返回材质数量
    //  */
    // getMaterialCount: function () {
    //     return Module._ModelMesh_GetMaterialCount(this.handle);
    // },

    // /**
    //  * 获取材质
    //  * @param {Number} index -材质序列号
    //  * @memberOf ModelMesh#
    //  * @example
    //  * let modelMesh = new PIE.ModelMesh();
    //  */
    // getMaterial: function (index) {
    //     var hMaterial = Module._ModelMesh_GetMaterial(this.handle, index);
    //     //todo 等待Material封装
    //     //return new PIEMaterial(hMaterial);
    // },

    // /**
    //  * 添加格网
    //  * @param {PIEMesh} mesh -格网对象
    //  * @memberOf ModelMesh#
    //  */
    // addMesh: function (mesh) {
    //     Module._ModelMesh_AddMesh(this.handle, mesh.getHandle());
    // },

    // /**
    //  * 获取格网个数
    //  *
    //  * @memberOf ModelMesh#
    //  * @returns {Number} 返回格网数量
    //  */
    // getMeshCount:function () {
    //     return Module._ModelMesh_GetMeshCount(this.handle);
    // },

    // /**
    //  * 获取格网数据
    //  * @param {Number} index -格网数据序列号
    //  * @memberOf ModelMesh#
    //  *
    //  * @returns {PIEMesh} 返回格网数据对象
    //  * @example
    //  * let modelMesh = new PIE.ModelMesh();
    //  */
    // getMesh:function (index) {
    //     var hMesh = Module._ModelMesh_GetMesh(this.handle, index);
    //     return new PIEMesh(hMesh);
    // },

    // /**
    //  * 模型mesh操作函数
    //  * @param {(Array/PIEVector3)} offset -偏移
    //  * @param {(Array/PIEVector3)} rotate -旋转角度
    //  * @param {(Array/PIEVector3)} scale -缩放比例
    //  * @memberOf ModelMesh#
    //  */
    // addInstance:function (offset, rotate, scale) {
    //     var offsetArray = null;
    //     var rotateArray = null;
    //     var scaleArray = null;
    //     if(offset instanceof Array){
    //         offsetArray = offset;
    //     }else if(offset instanceof PIEVector3){
    //         offsetArray = offset.toArray();
    //     }
    //     if(rotate instanceof Array){
    //         rotateArray = rotate;
    //     }else if(rotate instanceof PIEVector3){
    //         rotateArray = rotate.toArray();
    //     }
    //     if(scale instanceof Array){
    //         scaleArray = scale;
    //     }else if(scale instanceof PIEVector3){
    //         scaleArray = scale.toArray();
    //     }
    //     if(offsetArray && rotateArray && scaleArray){
    //         var arrayOffset = new PIEArray(offsetArray, PIEArrayType.Float64);
    //         var arrayRotate = new PIEArray(rotateArray, PIEArrayType.Float64);
    //         var arrayScale = new PIEArray(scaleArray, PIEArrayType.Float64);
    //         Module._ModelMesh_AddInstance(this.handle, arrayOffset.getHandle(), arrayRotate.getHandle(), arrayScale.getHandle());
    //         arrayOffset.dispose();
    //         arrayRotate.dispose();
    //         arrayScale.dispose();
    //     }
    // }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   *
   * 三维几何对象基类操作函数
   * @name Geometry3D
   * @extends Geometry
   *
   */
  function PIEGeometry3D(handle, autoRelease) {
    PIEGeometry.call(this, handle, autoRelease);
  }
  PIEGeometry3D.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 得到内点（可能是Geometry3D的质点）
     *
     * @memberOf Geometry3D#
     * @returns {PIEVector3} Geometry3D的内点
     */
    getCenter3D: function getCenter3D() {
      var arrayCenter3D = new PIEArray(3, PIEArrayType.Float64);
      Module._Geometry3D_GetCenter3D(this.handle, arrayCenter3D.getHandle());
      arrayCenter3D.updateData();
      var centerArray = arrayCenter3D.toArray();
      arrayCenter3D.dispose();
      return new PIEVector3(centerArray[0], centerArray[1], centerArray[2]);
    },
    // /**
    //  * 三维对象平移
    //  * @param {(PIEVector3/Array)} offset -Geometry3D的内点
    //  * @memberOf Geometry3D#
    //  *
    //  */
    // offset3D: function (offset) {
    //     var offsetArray = null;
    //     if(offset instanceof Array){
    //         offsetArray = offset;
    //     }else if(offset instanceof PIEVector3){
    //         offsetArray = [offset.x, offset.y, offset.z];
    //     }
    //     if(offsetArray){
    //         Module._Geometry3D_Offset3D(this.handle, offsetArray[0], offsetArray[1], offsetArray[2]);
    //     }
    // },
    // /**
    //  * 三维对象旋转
    //  * @param {(PIEVector3/Array)} position -旋转中心点
    //  * @param {Number} angle -旋转角度
    //  * @memberOf Geometry3D#
    //  */
    // rotate3D:function (position, angle) {
    //     var posArray = null;
    //     if(position instanceof Array){
    //         posArray = position;
    //     }else if(position instanceof PIEVector3){
    //         posArray = [position.x, position.y, position.z];
    //     }
    //     if(posArray){
    //         var ayyarPos = new PIEArray(posArray, PIEArrayType.Float64);
    //         Module._Geometry3D_Rotate3D(this.handle, ayyarPos.getHandle(), angle);
    //     }
    // },
    // /**
    //  * 三维对象轴旋转
    //  * @param {(PIEVector3/Array)} axisPos -最初位置
    //  * @param {Number} angle -旋转角度
    //  * @memberOf Geometry3D#
    //  *
    //  */
    // rotateAxis3D:function (axisPos, angle) {
    //     var axisPosArray = null;
    //     if(axisPos instanceof Array){
    //         axisPosArray = axisPos;
    //     }else if(axisPos instanceof PIEVector3){
    //         axisPosArray = [axisPos.x, axisPos.y, axisPos.z];
    //     }
    //     if(axisPosArray){
    //         var ayyarPos = new PIEArray(axisPosArray, PIEArrayType.Float64);
    //         Module._Geometry3D_RotateAxis3D(this.handle, ayyarPos.getHandle(), angle);
    //     }
    // },
    /**
     * 设置模型数据
     * @param {PIEModelMesh} modelMesh -modelMesh对象
     * @memberOf Geometry3D#
     *
     */
    setModelMesh: function setModelMesh(modelMesh) {
      Module._Geometry3D_SetModelMesh(this.handle, modelMesh.getHandle());
    },
    /**
     * 获取模型数据指针
     *
     * @memberOf Geometry3D#
     * @returns {PIEModelMesh} modelMesh对象
     */
    getModelMesh: function getModelMesh() {
      var hModelMesh = Module._Geometry3D_GetModelMesh(this.handle);
      return new PIEModelMesh({
        handle: hModelMesh
      });
    },
    /**
     * 得到对象的位置
     *
     * @memberOf Geometry3D#
     * @returns {PIEVector3} 模型位置
     */
    getPosition: function getPosition() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._Geometry3D_GetPosition(this.handle, arrayPos.getHandle());
      arrayPos.updateData();
      var position = arrayPos.toArray();
      arrayPos.dispose();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     * 设置对象的位置
     * @param {(PIEVector3/Array)} position -对象位置
     * @memberOf Geometry3D#
     *
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._Geometry3D_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取对象各方向的缩放比率
     *
     * @memberOf Geometry3D#
     * @returns {PIEVector3} 对象各方向的缩放比率
     */
    getScale: function getScale() {
      var arrayScale = new PIEArray(3, PIEArrayType.Float64);
      Module._Geometry3D_GetScale(this.handle, arrayScale.getHandle());
      arrayScale.updateData();
      var scale = arrayScale.toArray();
      arrayScale.dispose();
      return new PIEVector3(scale[0], scale[1], scale[2]);
    },
    /**
     * 设置对象的缩放大小
     * @param {(Array/PIEVector3)} scale -对象各方向的缩放比率
     * @memberOf Geometry3D#
     *
     */
    setScale: function setScale(scale) {
      var scaleArray = null;
      if (scale instanceof Array) {
        scaleArray = scale;
      } else if (scale instanceof PIEVector3) {
        scaleArray = scale.toArray();
      }
      if (scaleArray) {
        var arrayScale = new PIEArray(scaleArray, PIEArrayType.Float64);
        Module._Geometry3D_SetScale(this.handle, arrayScale.getHandle());
        arrayScale.dispose();
      }
    },
    /**
     * 得到对象各方向的旋转角度
     *
     * @memberOf Geometry3D#
     * @returns {PIEVector3}  对象各方向的缩放比率
     */
    getRotation: function getRotation() {
      var arrayRotation = new PIEArray(3, PIEArrayType.Float64);
      Module._Geometry3D_GetRotation(this.handle, arrayRotation.getHandle());
      arrayRotation.updateData();
      var scale = arrayRotation.toArray();
      arrayRotation.dispose();
      return new PIEVector3(scale[0], scale[1], scale[2]);
    },
    /**
     * 设置对象的旋转量
     * @param {(PIEVector3/Array)}  rotation -对象的旋转量
     * @memberOf Geometry3D#
     *
     */
    setRotation: function setRotation(rotation) {
      var rotationArray = null;
      if (rotation instanceof Array) {
        rotationArray = rotation;
      } else if (rotation instanceof PIEVector3) {
        rotationArray = rotation.toArray();
      }
      if (rotationArray) {
        var arrayRotation = new PIEArray(rotationArray, PIEArrayType.Float64);
        Module._Geometry3D_SetRotation(this.handle, arrayRotation.getHandle());
        arrayRotation.dispose();
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建点对象
   * @name Point3D
   * @class Point3D
   * 三维点操作函数
   *
   * @param {Object} options -
   * @param {(PIEVector3/Array)} options.point -3D点对象
   * @param {Number} options.ID -对象ID
   *
   * @extends Geometry3D
   */
  function PIEPoint3D(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var point = options.point;
      if (point != null) {
        if (point instanceof PIEVector3) {
          handle = Module._Point3D_Create(point.x, point.y, point.z);
        } else if (point instanceof Array) {
          handle = Module._Point3D_Create(point[0], point[1], point[2]);
        }
        autoRelease = true;
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEGeometry3D.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEPoint3D.prototype = Object.assign(Object.create(PIEGeometry3D.prototype), {
    /**
     * 获取点对象的坐标
     *
     * @memberOf Point3D#
     * @returns {PIEVector3} 返回的对象坐标的点
     */
    getPoint: function getPoint() {
      var arrayPoint = new PIEArray(3, PIEArrayType.Float64);
      Module._Point3D_GetPoint(this.handle, arrayPoint.getHandle());
      arrayPoint.updateData();
      var point = arrayPoint.toArray();
      arrayPoint.dispose();
      return new PIEVector3(point[0], point[1], point[2]);
    },
    /**
     * 设置点对象的坐标
     * @param {PIEVector3|Array} point -点对象坐标
     *
     * @memberOf Point3D#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setPoint: function setPoint(point) {
      var arrayPoint = null;
      if (point instanceof PIEVector3) {
        arrayPoint = point.toArray();
      } else if (point instanceof Array) {
        arrayPoint = point;
      }
      if (arrayPoint) {
        var pntArray = new PIEArray(arrayPoint, PIEArrayType.Float64);
        var res = Module._Point3D_SetPoint(this.handle, pntArray.getHandle());
        pntArray.dispose();
        return Boolean(res);
      }
      return false;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建简单3D线对象
   * @name Polyline3D
   * @class Polyline3D
   * 三维线操作函数
   *@param {Object} options -
   *@param {Array} options.points - 点串数组
   *@param {Number} options.ID -对象ID
   *
   * @extends Geometry3D
   *
   */
  function PIEPolyline3D(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var points = options.points;
      if (points) {
        if (points instanceof Array) {
          var pointsArray = new PIEArray(points, PIEArrayType.Float64);
          handle = Module._Polyline3D_Create_WithPoints(pointsArray.getHandle(), points.length);
          pointsArray.dispose();
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEGeometry3D.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEPolyline3D.prototype = Object.assign(Object.create(PIEGeometry3D.prototype), {
    /**
     * 获取3D线对象的点数量
     *
     * @memberOf Polyline3D#
     * @returns {Number} 如果获取成功返回所有子对象点个数的总和
     */
    getPointCount: function getPointCount() {
      return Module._Polyline3D_GetPointCount(this.handle);
    },
    /**
     * 获取子对象的个数
     *
     * @memberOf Polygon3D#
     * @returns {Number} 返回所有子对象个数
     */
    getSubCount: function getSubCount() {
      return Module._Polyline3D_GetSubCount(this.handle);
    },
    /**
     * 获取某个子对象的点的个数
     * @param {Number} subIndex -子对象索引值
     *
     * @memberOf Polyline3D#
     * @returns {Number} 如果获取成功返回该子对象点的总个数
     */
    getSubPointCount: function getSubPointCount(subIndex) {
      return Module._Polyline3D_GetSubPointCount(this.handle, subIndex);
    },
    /**
     * 获取线对象中指定子对象所包含点串数组
     * @param {Number} subIndex -子对象的索引值(默认为0)
     * @memberOf Polyline3D#
     * @returns {Array} 如果获取成功返回子对象所包含点串数组，否则返回null
     */
    getPoints: function getPoints() {
      var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = this.getSubPointCount(subIndex);
      if (count > 0) {
        var pointsRes = [];
        var pointsArrX = new PIEArray(count, PIEArrayType.Float64);
        var pointsArrY = new PIEArray(count, PIEArrayType.Float64);
        var pointsArrZ = new PIEArray(count, PIEArrayType.Float64);
        Module._Polyline3D_GetPoints(this.handle, subIndex, pointsArrX.getHandle(), pointsArrY.getHandle(), pointsArrZ.getHandle());
        pointsArrX.updateData();
        pointsArrY.updateData();
        pointsArrZ.updateData();
        var pointXs = pointsArrX.toArray();
        var pointYs = pointsArrY.toArray();
        var pointZs = pointsArrZ.toArray();
        pointsArrX.dispose();
        pointsArrY.dispose();
        pointsArrZ.dispose();
        for (var i = 0; i < count; i++) {
          pointsRes.push(new PIEVector3(pointXs[i], pointYs[i], pointZs[i]));
        }
        return pointsRes;
      }
      return null;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 三维面操作函数
   * @name Polygon3D
   * @class Polygon3D
   *
   * @param {Object} options -
   * @param {Array} options.points - 点串数组
   * @param {Number} options.ID -对象ID
   * @extends Geometry3D
   */
  function PIEPolygon3D(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var points = options.points;
      if (points) {
        if (points instanceof Array) {
          if (points[0] instanceof PIEVector3) {
            var Arraypoints = [];
            for (var i = 0; i < points.length; i++) {
              Arraypoints[i * 3 + 0] = points[i].x;
              Arraypoints[i * 3 + 1] = points[i].y;
              Arraypoints[i * 3 + 2] = points[i].z;
            }
            points = Arraypoints;
          }
          var pointsArray = new PIEArray(points, PIEArrayType.Float64);
          handle = Module._Polygon3D_Create(pointsArray.getHandle(), points.length);
          pointsArray.dispose();
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEGeometry3D.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEPolygon3D.prototype = Object.assign(Object.create(PIEGeometry3D.prototype), {
    /**
     * 获取3D面对象的点数量
     *
     * @memberOf Polygon3D#
     * @returns {Number} 返回所有子对象点个数的总和
     */
    getPointCount: function getPointCount() {
      return Module._Polygon3D_GetPointCount(this.handle);
    },
    /**
     * 获取子对象的个数
     *
     * @memberOf Polygon3D#
     * @returns {Number} 返回所有子对象个数
     */
    getSubCount: function getSubCount() {
      return Module._Polygon3D_GetSubCount(this.handle);
    },
    /**
     * 获取某个子对象的点的个数
     * @param {Number} subIndex -子对象索引
     *
     * @memberOf Polygon3D#
     * @returns {Number} 返回该子对象的点的总个数
     */
    getSubPointCount: function getSubPointCount(subIndex) {
      return Module._Polygon3D_GetSubPointCount(this.handle, subIndex);
    },
    /**
     * 在指定位置上设置点的坐标
     * @param {Number} index -位置索引
     * @param {PIEVector3|Array} point -点坐标
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setPoint: function setPoint(index, point) {
      var arrayPoint = null;
      if (point instanceof PIEVector3) {
        arrayPoint = point.toArray();
      } else if (point instanceof Array) {
        arrayPoint = point;
      }
      if (arrayPoint) {
        var pntArray = new PIEArray(arrayPoint, PIEArrayType.Float64);
        var res = Module._Polygon3D_SetPoint(this.handle, index, pntArray.getHandle());
        pntArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 在子对象指定的位置上设置点的坐标
     * @param {Number} subIndex -子对象索引
     * @param {Number} pointIndex -子对象点的位置索引
     * @param {PIEVector3|Array} point -点坐标
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setSubPoint: function setSubPoint(subIndex, pointIndex, point) {
      var arrayPoint = null;
      if (point instanceof PIEVector3) {
        arrayPoint = point.toArray();
      } else if (point instanceof Array) {
        arrayPoint = point;
      }
      if (arrayPoint) {
        var pntArray = new PIEArray(arrayPoint, PIEArrayType.Float64);
        var res = Module._Polygon3D_SetSubPoint(this.handle, subIndex, pointIndex, pntArray.getHandle());
        pntArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 获取线对象中指定子对象所包含点串数组
     * @param {Number} subIndex -子对象的索引值(默认为0)
     * @memberOf Polygon3D#
     * @returns {Array} 如果获取成功返回子对象所包含点串数组，否则返回null
     */
    getPoints: function getPoints() {
      var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = this.getSubPointCount(subIndex);
      if (count > 0) {
        var pointsRes = [];
        var pointsArr = new PIEArray(count * 3, PIEArrayType.Float64);
        Module._Polygon3D_GetPoints(this.handle, subIndex, pointsArr.getHandle());
        pointsArr.updateData();
        var points = pointsArr.toArray();
        pointsArr.dispose();
        for (var i = 0; i < count * 3; i += 3) {
          pointsRes.push(new PIEVector3(points[i], points[i + 1], points[i + 2]));
        }
        return pointsRes;
      }
      return null;
    },
    /**
     * 在面对象指定索引处插入一个点
     * @param {Number} subIndex -子对象索引号
     * @param {Number} pointIndex -子对象上插入点的索引号
     * @param {PIEVector3|Array} point -待插入的点的坐标
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 如果插入成功返回true，否则返回false
     */
    insertPoint: function insertPoint(subIndex, pointIndex, point) {
      var arrayPoint = null;
      if (point instanceof PIEVector3) {
        arrayPoint = point.toArray();
      } else if (point instanceof Array) {
        arrayPoint = point;
      }
      if (arrayPoint) {
        var pntArray = new PIEArray(arrayPoint, PIEArrayType.Float64);
        var res = Module._Polygon3D_InsertPoint(this.handle, subIndex, pointIndex, pntArray.getHandle());
        pntArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 组合面对象接口
     * @param {PIEPolygon3D} newPolygon -需要组合的面对象
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 如果组合成功返回true，否则返回false
     */
    combination: function combination(newPolygon) {
      return Boolean(Module._Polygon3D_Combination(this.handle, newPolygon.getHandle()));
    },
    /**
     * 获取三维面对象的面积
     *
     * @memberOf Polygon3D#
     * @returns {Number} 如果获取成功返回几何面积，否则返回0
     */
    getArea: function getArea() {
      return Module._Geometry_GetArea(this.handle);
    },
    /**
     * 获取指定空间参考系下的面积
     * @param {PIESpatialReference} spatialReference -指定空间参考系
     *
     * @memberOf Polygon3D#
     * @returns {Number} 如果获取成功返回面积，否则返回0
     */
    getAreaInSpatialReference: function getAreaInSpatialReference(spatialReference) {
      return Module._Geometry_GetAreaInSpatialReference(this.handle, spatialReference.getHandle());
    },
    /**
     * 判断点是否在面内
     * @param {PIEVector2|Array} point -点
     * @param {Boolean} border -点在边线上时，算作面内设置为true，算作面外设置为false
     * @param {Number} interval -容差
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 在面内返回TRUE，否则返回FALSE
     */
    ptInRegion: function ptInRegion(point, border, interval) {
      var arrayPoint = null;
      if (point instanceof PIEVector2) {
        arrayPoint = point.toArray();
      } else if (point instanceof Array) {
        arrayPoint = point;
      }
      if (arrayPoint) {
        var pointArray = new PIEArray(arrayPoint, PIEArrayType.Float64);
        var res = Module._Polygon3D_PtInRegion(this.handle, pointArray.getHandle(), border, interval);
        pointArray.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 判断多边形指定子对象是岛还是洞
     * @param {Number} subIndex -子对象索引号
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 如果是岛返回true，否则返回false
     */
    checkSubPolygon: function checkSubPolygon(subIndex) {
      return Boolean(Module._Polygon3D_CheckSubPolygon(this.handle, subIndex));
    },
    /**
     * 判断子多边形的走向是否是顺时针
     * @param {Number} subIndex -子对象索引号
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 如果是顺时针返回true，否则返回false
     */
    isCounterClockwise: function isCounterClockwise(subIndex) {
      return Boolean(Module._Polygon3D_IsCounterClockwise(this.handle, subIndex));
    },
    /**
     * 逆序子对象点串顺序
     * @param {Number} subIndex -子对象索引号
     *
     * @memberOf Polygon3D#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    reverseSubPolygon: function reverseSubPolygon(subIndex) {
      return Boolean(Module._Polygon3D_ReverseSubPolygon(this.handle, subIndex));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建文本对象
   * @name Text3D
   * @class Text3D
   * 三维文字操作函数
   *
   * @param {Object} options -
   * @param {(PIEVector3/Array)} options.point -文本对象的坐标
   * @param {String} options.text -文本字符串
   * @param {Number} options.ID -对象ID
   *
   * @extends Geometry3D
   */

  function PIEText3D(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var point = options.point;
      var text = options.text;
      if (point && text) {
        var strText = new PIEString$1(text);
        if (point instanceof Array) {
          handle = Module._Text3D_Create(point[0], point[1], point[2], strText.getHandle());
          autoRelease = true;
        } else if (point instanceof PIEVector3) {
          handle = Module._Text3D_Create(point.x, point.y, point.z, strText.getHandle());
          autoRelease = true;
        }
        strText.dispose();
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIEGeometry3D.call(this, handle, autoRelease);
    if (options != null && this.handle != null && options.ID != null) {
      this.setID(options.ID);
    }
  }
  PIEText3D.prototype = Object.assign(Object.create(PIEGeometry3D.prototype), {
    /**
     * 获取文本对象的坐标
     *
     * @memberOf Text3D#
     * @returns {PIEVector3} 返回的文本对象的坐标点
     */
    getPoint: function getPoint() {
      var pointArray = new PIEArray(3, PIEArrayType.Float64);
      Module._Text3D_GetPoint(this.handle, pointArray.getHandle());
      pointArray.updateData();
      var array = pointArray.toArray();
      pointArray.dispose();
      return new PIEVector3(array[0], array[1], array[2]);
    },
    /**
     * 设置文本对象的坐标
     * @param {PIEVector3} point -文本对象的坐标点
     *
     * @memberOf Text3D#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setPoint: function setPoint(point) {
      var array = null;
      if (point instanceof PIEVector3) {
        array = [point.x, point.y, point.z];
      } else if (point instanceof Array) {
        array = point;
      }
      if (array) {
        var pointArray = new PIEArray(array, PIEArrayType.Float64);
        var res = Module._Text3D_SetPoint(this.handle, pointArray.getHandle());
        pointArray.dispose();
        return res;
      }
      return false;
    },
    /**
     * 获取文本对象的字符串值
     *
     * @memberOf Text3D#
     * @returns {String} 返回文本对象的字符串值
     */
    getText: function getText() {
      var strText = new PIEString$1(256);
      Module._Text3D_GetText(this.handle, strText.getHandle());
      var text = strText.toString();
      strText.dispose();
      return text;
    },
    /**
     * 设置文本对象的字符串值
     * @param {String} text -文本对象的字符串值
     *
     * @memberOf Text3D#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setText: function setText(text) {
      var strText = new PIEString$1(text);
      var res = Module._Text3D_SetText(this.handle, strText.getHandle());
      strText.dispose();
      return res;
    },
    /**
     * 获取文本对象的对象风格
     *
     * @memberOf Text3D#
     * @returns {PIETextStyle} 返回文本对象的对象风格
     */
    getTextStyle: function getTextStyle() {
      var hStyle = Module._Text3D_GetTextStyle(this.handle);
      return new PIETextStyle(hStyle);
    },
    /**
     * 设置文本对象的对象风格
     * @param {PIETextStyle} style -文本对象的对象风格
     *
     * @memberOf Text3D#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setTextStyle: function setTextStyle(style) {
      return Module._Text3D_SetTextStyle(this.handle, style.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建三维模型几何对象
   * @name Model3D
   * @class Model3D
   * 三维模型操作函数
   * @param {Object} options -
   * @param {PIE.ModelMesh} options.modelMesh -模型格网
   *
   * @extends Geometry3D
   */
  function PIEModel3D(options) {
    var handle = null;
    var autoRelease = false;
    if (options) {
      var modelMesh = options.modelMesh;
      if (modelMesh) {
        handle = Module._Model3D_Create(modelMesh.getHandle());
        autoRelease = true;
      }
      if (options.handle) {
        handle = options.handle;
      }
    }
    PIEGeometry3D.call(this, handle, autoRelease);
  }
  PIEModel3D.prototype = Object.assign(Object.create(PIEGeometry3D.prototype), {
    // /**
    //  * 设置模型ID
    //  * @param {Number} id -设置的模型ID
    //  * @memberOf Model3D#
    //  *
    //  */
    setModelId: function setModelId(id) {
      Module._Model3D_SetModelId(this.handle, id);
    },
    // /**
    //  * 获取模型ID
    //  *
    //  * @memberOf Model3D#
    //  * @returns {Number} 获取的模型ID
    //  */
    getModelId: function getModelId() {
      return Module._Model3D_GetModelId(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  function PIEGeometryFactory() {}
  Object.assign(PIEGeometryFactory.prototype, {});
  PIEGeometryFactory.CreateInstance = function (hGeometry) {
    var geometryType = Module._Geometry_GetType(hGeometry);
    if (geometryType == PIEGeometryType$1.Point) {
      return new PIEPoint({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Point3D) {
      return new PIEPoint3D({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Line) {
      return new PIEPolyline({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Line3D) {
      return new PIEPolyline3D({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Region) {
      return new PIEPolygon({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.MultiRegion) {
      return new PIEMultiPolygon({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Region3D) {
      return new PIEPolygon3D({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Text) {
      return new PIEText({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Text3D) {
      return new PIEText3D({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.GeoPlot || geometryType == PIEGeometryType$1.GeoPlotSurface || geometryType == PIEGeometryType$1.GeoPlot3D) {
      return new PIEGeoPlot({
        handle: hGeometry
      });
    } else if (geometryType == PIEGeometryType$1.Model3D) {
      return new PIEModel3D({
        handle: hGeometry
      });
    }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 动画基础操作函数
   * @name Action
   */
  function PIEAction(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
    this.actionDoneEvent = null;
  }
  Object.assign(PIEAction.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     *  删除action对象
     *  @memberOf Action#
     */
    dispose: function dispose() {
      Module._Action_Delete(this.handle);
    },
    /**
     * 获取动画执行完毕的回调事件
     * @memberOf Action#
     * @returns {PIEEvent} 返回动画执行完毕的回调事件
     */
    getActionDoneEvent: function getActionDoneEvent() {
      if (this.actionDoneEvent == null) {
        this.actionDoneEvent = new PIEEvent();
        Module['setActionDoneCallBack'](this.handle, this);
      }
      return this.actionDoneEvent;
    },
    actionDoneCallback: function actionDoneCallback(tag) {
      this.actionDoneEvent.raiseEvent(tag);
    },
    /**
     *  设置是否自动释放Action
     *  @param {Boolean} autoRelease -是否自动释放
     *  @memberOf Action#
     *
     */
    setAutoRelease: function setAutoRelease(autoRelease) {
      Module._Action_SetAutoRelease(this.handle, autoRelease);
    },
    /**
     *  判断是否自动释放Action
     *
     *  @memberOf Action#
     *  @returns {Boolean} 自动释放返回true,否则返回false
     */
    isAutoRelease: function isAutoRelease() {
      return Boolean(Module._Action_IsAutoRelease(this.handle));
    },
    /**
     *  设置添加动画标签
     * @param {String} tag -动画标签
     * @memberOf Action#
     *
     */
    setTag: function setTag(tag) {
      var strTag = new PIEString$1(tag);
      Module._Action_SetTag(this.handle, strTag.getHandle());
      strTag.dispose();
    },
    /**
     * 获取动画标签
     *
     * @memberOf Action#
     * @returns {String}  返回动画标签
     */
    getTag: function getTag() {
      var strTag = new PIEString$1(256);
      Module._Action_GetTag(this.handle, strTag.getHandle());
      var tag = strTag.toString();
      strTag.dispose();
      return tag;
    },
    /**
     * 暂停动画
     * @memberOf Action#
     *
     */
    pause: function pause() {
      Module._IntervalAction_Pause(this.handle);
    },
    /**
     * 播放动画
     * @memberOf Action#
     *
     */
    play: function play() {
      Module._IntervalAction_Play(this.handle);
    },
    /**
     * 跳转到某个时刻
     * @param {Number} t -跳转时间
     * @memberOf Action#
     *
     */
    seek: function seek(t) {
      Module._IntervalAction_Seek(this.handle, t);
    },
    /**
     * 停止动画
     * @memberOf Action#
     *
     */
    stop: function stop() {
      Module._IntervalAction_Stop(this.handle);
    },
    /**
     *  设置动画持续时间
     * @param {Number} duration -持续时间
     * @memberOf Action#
     *
     */
    setDuration: function setDuration(duration) {
      Module._FiniteTimeAction_SetDuration(this.handle, duration);
    },
    /**
     * 获取动画持续时间
     * @memberOf Action#
     * @returns {Number}  返回动画持续时间
     */
    getDuration: function getDuration() {
      return Module._FiniteTimeAction_GetDuration(this.handle);
    }
  });

  Object.assign(Object.create(PIEAction.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   * 渲染对象移动动画操作函数
   * @name MoveableAction
   * @extends Action
   */
  function PIEMoveableAction(handle, autoRelease) {
    PIEAction.call(this, handle, autoRelease);
  }
  PIEMoveableAction.prototype = Object.assign(Object.create(PIEAction.prototype), {});

  Object.assign(Object.create(PIEMoveableAction.prototype), {});

  Object.assign(Object.create(PIEMoveableAction.prototype), {});

  Object.assign(Object.create(PIEAction.prototype), {
    getHandle: function getHandle() {
      return this.handle;
    }
  });

  Object.assign(Object.create(PIEAction.prototype), {});

  Object.assign(Object.create(PIEAction.prototype), {
    getHandle: function getHandle() {
      return this.handle;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *  标绘动画类型枚举
   * @readonly
   * @enum {String}
   */
  var PIEPlotActionType = {
    /** GeoJson数据源  */
    NULL: 0,
    /** 渐变 */
    Gradually: 1,
    /** 生长动画  */
    Grow: 2,
    /** 移动动画  */
    Move: 3,
    /** 旋转动画  */
    Rotate: 4,
    /** 比例动画  */
    Scale: 5,
    /** 擦动动画  */
    Wipe: 6,
    /** 退缩动画  */
    Shrink: 7,
    /** 路径移动动画  */
    MoveByPath: 8
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 标绘动画基础操作函数
   * @name PlotAction
   * @extends Action
   */
  function PIEPlotAction(handle, autoRelease) {
    PIEAction.call(this, handle, autoRelease);
  }
  PIEPlotAction.prototype = Object.assign(Object.create(PIEAction.prototype), {
    /**
     *  获取动画类型
     *  @memberOf PlotAction#
     *  @returns {PIEPlotActionType} 返回标绘动画类型
     */
    getType: function getType() {
      return Module._PlotAction_GetType(this.handle);
    },
    /**
     *  获取开始时间
     *  @memberOf PlotAction#
     *  @returns {Number} 返回开始时间
     */
    getBeginTime: function getBeginTime() {
      return Module._PlotAction_GetBeginTime(this.handle);
    },
    /**
     *  设置开始时间
     *  @param {Number} options.beginTime -开始时间
     *  @memberOf PlotAction#
     */
    setBeginTime: function setBeginTime(beginTime) {
      Module._PlotAction_SetBeginTime(this.handle, beginTime);
    },
    /**
     *  获取动画ID
     *  @memberOf PlotAction#
     *  @returns {Number} 返回动画ID
     */
    getActionID: function getActionID() {
      return Module._PlotAction_GetActionID(this.handle);
    },
    /**
     *  获取标绘ID
     *  @memberOf PlotAction#
     *  @returns {Number} 返回标绘ID
     */
    getPlotID: function getPlotID() {
      return Module._PlotAction_GetPlotID(this.handle);
    },
    /**
     *  设置标绘ID
     *  @param {Number} options.plotID -标绘ID
     *  @memberOf PlotAction#
     */
    setPlotID: function setPlotID(plotID) {
      Module._PlotAction_SetPlotID(this.handle, plotID);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘渐变动画对象
   * @name PlotGraduallyAction
   * @class PlotGraduallyAction
   *
   * @param {Object} options -
   * @param {Number} options.duration -相机运行时间
   * @param {PIEGraduallyActionType} options.type -渐变类型
   *
   * @extends PlotAction
   */
  function PIEPlotGraduallyAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration;
      var type = options.type;
      if (duration != null && type != null) {
        if (type > 2 || type < 0) {
          handle = null;
        } else {
          handle = Module._PlotGraduallyAction_Create(duration, type);
          autoRelease = true;
        }
      }
      if (options.handle) {
        handle = options.handle;
        autoRelease = false;
      }
      if (options.autoRelease != null) {
        autoRelease = options.autoRelease;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotGraduallyAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {
    /**
     *  获取渐变类型
     *  @memberOf PlotGraduallyAction#
     *  @returns {PIEGraduallyActionType} 返回渐变类型
     */
    getGraduallyType: function getGraduallyType() {
      return Module._PlotGraduallyAction_GetGraduallyType(this.handle);
    },
    /**
     *  获取闪烁速度
     *  @memberOf PlotGraduallyAction#
     *  @returns {Number} 返回闪烁速度
     */
    getBlinkSpeed: function getBlinkSpeed() {
      return Module._PlotGraduallyActionEx_GetBlinkSpeed(this.handle);
    },
    /**
     *  设置闪烁速度
     *  @param {Number} blinkSpeed -闪烁速度
     *  @memberOf PlotGraduallyAction#
     */
    setBlinkSpeed: function setBlinkSpeed(blinkSpeed) {
      return Module._PlotGraduallyActionEx_SetBlinkSpeed(this.handle, blinkSpeed);
    }
  });

  Object.assign(Object.create(PIEPlotGraduallyAction.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘生长动画对象
   * @name PlotGrowAction
   * @class PlotGrowAction
   *
   * @param {Object} options -
   * @param {Number} options.duration - 相机运行时间
   *
   * @extends PlotAction
   */
  function PIEPlotGrowAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration; //生长时间
      if (duration != null && duration > 0) {
        handle = Module._PlotGrowAction_Create(duration);
        autoRelease = true;
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotGrowAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {});

  Object.assign(Object.create(PIEPlotAction.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘移动动画对象
   * @name PlotMoveAction
   * @class PlotMoveAction
   *
   * @param {Object} options -
   * @param {Number} options.duration -相机运行时间
   * @param {(Array/PIEVector3)} options.position -目标位置
   *
   * @extends PlotAction
   */
  function PIEPlotMoveAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration; //生长时间
      var points = options.position;
      if (duration != null && points != null) {
        var pointsArray = null;
        if (points instanceof Array) {
          pointsArray = points;
        } else if (points instanceof PIEVector3) {
          pointsArray = points.toArray();
        }
        if (pointsArray) {
          var arrayPoints = new PIEArray(pointsArray, PIEArrayType.Float64);
          handle = Module._PlotTranslateAction_Create(duration, arrayPoints.getHandle());
          arrayPoints.dispose();
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotMoveAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘旋转动画对象
   * @name PlotRotateAction
   * @class PlotRotateAction
   *
   * @param {Object} options -
   * @param {Number} options.duration -相机运行时间
   * @param {(Array/PIEVector3)} options.rotate -旋转角度
   *
   * @extends PlotAction
   */
  function PIEPlotRotateAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration; //生长时间
      var rotate = options.rotate;
      if (duration != null && rotate != null) {
        var rotateArray = null;
        if (rotate instanceof Array) {
          rotateArray = rotate;
        } else if (rotate instanceof PIEVector3) {
          rotateArray = rotate.toArray();
        }
        if (rotateArray) {
          var arrayRotate = new PIEArray(rotateArray, PIEArrayType.Float64);
          handle = Module._PlotRotateAction_Create(duration, arrayRotate.getHandle());
          arrayRotate.dispose();
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotRotateAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘比例动画对象
   * @name PlotScaleAction
   * @class PlotScaleAction
   *
   * @param {Object} options -
   * @param {Number} options.duration -相机运行时间
   * @param {(Array/PIEVector3)} options.scale -比例
   *
   * @extends PlotAction
   */
  function PIEPlotScaleAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration; //生长时间
      var scale = options.scale;
      if (duration != null && scale != null) {
        var scaleArray = null;
        if (scale instanceof Array) {
          scaleArray = scale;
        } else if (scale instanceof PIEVector3) {
          scaleArray = scale.toArray();
        }
        if (scaleArray) {
          var arrayScale = new PIEArray(scaleArray, PIEArrayType.Float64);
          handle = Module._PlotScaleAction_Create(duration, arrayScale.getHandle());
          arrayScale.dispose();
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotScaleAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {
    /**
     *  获取缩放比例
     *  @memberOf PlotScaleAction#
     *  @returns {PIEVector3} 返回缩放比例
     */
    getScale: function getScale() {
      var scaleArr = new PIEArray(3, PIEArrayType.Float64);
      Module._PlotScaleAction_GetScale(this.handle, scaleArr.getHandle());
      scaleArr.updateData();
      var scale = scaleArr.toArray();
      scaleArr.dispose();
      return new PIEVector3(scale[0], scale[1], scale[2]);
    },
    /**
     *  设置缩放比例
     *  @param {PIEVector3|Array} scale -缩放比例
     *  @memberOf PlotScaleAction#
     */
    setScale: function setScale(scale) {
      var scaleArray = null;
      if (scale == null) {
        return;
      }
      if (scale instanceof PIEVector3) {
        scaleArray = scale.toArray();
      } else if (scale instanceof Array) {
        scaleArray = scale;
      }
      if (scaleArray) {
        var scaleArr = new PIEArray(scaleArray, PIEArrayType.Float64);
        Module._PlotScaleAction_SetScale(this.handle, scaleArr.getHandle());
        scaleArr.dispose();
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘擦动动画对象
   * @name PlotWipeAction
   * @class PlotWipeAction
   *
   * @param {Object} options -
   * @param {Number} options.duration -相机运行时间
   * @param {PIEWipeActionType} options.type -擦动类型
   *
   * @extends PlotAction
   */
  function PIEPlotWipeAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration;
      var type = options.type;
      if (duration != null && type != null) {
        handle = Module._PlotWipeAction_Create(duration, type);
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotWipeAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {
    /**
     *  获取擦动类型
     *  @memberOf PlotWipeAction#
     *  @returns {PIEWipeActionType} 返回擦动类型
     */
    getGraduallyType: function getGraduallyType() {
      return Module._PlotWipeAction_GetWipeType(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘退缩动画对象
   * @name PlotShrinkAction
   * @class PlotShrinkAction
   *
   * @param {Object} options -
   * @param {Number} options.duration -相机运行时间
   * @param {Number} options.scale -退缩比例（默认为0）
   *
   * @extends PlotAction
   */
  function PIEPlotShrinkAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration;
      var scale = options.scale;
      if (duration != null) {
        if (scale == null || scale < 0) {
          scale = 0;
        }
        handle = Module._PlotShrinkAction_Create(duration, scale);
        autoRelease = true;
      }
      if (options.handle) {
        handle = options.handle;
        autoRelease = false;
      }
      if (options.autoRelease != null) {
        autoRelease = options.autoRelease;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotShrinkAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {
    /**
     *  获取退缩比例
     *  @memberOf PlotShrinkAction#
     *  @returns {Number} 返回退缩比例
     */
    getScale: function getScale() {
      return Module._PlotShrinkAction_GetScale(this.handle);
    },
    /**
     *  设置退缩比例
     *  @memberOf PlotShrinkAction#
     *  @returns {Number} 退缩比例
     */
    setScale: function setScale(scale) {
      return Module._PlotShrinkAction_SetScale(this.handle, scale);
    }
  });

  Object.assign(Object.create(PIEPlotShrinkAction.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 动画模块
   * ---
   */

  /**
   *
   * 创建标绘路径移动动画对象
   * @name PlotMoveByPathAction
   * @class PlotMoveByPathAction
   *
   * @param {Object} options -
   * @param {Number} options.duration -相机运行时间
   * @param {Array} options.positions -路径数组(可以使用Number数组或者PIEVector3数组)
   * @extends PlotAction
   */
  function PIEPlotMoveByPathAction(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var duration = options.duration;
      var positions = options.positions;
      if (duration != null && positions != null) {
        if (positions instanceof Array) {
          var posArray = [];
          var length = 0;
          if (positions[0] instanceof PIEVector3) {
            positions.forEach(function (item) {
              if (item instanceof PIEVector3) {
                length++;
                posArray = posArray.concat(item.toArray());
              }
            });
          } else if (typeof positions[0] == "number") {
            posArray = positions;
            length = posArray.length / 3;
          }
          if (posArray.length > 0 && length >= 1) {
            var arrPos = new PIEArray(posArray, PIE.ArrayType.Float64);
            handle = Module._PlotMoveByPathAction_Create(duration, arrPos.getHandle(), length);
            autoRelease = true;
          }
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIEPlotAction.call(this, handle, autoRelease);
  }
  PIEPlotMoveByPathAction.prototype = Object.assign(Object.create(PIEPlotAction.prototype), {
    /**
     *  设置路径数组
     *  @param {Array} positions -路径数组(可以使用Number数组或者PIEVector3数组)
     *  @memberOf PlotMoveByPathAction#
     */
    setPathPoints: function setPathPoints(positions) {
      if (positions == null) {
        return;
      }
      if (positions instanceof Array) {
        if (positions.length < 3) {
          return;
        }
        var posArray = [];
        var length = 0;
        if (positions[0] instanceof PIEVector3) {
          positions.forEach(function (item) {
            if (item instanceof PIEVector3) {
              length++;
              posArray = posArray.concat(item.toArray());
            }
          });
        } else if (typeof positions[0] == "number") {
          posArray = positions;
          length = posArray.length / 3;
        }
        if (posArray.length > 0 && length >= 1) {
          var arrPos = new PIEArray(posArray, PIE.ArrayType.Float64);
          Module._PlotMoveByPathAction_SetPathPoints(this.handle, arrPos.getHandle(), length);
          arrPos.dispose();
        }
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建像素范围对象
   * @name Rect
   * @class Rect
   * 像素范围类相关函数
   *
   * @param {Number} left -左值
   * @param {Number} top -上值
   * @param {Number} right -右值
   * @param {Number} bottom -下值
   */
  function PIERect(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  Object.assign(PIERect.prototype, {
    /**
     * 获取宽度
     * @memberOf Rect#
     * @returns {Number} -返回宽度
     */
    getWidth: function getWidth() {
      return this.right - this.left;
    },
    /**
     * 获取高度
     * @memberOf Rect#
     * @returns {Number} -返回高度
     */
    getHeight: function getHeight() {
      return this.bottom - this.top;
    },
    /**
     * 矩形合并
     * @param {Number} x
     * @param {Number} y
     * @memberOf Rect#
     *
     */
    union: function union(x, y) {
      this.left = Math.min(this.left, x);
      this.top = Math.min(this.top, y);
      this.right = Math.max(this.right, x);
      this.bottom = Math.max(this.bottom, y);
    },
    /**
     * 矩形膨胀
     * @param {Number} leftmargin -左值的膨胀尺寸
     * @param {Number} topmargin -上值的膨胀尺寸
     * @param {Number} rightmargin -右值的膨胀尺寸
     * @param {Number} bottommargin -下值的膨胀尺寸
     * @memberOf Rect#
     *
     */
    inflate: function inflate(leftmargin, topmargin, rightmargin, bottommargin) {
      this.left -= leftmargin;
      this.top -= topmargin;
      this.right += rightmargin;
      this.bottom += bottommargin;
    },
    /**
     * 矩形收缩
     * @param {Number} leftmargin -左值的收缩尺寸
     * @param {Number} topmargin -上值的收缩尺寸
     * @param {Number} rightmargin -右值的收缩尺寸
     * @param {Number} bottommargin -下值的收缩尺寸
     * @memberOf Rect#
     *
     */
    deflate: function deflate(leftmargin, topmargin, rightmargin, bottommargin) {
      this.inflate(-leftmargin, -topmargin, -rightmargin, -bottommargin);
    },
    toArray: function toArray() {
      return [this.left, this.top, this.right, this.bottom];
    }
  });
  PIERect.fromArray = function (array) {
    var arrayBuffer = array.toArrayBuffer();
    return new PIERect(arrayBuffer[0], arrayBuffer[1], arrayBuffer[2], arrayBuffer[3]);
  };
  PIERect.toArray = function (rect) {
    return new PIEArray([rect.left, rect.top, rect.right, rect.bottom], PIEArrayType.Int32);
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 创建三维矩阵
   * @name Matrix3
   * @class Matrix3
   * 三维矩阵操作函数
   */
  function PIEMatrix3() {
    this.m = new Float32Array(9);
    {
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 1;
      this.m[5] = 0;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 1;
    }
  }
  Object.assign(PIEMatrix3.prototype, {
    /**
     * 创建矩阵
     * @param {Number} m0
     * @param {Number} m1
     * @param {Number} m2
     * @param {Number} m3
     * @param {Number} m4
     * @param {Number} m5
     * @param {Number} m6
     * @param {Number} m7
     * @param {Number} m8
     * @returns {PIEMatrix3} 返回创建的矩阵
     * @memberOf Matrix3#
     */
    create: function create(m0, m1, m2, m3, m4, m5, m6, m7, m8) {
      this.m[0] = m0;
      this.m[1] = m1;
      this.m[2] = m2;
      this.m[3] = m3;
      this.m[4] = m4;
      this.m[5] = m5;
      this.m[6] = m6;
      this.m[7] = m7;
      this.m[8] = m8;
      return this;
    },
    /**
     * 构造3*3单位矩阵
     *@returns {PIEMatrix3} 返回单位矩阵
     * @memberOf Matrix3#
     */
    identity: function identity() {
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 1;
      this.m[5] = 0;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 1;
      return this;
    },
    /**
     * 初始化3*3的单位矩阵
     * @returns {PIEMatrix3} 返回初始化的矩阵
     * @memberOf Matrix3#
     */
    zero: function zero() {
      this.m[0] = 0;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 0;
      this.m[5] = 0;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 0;
      return this;
    },
    /**
     * 平移矩阵
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @returns {PIEMatrix3} 返回平移后的矩阵
     * @memberOf Matrix3#
     */
    translation: function translation(x, y, z) {
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = 1;
      this.m[5] = 0;
      this.m[6] = x;
      this.m[7] = y;
      this.m[8] = 1;
      return this;
    },
    /**
     * 缩放矩阵
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @returns {PIEMatrix3} 返回缩放后的矩阵
     * @memberOf Matrix3#
     */
    scaling: function scaling(x, y, z) {
      this.m[0] = x;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = y;
      this.m[5] = 0;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = z;
      return this;
    },
    /**
     * 以X轴旋转
     * @param {Number} radian -顺时针旋转角度
     * @returns {PIEMatrix3} 返回旋转后的矩阵
     * @memberOf Matrix3#
     */
    rotationX: function rotationX(radian) {
      var s = Math.sin(radian);
      var c = Math.cos(radian);
      this.m[0] = 1;
      this.m[1] = 0;
      this.m[2] = 0;
      this.m[3] = 0;
      this.m[4] = c;
      this.m[5] = s;
      this.m[6] = 0;
      this.m[7] = -s;
      this.m[8] = c;
      return this;
    },
    /**
     * 以Y轴旋转
     * @param {Number} radian -顺时针旋转角度
     * @returns {PIEMatrix3} 返回旋转后的矩阵
     * @memberOf Matrix3#
     */
    rotationY: function rotationY(radian) {
      var s = Math.sin(radian);
      var c = Math.cos(radian);
      this.m[0] = c;
      this.m[1] = 0;
      this.m[2] = -s;
      this.m[3] = 0;
      this.m[4] = 1;
      this.m[5] = 0;
      this.m[6] = s;
      this.m[7] = 0;
      this.m[8] = c;
      return this;
    },
    /**
     * 以Z轴旋转
     * @param {Number} radian -顺时针旋转角度
     * @returns {PIEMatrix3} 返回旋转后的矩阵
     * @memberOf Matrix3#
     */
    rotationZ: function rotationZ(radian) {
      var s = Math.sin(radian);
      var c = Math.cos(radian);
      this.m[0] = c;
      this.m[1] = s;
      this.m[2] = 0;
      this.m[3] = -s;
      this.m[4] = c;
      this.m[5] = 0;
      this.m[6] = 0;
      this.m[7] = 0;
      this.m[8] = 1;
      return this;
    },
    // /**
    //  * 把矩阵分解成位置、缩放和四元数
    //  * @param {PIEMatrix3} kQ
    //  * @param {PIEVector3} kD
    //  * @param {PIEVector3} kU
    //  *
    //  * @memberOf Matrix3#
    //  */
    // decomposition: function (kQ, kD, kU) {
    //     var kM = this;
    //
    //     var fInvLength = this.invertSqrt(kM.m[0] * kM.m[0] + kM.m[3] * kM.m[3] + kM.m[6] * kM.m[6]);
    //     kQ.m[0] = kM.m[0] * fInvLength;
    //     kQ.m[3] = kM.m[3] * fInvLength;
    //     kQ.m[6] = kM.m[6] * fInvLength;
    //
    //     var fDot = kQ.m[0] * kM.m[1] + kQ.m[3] * kM.m[4] + kQ.m[6] * kM.m[7];
    //     kQ.m[1] = kM.m[1] - fDot * kQ.m[0];
    //     kQ.m[4] = kM.m[4] - fDot * kQ.m[3];
    //     kQ.m[7] = kM.m[7] - fDot * kQ.m[6];
    //     fInvLength = this.invertSqrt(kQ.m[1] * kQ.m[1] + kQ.m[4] * kQ.m[4] + kQ.m[7] * kQ.m[7]);
    //     kQ.m[1] *= fInvLength;
    //     kQ.m[4] *= fInvLength;
    //     kQ.m[7] *= fInvLength;
    //
    //     fDot = kQ.m[0] * kM.m[2] + kQ.m[3] * kM.m[5] + kQ.m[6] * kM.m[8];
    //     kQ.m[2] = kM.m[2] - fDot * kQ.m[0];
    //     kQ.m[5] = kM.m[5] - fDot * kQ.m[3];
    //     kQ.m[8] = kM.m[8] - fDot * kQ.m[6];
    //     fDot = kQ.m[1] * kM.m[2] + kQ.m[4] * kM.m[5] + kQ.m[7] * kM.m[8];
    //     kQ.m[2] -= fDot * kQ.m[1];
    //     kQ.m[5] -= fDot * kQ.m[4];
    //     kQ.m[8] -= fDot * kQ.m[7];
    //     fInvLength = this.invertSqrt(kQ.m[2] * kQ.m[2] + kQ.m[5] * kQ.m[5] + kQ.m[8] * kQ.m[8]);
    //     kQ.m[2] *= fInvLength;
    //     kQ.m[5] *= fInvLength;
    //     kQ.m[8] *= fInvLength;
    //
    //     // guarantee that orthogonal matrix has determinant 1 (no reflections)
    //     var fDet = kQ.m[0] * kQ.m[4] * kQ.m[8] + kQ.m[1] * kQ.m[5] * kQ.m[6] +
    //         kQ.m[2] * kQ.m[3] * kQ.m[7] - kQ.m[2] * kQ.m[4] * kQ.m[6] -
    //         kQ.m[1] * kQ.m[3] * kQ.m[8] - kQ.m[0] * kQ.m[5] * kQ.m[7];
    //
    //     if (fDet < 0.0) {
    //         for (var iRow = 0; iRow < 3; iRow++) {
    //             for (var iCol = 0; iCol < 3; iCol++) {
    //                 kQ.m[3 * iRow + iCol] = -kQ.m[3 * iRow + iCol];
    //             }
    //         }
    //     }
    //
    //     // build "right" matrix R
    //     var kR = new PIEMatrix3();
    //     kR.m[0] = kQ.m[0] * kM.m[0] + kQ.m[3] * kM.m[3] + kQ.m[6] * kM.m[6];
    //     kR.m[1] = kQ.m[0] * kM.m[1] + kQ.m[3] * kM.m[4] + kQ.m[6] * kM.m[7];
    //     kR.m[4] = kQ.m[1] * kM.m[1] + kQ.m[4] * kM.m[4] + kQ.m[7] * kM.m[7];
    //     kR.m[2] = kQ.m[0] * kM.m[2] + kQ.m[3] * kM.m[5] + kQ.m[6] * kM.m[8];
    //     kR.m[5] = kQ.m[1] * kM.m[2] + kQ.m[4] * kM.m[5] + kQ.m[7] * kM.m[8];
    //     kR.m[8] = kQ.m[2] * kM.m[2] + kQ.m[5] * kM.m[5] + kQ.m[8] * kM.m[8];
    //
    //     // the scaling component
    //     kD.x = kR.m[0];
    //     kD.y = kR.m[4];
    //     kD.z = kR.m[8];
    //
    //     // the shear component
    //     var fInvD0 = 1.0 / kD.x;
    //     kU.x = kR.m[1] * fInvD0;
    //     kU.y = kR.m[2] * fInvD0;
    //     kU.z = kR.m[5] / kD.y;
    // },
    /**
     * 计算机矩阵转置矩阵
     * @returns {PIEMatrix3} 返回转置矩阵
     * @memberOf Matrix3#
     */
    transpose: function transpose() {
      var tmp;
      var m = this.m;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
  });

  /**
   * 向量和矩阵相乘
   * @param {PIEVector3} v -向量
   * @param {PIEMatrix3} matrix -矩阵
   * @returns {PIEVector3} 返回相乘后的结果
   * @memberOf Matrix3
   */
  PIEMatrix3.prototype.multiplyMV = function (v, matrix) {
    var m11 = 0,
      m12 = 0,
      m13 = 0;
    m11 = v.x * matrix.m[0] + v.y * matrix.m[3] + v.z * matrix.m[6];
    m12 = v.x * matrix.m[1] + v.y * matrix.m[4] + v.z * matrix.m[7];
    m13 = v.x * matrix.m[2] + v.y * matrix.m[5] + v.z * matrix.m[8];
    return new PIEVector3(m11, m12, m13);
  };

  function PIEProductVersion(handle, autoRelease) {
    if (handle == null) {
      this.handle = Module._ProductVersion_Create();
      this.autoRelease = true;
    }
  }
  Object.assign(PIEProductVersion.prototype, {
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._ProductVersion_Delete(this.handle);
      }
      this.handle = null;
    },
    getProductInfo: function getProductInfo() {
      var strProductInfo = new PIEString$1(256);
      Module._ProductVersion_GetProductInfo(this.handle, strProductInfo.getHandle());
      var info = strProductInfo.toString();
      strProductInfo.dispose();
      return info;
    },
    getProductName: function getProductName() {
      var ProductName = new PIEString$1(256);
      Module._ProductVersion_GetProductName(this.handle, ProductName.getHandle());
      var Name = ProductName.toString();
      ProductName.dispose();
      return Name;
    },
    getCompanyName: function getCompanyName() {
      var CompanyName = new PIEString$1(256);
      Module._ProductVersion_GetCompanyName(this.handle, CompanyName.getHandle());
      var Name = CompanyName.toString();
      CompanyName.dispose();
      return Name;
    },
    getProductVersion: function getProductVersion() {
      var ProductVersion = new PIEString$1(256);
      Module._ProductVersion_GetProductVersion(this.handle, ProductVersion.getHandle());
      var Version = ProductVersion.toString();
      ProductVersion.dispose();
      return Version;
    },
    getReleaseData: function getReleaseData() {
      var ReleaseData = new PIEString$1(256);
      Module._ProductVersion_GetReleaseData(this.handle, ReleaseData.getHandle());
      var Data = ReleaseData.toString();
      ReleaseData.dispose();
      return Data;
    },
    getSvnVersion: function getSvnVersion() {
      var SvnVersion = new PIEString$1(256);
      Module._PIE_ProductVersion_GetSvnVersion(this.handle, SvnVersion.getHandle());
      var Version = SvnVersion.toString();
      SvnVersion.dispose();
      return Version;
    },
    getDescribeInfo: function getDescribeInfo() {
      var DescribeInfo = new PIEString$1(256);
      Module._ProductVersion_GetDescribeInfo(this.handle, DescribeInfo.getHandle());
      var beInfo = DescribeInfo.toString();
      DescribeInfo.dispose();
      return beInfo;
    },
    getHistoryVersion: function getHistoryVersion() {
      var HistoryVersion = new PIEString$1(256);
      Module._ProductVersion_GetHistoryVersion(this.handle, HistoryVersion.getHandle());
      var Version = HistoryVersion.toString();
      HistoryVersion.dispose();
      return Version;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 新建颜色表对象
   * @name ColorRange
   * @class ColorRange
   * 颜色表操作函数
   *
   * @example
   * let colorRange = new PIE.ColorRange()
   */
  function PIEColorRange(handle, autoRelease) {
    if (handle == null) {
      this.handle = Module._ColorRange_Create();
      this.autoRelease = true;
    }
  }
  Object.assign(PIEColorRange.prototype, {
    /**
     * 设置颜色集中的最大值
     * @param {Number} value -颜色值
     * @memberOf ColorRange#
     *
     */
    setCeiling: function setCeiling(value) {
      Module._ColorRange_SetCeiling(this.handle, value);
    },
    /**
     * 设置颜色集中的最小值
     * @param {Number} value -颜色值
     * @memberOf ColorRange#
     */
    setFloor: function setFloor(value) {
      Module._ColorRange_SetFloor(this.handle, value);
    },
    /**
     * 添加颜色
     * @param {(PIEColor/Array)} color -添加新的颜色
     * @memberOf ColorRange#
     */
    addColor: function addColor(color) {
      var arrayColor = [];
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        Module._ColorRange_AddColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) ;
      this.handle = null;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 通道操作函数
   * @name Pass
   *
   */
  function PIEPass(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEPass.prototype, {
    /**
     * 设置通道对象名称
     * @param {String} name -通道名称
     * @memberOf Pass#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._Pass_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取通道对象名称
     *
     * @memberOf Pass#
     * @returns {String} 返回通道名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Pass_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置通道对象Program类型
     * @param {String} program -Program类型
     * @memberOf Pass#
     */
    setProgram: function setProgram(program) {
      var strProgram = new PIEString$1(program);
      Module._Pass_SetProgram(this.handle, strProgram.getHandle());
      strProgram.dispose();
    },
    /**
     * 设置是否启用AutoProgram
     * @param {Boolean} enabled -是否已启用AutoProgram
     * @memberOf Pass#
     */
    setAutoProgramEnabled: function setAutoProgramEnabled(enabled) {
      Module._Pass_SetAutoProgramEnabled(this.handle, enabled);
    },
    /**
     * 判断是否启用AutoProgram
     * @memberOf Pass#
     * @returns {Boolean} 是否已启用AutoProgram
     */
    isAutoProgramEnabled: function isAutoProgramEnabled() {
      return Boolean(Module._Pass_IsAutoProgramEnabled(this.handle));
    },
    /**
     * 设置漫射光
     * @param {PIEVector4} diffuse -漫射光
     * @memberOf Pass#
     */
    setDiffuse: function setDiffuse(diffuse) {
      var arrayDiffuse = new PIEArray(diffuse, PIEArrayType.Float32);
      Module._Pass_SetDiffuse(this.handle, arrayDiffuse.getHandle());
      arrayDiffuse.dispose();
    },
    /**
     * 获取漫射光
     * @memberOf Pass#
     * @returns {PIEVector4} 返回漫射光
     */
    getDiffuse: function getDiffuse() {
      var arrayDiffuse = new PIEArray(4, PIEArrayType.Float32);
      Module._Pass_GetDiffuse(this.handle, arrayDiffuse.getHandle());
      var diffuse = arrayDiffuse.toArray();
      arrayDiffuse.dispose();
      return diffuse;
    },
    /**
     * 设置环境光
     * @param {PIEVector4} ambient -环境光
     * @memberOf Pass#
     */
    setAmbient: function setAmbient(ambient) {
      var arrayAmbient = new PIEArray(ambient, PIEArrayType.Float32);
      Module._Pass_SetAmbient(this.handle, arrayAmbient.getHandle());
      arrayAmbient.dispose();
    },
    /**
     * 获取环境光
     *
     * @memberOf Pass#
     * @returns {PIEVector4} 返回环境光
     */
    getAmbient: function getAmbient() {
      var arrayAmbient = new PIEArray(4, PIEArrayType.Float32);
      Module._Pass_GetAmbient(this.handle, arrayAmbient.getHandle());
      var ambient = arrayAmbient.toArray();
      arrayAmbient.dispose();
      return ambient;
    },
    /**
     * 设置反射光
     * @param {PIEVector4} specular -反射光
     * @memberOf Pass#
     */
    setSpecular: function setSpecular(specular) {
      var arraySpeclar = new PIEArray(specular, PIEArrayType.Float32);
      Module._Pass_SetSpecular(this.handle, arraySpeclar.getHandle());
      arraySpeclar.dispose();
    },
    /**
     * 获取反射光
     *
     * @memberOf Pass#
     * @returns {PIEVector4} 返回反射光
     */
    getSpecular: function getSpecular() {
      var arraySpeclar = new PIEArray(4, PIEArrayType.Float32);
      Module._Pass_GetSpecular(this.handle, arraySpeclar.getHandle());
      var speclar = arraySpeclar.toArray();
      arraySpeclar.dispose();
      return speclar;
    },
    /**
     * 设置发射因子
     * @param {PIEVector4} emmissive -发射因子
     * @memberOf Pass#
     */
    setEmmissive: function setEmmissive(emmissive) {
      var arrayEmmissive = new PIEArray(emmissive, PIEArrayType.Float32);
      Module._Pass_SetEmmissive(this.handle, arrayEmmissive.getHandle());
      arrayEmmissive.dispose();
    },
    /**
     * 获取发射因子
     *
     * @memberOf Pass#
     * @returns {PIEVector4} 返回发射因子
     */
    getEmmissive: function getEmmissive() {
      var arrayEmmissive = new PIEArray(4, PIEArrayType.Float32);
      Module._Pass_GetEmmissive(this.handle, arrayEmmissive.getHandle());
      var emmissive = arrayEmmissive.toArray();
      arrayEmmissive.dispose();
      return emmissive;
    },
    /**
     * 设置光照强度
     * @param {Number} shininess -光照强度
     * @memberOf Pass#
     */
    setShininess: function setShininess(shininess) {
      Module._Pass_SetShininess(this.handle, shininess);
    },
    /**
     * 获取光照强度
     *
     * @memberOf Pass#
     * @returns {Number} 返回光照强度
     */
    getShininess: function getShininess() {
      return Module._Pass_GetShininess(this.handle);
    },
    /**
     * 设置是否启用灯光
     * @param {Boolean} enabled -是否启用灯光
     * @memberOf Pass#
     */
    setLightingEnabled: function setLightingEnabled(enabled) {
      Module._Pass_SetLightingEnabled(this.handle, enabled);
    },
    /**
     * 判断是否启用灯光
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否启用灯光
     */
    isLightingEnabled: function isLightingEnabled() {
      return Boolean(Module._Pass_IsLightingEnabled(this.handle));
    },
    /**
     * 判断是否透明
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否透明
     */
    isTransparent: function isTransparent() {
      return Boolean(Module._Pass_IsTransparent(this.handle));
    },
    /**
     * 设置是否透明排序
     * @param {Boolean} transSort -是否透明排序
     * @memberOf Pass#
     */
    setTransparentSortingEnabled: function setTransparentSortingEnabled(transSort) {
      Module._Pass_SetTransparentSortingEnabled(this.handle, transSort);
    },
    /**
     * 判断是否透明排序
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否透明排序
     */
    isTransparentSortingEnabled: function isTransparentSortingEnabled() {
      return Boolean(Module._Pass_IsTransparentSortingEnabled(this.handle));
    },
    /**
     * 设置是否强制透明排序
     * @param {Boolean} transSortForce -是否强制透明排序
     * @memberOf Pass#
     */
    setTransparentSortingForced: function setTransparentSortingForced(transSortForce) {
      Module._Pass_SetTransparentSortingForced(this.handle, transSortForce);
    },
    /**
     * 判断是否强制透明排序
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否强制透明排序
     */
    isTransparentSortingForced: function isTransparentSortingForced() {
      return Boolean(Module._Pass_IsTransparentSortingForced(this.handle));
    },
    /**
     * 设置是否自动深度
     *
     * @memberOf Pass#
     * @param {Boolean} enabled -是否自动深度
     */
    setAutoDepthEnabled: function setAutoDepthEnabled(enabled) {
      Module._Pass_SetAutoDepthEnabled(this.handle, enabled);
    },
    /**
     * 是否启用自动深度
     *
     * @memberOf Pass#
     * @returns {Boolean} true 启用自动深度
     */
    isAutoDepthEnabled: function isAutoDepthEnabled() {
      return Boolean(Module._Pass_IsAutoDepthEnabled(this.handle));
    },
    /**
     * 设置是否启用深度写功能
     * @param {Boolean} enabled -是否启用深度写功能
     * @memberOf Pass#
     */
    setDepthWriteEnabled: function setDepthWriteEnabled(enabled) {
      Module._Pass_SetDepthWriteEnabled(this.handle, enabled);
    },
    /**
     * 判断是否启用深度写功能
     * @memberOf Pass#
     * @returns {Boolean} 返回是否启用深度写功能
     */
    isDepthWriteEnabled: function isDepthWriteEnabled() {
      return Boolean(Module._Pass_IsDepthWriteEnabled(this.handle));
    },
    /**
     * 设置是否启用深度检验功能
     * @param {Boolean} enabled -是否启用深度检验功能
     * @memberOf Pass#
     */
    setDepthCheckEnabled: function setDepthCheckEnabled(enabled) {
      Module._Pass_SetDepthCheckEnabled(this.handle, enabled);
    },
    /**
     * 判断是否启用深度检验功能
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否启用深度检验功能
     */
    isDepthCheckEnabled: function isDepthCheckEnabled() {
      return Boolean(Module._Pass_IsDepthCheckEnabled(this.handle));
    },
    /**
     * 设置深度偏差
     * @param {Number} biasConstant -深度偏差
     * @memberOf Pass#
     */
    setDepthBiasConstant: function setDepthBiasConstant(biasConstant) {
      Module._Pass_SetDepthBiasConstant(this.handle, biasConstant);
    },
    /**
     * 获取深度偏差
     *
     * @memberOf Pass#
     * @returns {Number} 返回深度偏差
     */
    getDepthBiasConstant: function getDepthBiasConstant() {
      return Module._Pass_GetDepthBiasConstant(this.handle);
    },
    /**
     * 设置深度偏差坡度值
     * @param {Number} biasSlopeScale -深度偏差坡度值
     * @memberOf Pass#
     */
    setDepthBiasSlopeScale: function setDepthBiasSlopeScale(biasSlopeScale) {
      Module._Pass_SetDepthBiasSlopeScale(this.handle, biasSlopeScale);
    },
    /**
     * 获取深度偏差坡度值
     *
     * @memberOf Pass#
     * @returns {Number} 返回深度偏差坡度值
     */
    getDepthBiasSlopeScale: function getDepthBiasSlopeScale() {
      return Module._Pass_GetDepthBiasSlopeScale(this.handle);
    },
    /**
     * 设置是否启用颜色写入
     * @param {Boolean} enabled -是否启用颜色写入
     * @memberOf Pass#
     */
    setColorWriteEnabled: function setColorWriteEnabled(enabled) {
      Module._Pass_SetColorWriteEnabled(this.handle, enabled);
    },
    /**
     * 判断是否启用颜色写入
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否启用颜色写入
     */
    hasColorWriteDisabled: function hasColorWriteDisabled() {
      return Boolean(Module._Pass_HasColorWriteDisabled(this.handle));
    },
    /**
     * 是否有独立的集合
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否有独立的集合
     */
    hasSeparateBlending: function hasSeparateBlending() {
      return Boolean(Module._Pass_HasSeparateBlending(this.handle));
    },
    /**
     * 获取 AlphaReject值
     *
     * @memberOf Pass#
     * @returns {Number} 返回AlphaReject值
     */
    getAlphaRejectValue: function getAlphaRejectValue() {
      return Module._Pass_GetAlphaRejectValue(this.handle);
    },
    /**
     * 设置是否启用线平滑模式
     * @param {Boolean} lineSmoothMode -是否启用线平滑模式
     * @memberOf Pass#
     */
    setLineSmoothMode: function setLineSmoothMode(lineSmoothMode) {
      Module._Pass_SetLineSmoothMode(this.handle, lineSmoothMode);
    },
    /**
     * 判断是否启用线平滑模式
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否启用线平滑模式
     */
    isLineSmoothMode: function isLineSmoothMode() {
      return Boolean(Module._Pass_IsLineSmoothMode(this.handle));
    },
    /**
     * 设置线宽
     * @param {Number} lineWidth -线宽
     * @memberOf Pass#
     */
    setLineWidth: function setLineWidth(lineWidth) {
      Module._Pass_SetLineWidth(this.handle, lineWidth);
    },
    /**
     * 获取线宽
     *
     * @memberOf Pass#
     * @returns {Number} 返回线宽
     */
    getLineWidth: function getLineWidth() {
      return Module._Pass_GetLineWidth(this.handle);
    },
    /**
     * 设置点的大小
     * @param {Number} pointSize -点的大小
     * @memberOf Pass#
     */
    setPointSize: function setPointSize(pointSize) {
      Module._Pass_SetPointSize(this.handle, pointSize);
    },
    /**
     * 获取点的大小
     *
     * @memberOf Pass#
     * @returns {Number} 返回点的大小
     */
    getPointSize: function getPointSize() {
      return Module._Pass_GetPointSize(this.handle);
    },
    /**
     * 设置雾颜色
     * @param {PIEVector4} color -雾颜色
     * @memberOf Pass#
     */
    setFogColor: function setFogColor(color) {
      var arrayColor = new PIEArray(color, PIEArrayType.Float32);
      Module._Pass_SetFogColor(this.handle, arrayColor.getHandle());
      arrayColor.dispose();
    },
    /**
     * 获取雾颜色
     *
     * @memberOf Pass#
     * @returns {PIEVector4} 返回雾颜色
     */
    getFogColor: function getFogColor() {
      var arrayColor = new PIEArray(4, PIEArrayType.Float32);
      Module._Pass_GetFogColor(this.handle, arrayColor.getHandle());
      var color = arrayColor.toArray();
      arrayColor.dispose();
      return color;
    },
    /**
     * 设置雾开始时间
     * @param {Number} fogStart -雾开始时间
     * @memberOf Pass#
     */
    setFogStart: function setFogStart(fogStart) {
      Module._Pass_SetFogStart(this.handle, fogStart);
    },
    /**
     * 获取雾开始时间
     *
     * @memberOf Pass#
     * @returns {Number} 返回雾开始时间
     */
    getFogStart: function getFogStart() {
      return Module._Pass_GetFogStart(this.handle);
    },
    /**
     * 设置雾结束时间
     * @param {Number} fogEnd -雾结束时间
     * @memberOf Pass#
     */
    setFogEnd: function setFogEnd(fogEnd) {
      Module._Pass_SetFogEnd(this.handle, fogEnd);
    },
    /**
     * 获取雾结束时间
     *
     * @memberOf Pass#
     * @returns {Number} 返回雾结束时间
     */
    getFogEnd: function getFogEnd() {
      return Module._Pass_GetFogEnd(this.handle);
    },
    /**
     * 设置雾的密集程度
     * @param {Number} fogDensity -雾的密集程度
     * @memberOf Pass#
     */
    setFogDensity: function setFogDensity(fogDensity) {
      Module._Pass_SetFogDensity(this.handle, fogDensity);
    },
    /**
     * 获取雾的密集程度
     *
     * @memberOf Pass#
     * @returns {Number} 返回雾的密集程度
     */
    getFogDensity: function getFogDensity() {
      return Module._Pass_GetFogDensity(this.handle);
    },
    /**
     * 获取是否为面裁剪模式
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否为面裁剪模式
     */
    isCullFaceMode: function isCullFaceMode() {
      return Boolean(Module._Pass_IsCullFaceMode(this.handle));
    },
    /**
     * 是否设置投影密度
     * @param {Boolean} autoMipMap -是否设置投影密度
     * @memberOf Pass#
     */
    setAutoMipMap: function setAutoMipMap(autoMipMap) {
      Module._Pass_SetAutoMipMap(this.handle, autoMipMap);
    },
    /**
     * 获取是否设置投影密度
     *
     * @memberOf Pass#
     * @returns {Boolean} 返回是否设置投影密度
     */
    isAutoMipMap: function isAutoMipMap() {
      return Boolean(Module._Pass_IsAutoMipMap(this.handle));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 材质操作函数
   * @name Material
   * @class Material
   * 创建材质对象
   *
   */
  function PIEMaterial(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Material_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEMaterial.prototype, {
    /**
     * 删除材质对象
     * @memberOf Material#
     */
    "delete": function _delete() {
      Module._Material_Delete(this.handle);
    },
    /**
     * 设置名称
     * @param {String} name -Mesh名称
     * @memberOf Material#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._Material_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取名称
     *
     * @memberOf Material#
     * @returns {String} 返回Material名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Material_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置漫射光
     * @param {PIEVector4} diffuse -漫射光
     * @memberOf Material#
     */
    setDiffuse: function setDiffuse(diffuse) {
      var arrayDiffuse = new PIEArray(diffuse, PIEArrayType.Float32);
      Module._Material_SetDiffuse(this.handle, arrayDiffuse.getHandle());
      arrayDiffuse.dispose();
    },
    /**
     * 设置环境光
     * @param {PIEVector4} ambient -环境光
     * @memberOf Material#
     */
    setAmbient: function setAmbient(ambient) {
      var arrayAmbient = new PIEArray(ambient, PIEArrayType.Float32);
      Module._Material_SetAmbient(this.handle, arrayAmbient.getHandle());
      arrayAmbient.dispose();
    },
    /**
     * 设置反射光
     * @param {PIEVector4} specular -反射光
     * @memberOf Material#
     */
    setSpecular: function setSpecular(specular) {
      var arraySpeclar = new PIEArray(specular, PIEArrayType.Float32);
      Module._Material_SetSpecular(this.handle, arraySpeclar.getHandle());
      arraySpeclar.dispose();
    },
    /**
     * 设置发射因子
     * @param {PIEVector4} emmissive -发射因子
     * @memberOf Material#
     */
    setEmmissive: function setEmmissive(emmissive) {
      var arrayEmmissive = new PIEArray(emmissive, PIEArrayType.Float32);
      Module._Material_SetEmmissive(this.handle, arrayEmmissive.getHandle());
      arrayEmmissive.dispose();
    },
    /**
     * 设置光照强度
     * @param {Number} shniniess -光照强度
     * @memberOf Material#
     */
    setShininess: function setShininess(shniniess) {
      Module._Material_SetShininess(this.handle, shniniess);
    },
    /**
     * 设置深度写开关
     * @param {Boolean} enabled -深度写打开与关闭
     * @memberOf Material#
     */
    setDepthWriteEnabled: function setDepthWriteEnabled(enabled) {
      Module._Material_SetDepthWriteEnabled(this.handle, enabled);
    },
    /**
     * 设置深度检测
     * @param {Boolean} enabled -深度检查打开与关闭
     * @memberOf Material#
     */
    setDepthCheckEnabled: function setDepthCheckEnabled(enabled) {
      Module._Material_SetDepthCheckEnabled(this.handle, enabled);
    },
    /**
     * 获取深度检测
     *
     * @memberOf Material#
     * @returns {Boolean} true开启，false关闭
     */
    isDepthCheckEnabled: function isDepthCheckEnabled() {
      return Module._Material_IsDepthCheckEnabled(this.handle);
    },
    /**
     * 设置颜色可写开关
     * @param {Boolean} enabled -颜色写开关
     * @memberOf Material#
     */
    setColourWriteEnabled: function setColourWriteEnabled(enabled) {
      Module._Material_SetColourWriteEnabled(this.handle, enabled);
    },
    /**
     * 是否透明
     *
     * @memberOf Material#
     * @returns {Boolean} 返回材质是否透明
     */
    isTransparent: function isTransparent() {
      return Module._Material_IsTransparent(this.handle);
    },
    /**
     * 是否开启透明排序
     *
     * @memberOf Material#
     * @returns {Boolean} 返回是否开启透明排序
     */
    isTransparentSortingEnabled: function isTransparentSortingEnabled() {
      return Module._Material_IsTransparentSortingEnabled(this.handle);
    },
    /**
     * 是否强制开启透明排序
     *
     * @memberOf Material#
     * @returns {Boolean} 返回是否强制开启透明排序
     */
    isTransparentSortingForced: function isTransparentSortingForced() {
      return Module._Material_IsTransparentSortingForced(this.handle);
    },
    /**
     * 是否具有纹理单元
     *
     * @memberOf Material#
     * @returns {Boolean} 返回是否具有纹理单元
     */
    hasTextureUnit: function hasTextureUnit() {
      return Module._Material_HasTextureUnit(this.handle);
    },
    /**
     * 创建通道对象
     *
     * @memberOf Material#
     * @returns {PIEPass} 返回通道对象
     */
    createPass: function createPass() {
      var handle = Module._Material_CreatePass(this.handle);
      if (handle) {
        return new PIEPass(handle);
      }
    },
    /**
     * 根据序列号获取通道对象
     *
     * @memberOf Material#
     * @returns {PIEPass} 返回通道对象
     */
    getPass: function getPass() {
      var handle = Module._Material_GetPass(this.handle);
      if (handle) {
        return new PIEPass(handle);
      }
    },
    /**
     * 获取通道数量
     *
     * @memberOf Material#
     * @returns {Number} 返回通道数量
     */
    getPassCount: function getPassCount() {
      return Module._Material_GetPassCount(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 编码格式
   * @readonly
   * @enum {number}
   */
  var PIECharsetType = {
    /** Default编码 */
    Default: 1,
    /** GB18030编码*/
    GB18030: 134,
    /** UTF8编码*/
    UTF8: 250,
    /** Windows默认的Unicode编码*/
    UTF16LE: 251,
    /** UCS2BE编码*/
    UTF16BE: 252,
    /** Windows1252编码*/
    Windows1252: 137,
    /** UTF32编码*/
    UTF32LE: 8,
    /** UTF32BE编码*/
    UTF32BE: 9
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 数据集类型枚举
   * @readonly
   * @enum {Number}
   */
  var PIEDatasetType = {
    /**未知数据集*/
    UnKnown: -1,
    /**属性数据集*/
    Attribute: 0,
    /**点数据集*/
    Point: 1,
    /**线数据集*/
    Line: 3,
    /**面数据集*/
    Region: 5,
    /**文本数据集*/
    Text: 7,
    /**路线数据集*/
    LineM: 35,
    /**复杂数据集*/
    Complex: 149,
    /**标绘数据集*/
    Plot: 150,
    /**栅格数据集*/
    Raster: 170,
    /**瓦片数据集*/
    Tile: 200,
    /**模型数据集*/
    Model: 210,
    /**Tiles3D数据集*/
    Tiles3D: 220,
    /**mapbox数据集*/
    MVT: 224,
    /**GE数据集*/
    GEDataModel: 300
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 空间参考系模块
   * ---
   */

  /**
   *
   *空间参考系操作函数
   * @name SpatialReference
   */
  function PIESpatialReference(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESpatialReference.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 删除坐标系统对象
     * @memberOf SpatialReference#
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._SpatialReference_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 将坐标系统输出为WKT格式
     *
     * @memberOf SpatialReference#
     * @returns {String} 返回是否成功将坐标系统输出为WKT字符串
     */
    toWKT: function toWKT() {
      var strWkt = new PIEString$1(600);
      Module._SpatialReference_ToWKT(this.handle, strWkt.getHandle());
      var wkt = strWkt.toString();
      strWkt.dispose();
      return wkt;
    },
    /**
     * 经纬度坐标转投影坐标
     * @param {(Array/PIEVector2)} point -待转换的经纬度坐标点
     * @memberOf SpatialReference#
     *
     * @returns {(Array/PIEVector2)} 返回转换后的投影坐标点
     */
    forward: function forward(point) {
      var pointArray = null;
      if (point instanceof Array) {
        pointArray = new PIEArray(point, PIEArrayType.Float64);
      } else if (point instanceof PIEVector2) {
        pointArray = new PIEArray([point.x, point.y], PIEArrayType.Float64);
      }
      if (!pointArray) {
        return null;
      }
      var forwardPoint = new PIEArray(2, PIEArrayType.Float64);
      Module._SpatialReference_Forward(this.handle, pointArray.getHandle(), forwardPoint.getHandle());
      forwardPoint.updateData();
      var retArray = forwardPoint.toArray();
      pointArray.dispose();
      forwardPoint.dispose();
      if (point instanceof Array) {
        return retArray;
      } else if (point instanceof PIEVector2) {
        var retPoint = new PIEVector2(retArray[0], retArray[1]);
        return retPoint;
      }
    },
    /**
     * 投影坐标转经纬度坐标
     * @param {(Array/PIEVector2)} point -待转换的投影坐标点
     * @memberOf SpatialReference#
     *
     * @returns {(Array/PIEVector2)} 返回转换后的经纬度坐标点
     */
    inverse: function inverse(point) {
      var pointArray = null;
      if (point instanceof Array) {
        pointArray = new PIEArray(point, PIEArrayType.Float64);
      } else if (point instanceof PIEVector2) {
        pointArray = new PIEArray([point.x, point.y], PIEArrayType.Float64);
      }
      if (!pointArray) {
        return null;
      }
      var inversePoint = new PIEArray(2, PIEArrayType.Float64);
      Module._SpatialReference_Inverse(this.handle, pointArray.getHandle(), inversePoint.getHandle());
      inversePoint.updateData();
      var retArray = inversePoint.toArray();
      pointArray.dispose();
      inversePoint.dispose();
      if (point instanceof Array) {
        return retArray;
      } else if (point instanceof PIEVector2) {
        var retPoint = new PIEVector2(retArray[0], retArray[1]);
        return retPoint;
      }
    },
    /**
     * 经纬度范围转投影范围
     * @param {(Array/PIEBounds)} bounds -待转换的范围
     * @memberOf SpatialReference#
     * @returns {(Array/PIEBounds)} 返回转换后的范围
     */
    forwardBounds: function forwardBounds(bounds) {
      var boundsArray = null;
      if (bounds instanceof Array) {
        boundsArray = new PIEArray(bounds, PIEArrayType.Float64);
      } else if (bounds instanceof PIEBounds) {
        boundsArray = new PIEArray([bounds.left, bounds.top, bounds.right, bounds.bottom], PIEArrayType.Float64);
      }
      if (!boundsArray) {
        return null;
      }
      var forwardBounds = new PIEArray(4, PIEArrayType.Float64);
      Module._SpatialReference_ForwardBounds(this.handle, boundsArray.getHandle(), forwardBounds.getHandle());
      forwardBounds.updateData();
      var retArray = forwardBounds.toArray();
      boundsArray.dispose();
      forwardBounds.dispose();
      if (bounds instanceof Array) {
        return retArray;
      } else if (bounds instanceof PIEBounds) {
        var retBounds = new PIEBounds(retArray[0], retArray[1], retArray[2], retArray[3]);
        return retBounds;
      }
    },
    /**
     * 投影范围转经纬度范围
     * @param {(Array/PIEBounds)} bounds -待转换的范围
     * @memberOf SpatialReference#
     * @returns {(Array/PIEBounds)} 返回转换后的范围
     */
    inverseBounds: function inverseBounds(bounds) {
      var boundsArray = null;
      if (bounds instanceof Array) {
        boundsArray = new PIEArray(bounds, PIEArrayType.Float64);
      } else if (bounds instanceof PIEBounds) {
        boundsArray = new PIEArray([bounds.left, bounds.top, bounds.right, bounds.bottom], PIEArrayType.Float64);
      }
      if (!boundsArray) {
        return null;
      }
      var inverseBounds = new PIEArray(4, PIEArrayType.Float64);
      Module._SpatialReference_InverseBounds(this.handle, boundsArray.getHandle(), inverseBounds.getHandle());
      inverseBounds.updateData();
      var retArray = inverseBounds.toArray();
      boundsArray.dispose();
      inverseBounds.dispose();
      if (bounds instanceof Array) {
        return retArray;
      } else if (bounds instanceof PIEBounds) {
        var retBounds = new PIEBounds(retArray[0], retArray[1], retArray[2], retArray[3]);
        return retBounds;
      }
    },
    /**
     * 获取坐标系统的空间坐标系类型
     *
     * @memberOf SpatialReference#
     * @returns {PIESpatialRefType} 返回的空间坐标系类型
     */
    getType: function getType() {
      return Module._SpatialReference_GetType(this.handle);
    },
    /**
     * 获取坐标系名称
     *
     * @memberOf SpatialReference#
     * @returns {String} 返回的坐标系名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._SpatialReference_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    // /**
    //  * 设置坐标系统的地图投影
    //  * @param {PIEProjection} projection -坐标系统的地图投影
    //  * @memberOf SpatialReference#
    //  *
    //  * @returns {Boolean} 返回是否成功设置坐标系统的地图投影(true表示设置成功，false表示设置失败)
    //  */
    // setProjection: function (projection) {
    //     return Module._SpatialReference_SetProjection(this.handle, projection.getHandle());
    // },
    // /**
    //  * 获取坐标系统的地图投影
    //  * @memberOf SpatialReference#
    //  * @returns {PIEProjection} 返回坐标系统的地图投影
    //  */
    // getProjection: function () {
    //     var hProjection = Module._SpatialReference_GetProjection(this.handle);
    //     return new PIEProjection(hProjection);
    // },
    /**
     * 判断两个坐标系统是否相同
     * @param {PIESpatialReference} SpatialReference -目标坐标系统对象
     * @memberOf SpatialReference#
     *
     * @returns {Boolean} true表示相同，false表示不相同
     */
    isSame: function isSame(SpatialReference) {
      return Boolean(Module._SpatialReference_IsSame(this.handle, SpatialReference.getHandle()));
    }
  });
  /**
   * 根据EPSG代码从CRS库中读取坐标系统
   * @param {Number} code -EPSG代码
   * @memberOf SpatialReference
   * @returns {PIESpatialReference} 返回坐标系统对象
   * @example
   * var spatialReference = PIE.SpatialReference.fromEpsg(3857);//创建web墨卡托投影坐标系
   */
  PIESpatialReference.fromEpsg = function (code) {
    var handle = Module._SpatialReference_FromEPSG(code);
    return new PIESpatialReference(handle, true);
  };

  /**
   * 创建Web Mercator坐标系统对象
   *
   * @memberOf SpatialReference
   * @returns {PIESpatialReference} 返回新建的坐标系统对象
   */
  PIESpatialReference.createWebMercator = function () {
    var handle = Module._SpatialReference_CreateWebMercator();
    return new PIESpatialReference(handle, true);
  };
  /**
   * 创建CGCS2000坐标系统对象
   *
   * @memberOf SpatialReference
   * @returns {PIESpatialReference} 返回新建的坐标系统对象
   */
  PIESpatialReference.createChina2000 = function () {
    var handle = Module._SpatialReference_CreateChina2000();
    return new PIESpatialReference(handle, true);
  };
  /**
   * 创建WGS84坐标系统对象
   *
   * @memberOf SpatialReference
   * @returns {PIESpatialReference} 返回新建的坐标系统对象
   */
  PIESpatialReference.createWGS1984 = function () {
    var handle = Module._SpatialReference_CreateWGS1984();
    return new PIESpatialReference(handle, true);
  };

  /**
   * 创建AlbersConicEqualArea坐标系统对象
   * @param {Number} left -bounds
   * @param {Number} right -bounds
   * @param {Number} top -bounds
   * @param {Number} bottom -bounds
   * @memberOf SpatialReference
   * @returns {PIESpatialReference} 返回新建的坐标系统对象
   */
  PIESpatialReference.CreateAlbersConicEqualArea = function (spatialReference, left, right, top, bottom) {
    var handle = Module._SpatialReference_CreateAlbersConicEqualArea(spatialReference.getHandle(), left, right, top, bottom);
    return new PIESpatialReference(handle, true);
  };
  /**
   * 从WKT中读取坐标系统
   * @param {String} wkt -WKT字符串
   * @memberOf SpatialReference
   *
   * @returns {PIESpatialReference} 返回坐标系统对象
   */
  PIESpatialReference.fromWKT = function (wkt) {
    var strWkt = new PIEString$1(wkt);
    var handle = Module._SpatialReference_FromWKT(strWkt.getHandle());
    strWkt.dispose();
    return new PIESpatialReference(handle, true);
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *  数据源枚举
   * @readonly
   * @enum {String}
   */
  var PIEDataSourceType = {
    /** GeoJson数据源  */
    GeoJson: 'GeoJsonDataSource',
    /** GSF数据源  */
    Gsf: 'GsfDataSource',
    /** OSGB数据源  */
    Osgb: 'OsgbDataSource',
    /** Tiles3D数据源  */
    Tiles3D: 'DataSource3DTiles',
    /** Shp数据源  */
    Shp: 'ShpDataSource',
    /** GE数据源  */
    GE: 'DataSourceGE',
    /** 栅格数据源  */
    Raster: 'GdalRasterDataSource',
    /** 矢量数据源  */
    Feature: 'GdalFeatureDataSource',
    /** Mapbox矢量数据源  */
    MVT: 'MVTDataSource',
    /** 标绘数据源  */
    PLOT: 'FHBHDataSource'
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 矢量数据源对象
   * @name FeatureDataSource
   * @extends DataSource
   */
  function PIEFeatureDataSource(handle, autoRelease) {
    PIEDataSource.call(this, handle, autoRelease);
  }
  PIEFeatureDataSource.prototype = Object.assign(Object.create(PIEDataSource.prototype), {

    // /**
    //  * 获取数据集中要素对象个数
    //  * @memberOf FeatureDataSource#
    //  * @returns {Number} 返回对象个数
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.getObjectCount()
    //  */
    // getObjectCount: function () {
    //     return Module._PIE_FDataset_GetObjectCount(this.dataset);
    // },
    //
    // /**
    //  * 获取数据集中字段个数
    //  * @memberOf FeatureDataSource#
    //  * @returns {Number} 返回字段个数
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.getFieldCount()
    //  */
    // getFieldCount: function () {
    //     return Module._PIE_FDataset_GetFieldCount(this.dataset);
    // },
    //
    // /**
    //  * 通过数据集字段名删除数据集字段
    //  * @param {String} field -字段名称
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果删除成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.deleteField(field)
    //  */
    // deleteField: function (field) {
    //     var strName = new PIEString(field);
    //     var result = Module._PIE_FDataset_DeleteField(this.dataset, strName.getHandle());
    //     strName.dispose();
    //     return result;
    // },
    //
    // /**
    //  * 通过数据集字段索引删除数据集字段
    //  * @param {Number} index -索引值
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果删除成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.deleteFieldByIndex(index)
    //  */
    // deleteFieldByIndex: function (index) {
    //     return Module._PIE_FDataset_DeleteFieldByIndex(this.dataset, index);
    // },
    //
    // /**
    //  * 通过指定ID数组查询要素集
    //  * @param {Array} ids -查询时的ID数组
    //  * @param {Number} count -查询时的ID个数
    //  * @memberOf FeatureDataSource#
    //  * @returns {PIEFeature} 如果查询成功返回要素集对象，否则返回NULL
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.queryByID(ids, count)
    //  */
    // queryByID: function (ids, count) {
    //     var pIDs = new PIEArray(ids, PIEArrayType.Int32);
    //     var result = Module._PIE_FDataset_QueryByID(this.dataset, pIDs.getHandle(), count);
    //     pIDs.dispose();
    //     return result;
    // },
    //
    // /**
    //  * 通过属性数据查询条件查询要素集
    //  * @param {String} general -属性数据查询条件
    //  * @memberOf FeatureDataSource#
    //  * @returns {PIEFeature} 如果查询成功返回要素集对象，否则返回NULL
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.queryByGeneral(general)
    //  */
    // queryByGeneral: function (general) {
    //     var strFilter = new PIEString(general);
    //     var result = Module._PIE_FDataset_QueryByGeneral(this.dataset, general.getHandle());
    //     strFilter.dispose();
    //     return result;
    // },
    //
    // /**
    //  * 通过数据范围查询要素集
    //  * @param {PIERect} bounds -矩形对象
    //  * @memberOf FeatureDataSource#
    //  * @returns {PIEFeature} 如果查询成功返回要素集对象，否则返回NULL
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.queryByBounds(bounds)
    //  */
    // queryByBounds: function (bounds) {
    //     let bbox = [];
    //     if (bounds instanceof PIEBounds) {
    //         bbox = bounds.toArray();
    //     } else if (bounds instanceof Array) {
    //         bbox = bounds;
    //     }
    //     return Module._PIE_FDataset_QueryByBounds(this.dataset, bbox[0], bbox[1], bbox[2], bbox[3]);
    // },
    //
    // /**
    //  * 通过要素集句柄释放要素集内存空间
    //  * @param {PIEFeature} featureSet -矢量要素集句柄
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果释放成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.releaseFeatureSet(featureSet)
    //  */
    // releaseFeatureSet: function (featureSet) {
    //     return Module._PIE_FDataset_ReleaseFeatureSet(this.dataset, featureSet.getHandle());
    // },
    //
    // /**
    //  *根据索引设置数据集字段别名
    //  * @param {Number} index -牵引值
    //  * @param {String} name -字段别名
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果设置成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.setFieldForignNameAt(index, name)
    //  */
    // setFieldForignNameAt: function (index, name) {
    //     var strName = new PIEString(name);
    //     var result = Module._PIE_FDataset_SetFieldForignNameAt(this.dataset, index, strName.getHandle());
    //     strName.dispose();
    //     return result;
    // },
    //
    // /**
    //  * 同一空间参考系正转换
    //  * @param {PIESpatialReference} spatialReference 空间参考坐标系
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果转换成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.forward(spatialReference)
    //  */
    // forward: function (spatialReference) {
    //     return Module._PIE_FDataset_PJForward(this.dataset, spatialReference.getHandle());
    // },
    //
    // /**
    //  * 同一空间参考系反转换
    //  * @param {PIESpatialReference} spatialReference -空间参考坐标系
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果转换成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.inverse(spatialReference)
    //  */
    // inverse: function (spatialReference) {
    //     return Module._PIE_FDataset_PJInverse(this.dataset, spatialReference.getHandle());
    // },
    //
    // /**
    //  * 不同空间坐标系转换
    //  * @param {PIEReferenceTranslator} refTranslator -参考系转换器
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果转换成功返回true, 否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.convert(refTranslator)
    //  */
    // convert: function (refTranslator) {
    //     return Module._PIE_FDataset_PJConvert(this.dataset, refTranslator.getHandle());
    // },
    //
    // /**
    //  * 创建空间坐标系
    //  * @param {PIESpatialReference} spatialReference -空间参考坐标系
    //  * @memberOf FeatureDataSource#
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.setSpatialReference(spatialReference)
    //  */
    // setSpatialReference:function(spatialReference) {
    //     var patialReference = new PIESpatialReference(spatialReference);
    //     Module._DataSource_SetSpatialReference(this.handle,patialReference.getHandle());
    // },
    //
    // /**
    //  * 获取空间参考系
    //  * @memberOf FeatureDataSource#
    //  * @returns {PIESpatialReference} 如果获取成功返回空间参考系，否则返回NULL
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.getSpatialReference()
    //  */
    // getSpatialReference: function () {
    //     var hSpatialReference = Module._PIE_FDataset_GetSpatialReference(this.dataset);
    //     if(hSpatialReference){
    //         return new PIESpatialReference(hSpatialReference);
    //     }
    //     return null;
    // },
    //
    // /**
    //  * 建立空间索引
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果索引创建成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.buildSpatialIndex()
    //  */
    // buildSpatialIndex: function () {
    //     return Module._PIE_FDataset_BuildSpatialIndex(this.dataset);
    // },
    //
    // /**
    //  * 删除空间索引
    //  * @memberOf FeatureDataSource#
    //  * @returns {Boolean} 如果索引删除成功返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.dropSpatialIndex()
    //  */
    // dropSpatialIndex: function () {
    //     return Module._PIE_FDataset_DropSpatialIndex(this.dataset);
    // },
    //
    // /**
    //  * 返回数据集字符编码方式
    //  * @memberOf FeatureDataSource#
    //  * @returns {Number} 如果索引删除返回true，否则返回false
    //  *
    //  * @example
    //  * let featureDataSource = new PIE.FeatureDataSource()
    //  * featureDataSource.getCharset()
    //  */
    // getCharset: function () {
    //     return Module._PIE_FDataset_GetCharset(this.dataset);
    // }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建GeoJson数据源
   * @name GeoJsonDataSource
   * @class GeoJsonDataSource
   * GeoJson数据源操作函数
   * @extends FeatureDataSource
   */
  function PIEGeoJsonDataSource(handle, autoRelease) {
    PIEFeatureDataSource.call(this, handle, autoRelease);
  }
  function isJson(obj) {
    if (_typeof(obj) == "object" && obj != null) {
      return true;
    }
    return false;
  }
  PIEGeoJsonDataSource.prototype = Object.assign(Object.create(PIEFeatureDataSource.prototype), {
    /**
     * 通过数据源路径加载并打开数据源
     * @param {Object} options -
     * @param {String} options.file -数据源从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.url -数据源的服务地址
     * @param {String} options.alias -数据源名称
     * @param {PIECharsetType} options.charset -数据集编码(默认PIE.CharsetType.UTF8)
     *
     * @memberOf GeoJsonDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     * @example
     * let options = {
        file: 'data/geojson.json',
        url: 'http://127.0.0.1:8080/data/geojson.json',
      };
     let workspace = viewer.getGlobe().getDocument();
     let dataSource = new PIE.GeoJsonDataSource();
     dataSource.load(options).then((value)=>{
           //vaule就是load之后的被成功打开的dataSource 可以用来添加到工作空间中，然后与layer绑定
            workspace.getDataSourceManager().addDataSource(value);
       })
     */
    load: function load(options) {
      var that = this;
      var datasetCharset = options.charset == null ? PIECharsetType.UTF8 : options.charset;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var url = options.url;
        var filesPicks = [];
        if (!url || url == "") {
          reject(new Error('PIE.GeoJsonDataSource.load: input url is NULL'));
          return;
        }
        var name = PIEFile.getFileName(url);
        var index = name.lastIndexOf(".");
        if (index < 0) {
          name = name + ".json";
        }
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        filesPicks.push(file);
        var urlsPicks = [];
        urlsPicks.push(options.url);
        function callBack(filelist, urllist, datalist) {
          if (that.open({
            database: filesPicks[0],
            alias: options.alias
          })) {
            var dataset = that.getDataset();
            if (dataset != null) {
              dataset.setCharset(datasetCharset);
            }
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    /**
     * 通过json对象数据加载并打开数据源
     * @param {Object} options -
     * @param {String} options.jsonData -json数据
     * @param {String} options.alias -数据源名称
     * @param {PIECharsetType} options.charset -数据集编码(默认PIE.CharsetType.UTF8)
     *
     * @memberOf GeoJsonDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     *
     */
    loadJsonData: function loadJsonData(options) {
      var that = this;
      var datasetCharset = options.charset == null ? PIECharsetType.UTF8 : options.charset;
      return new Promise(function (resolve, reject) {
        if (isJson(options.jsonData)) {
          var file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + "cacheData.geojson"; //设置生成json文件路径
          PIEFile.makeFolder(file);
          var data = JSON.stringify(options.jsonData);
          var stream = Module.FS.open(file, 'w+');
          var blob = new Blob([data], {
            type: "text/json"
          });
          blob.arrayBuffer().then(function (buffer) {
            var dataArray = new Uint8Array(buffer);
            Module.FS.write(stream, dataArray, 0, dataArray.length, 0);
            Module.FS.close(stream);
            if (that.open({
              database: file,
              alias: options.alias
            })) {
              var dataset = that.getDataset();
              if (dataset != null) {
                dataset.setCharset(datasetCharset);
              }
              resolve(that);
            }
          });
        } else {
          resolve(null);
        }
      });
    },
    toGeojson: function toGeojson() {
      var strGeojson = new PIEString$1(10240);
      Module._DataSource_GetGeojson(this.handle, strGeojson.getHandle());
      var geojson = strGeojson.toString();
      strGeojson.dispose();
      return geojson;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建Shp数据源
   * @name ShpDataSource
   * @class ShpDataSource
   * Shp数据源操作函数
   * @extends FeatureDataSource
   */
  function PIEShpDataSource$1(handle, autoRelease) {
    PIEFeatureDataSource.call(this, handle, autoRelease);
  }
  PIEShpDataSource$1.prototype = Object.assign(Object.create(PIEFeatureDataSource.prototype), {
    /**
     * 通过数据源路径加载并打开数据源
     * @param {Object} options -
     * @param {String} options.file -数据源从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.url -数据源的服务地址
     * @param {String} options.alias -数据源名称
     * @param {PIECharsetType} options.charset -数据集编码(默认PIE.CharsetType.UTF8)
     *
     * @memberOf ShpDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     * @example
     * let options = {
        file: 'data/provice.shp',
        url: 'http://127.0.0.1:8080/data/provice.shp',
      };
     let workspace = viewer.getGlobe().getDocument();
     let dataSource = new PIE.ShpDataSource();
     dataSource.load(options).then((value)=>{
           //vaule就是load之后的被成功打开的dataSource 可以用来添加到工作空间中，然后与layer绑定
            workspace.getDataSourceManager().addDataSource(value);
       })
     */
    load: function load(options) {
      var that = this;
      var datasetCharset = options.charset == null ? PIECharsetType.UTF8 : options.charset;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var shpUrl = options.url;
        if (shpUrl == null || shpUrl == "") {
          reject(new Error('PIE.ShpDataSource.load: input url is NULL'));
          return;
        }
        var name = PIEFile.getFileName(shpUrl);
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        var filesPicks = [];
        filesPicks.push(file);
        filesPicks.push(file.slice(0, -4) + '.dbf');
        filesPicks.push(file.slice(0, -4) + '.prj');
        filesPicks.push(file.slice(0, -4) + '.qix');
        filesPicks.push(file.slice(0, -4) + '.shx');
        filesPicks.push(file.slice(0, -4) + '.cpg');
        var urlsPicks = [];
        urlsPicks.push(shpUrl);
        urlsPicks.push(shpUrl.slice(0, -4) + '.dbf');
        urlsPicks.push(shpUrl.slice(0, -4) + '.prj');
        urlsPicks.push(shpUrl.slice(0, -4) + '.qix');
        urlsPicks.push(shpUrl.slice(0, -4) + '.shx');
        urlsPicks.push(shpUrl.slice(0, -4) + '.cpg');
        function callBack(filelist, urllist, datalist) {
          if (that.open({
            database: filesPicks[0],
            alias: options.alias
          })) {
            var dataset = that.getDataset();
            dataset.setCharset(datasetCharset);
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建GSF数据源
   * @name GSFDataSource
   * @class GSFDataSource
   * GSF数据源操作函数
   * @extends FeatureDataSource
   */
  function PIEGSFDataSource(handle, autoRelease) {
    PIEFeatureDataSource.call(this, handle, autoRelease);
  }
  PIEGSFDataSource.prototype = Object.assign(Object.create(PIEFeatureDataSource.prototype), {
    /**
     * 通过gsf数据源路径加载并打开数据源
     * @param {Object} options -
     * @param {String} options.file -数据源从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.gsfUrl -gsf数据服务地址
     * @param {String} options.esfUrl -esf数据服务地址(可以为空，默认取与gsf数据相同路径地址)
     * @param {String} options.alias -数据源名称(可以为空，默认取文件名)
     *
     * @memberOf GSFDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     * @example
     * let options = {
        gsfUrl: 'http://127.0.0.1:8080/data/Provinces_R.gsf',
        alias: 'testGsf'
      };
     var globe = viewer.getGlobe();
     var workspace = globe.getDocument();
     let dataSource = new PIE.GSFDataSource();
     dataSource.load(options).then((value)=>{
           //vaule就是load之后的被成功打开的dataSource 可以用来添加到工作空间中，然后与layer绑定
            workspace.getDataSourceManager().addDataSource(value);
       })
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var esfFile = "";
        var gsfUrl = options.gsfUrl;
        if (gsfUrl == null || gsfUrl == "") {
          reject(new Error('PIE.GSFDataSource.load: input gsfUrl is NULL'));
          return;
        }
        var name = PIEFile.getFileName(gsfUrl);
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        esfFile = file.replace(/.gsf/, '.esf');
        var filesPicks = [];
        filesPicks.push(file);
        filesPicks.push(esfFile);
        var urlsPicks = [];
        var esfUrl = options.esfUrl;
        if (!esfUrl) {
          esfUrl = gsfUrl.replace(/.gsf/, '.esf');
        }
        urlsPicks.push(gsfUrl);
        urlsPicks.push(esfUrl);
        function callBack(filelist, urllist, datalist) {
          if (that.open({
            database: filesPicks[0],
            alias: options.alias
          })) {
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    /**
     * 新建数据集
     * @param {PIEDatasetType} type -数据集类型
     * @param {String} name -数据集名称
     *
     * @memberOf GSFDataSource#
     * @returns {PIEDataset} 如果创建成功返回数据集对象，否则返回null
     */
    createDataset: function createDataset(type, name) {
      var datasetName = new PIEString$1(name);
      var hDataset = Module._DataSource_CreateDataset(this.handle, type, datasetName.getHandle());
      datasetName.dispose();
      if (hDataset) {
        return PIEDatasetFactory.CreateInstance(hDataset);
      }
      return null;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 模型数据源操作函数
   * @name ModelDataSource
   *@extends DataSource
   *
   */
  function PIEModelDataSource(handle, autoRelease) {
    PIEDataSource.call(this, handle, autoRelease);
  }
  PIEModelDataSource.prototype = Object.assign(Object.create(PIEDataSource.prototype), {

    // /**
    //  * 设置OSGB数据集坐标
    //  * @param {(Array/PIEVector3)} position -坐标
    //  * @memberOf ModelDataSource#
    //  */
    // setPosition: function (position) {
    //     var array = null;
    //     if (position instanceof PIEVector3) {
    //         array = position.toArray();
    //     } else if (position instanceof Array) {
    //         array = position;
    //     }
    //     if(array){
    //         var positionArray = new PIEArray(array, PIEArrayType.Float64);
    //         Module._MDataset_SetPosition(this.dataset, positionArray.getHandle());
    //         positionArray.dispose();
    //     }
    // },
    //
    // /**
    //  * 获取OSGB数据集坐标
    //  * @returns {PIEVector3} 返回数据集坐标
    //  *
    //  * @memberOf ModelDataSource#
    //  */
    // getPosition: function () {
    //     var positionArray = new PIEArray(3, PIEArrayType.Float64);
    //     Module._MDataset_GetPosition(this.dataset, positionArray.getHandle());
    //     positionArray.updateData();
    //     var position = positionArray.toArray();
    //     positionArray.dispose();
    //     return new PIEVector3(position[0], position[1], position[2]);
    // }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建OSGB数据源
   * @name OSGBDataSource
   * @class OSGBDataSource
   * OSGB数据源操作函数
   * @extends ModelDataSource
   */
  function PIEOSGBDataSource(handle, autoRelease) {
    PIEModelDataSource.call(this, handle, autoRelease);
  }
  PIEOSGBDataSource.prototype = Object.assign(Object.create(PIEModelDataSource.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  //暂时不开放接口文档
  // /**
  //  * 创建Google数据源
  //  * @name GEDataSource
  //  * @class GEDataSource
  //  * Google数据源操作函数
  //  * @extends ModelDataSource
  //  */
  function PIEGEDataSource$1(handle, autoRelease) {
    PIEModelDataSource.call(this, handle, autoRelease);
  }
  PIEGEDataSource$1.prototype = Object.assign(Object.create(PIEModelDataSource.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * GDAL矢量数据源对象
   * @name GdalFeatureDataSource
   * @class GdalFeatureDataSource
   * @extends FeatureDataSource
   */
  function PIEGdalFeatureDataSource$1(handle, autoRelease) {
    PIEFeatureDataSource.call(this, handle, autoRelease);
  }
  PIEGdalFeatureDataSource$1.prototype = Object.assign(Object.create(PIEFeatureDataSource.prototype), {
    /**
     * 通过数据源路径加载并打开数据源
     * @param {Object} options -
     * @param {String} options.file -数据源从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.url -数据源的服务地址
     * @param {String} options.alias -数据源名称
     *
     * @memberOf GdalFeatureDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     * @example
     * let options = {
        file: 'data/111.000',
        url: 'http://127.0.0.1:8080/data/111.000',
      };
     let workspace = viewer.getGlobe().getDocument();
     let dataSource = new PIE.FeatureDataSource();
     dataSource.load(options).then((value)=>{
           //vaule就是load之后的被成功打开的dataSource 可以用来添加到工作空间中，然后与layer绑定
            workspace.getDataSourceManager().addDataSource(value);
       })
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var url = options.url;
        var filesPicks = [];
        if (url == null) {
          return null;
        }
        var name = PIEFile.getFileName(url);
        var index = name.lastIndexOf(".");
        if (index < 0) {
          name = name + ".000";
        }
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        filesPicks.push(file);
        var urlsPicks = [];
        urlsPicks.push(options.url);
        function callBack(filelist, urllist, datalist) {
          if (that.open({
            database: filesPicks[0],
            alias: options.alias
          })) {
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 栅格数据源
   * @name RasterDataSource
   * @extends DataSource
   */
  function PIERasterDataSource(handle, autoRelease) {
    PIEDataSource.call(this, handle, autoRelease);
  }
  PIERasterDataSource.prototype = Object.assign(Object.create(PIEDataSource.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建GDAL栅格数据源
   * @name GdalRasterDataSource
   * @class GdalRasterDataSource
   * GDAL栅格数据源操作函数
   * @extends RasterDataSource
   */
  function PIEGdalRasterDataSource$1(handle, autoRelease) {
    PIERasterDataSource.call(this, handle, autoRelease);
  }
  PIEGdalRasterDataSource$1.prototype = Object.assign(Object.create(PIERasterDataSource.prototype), {
    /**
     * 通过数据源路径加载并打开数据源
     * @param {Object} options -
     * @param {String} options.file -数据源从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.url -数据源的服务地址
     * @param {String} options.alias -数据源名称
     *
     * @memberOf GdalRasterDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var url = options.url;
        var filesPicks = [];
        if (url == null) {
          return null;
        }
        var name = PIEFile.getFileName(url);
        var ext = PIEFile.getExtFromName(name);
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        var rrdFile;
        var auxFile;
        if (ext == "tif") {
          rrdFile = file.replace('.tif', '.rrd');
          auxFile = file.replace('.tif', '.aux');
        } else if (ext == "tiff") {
          rrdFile = file.replace('.tiff', '.rrd');
          auxFile = file.replace('.tiff', '.aux');
        }
        filesPicks.push(file);
        filesPicks.push(rrdFile);
        filesPicks.push(auxFile);
        var urlsPicks = [];
        urlsPicks.push(options.url);
        var rrdUrl;
        var auxUrl;
        if (ext == "tif") {
          rrdUrl = url.replace('.tif', '.rrd');
          auxUrl = url.replace('.tif', '.aux');
        } else if (ext == "tiff") {
          rrdUrl = url.replace('.tiff', '.rrd');
          auxUrl = url.replace('.tiff', '.aux');
        }
        urlsPicks.push(rrdUrl);
        urlsPicks.push(auxUrl);
        function callBack(filelist, urllist, datalist) {
          if (that.open({
            database: filesPicks[0],
            alias: options.alias
          })) {
            that.getDataset();
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建Mapbox瓦片数据源
   * @name MVTDataSource
   * @class MVTDataSource
   * Mapbox瓦片数据源操作函数
   * @extends DataSource
   */
  function PIEMVTDataSource$1(handle, autoRelease) {
    PIEDataSource.call(this, handle, autoRelease);
  }
  PIEMVTDataSource$1.prototype = Object.assign(Object.create(PIEDataSource.prototype), {
    /**
     * 创建矢量瓦片
     * @param {Object} options -
     * @param {String} options.server -url地址(必输)
     * @param {String} options.alias -瓦片数据源别名(必输)
     * @memberOf MVTDataSource#
     */
    create: function create(options) {
      if (options != null) {
        var serverUrl = options.server;
        var name = options.alias;
        options.cachePath;
        if (serverUrl == null || serverUrl == "") {
          return;
        }
        var strProvider = new PIEString$1(serverUrl);
        this.handle = Module._DataSource_CreateMVTDataSource(strProvider.getHandle(), null, null);
        if (this.handle) {
          this.autoRelease = true;
          this.setAlias(name);
        }
        strProvider.dispose();
      }
    },
    /**
     * 打开矢量瓦片数据源
     * @param {Object} options -
     * @param {String} options.dataBase -数据源(必填项)
     * @param {String} options.server -数据源服务地址(非必填项)
     * @param {String} options.alias -瓦片数据源别名（非必填项）
     * @memberOf MVTDataSource#
     */
    open: function open(options) {
      var dataBase = options.dataBase;
      var server = options.server;
      var name = options.alias;
      if (dataBase == null) {
        return;
      }
      var strDataBase = new PIEString$1(dataBase);
      var strServer = new PIEString$1(server);
      this.handle = Module._DataSource_OpenMVTDataSource(strDataBase.getHandle(), strServer.getHandle());
      strDataBase.dispose();
      strServer.dispose();
      if (options.alias) {
        this.setAlias(name);
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建Tiles3D数据源
   * @name Tiles3DDataSource
   * @class Tiles3DDataSource
   * Tiles3D数据源操作函数
   * @extends ModelDataSource
   */
  function PIETiles3DDataSource$1(handle, autoRelease) {
    PIEModelDataSource.call(this, handle, autoRelease);
  }
  PIETiles3DDataSource$1.prototype = Object.assign(Object.create(PIEModelDataSource.prototype), {});

  function PIEPlotActionFactory() {}
  Object.assign(PIEPlotActionFactory.prototype, {});
  PIEPlotActionFactory.CreateInstance = function (hAction) {
    var actionType = Module._PlotAction_GetType(hAction);
    if (actionType == PIEPlotActionType.Gradually) {
      return new PIEPlotGraduallyAction({
        handle: hAction
      });
    } else if (actionType == PIEPlotActionType.Grow) {
      return new PIEPlotGrowAction({
        handle: hAction
      });
    } else if (actionType == PIEPlotActionType.Move) {
      return new PIEPlotMoveAction({
        handle: hAction
      });
    } else if (actionType == PIEPlotActionType.Rotate) {
      return new PIEPlotRotateAction({
        handle: hAction
      });
    } else if (actionType == PIEPlotActionType.Scale) {
      return new PIEPlotScaleAction({
        handle: hAction
      });
    } else if (actionType == PIEPlotActionType.Wipe) {
      return new PIEPlotWipeAction({
        handle: hAction
      });
    } else if (actionType == PIEPlotActionType.MoveByPath) {
      return new PIEPlotMoveByPathAction({
        handle: hAction
      });
    }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 标绘模块
   * ---
   */

  /**
   * 标绘动画结构节点操作函数
   * @name FHBHAssembleNode
   */
  function PIEFHBHAssembleNode(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEFHBHAssembleNode.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 销毁节点
     * @memberOf FHBHAssembleNode#
     */
    dispose: function dispose() {
      Module._FHBHAssembleNode_Destroy(this.handle);
    },
    /**
     * 获取子节点个数
     * @returns {Number} 返回子节点个数
     * @memberOf FHBHAssembleNode#
     */
    getChildCount: function getChildCount() {
      return Module._FHBHAssembleNode_GetChildCount(this.handle);
    },
    /**
     * 获取子节点
     * @param {Number} index -子节点索引
     * @returns {PIEFHBHAssembleNode} 返回子节点
     * @memberOf FHBHAssembleNode#
     */
    getChildAt: function getChildAt(index) {
      var handle = Module._FHBHAssembleNode_GetChildAt(this.handle, index);
      return new PIEFHBHAssembleNode(handle);
    },
    /**
     * 获取标绘结构节点对应几何对象id
     * @returns {Number} 返回几何对象id
     * @memberOf FHBHAssembleNode#
     */
    getPlotID: function getPlotID() {
      return Module._FHBHAssembleNode_GetPlotID(this.handle);
    },
    /**
     * 是否可见
     * @returns {Boolean} 返回节点是否可见
     * @memberOf FHBHAssembleNode#
     */
    isVisible: function isVisible() {
      return Boolean(Module._FHBHAssembleNode_IsVisible(this.handle));
    },
    /**
     * 设置是否可见
     * @param {Boolean} visible -是否可见
     * @memberOf FHBHAssembleNode#
     */
    setVisible: function setVisible(visible) {
      return Module._FHBHAssembleNode_SetVisible(this.handle, visible);
    },
    /**
     * 获取节点名称
     * @returns {String} 返回节点名称
     * @memberOf FHBHAssembleNode#
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._FHBHAssembleNode_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置节点名称
     * @param {String} 节点名称
     * @memberOf FHBHAssembleNode#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._FHBHAssembleNode_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 判断节点是否是标绘节点
     * @returns {Boolean} 返回节点是否是标绘节点
     * @memberOf FHBHAssembleNode#
     */
    isPlot: function isPlot() {
      return Boolean(Module._FHBHAssembleNode_IsPlot(this.handle));
    },
    /**
     * 获取节点动画个数
     * @returns {Boolean} 返回动画个数                                                                                                                                                                                                                                 否是标绘节点
     * @memberOf FHBHAssembleNode#
     */
    getActionCount: function getActionCount() {
      return Module._FHBHAssembleNode_GetActionCount(this.handle);
    },
    /**
     * 获取节点的所有动画
     * @returns {Array} 返回动画对象数组                                                                                                                                                                                                                                     否是标绘节点
     * @memberOf FHBHAssembleNode#
     */
    getAllAction: function getAllAction() {
      var count = this.getActionCount();
      if (count > 0) {
        var actionArray = new PIEArray(count, PIEArrayType.Int32);
        Module._FHBHAssembleNode_GetAllAction(this.handle, actionArray.getHandle());
        actionArray.updateData();
        var arrayAction = actionArray.toArray();
        actionArray.dispose();
        var actions = [];
        for (var i = 0; i < count; i++) {
          var action = PIEPlotActionFactory.CreateInstance(arrayAction[i]);
          actions.push(action);
        }
        return actions;
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 标绘模块
   * ---
   */

  /**
   * 标绘动画结构树操作函数
   * @name FHBHAssemble
   *
   */
  function PIEFHBHAssemble(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEFHBHAssemble.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 获取数据源对象
     *
     * @memberOf FHBHAssemble#
     * @returns {PIEFHBHDataSource} 成功返回当前记录的ID
     */
    getDataSource: function getDataSource() {
      var handle = Module._FHBHAssemble_GetDataSource(this.handle);
      return new PIEFHBHDataSource(handle);
    },
    /**
     * 获取动画结构树根节点
     *
     * @memberOf FHBHAssemble#
     * @returns {PIEFHBHAssembleNode} 返回动画结构节点对象
     */
    getRoot: function getRoot() {
      var handle = Module._FHBHAssemble_GetRoot(this.handle);
      return new PIEFHBHAssembleNode(handle);
    },
    /**
     * 获取动画结构树根节点
     * @param {Number} id -标绘id
     * @memberOf FHBHAssemble#
     * @returns {PIEFHBHAssembleNode} 返回动画结构节点对象
     */
    getPlotNode: function getPlotNode(id) {
      var handle = Module._FHBHAssemble_GetPlotNode(this.handle, id);
      return new PIEFHBHAssembleNode(handle);
    },
    /**
     * 设置编辑节点
     * @param {PIEFHBHAssembleNode} node -动画结构节点对象
     * @returns {Boolean} 返回是否成功
     * @memberOf FHBHAssemble#
     */
    setEditNode: function setEditNode(node) {
      return Module._FHBHAssemble_SetEditNode(this.handle, node.getHandle());
    },
    /**
     * 删除当前编辑节点
     * @returns {Boolean} 返回是否成功
     * @memberOf FHBHAssemble#
     */
    removeNode: function removeNode(node) {
      return Module._FHBHAssemble_RemoveNode(this.handle);
    },
    /**
     * 删除当前编辑节点并删除数据集中的几何对象
     * @param {PIEFHBHAssembleNode} node -动画结构节点对象
     * @returns {Boolean} 返回是否成功
     * @memberOf FHBHAssemble#
     */
    removeNodeAndGeometry: function removeNodeAndGeometry(node) {
      return Module._FHBHAssemble_RemoveNodeAddGeometry(this.handle, node.getHandle());
    },
    /**
     * 保存
     * @returns {Boolean} 返回是否成功
     * @memberOf FHBHAssemble#
     */
    save: function save() {
      return Module._FHBHAssemble_Save(this.handle);
    },
    /**
     * 添加节点
     * @param {PIEFHBHAssembleNode} node -动画结构节点对象
     * @returns {Boolean} 返回是否成功
     * @memberOf FHBHAssemble#
     */
    addNode: function addNode(node) {
      return Module._FHBHAssemble_AddNode(this.handle, node.getHandle());
    },
    /**
     * 添加新节点
     * @param {String} name -节点名称
     * @returns {Boolean} 返回是否成功
     * @memberOf FHBHAssemble#
     */
    addNewNode: function addNewNode(name) {
      var strName = new PIEString$1(name);
      var res = Module._FHBHAssemble_AddNewNode(this.handle, strName.getHandle());
      strName.dispose();
      return res;
    },
    /**
     * 添加动画
     * @param {PIEPlotAction} action -标绘动画对象
     * @returns {Boolean} 返回是否成功
     * @memberOf FHBHAssemble#
     */
    addPlotAction: function addPlotAction(action) {
      return Module._FHBHAssemble_AddPlotAction(this.handle, action.getHandle());
    },
    /**
     * 更新动画
     * @param {PIEPlotAction} action -标绘动画对象
     * @memberOf FHBHAssemble#
     */
    updataAction: function updataAction(action) {
      Module._FHBHAssemble_UpdataAction(this.handle, action.getHandle());
    },
    /**
     * 删除动画
     * @param {PIEPlotAction} action -标绘动画对象
     * @memberOf FHBHAssemble#
     */
    removeAction: function removeAction(action) {
      Module._FHBHAssemble_RemoveAction(this.handle, action.getHandle());
    },
    /**
     * 获取动画终止时间
     * @returns {Number} 返回终止时间
     * @memberOf FHBHAssemble#
     */
    getActionsEndTime: function getActionsEndTime() {
      return Module._FHBHAssemble_GetActionsEndTime(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建FHBH数据源
   * @name FHBHDataSource
   * @class FHBHDataSource
   * FHBH数据源操作函数
   * @extends GSFDataSource
   */
  function PIEFHBHDataSource(options) {
    var handle = null;
    var autoRelease = false;
    if (options) {
      if (options.handle) {
        handle = options.handle;
      } else {
        if (options.path != null) {
          var strPath = new PIEString$1(options.path);
          handle = Module._DataSource_Create(strPath.getHandle());
          autoRelease = true;
          strPath.dispose();
        }
      }
    }
    PIEGSFDataSource.call(this, handle, autoRelease);
  }
  PIEFHBHDataSource.prototype = Object.assign(Object.create(PIEGSFDataSource.prototype), {
    /**
     * 通过gsf数据源路径加载并打开数据源
     * @param {Object} options -
     * @param {String} options.file -数据源从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.bhmUrl -bhm数据服务地址
     * @param {String} options.alias -数据源名称(可以为空，默认取文件名)
     *
     * @memberOf FHBHDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var gsfFile = "";
        var esfFile = "";
        var bhmUrl = options.bhmUrl;
        if (bhmUrl == null || bhmUrl == "") {
          reject(new Error('PIE.GSFDataSource.load: input bhmUrl is NULL'));
          return;
        }
        var name = PIEFile.getFileName(bhmUrl);
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        gsfFile = file.replace(/.bhm/, '.gsf');
        esfFile = file.replace(/.bhm/, '.esf');
        var filesPicks = [];
        filesPicks.push(file);
        filesPicks.push(gsfFile);
        filesPicks.push(esfFile);
        var urlsPicks = [];
        var gsfUrl = options.gsfUrl;
        var esfUrl = options.esfUrl;
        if (!gsfUrl) {
          gsfUrl = bhmUrl.replace(/.bhm/, '.gsf');
        }
        if (!esfUrl) {
          esfUrl = bhmUrl.replace(/.bhm/, '.esf');
        }
        urlsPicks.push(bhmUrl);
        urlsPicks.push(gsfUrl);
        urlsPicks.push(esfUrl);
        function callBack(filelist, urllist, datalist) {
          if (that.open({
            database: filesPicks[0],
            alias: options.alias
          })) {
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    /**
     * 获取标绘结构对象
     *
     * @memberOf FHBHDataSource#
     * @returns {PIEFHBHAssemble} 成功返回当前记录的ID
     */
    getAssemble: function getAssemble() {
      var handle = Module._DataSourceFHBH_GetAssemble(this.handle);
      return new PIEFHBHAssemble(handle);
    }
  });

  function PIEDataSourceFactory() {}
  Object.assign(PIEDataSourceFactory.prototype, {});
  PIEDataSourceFactory.CreateInstance = function (hDataSource) {
    if (hDataSource) {
      var strType = new PIEString$1(256);
      Module._DataSource_GetType(hDataSource, strType.getHandle());
      var type = strType.toString();
      strType.dispose();
      if (type == PIEDataSourceType.GeoJson) {
        return new PIEGeoJsonDataSource(hDataSource);
      } else if (type == PIEDataSourceType.Gsf) {
        return new PIEGSFDataSource(hDataSource);
      } else if (type == PIEDataSourceType.Osgb) {
        return new PIEOSGBDataSource(hDataSource);
      }
      if (type == PIEDataSourceType.Tiles3D) {
        return new PIETiles3DDataSource$1(hDataSource);
      } else if (type == PIEDataSourceType.GE) {
        return new PIEGEDataSource$1(hDataSource);
      } else if (type == PIEDataSourceType.Shp) {
        return new PIEShpDataSource$1(hDataSource);
      } else if (type == PIEDataSourceType.Feature) {
        return new PIEGdalFeatureDataSource$1(hDataSource);
      } else if (type == PIEDataSourceType.Raster) {
        return new PIEGdalRasterDataSource$1(hDataSource);
      } else if (type == PIEDataSourceType.MVT) {
        return new PIEMVTDataSource$1(hDataSource);
      } else if (type == PIEDataSourceType.PLOT) {
        return new PIEFHBHDataSource({
          handle: hDataSource
        });
      } else {
        return new PIEDataSource(hDataSource);
      }
    }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 数据集操作函数
   * @name Dataset
   *
   */
  function PIEDataset(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEDataset.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 打开数据集
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果打开成功返回true，否则返回false
     */
    open: function open() {
      return Boolean(Module._Dataset_Open(this.handle));
    },
    /**
     * 判断数据集是否已经打开
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果已经打开返回true，否则返回false
     */
    isOpen: function isOpen() {
      return Boolean(Module._Dataset_IsOpen(this.handle));
    },
    /**
     * 关闭数据集
     * @memberOf Dataset#
     */
    close: function close() {
      Module._Dataset_Close(this.handle);
    },
    // /**
    //  * 释放数据集缓存对象(仅支持瓦片型数据源)
    //  * @memberOf Dataset#
    //     */
    // releaseCacheHandles: function () {
    //     Module._Dataset_ReleaseCacheHandles(this.handle);
    // },

    /**
     * 获取数据集类型
     *
     * @memberOf Dataset#
     * @returns {PIEDatasetType} 返回数据集类型
     */
    getType: function getType() {
      return Module._Dataset_GetType(this.handle);
    },
    /**
     * 判断数据集是否只读
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果是只读返回true，否则返回false
     */
    isReadOnly: function isReadOnly() {
      return Boolean(Module._Dataset_IsReadOnly(this.handle));
    },
    /**
     * 获取数据集名称
     *
     * @memberOf Dataset#
     * @returns {String} 返回的数据集名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Dataset_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 数据集重命名
     * @param {String} dataSetName -新命名的数据集名称
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果重命名成功返回true，否则返回false(新名称与原名称相同则返回false)
     */
    rename: function rename(dataSetName) {
      var strNewName = new PIEString$1(dataSetName);
      var res = Module._Dataset_Rename(this.handle, strNewName.getHandle());
      strNewName.toString();
      strNewName.dispose();
      return Boolean(res);
    },
    // /**
    //  * 获取数据集表名
    //  *
    //  * @memberOf Dataset#
    //  * @returns {String} 返回数据集表名称
    //  */
    // getTableName: function () {
    //     var strDataSetTableName = new PIEString(256);
    //     Module._Dataset_GetTableName(this.handle, strDataSetTableName.getHandle());
    //     var tableName = strDataSetTableName.toString();
    //     strDataSetTableName.dispose();
    //     return tableName;
    // },

    /**
     * 判断是否为矢量数据集
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果是矢量数据集返回true，否则返回false
     */
    isVector: function isVector() {
      return Boolean(Module._Dataset_IsVector(this.handle));
    },
    /**
     * 判断是否为栅格数据集
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果是栅格数据集返回true，否则返回false
     */
    isRaster: function isRaster() {
      return Boolean(Module._Dataset_IsRaster(this.handle));
    },
    /**
     * 判断是否为瓦片数据集
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果是瓦片数据集返回true，否则返回false
     */
    isTile: function isTile() {
      return Boolean(Module._Dataset_IsTile(this.handle));
    },
    /**
     * 获取数据集范围
     *
     * @memberOf Dataset#
     * @returns {PIEBounds} 返回数据集范围
     */
    getBounds: function getBounds() {
      var boundsArr = new PIEArray(4, PIEArrayType.Float64);
      Module._Dataset_GetBounds(this.handle, boundsArr.getHandle());
      boundsArr.updateData();
      var array = boundsArr.toArray();
      var bounds = new PIEBounds(array[0], array[1], array[2], array[3]);
      boundsArr.dispose();
      return bounds;
    },
    /**
     * 获取数据集的空间参考系
     *
     * @memberOf Dataset#
     * @returns {PIESpatialReference} 如果获取成功返回数据集的空间参考系对象，否则返回null
     */
    getSpatialReference: function getSpatialReference() {
      var handle = Module._Dataset_GetSpatialReference(this.handle);
      if (handle) {
        return new PIESpatialReference(handle);
      }
      return null;
    },
    /**
     * 设置数据集的空间参考系
     * @param {PIESpatialReference} spatialReference -空间参考系对象
     *
     * @memberOf Dataset#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setSpatialReference: function setSpatialReference(spatialReference) {
      return Boolean(Module._Dataset_SetSpatialReference(this.handle, spatialReference.getHandle()));
    },
    /**
     * 获取数据集对应的数据源
     *
     * @memberOf Dataset#
     * @returns {PIEDataSource} 如果获取成功返回数据源对象，否则返回null
     */
    getDataSource: function getDataSource() {
      var hDataSource = Module._Dataset_GetDataSource(this.handle);
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建字段信息对象
   * @name FieldInfo
   * @class FieldInfo
   * 字段信息操作函数
   * @param {object} options -
   * @param {Boolean} options.isSystem -是否是系统字段(默认false)
   * @param {Boolean} options.isRequired -是否是必输字段(默认false)
   * @param {PIEFieldType} options.type -字段类型(默认PIE.FieldType.UnKnown)
   * @param {Number} options.size -字段长度(必输项)
   * @param {String} options.name -字段名
   * @param {String} options.alias -字段别名
   * @param {String} options.defaultValue -字段默认值
   *
   */
  function PIEFieldInfo(options) {
    var handle = options.handle;
    if (handle == null) {
      handle = Module._FieldInfo_Create();
      this.autoRelease = true;
      this.handle = handle;
      if (options.isSystem != null) {
        this.setIsSystem(options.isSystem);
      }
      if (options.isRequired != null) {
        this.setIsRequired(options.isRequired);
      }
      if (options.type != null) {
        this.setFieldType(options.type);
      }
      if (options.size != null) {
        this.setFieldSize(options.size);
      }
      if (options.name != null) {
        this.setFieldName(options.name);
      }
      if (options.alias != null) {
        this.setForeignName(options.alias);
      }
      if (options.defaultValue != null) {
        this.setDefaultValue(options.defaultValue);
      }
    } else {
      this.autoRelease = false;
      this.handle = handle;
    }
  }
  Object.assign(PIEFieldInfo.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    /**
     * 删除字段对象
     * @memberOf FieldInfo#
     */
    dispose: function dispose() {
      Module._FieldInfo_Delete(this.handle);
    },
    /**
     * 设置是否是系统字段
     * @param {Boolean} isSystem -是否是系统字段
     * @memberOf FieldInfo#
     */
    setIsSystem: function setIsSystem(isSystem) {
      Module._Field_SetIsSystem(this.handle, isSystem);
    },
    /**
     * 获取是否是系统字段
     * @memberOf FieldInfo#
     * @returns {Boolean} 是系统字段返回true，否则返回false
     */
    getIsSystem: function getIsSystem() {
      return Boolean(Module._Field_GetIsSystem(this.handle));
    },
    /**
     * 设置是否是必输字段
     * @param {Boolean} isRequired -是否是必输字段
     * @memberOf FieldInfo#
     */
    setIsRequired: function setIsRequired(isRequired) {
      Module._Field_SetIsRequired(this.handle, isRequired);
    },
    /**
     * 获取是否是必输字段
     * @memberOf FieldInfo#
     * @returns {Boolean} 是必输字段返回true，否则返回false
     */
    getIsRequired: function getIsRequired() {
      return Boolean(Module._Field_GetIsRequired(this.handle));
    },
    /**
     * 设置字段类型
     * @param {PIEFieldType} fieldType -字段类型
     * @memberOf FieldInfo#
     */
    setFieldType: function setFieldType(fieldType) {
      Module._Field_SetFieldType(this.handle, fieldType);
    },
    /**
     * 获取字段类型
     * @memberOf FieldInfo#
     * @returns {PIEFieldType} 字段类型
     */
    getFieldType: function getFieldType() {
      return Module._Field_GetFieldType(this.handle);
    },
    /**
     * 设置字段内存空间大小
     * @param {int} fieldSize -字段内存空间大小
     * @memberOf FieldInfo#
     */
    setFieldSize: function setFieldSize(fieldSize) {
      Module._Field_SetFieldSize(this.handle, fieldSize);
    },
    /**
     * 获取字段内存空间大小
     * @memberOf FieldInfo#
     * @returns {int} 字段内存空间大小
     */
    getFieldSize: function getFieldSize() {
      return Module._Field_GetFieldSize(this.handle);
    },
    /**
     * 设置字段名
     * @param {String} fieldName -字段名
     * @memberOf FieldInfo#
     */
    setFieldName: function setFieldName(fieldName) {
      var strName = new PIEString$1(fieldName);
      Module._Field_SetFieldName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取字段名
     * @memberOf FieldInfo#
     * @returns {String} 字段名
     */
    getFieldName: function getFieldName() {
      var strName = new PIEString$1(256);
      Module._Field_GetFieldName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置字段别名
     * @param {String} foreignName -字段别名
     * @memberOf FieldInfo#
     */
    setForeignName: function setForeignName(foreignName) {
      var strName = new PIEString$1(foreignName);
      Module._Field_SetForeignName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取字段别名
     * @memberOf FieldInfo#
     * @returns {String} 字段别名
     */
    getForeignName: function getForeignName() {
      var strName = new PIEString$1(256);
      Module._Field_GetForeignName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置字段默认值
     * @param {String} value -字段默认值
     * @memberOf FieldInfo#
     */
    setDefaultValue: function setDefaultValue(value) {
      var strValue = new PIEString$1(value);
      Module._Field_SetDefaultValue(this.handle, strValue.getHandle());
      strValue.dispose();
    },
    /**
     * 获取字段默认值
     * @memberOf FieldInfo#
     * @returns {String} 字段默认值
     */
    getDefaultValue: function getDefaultValue() {
      var strValue = new PIEString$1(256);
      Module._Field_GetDefaultValue(this.handle, strValue.getHandle());
      var value = strValue.toString();
      strValue.dispose();
      return value;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 几何要素类操作函数
   * @name Feature
   * @class Feature
   *
   * @example
   * let feature = new PIE.Feature();
   */
  function PIEFeature(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Feature_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEFeature.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放矢量要素对象
     * @memberOf Feature#
     *
     */
    dispose: function dispose() {
      Module._Feature_Delete(this.handle);
    },
    /**
     * 设置几何对象Id
     * @param {Number} id -几何对象id，为正整数
     * @memberOf Feature#
     */
    setId: function setId(id) {
      Module._Feature_SetID(this.handle, id);
    },
    /**
     * 获取几何对象ID
     *
     * @memberOf Feature#
     * @returns {Number} 如果成功返回几何对象Id,失败返回0
     *
     */
    getId: function getId() {
      return Module._Feature_GetID(this.handle);
    },
    /**
     * 设置几何对象
     * @param {PIEGeometry} geometry -几何对象
     * @memberOf Feature#
     */
    setGeometry: function setGeometry(geometry) {
      Module._Feature_SetGeometry(this.handle, geometry.getHandle());
    },
    /**
     * 获取几何对象
     *
     * @memberOf Feature#
     * @returns {PIEGeometry} 如果获取成功返回几何对象，否则返回NULL
     *
     */
    getGeometry: function getGeometry() {
      var handle = Module._Feature_GetGeometry(this.handle);
      if (handle) {
        return PIEGeometryFactory.CreateInstance(handle);
      }
      return null;
    },
    /**
     * 设置是否自动释放几何对象
     * @param {Boolean} release -是否自动释放几何对象
     * @memberOf Feature#
     *
     */
    setAutoReleaseGeometry: function setAutoReleaseGeometry(release) {
      Module._Feature_SetAutoReleaseGeometry(this.handle, release);
    },
    /**
     * 获取是否自动释放几何对象
     *
     * @memberOf Feature#
     * @returns {Boolean} 如果是自动释放几何对象返回true，否则返回false
     *
     */
    isAutoReleaseGeometry: function isAutoReleaseGeometry() {
      return Boolean(Module._Feature_IsAutoReleaseGeometry(this.handle));
    },
    /**
     * 获取要素中的字符集
     *
     * @memberOf Feature#
     * @returns {PIECharsetType} 返回字符集
     *
     */
    getCharset: function getCharset() {
      return Module._Feature_GetCharset(this.handle);
    },
    /**
     * 设置要素中的字符集
     * @param {PIECharsetType} charset -字符集
     * @memberOf Feature#
     *
     */
    setCharset: function setCharset(charset) {
      Module._Feature_SetCharset(this.handle, charset);
    },
    /**
     * 添加字段
     * @param {PIEFieldInfo} fieldInfo -字段信息对象
     * @memberOf Feature#
     *
     */
    addField: function addField(fieldInfo) {
      Module._Feature_AddField(this.handle, fieldInfo.getHandle());
    },
    /**
     * 已知字段为Boolean类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Boolean} value -字段值，默认是false
     * @memberOf Feature#
     *
     */
    setBoolAt: function setBoolAt(fieldIndex, value) {
      Boolean(Module._Feature_SetBool(this.handle, fieldIndex, value));
    },
    /**
     * 已知字段为Boolean类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Boolean} value -字段值，默认是false
     * @memberOf Feature#
     *
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setBool: function setBool(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var res = Module._Feature_FieldSetBool(this.handle, strFieldName.getHandle(), value);
      strFieldName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为Boolean类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     *
     * @returns {Boolean} 返回bool类型字段值
     *
     *
     */
    getBoolAt: function getBoolAt(fieldIndex) {
      return Boolean(Module._Feature_GetBool(this.handle, fieldIndex));
    },
    /**
     * 已知字段为Boolean类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Boolean} 返回Boolean类型字段值
     *
     *
     */
    getBool: function getBool(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var field = Module._Feature_FieldGetBool(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
      return Boolean(field);
    },
    /**
     * 已知字段为byte类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Number} value -字段值
     * @memberOf Feature#
     *
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setByteAt: function setByteAt(fieldIndex, value) {
      return Boolean(Module._Feature_SetByte(this.handle, fieldIndex, value));
    },
    /**
     * 已知字段为byte类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setByte: function setByte(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var res = Module._Feature_FieldSetByte(this.handle, strFieldName.getHandle(), value);
      strFieldName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为byte类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Number} 返回byte类型字段值
     *
     */
    getByteAt: function getByteAt(fieldIndex) {
      return Module._Feature_GetByte(this.handle, fieldIndex);
    },
    /**
     * 已知字段为byte类型，根据字段名获取字段值
     * @param {String} fieldName -字段序号
     * @memberOf Feature#
     * @returns {Number} 返回byte类型字段值
     */
    getByte: function getByte(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var field = Module._Feature_FieldGetByte(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
      return field;
    },
    /**
     * 已知字段为short类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Number} value -字段值
     * @memberOf Feature#
     *
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setINT16At: function setINT16At(fieldIndex, value) {
      return Boolean(Module._Feature_SetINT16(this.handle, fieldIndex, value));
    },
    /**
     * 已知字段为short类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Number} value -字段值
     * @memberOf Feature#
     *
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setINT16: function setINT16(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var res = Module._Feature_FieldSetINT16(this.handle, strFieldName.getHandle(), value);
      strFieldName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为short类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Number} 返回short类型字段值
     *
     */
    getINT16At: function getINT16At(fieldIndex) {
      return Module._Feature_GetINT16(this.handle, fieldIndex);
    },
    /**
     * 已知字段为short类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Number} 返回short类型字段值
     *
     */
    getINT16: function getINT16(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var field = Module._Feature_FieldGetINT16(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
      return field;
    },
    /**
     * 已知字段为int类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setINT32At: function setINT32At(fieldIndex, value) {
      return Boolean(Module._Feature_SetINT32(this.handle, fieldIndex, value));
    },
    /**
     * 已知字段为int类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setINT32: function setINT32(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var res = Module._Feature_FieldSetINT32(this.handle, strFieldName.getHandle(), value);
      strFieldName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为int类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Number} 返回int类型字段值
     *
     */
    getINT32At: function getINT32At(fieldIndex) {
      return Module._Feature_GetINT32(this.handle, fieldIndex);
    },
    /**
     * 已知字段为int类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Number} 返回int类型字段值
     *
     */
    getINT32: function getINT32(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var field = Module._Feature_FieldGetINT32(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
      return field;
    },
    /**
     * 已知字段为long类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setINT64At: function setINT64At(fieldIndex, value) {
      return Boolean(Module._Feature_SetINT64(this.handle, fieldIndex, value));
    },
    /**
     * 已知字段为long类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setINT64: function setINT64(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var res = Module._Feature_FieldSetINT64(this.handle, strFieldName.getHandle(), value);
      strFieldName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为long类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Number} 返回long类型字段值
     *
     *
     */
    getINT64At: function getINT64At(fieldIndex) {
      return Module._Feature_GetINT64(this.handle, fieldIndex);
    },
    /**
     * 已知字段为long类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Number} 返回long类型字段值
     *
     */
    getINT64: function getINT64(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var field = Module._Feature_FieldGetINT64(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
      return field;
    },
    /**
     * 已知字段为float类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setFloatAt: function setFloatAt(fieldIndex, value) {
      return Boolean(Module._Feature_SetFloat(this.handle, fieldIndex, value));
    },
    /**
     * 已知字段为float类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setFloat: function setFloat(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var res = Module._Feature_FieldSetFloat(this.handle, strFieldName.getHandle(), value);
      strFieldName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为float类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Number} 返回float类型字段值
     *
     */
    getFloatAt: function getFloatAt(fieldIndex) {
      return Module._Feature_GetFloat(this.handle, fieldIndex);
    },
    /**
     * 已知字段为float类型，根据字段名获取字段值
     *  @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Number} 返回float类型字段值
     *
     */
    getFloat: function getFloat(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var field = Module._Feature_FieldGetFloat(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
      return field;
    },
    /**
     * 已知字段为double类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setDoubleAt: function setDoubleAt(fieldIndex, value) {
      return Boolean(Module._Feature_SetDouble(this.handle, fieldIndex, value));
    },
    /**
     * 已知字段为double类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Number} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setDouble: function setDouble(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var res = Module._Feature_FieldSetDouble(this.handle, strFieldName.getHandle(), value);
      strFieldName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为double类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Number} 返回double类型字段值
     *
     */
    getDoubleAt: function getDoubleAt(fieldIndex) {
      return Module._Feature_GetDouble(this.handle, fieldIndex);
    },
    /**
     * 已知字段为double类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Number} 返回double类型字段值
     *
     */
    getDouble: function getDouble(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var field = Module._Feature_FieldGetDouble(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
      return field;
    },
    /**
     * 已知字段为time类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Date} time -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setTimeAt: function setTimeAt(fieldIndex, time) {
      if (time instanceof Date) {
        var timeArray = [time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), time.getMinutes(), time.getSeconds()];
        var arrayTime = new PIEArray(timeArray, PIEArrayType.Int32);
        var res = Module._Feature_SetTime(this.handle, fieldIndex, arrayTime.getHandle());
        arrayTime.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 已知字段为time类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Date} time -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setTime: function setTime(fieldName, time) {
      if (time instanceof Date) {
        var timeArray = [time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), time.getMinutes(), time.getSeconds()];
        var strField = new PIEString$1(fieldName);
        var arrayTime = new PIEArray(timeArray, PIEArrayType.Int32);
        var res = Module._Feature_FieldSetTime(this.handle, strField.getHandle(), arrayTime.getHandle());
        arrayTime.dispose();
        strField.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 已知字段为time类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Date} 返回Date类型字段值
     *
     */
    getTimeAt: function getTimeAt(fieldIndex) {
      var arrayFiled = new PIEArray(6, PIEArrayType.Int32);
      Module._Feature_GetTime(this.handle, fieldIndex, arrayFiled.getHandle());
      var dateArray = arrayFiled.toArray();
      var date = new Date(dateArray[0], dateArray[1], dateArray[2], dateArray[3], dateArray[4], dateArray[5]);
      arrayFiled.dispose();
      return date;
    },
    /**
     * 已知字段为time类型，根据字段名获取字段值
     *  @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Date} 返回Date类型字段值
     *
     */
    getTime: function getTime(fieldName) {
      if (fieldName != null) {
        var strFieldName = new PIEString$1(fieldName);
        var arrayTime = new PIEArray(6, PIEArrayType.Int32);
        Module._Feature_FieldGetTime(this.handle, strFieldName.getHandle(), arrayTime.getHandle());
        arrayTime.updateData();
        var dataTime = arrayTime.toArray();
        var date = new Date(dataTime[0], dataTime[1], dataTime[2], dataTime[3], dataTime[4], dataTime[5]);
        arrayTime.dispose();
        strFieldName.dispose();
        return date;
      }
      return null;
    },
    /**
     * 已知字段为Date类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Date} time -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setDateAt: function setDateAt(fieldIndex, time) {
      if (time instanceof Date) {
        var timeArray = [time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), time.getMinutes(), time.getSeconds()];
        var arrayTime = new PIEArray(timeArray, PIEArrayType.Int32);
        var res = Module._Feature_SetDate(this.handle, fieldIndex, arrayTime.getHandle());
        arrayTime.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 已知字段为date类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Date} time -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setDate: function setDate(fieldName, time) {
      if (time instanceof Date) {
        var timeArray = [time.getFullYear(), time.getMonth(), time.getDate(), time.getHours(), time.getMinutes(), time.getSeconds()];
        var strField = new PIEString$1(fieldName);
        var arrayTime = new PIEArray(timeArray, PIEArrayType.Int32);
        var res = Module._Feature_FieldSetDate(this.handle, strField.getHandle(), arrayTime.getHandle());
        arrayTime.dispose();
        strField.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 已知字段为date类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Date} 返回Date类型字段值
     *
     */
    getDateAt: function getDateAt(fieldIndex) {
      var arrayFiled = new PIEArray(6, PIEArrayType.Int32);
      Module._Feature_GetDate(this.handle, fieldIndex, arrayFiled.getHandle());
      var dateArray = arrayFiled.toArray();
      var date = new Date(dateArray[0], dateArray[1], dateArray[2], dateArray[3], dateArray[4], dateArray[5]);
      arrayFiled.dispose();
      return date;
    },
    /**
     * 已知字段为date类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Date} 返回Date类型字段值
     *
     */
    getDate: function getDate(fieldName) {
      if (fieldName != null) {
        var strFieldName = new PIEString$1(fieldName);
        var arrayTime = new PIEArray(6, PIEArrayType.Int32);
        Module._Feature_FieldGetDate(this.handle, strFieldName.getHandle(), arrayTime.getHandle());
        arrayTime.updateData();
        var dataTime = arrayTime.toArray();
        var date = new Date(dataTime[0], dataTime[1], dataTime[2], dataTime[3], dataTime[4], dataTime[5]);
        arrayTime.dispose();
        strFieldName.dispose();
        return date;
      }
      return null;
    },
    /**
     * 已知字段为binary类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {Array} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setBinaryAt: function setBinaryAt(fieldIndex, value) {
      var length = value.length;
      var strValue = new PIEArray(value, PIEArrayType.UInt8);
      var res = Module._Feature_SetBinary(this.handle, fieldIndex, strValue.getHandle(), length);
      strValue.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为binary类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {Array} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setBinary: function setBinary(fieldName, value) {
      if (fieldName != null && value != null) {
        var length = value.length;
        var strFieldName = new PIEString$1(fieldName);
        var strValue = new PIEArray(value, PIEArrayType.UInt8);
        var res = Module._Feature_FieldSetBinary(this.handle, strFieldName.getHandle(), strValue.getHandle(), length);
        strFieldName.dispose();
        strValue.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 已知字段为binary类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段序号
     * @memberOf Feature#
     * @returns {Array} 返回字段值
     *
     */
    getBinaryAt: function getBinaryAt(fieldIndex) {
      var arrValue = new PIEArray(1024, PIEArrayType.UInt8);
      Module._Feature_GetBinary(this.handle, fieldIndex, arrValue.getHandle());
      arrValue.updateData();
      var fieldData = arrValue.toArray();
      arrValue.dispose();
      return fieldData;
    },
    /**
     * 已知字段为binary类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {Array} 返回字段值
     *
     */
    getBinary: function getBinary(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var arrValue = new PIEArray(1024, PIEArrayType.UInt8);
      Module._Feature_FieldGetBinary(this.handle, strFieldName.getHandle(), arrValue.getHandle());
      arrValue.updateData();
      strFieldName.dispose();
      var fieldData = arrValue.toArray();
      arrValue.dispose();
      return fieldData;
    },
    /**
     * 已知字段为string类型，根据字段序号设置字段值
     * @param {Number} fieldIndex -字段序号
     * @param {String} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setStringAt: function setStringAt(fieldIndex, value) {
      var strValue = new PIEString$1(value);
      var res = Module._Feature_SetString(this.handle, fieldIndex, strValue.getHandle());
      strValue.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为string类型，根据字段名设置字段值
     * @param {String} fieldName -字段名
     * @param {String} value -字段值
     * @memberOf Feature#
     * @returns {Boolean} 如果设置成功返回true，设置失败返回false
     *
     */
    setString: function setString(fieldName, value) {
      var strFieldName = new PIEString$1(fieldName);
      var strValue = new PIEString$1(value);
      var res = Module._Feature_FieldSetString(this.handle, strFieldName.getHandle(), strValue.getHandle());
      strFieldName.dispose();
      strValue.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为string类型，根据字段序号获取字段值
     * @param {Number} fieldIndex -字段符号
     * @memberOf Feature#
     * @returns {String} 返回string类型字段值
     *
     */
    getStringAt: function getStringAt(fieldIndex) {
      var strValue = new PIEString$1(16);
      Module._Feature_GetString(this.handle, fieldIndex, strValue.getHandle());
      var value = strValue.toString();
      strValue.dispose();
      return value;
    },
    /**
     * 已知字段为string类型，根据字段名获取字段值
     * @param {String} fieldName -字段名
     * @memberOf Feature#
     * @returns {String} 返回String类型字段值
     *
     */
    getString: function getString(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      var strValue = new PIEString$1(256);
      Module._Feature_FieldGetString(this.handle, strFieldName.getHandle(), strValue.getHandle());
      var value = strValue.toString();
      strValue.dispose();
      strFieldName.dispose();
      return value;
    },
    /**
     * 获取字段个数
     *
     * @memberOf Feature#
     * @returns {Number} 如果成功返回字段个数，否则返回0
     */
    getFieldCount: function getFieldCount() {
      return Module._Feature_GetFieldCount(this.handle);
    },
    /**
     * 根据索引获取数据集字段信息
     * @param {Number} index -字段索引
     * @memberOf Feature#
     * @returns {PIEFieldInfo} 返回字段信息对象
     */
    getFieldInfoAt: function getFieldInfoAt(index) {
      var handle = Module._Feature_GetFieldInfoAt(this.handle, index);
      var field = new PIEFieldInfo({
        handle: handle
      });
      return field;
    },
    /**
     * 生成JSON对象
     * @param {PIESpatialReference} spatialReference -坐标系统
     * @memberOf Feature#
     * @returns {Object} 返回JSON对象
     *
     */
    toGeoJSON: function toGeoJSON(spatialReference) {
      var properties = {};
      var fieldCount = this.getFieldCount();
      for (var i = 0; i < fieldCount; i++) {
        var fieldInfo = this.getFieldInfoAt(i);
        var name = fieldInfo.getFieldName();
        var value = "";
        if (fieldInfo.getFieldType() == PIE.FieldType.INT16) {
          value = this.getINT16(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.INT32) {
          value = this.getINT32(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.INT64) {
          value = this.getINT64(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.Text) {
          value = this.getString(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.Float) {
          value = this.getFloat(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.Double) {
          value = this.getDouble(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.Boolean) {
          value = this.getBool(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.Date) {
          value = this.getDate(name);
        } else if (fieldInfo.getFieldType() == PIE.FieldType.Time) {
          value = this.getTime(name);
        }
        properties[name] = value;
      }
      var geoPoints = [];
      if (this.getGeometry()) {
        var geometry = this.getGeometry();
        if (this.getGeometry().getType() == PIE.GeometryType.Point) {
          var point = geometry.getPoint();
          if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
            geoPoints.push(point.x);
            geoPoints.push(point.y);
          } else {
            var temppoint = spatialReference.inverse(point);
            geoPoints.push(temppoint.x);
            geoPoints.push(temppoint.y);
          }
          return {
            "type": "FeatureCollection",
            "features": [{
              "type": "Feature",
              "properties": properties,
              "geometry": {
                "type": "Point",
                "coordinates": geoPoints
              }
            }]
          };
        } else if (this.getGeometry().getType() == PIE.GeometryType.Line) {
          var subCount = geometry.getSubCount();
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var points = geometry.getPoints(subIndex);
            var subPointCount = geometry.getSubPointCount(subIndex);
            for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
              if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
                var Point = [];
                Point.push(points[numIndex].x);
                Point.push(points[numIndex].y);
                geoPoints.push(Point);
              } else {
                var temppoint = spatialReference.inverse(points[numIndex]);
                var _Point = [];
                _Point.push(temppoint.x);
                _Point.push(temppoint.y);
                geoPoints.push(_Point);
              }
            }
          }
          return {
            "type": "FeatureCollection",
            "features": [{
              "type": "Feature",
              "properties": properties,
              "geometry": {
                "type": "LineString",
                "coordinates": geoPoints
              }
            }]
          };
        } else if (this.getGeometry().getType() == PIE.GeometryType.Region) {
          var subCount = geometry.getSubCount();
          var subpoint = [];
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var points = geometry.getPoints(subIndex);
            var subPointCount = geometry.getSubPointCount(subIndex);
            for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
              if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
                var _Point2 = [];
                _Point2.push(points[numIndex].x);
                _Point2.push(points[numIndex].y);
                subpoint.push(_Point2);
              } else {
                var temppoint = spatialReference.inverse(points[numIndex]);
                var _Point3 = [];
                _Point3.push(temppoint.x);
                _Point3.push(temppoint.y);
                subpoint.push(_Point3);
              }
            }
          }
          geoPoints.push(subpoint);
          return {
            "type": "FeatureCollection",
            "features": [{
              "type": "Feature",
              "properties": properties,
              "geometry": {
                "type": "Polygon",
                "coordinates": geoPoints
              }
            }]
          };
        }
        if (this.getGeometry().getType() == PIE.GeometryType.Point3D) {
          var point = geometry.getPoint();
          if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
            geoPoints.push(point.x);
            geoPoints.push(point.y);
            geoPoints.push(point.z);
          } else {
            var pointsrc = [];
            pointsrc.push(point.x);
            pointsrc.push(point.y);
            var temppoint = spatialReference.inverse(pointsrc);
            geoPoints.push(temppoint[0]);
            geoPoints.push(temppoint[1]);
            geoPoints.push(point.z);
          }
          return {
            "type": "FeatureCollection",
            "features": [{
              "type": "Feature",
              "properties": properties,
              "geometry": {
                "type": "Point3D",
                "coordinates": geoPoints
              }
            }]
          };
        } else if (this.getGeometry().getType() == PIE.GeometryType.Line3D) {
          var subCount = geometry.getSubCount();
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var points = geometry.getPoints(subIndex);
            var subPointCount = geometry.getSubPointCount(subIndex);
            for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
              if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
                var _Point4 = [];
                _Point4.push(points[numIndex].x);
                _Point4.push(points[numIndex].y);
                _Point4.push(points[numIndex].z);
                geoPoints.push(_Point4);
              } else {
                var temppoint = spatialReference.inverse(points[numIndex]);
                var _Point5 = [];
                _Point5.push(temppoint.x);
                _Point5.push(temppoint.y);
                _Point5.push(temppoint.z);
                geoPoints.push(_Point5);
              }
            }
          }
          return {
            "type": "FeatureCollection",
            "features": [{
              "type": "Feature",
              "properties": properties,
              "geometry": {
                "type": "LineString3D",
                "coordinates": geoPoints
              }
            }]
          };
        } else if (this.getGeometry().getType() == PIE.GeometryType.Region3D) {
          var subCount = geometry.getSubCount();
          var subpoint = [];
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var points = geometry.getPoints(subIndex);
            var subPointCount = geometry.getSubPointCount(subIndex);
            for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
              if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
                var _Point6 = [];
                _Point6.push(points[numIndex].x);
                _Point6.push(points[numIndex].y);
                _Point6.push(points[numIndex].z);
                subpoint.push(_Point6);
              } else {
                var temppoint = spatialReference.inverse(points[numIndex]);
                var _Point7 = [];
                _Point7.push(temppoint.x);
                _Point7.push(temppoint.y);
                _Point7.push(temppoint.z);
                subpoint.push(_Point7);
              }
            }
          }
          geoPoints.push(subpoint);
          return {
            "type": "FeatureCollection",
            "features": [{
              "type": "Feature",
              "properties": properties,
              "geometry": {
                "type": "Polygon3D",
                "coordinates": geoPoints
              }
            }]
          };
        } else {
          return {
            "type": "Feature",
            "geometry": {
              "type": "UnKnow"
            }
          };
        }
      } else {
        return null;
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 矢量记录集操作函数
   * @name FeatureSet
   */
  function PIEFeatureSet(handle, autuRelease) {
    this.handle = handle;
    this.autoRelease = autuRelease;
  }
  Object.assign(PIEFeatureSet.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 判断当前记录指针是否指向记录集中最后一个记录之后
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果指向最后一条记录返回true，否则返回false
     */
    isEOF: function isEOF() {
      return Boolean(Module._FeatureSet_IsEOF(this.handle));
    },
    /**
     * 移动记录指针到第一条记录
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    moveFirst: function moveFirst() {
      return Boolean(Module._FeatureSet_MoveFirst(this.handle));
    },
    /**
     * 移动记录指针到下一条记录
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    moveNext: function moveNext() {
      return Boolean(Module._FeatureSet_MoveNext(this.handle));
    },
    /**
     * 移动记录指针到末尾记录
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    moveLast: function moveLast() {
      return Boolean(Module._FeatureSet_MoveLast(this.handle));
    },
    /**
     * 移动记录指针到指定位置
     * @param {Number} row -记录集行号
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    moveTo: function moveTo(row) {
      return Boolean(Module._FeatureSet_MoveTo(this.handle, row));
    },
    /**
     * 获取记录个数
     *
     * @memberOf FeatureSet#
     * @returns {Number} 成功返回记录集个数，否则返回0
     */
    getFeatureCount: function getFeatureCount() {
      return Module._FeatureSet_GetFeatureCount(this.handle);
    },
    /**
     * 获取当前记录的ID
     *
     * @memberOf FeatureSet#
     * @returns {Number} 成功返回当前记录的ID
     */
    getID: function getID() {
      return Module._FeatureSet_GetID(this.handle);
    },
    /**
     * 获取当前记录的几何对象
     *
     * @memberOf FeatureSet#
     * @returns {PIEGeometry} 如果成功返回几何对象，否则返回NULL
     */
    getGeometry: function getGeometry() {
      var handle = Module._FeatureSet_GetGeometry(this.handle);
      if (handle) {
        return PIEGeometryFactory.CreateInstance(handle);
      }
      return null;
    },
    /**
     * 设置当前记录的几何对象
     * @param {PIEGeometry} geometry -几何对象
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setGeometry: function setGeometry(geometry) {
      return Boolean(Module._FeatureSet_SetGeometry(this.handle, geometry.getHandle()));
    },
    /**
     * 添加几何对象
     * @param {PIEGeometry} geometry -几何对象
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    addNew: function addNew(geometry) {
      return Boolean(Module._FeatureSet_AddNew(this.handle, geometry.getHandle()));
    },
    /**
     * 删除当前记录
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    "delete": function _delete() {
      return Boolean(Module._FeatureSet_Delete(this.handle));
    },
    /**
     * 删除所有记录
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    deleteAll: function deleteAll() {
      return Boolean(Module._FeatureSet_DeleteAll(this.handle));
    },
    /**
     * 开始编辑
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    edit: function edit() {
      return Boolean(Module._FeatureSet_Edit(this.handle));
    },
    // /**
    //  * 开始编辑，批量更新
    //  * @param {Boolean} editBulkPoerate -是否批量更新
    //  *
    //  * @memberOf FeatureSet#
    //  * @returns {Boolean} 如果成功返回true，否则返回false
    //  */
    // editBulk: function (editBulkPoerate) {
    //     return Module._FeatureSet_EditBulk(this.handle, editBulkPoerate);
    // },

    /**
     * 提交更新
     *
     * @memberOf FeatureSet#
     * @returns {Number} 如果成功则返回更新对象的ID，否则返回0
     */
    update: function update() {
      return Module._FeatureSet_Update(this.handle);
    },
    /**
     * 获取要素集对应的数据集
     *
     * @memberOf FeatureSet#
     * @returns {PIEFeatureDataset} 如果成功则返回数据集对象，否则返回NULL
     */
    getDataset: function getDataset() {
      var hDataset = Module._FeatureSet_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(hDataset);
    },
    /**
     * 获取数据集中某行特征要素
     *
     * @memberOf FeatureSet#
     * @returns {PIEFeature} 如果成功则返回要素对象，否则返回NULL
     */
    getFeature: function getFeature() {
      var handle = Module._FeatureSet_GetFeature(this.handle);
      if (handle) {
        return new PIEFeature(handle);
      }
      return null;
    },
    /**
     * 获取字段个数
     *
     * @memberOf FeatureSet#
     * @returns {Number} 如果成功返回字段个数，否则返回0
     */
    getFieldCount: function getFieldCount() {
      return Module._FeatureSet_GetFieldCount(this.handle);
    },
    /**
     * 已知字段为bool类型，根据字段名获取字段值
     * @param {String} name -字段名称
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 字段值为真返回true，为假返回false
     */
    getFieldValueBool: function getFieldValueBool(name) {
      var strName = new PIEString$1(name);
      var value = Module._FeatureSet_GetFieldValueBool(this.handle, strName.getHandle());
      strName.dispose();
      return Boolean(value);
    },
    /**
     * 已知字段为bool类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {Boolean} val -字段值，默认为false
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueBool: function setFieldValueBool(name, val) {
      var strName = new PIEString$1(name);
      var res = Module._FeatureSet_SetFieldValueBool(this.handle, strName.getHandle(), val);
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为Byte类型，根据字段名获取字段值
     * @param {String} name -字段名称
     *
     * @memberOf FeatureSet#
     * @returns {Number} 返回Byte型字段值
     */
    getFieldValueByte: function getFieldValueByte(name) {
      var strName = new PIEString$1(name);
      var FieldValue = Module._FeatureSet_GetFieldValueByte(this.handle, strName.getHandle());
      strName.dispose();
      return FieldValue;
    },
    /**
     * 已知字段为Byte类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {Number} val -字段值，默认为0
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueByte: function setFieldValueByte(name, val) {
      var strName = new PIEString$1(name);
      var res = Module._FeatureSet_SetFieldValueByte(this.handle, strName.getHandle(), val);
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为int16类型，根据字段名获取字段值
     * @param {String} name -字段名称
     *
     * @memberOf FeatureSet#
     * @returns {Number} 返回int型字段值
     */
    getFieldValueInt16: function getFieldValueInt16(name) {
      var strName = new PIEString$1(name);
      var value = Module._FeatureSet_GetFieldValueInt16(this.handle, strName.getHandle());
      strName.dispose();
      return value;
    },
    /**
     * 已知字段为int16类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {Number} val -字段值，默认为0
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueInt16: function setFieldValueInt16(name, val) {
      var strName = new PIEString$1(name);
      var res = Module._FeatureSet_SetFieldValueInt16(this.handle, strName.getHandle(), val);
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为int32类型，根据字段名获取字段值
     * @param {String} name -字段名称
     *
     * @memberOf FeatureSet#
     * @returns {Number} 返回int型字段值
     */
    getFieldValueInt32: function getFieldValueInt32(name) {
      var strName = new PIEString$1(name);
      var FieldValue = Module._FeatureSet_GetFieldValueInt32(this.handle, strName.getHandle());
      strName.dispose();
      return FieldValue;
    },
    /**
     * 已知字段为int32类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {Number} val -字段值，默认为0
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueInt32: function setFieldValueInt32(name, val) {
      var strName = new PIEString$1(name);
      var res = Module._FeatureSet_SetFieldValueInt32(this.handle, strName.getHandle(), val);
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为long类型，根据字段名获取字段值
     * @param {String} name -字段名称
     *
     * @memberOf FeatureSet#
     * @returns {Number} 返回long型字段值
     */
    getFieldValueInt64: function getFieldValueInt64(name) {
      var strName = new PIEString$1(name);
      var value = Module._FeatureSet_GetFieldValueInt64(this.handle, strName.getHandle());
      strName.dispose();
      return value;
    },
    /**
     * 已知字段为long类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {Number} val -字段值，默认为0
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueInt64: function setFieldValueInt64(name, val) {
      var strName = new PIEString$1(name);
      var res = Module._FeatureSet_SetFieldValueInt64(this.handle, strName.getHandle(), val);
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为double类型，根据字段名获取字段值
     * @param {String} name -字段名称
     *
     * @memberOf FeatureSet#
     * @returns {Number} 返回double型字段值
     */
    getFieldValueDouble: function getFieldValueDouble(name) {
      var strName = new PIEString$1(name);
      var value = Module._FeatureSet_GetFieldValueDouble(this.handle, strName.getHandle());
      strName.dispose();
      return value;
    },
    /**
     * 已知字段为double类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {Number} val -字段值，默认为false
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueDouble: function setFieldValueDouble(name, val) {
      var strName = new PIEString$1(name);
      var res = Module._FeatureSet_SetFieldValueDouble(this.handle, strName.getHandle(), val);
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为float类型，根据字段名获取字段值
     * @param {String} name -字段名称
     *
     * @memberOf FeatureSet#
     * @returns {Number} 返回float型字段值
     */
    getFieldValueFloat: function getFieldValueFloat(name) {
      var strName = new PIEString$1(name);
      var value = Module._FeatureSet_GetFieldValueFloat(this.handle, strName.getHandle());
      strName.dispose();
      return value;
    },
    /**
     * 已知字段为float类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {Number} val -字段值，默认为0
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueFloat: function setFieldValueFloat(name, val) {
      var strName = new PIEString$1(name);
      var res = Module._FeatureSet_SetFieldValueFloat(this.handle, strName.getHandle(), val);
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 已知字段为string类型，根据字段名获取字段值
     * @param {String} name -字段名称
     * @param {Number} length -字段值长度(非必填项，默认为512，如果字段值长度大于512，可以进行传参说明)
     * @memberOf FeatureSet#
     * @returns {String} 字段值为真返回true，为假返回false
     */
    getFieldValueString: function getFieldValueString(name, length) {
      if (!length) {
        length = 512;
      }
      var strName = new PIEString$1(name);
      var Name = new PIEString$1(length);
      Module._FeatureSet_GetFieldValueString(this.handle, strName.getHandle(), Name.getHandle());
      var FieldValue = Name.toString();
      Name.dispose();
      strName.dispose();
      return FieldValue;
    },
    /**
     * 已知字段为string类型，根据字段名设置字段值
     * @param {String} name -字段名称
     * @param {String} val -字段值
     *
     * @memberOf FeatureSet#
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    setFieldValueString: function setFieldValueString(name, val) {
      var strName = new PIEString$1(name);
      var strVal = new PIEString$1(val);
      var res = Module._FeatureSet_SetFieldValueString(this.handle, strName.getHandle(), strVal.getHandle());
      strName.dispose();
      strVal.dispose();
      return Boolean(res);
    },
    fromGeojson: function fromGeojson(featureSetGeojson) {
      var geometryJson = featureSetGeojson.geometry;
      var coordinates = geometryJson.coordinates;
      var type = geometryJson.type;
      var bAddSucceed = false;
      var id = featureSetGeojson.id;
      this.editBulk(true);
      if (type == "Point") {
        var pointGeo = new PIE.Point({
          point: coordinates
        });
        pointGeo.setID(id);
        bAddSucceed = this.addNew(pointGeo);
        this.getGeometry();
        var id = pointGeo.getID();
      } else if (type == "Line") {
        var lineGeo = new PIE.polyline({
          point: coordinates
        });
        lineGeo.setID(id);
        bAddSucceed = this.addNew(lineGeo);
      } else if (type == "Region") {
        var regoinGeo = new PIE.Polygon({
          point: coordinates
        });
        regoinGeo.setID(id);
        bAddSucceed = this.addNew(regoinGeo);
      } else if (type == "Point3D") {
        var pointGeo3D = new PIE.Point3D({
          point: coordinates
        });
        pointGeo3D.setID(id);
        bAddSucceed = this.addNew(pointGeo3D);
      } else if (type == "Line3D") {
        var lineGeo3D = new PIE.polyline3D({
          point: coordinates
        });
        lineGeo3D.setID(id);
        bAddSucceed = this.addNew(lineGeo3D);
      } else if (type == "Region3D") {
        var regionGeo3D = new PIE.polyline3D({
          point: coordinates
        });
        regionGeo3D.setID(id);
        bAddSucceed = this.addNew(regionGeo3D);
      }
      if (bAddSucceed) {
        var featureDataset = this.getDataset();
        if (featureDataset) {
          var fieldCount = featureDataset.getFieldCount();
          var properties = featureSetGeojson.properties;
          for (var propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
            this.edit();
            for (var i = 0; i < fieldCount; i++) {
              var fieldInfo = featureDataset.getFieldInfoAt(i);
              var fieldName = fieldInfo.getFieldName();
              var fieldType = fieldInfo.getFieldType();
              if (fieldName == properties[propertyIndex].name) {
                if (fieldType == PIE.FieldType.INT16) {
                  this.setFieldValueInt16(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.INT32) {
                  this.setFieldValueInt32(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.INT64) {
                  this.setFieldValueInt64(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.Text) {
                  this.setFieldValueString(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.Boolean) {
                  this.setFieldValueBool(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.Float) {
                  this.setFieldValueFloat(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.Double) {
                  this.setFieldValueDouble(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.Date) {
                  this.setFieldValueString(fieldName, properties[propertyIndex].value);
                } else if (fieldType == PIE.FieldType.Time) {
                  this.setFieldValueString(fieldName, properties[propertyIndex].value);
                }
              }
            }
            this.update();
          }
        }
      }
      this.update();
      this.editBulk(false);
    },
    toGeojson: function toGeojson(spatialReference) {
      var feature = {
        "type": "Feature"
      };
      var properties = {};
      var id = this.getID();
      feature.id = id;
      var featureDataset = this.getDataset();
      if (featureDataset) {
        var fieldCount = featureDataset.getFieldCount();
        for (var i = 0; i < fieldCount; i++) {
          var fieldInfo = featureDataset.getFieldInfoAt(i);
          var name = fieldInfo.getFieldName();
          var value = "";
          fieldInfo.getFieldType();
          if (fieldInfo.getFieldType() == PIE.FieldType.INT16) {
            value = this.getFieldValueInt16(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.INT32) {
            value = this.getFieldValueInt32(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.INT64) {
            value = this.getFieldValueInt64(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.Text) {
            value = this.getFieldValueString(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.Float) {
            value = this.getFieldValueFloat(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.Double) {
            value = this.getFieldValueDouble(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.Boolean) {
            value = this.getFieldValueBool(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.Date) {
            value = this.getFieldValueString(name);
          } else if (fieldInfo.getFieldType() == PIE.FieldType.Time) {
            value = this.getFieldValueString(name);
          }
          properties[name] = value;
        }
        feature.properties = properties;
      }
      var coordinates = [];
      if (this.getGeometry()) {
        this.getGeometry().getType();
        var geometry = {};
        if (this.getGeometry().getType() == PIEGeometryType.Point) {
          geometry.type = "Point";
          var pointGeo = this.getGeometry();
          var point = pointGeo.getPoint();
          if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
            coordinates.push(point.x);
            coordinates.push(point.y);
          } else {
            var temppoint = spatialReference.inverse(point);
            coordinates.push(temppoint.x);
            coordinates.push(temppoint.y);
          }
          geometry.coordinates = coordinates;
        } else if (this.getGeometry().getType() == PIEGeometryType.Line) {
          geometry.type = "LineString";
          var polyLine = this.getGeometry();
          var subCount = polyLine.getSubCount();
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var points = polyLine.getPoints(subIndex);
            var subPointCount = polyLine.getSubPointCount(subIndex);
            for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
              if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
                var Point = [];
                Point.push(points[numIndex].x);
                Point.push(points[numIndex].y);
                coordinates.push(Point);
              } else {
                var temppoint = spatialReference.inverse(points[numIndex]);
                var _Point = [];
                _Point.push(temppoint.x);
                _Point.push(temppoint.y);
                coordinates.push(_Point);
              }
            }
          }
          geometry.coordinates = coordinates;
        } else if (this.getGeometry().getType() == PIEGeometryType.Region) {
          var polygon = this.getGeometry();
          var subCount = polygon.getSubCount();
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var points = polygon.getPoints(subIndex);
            var subPointCount = polygon.getSubPointCount(subIndex);
            var subpoint = [];
            for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
              if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
                var _Point2 = [];
                _Point2.push(points[numIndex].x);
                _Point2.push(points[numIndex].y);
                subpoint.push(_Point2);
              } else {
                var temppoint = spatialReference.inverse(points[numIndex]);
                var _Point3 = [];
                _Point3.push(temppoint.x);
                _Point3.push(temppoint.y);
                subpoint.push(_Point3);
              }
            }
            coordinates.push(subpoint);
          }
          geometry.type = "Polygon";
          geometry.coordinates = coordinates;
        } else if (this.getGeometry().getType() == PIEGeometryType.MultiRegion) {
          geometry.type = "MultiPolygon";
          var fluag = 0;
          var Multipoint = [];
          var MultiRegion = this.getGeometry();
          var PolygonCount = MultiRegion.getPolygonCount();
          for (var PolygonIndex = 0; PolygonIndex < PolygonCount; PolygonIndex++) {
            var PolygonSubCount = MultiRegion.getSubCount(PolygonIndex);
            for (var SubIndex = 0; SubIndex < PolygonSubCount; SubIndex++) {
              var subpoint = [];
              var subpoints = MultiRegion.getPoints(PolygonIndex, SubIndex);
              var subPointCount = MultiRegion.getSubPntCount(PolygonIndex, SubIndex);
              for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
                if (spatialReference == null || spatialReference.getType() == PIE.SpatialRefType.GEOGRAPHIC) {
                  var _Point4 = [];
                  _Point4.push(subpoints[numIndex].x);
                  _Point4.push(subpoints[numIndex].y);
                  subpoint.push(_Point4);
                } else {
                  var temppoint = spatialReference.inverse(points[numIndex]);
                  var _Point5 = [];
                  _Point5.push(temppoint.x);
                  _Point5.push(temppoint.y);
                  subpoint.push(_Point5);
                }
              }
              Multipoint.push(subpoint);
              if (PolygonSubCount > 1) {
                var result = MultiRegion.checkSubPolygon(PolygonIndex, SubIndex);
                if (result) {
                  fluag = 1;
                }
              }
            }
          }
          if (fluag) {
            coordinates.push(Multipoint);
          } else {
            for (var i = 0; i < Multipoint.length; i++) {
              var temppoint = [];
              temppoint.push(Multipoint[i]);
              coordinates.push(temppoint);
            }
          }
          geometry.coordinates = coordinates;
        } else if (this.getGeometry().getType() == PIEGeometryType.Point3D) {
          geometry.type = "Point3D";
          var pointGeo3D = this.getGeometry();
          var point = pointGeo3D.getPoint();
          coordinates.push(point.x);
          coordinates.push(point.y);
          coordinates.push(point.z);
          geometry.coordinates = coordinates;
        } else if (this.getGeometry().getType() == PIEGeometryType.Line3D) {
          geometry.type = "Line3D";
          var polyLine = this.getGeometry();
          var subCount = polyLine.getSubCount();
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var subPoints = [];
            var points = polyLine.getPoints(subIndex);
            var subPointCount = polyLine.getSubPointCount(subIndex);
            for (var numIndex = 0; numIndex < subPointCount * 3; numIndex++) {
              subPoints.push(points[numIndex]);
            }
            coordinates.push(subPoints);
          }
          geometry.coordinates = coordinates;
        } else if (this.getGeometry().getType() == PIEGeometryType.Region3D) {
          geometry.type = "Region3D";
          var polygon = this.getGeometry();
          var subCount = polygon.getSubCount();
          for (var subIndex = 0; subIndex < subCount; subIndex++) {
            var subPoints = [];
            var points = polygon.getPoints(subIndex);
            var subPointCount = polygon.getSubPointCount(subIndex);
            for (var numIndex = 0; numIndex < subPointCount * 3; numIndex++) {
              subPoints.push(points[numIndex]);
            }
            coordinates.push(subPoints);
          }
          geometry.coordinates = coordinates;
        } else {
          geometry.type = "UnKnow";
        }
        feature.geometry = geometry;
      }
      return feature;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 矢量数据集操作函数
   * @name FeatureDataset
   *
   * @extends Dataset
   */
  function PIEFeatureDataset(handle, autoRelease) {
    PIEDataset.call(this, handle, autoRelease);
  }
  PIEFeatureDataset.prototype = Object.assign(Object.create(PIEDataset.prototype), {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 获取数据集中要素对象个数
     *
     * @memberOf FeatureDataset#
     * @returns {Number} 返回对象个数
     */
    getObjectCount: function getObjectCount() {
      return Module._FDataset_GetObjectCount(this.handle);
    },
    /**
     * 获取数据集中字段个数
     *
     * @memberOf FeatureDataset#
     * @returns {Number} 返回字段个数
     */
    getFieldCount: function getFieldCount() {
      return Module._FDataset_GetFieldCount(this.handle);
    },
    /**
     * 根据索引获取数据集字段信息
     * @param {Number} index -字段索引
     * @memberOf FeatureDataset#
     * @returns {PIEFieldInfo} 返回字段信息对象(返回的是目标字段对象的拷贝，使用完成需要调用dispose自行释放，否则会造成内存泄漏)
     */
    getFieldInfoAt: function getFieldInfoAt(index) {
      var handle = Module._FDataset_GetFieldInfoAt(this.handle, index);
      var field = new PIEFieldInfo({
        handle: handle
      });
      return field;
    },
    /**
     * 创建数据集字段
     * @param {PIEFieldInfo} field -字段信息对象
     * @memberOf FeatureDataset#
     * @returns {Boolean} 返回创建是否成功(字段存在返回false，内部会进行拷贝，field需要自行释放）
     */
    createField: function createField(field) {
      return Boolean(Module._FDataset_CreateField(this.handle, field.getHandle()));
    },
    /**
     * 通过数据集字段名删除数据集字段
     * @param {String} name -字段名称
     *
     * @memberOf FeatureDataset#
     * @returns {Boolean} 如果删除成功返回true，否则返回false
     */
    deleteField: function deleteField(name) {
      var strName = new PIEString$1(name);
      var res = Module._FDataset_DeleteField(this.handle, strName.getHandle());
      strName.dispose();
      return Boolean(res);
    },
    /**
     * 通过数据集字段索引删除数据集字段
     * @param {Number} index -索引值
     *
     * @memberOf FeatureDataset#
     * @returns {Boolean} 如果删除成功返回true，否则返回false
     */
    deleteFieldByIndex: function deleteFieldByIndex(index) {
      return Boolean(Module._FDataset_DeleteField(this.handle, index));
    },
    /**
     * 通过指定ID数组查询要素集
     * @param {Array} IDs -查询时的ID数组
     *
     * @memberOf FeatureDataset#
     * @returns {PIEFeatureSet} 如果查询成功返回要素集对象，否则返回null
     */
    queryByIDs: function queryByIDs(IDs) {
      var ArrayIDs = new PIEArray(IDs, PIEArrayType.Int32);
      var res = Module._FDataset_QueryByID(this.handle, ArrayIDs.getHandle(), IDs.length);
      ArrayIDs.dispose();
      if (res) {
        return new PIEFeatureSet(res, true);
      }
      return null;
    },
    /**
     * 通过属性数据查询条件查询要素集
     * @param {String} filter -属性数据查询条件
     *
     * @memberOf FeatureDataset#
     * @returns {PIEFeatureSet} 如果查询成功返回要素集对象，否则返回null
     */
    queryByGeneral: function queryByGeneral(filter) {
      var strFilter = new PIEString$1(filter);
      var res = Module._FDataset_QueryByGeneral(this.handle, strFilter.getHandle());
      strFilter.dispose();
      if (res) {
        return new PIEFeatureSet(res, true);
      }
      return null;
    },
    /**
     * 通过数据范围查询要素集
     * @param {(PIEBounds/Array)} bounds -范围对象(支持数组)
     *
     * @memberOf FeatureDataset#
     * @returns {PIEFeatureSet} 如果查询成功返回要素集对象，否则返回null
     */
    queryByBounds: function queryByBounds(bounds) {
      var bbox = [];
      if (bounds instanceof PIEBounds) {
        bbox = bounds.toArray();
      } else if (bounds instanceof Array) {
        bbox = bounds;
      }
      var handle = Module._FDataset_QueryByBounds(this.handle, bbox[0], bbox[1], bbox[2], bbox[3]);
      if (handle) {
        return new PIEFeatureSet(handle);
      }
      return null;
    },
    /**
     * 通过要素集对象释放要素集内存空间
     * @param {PIEFeatureSet} featureSet -矢量要素集对象
     *
     * @memberOf FeatureDataset#
     * @returns {Boolean} 如果释放成功返回true，否则返回false
     */
    releaseFeatureSet: function releaseFeatureSet(featureSet) {
      return Boolean(Module._FDataset_ReleaseFeatureSet(this.handle, featureSet.getHandle()));
    },
    /**
     * 根据索引设置数据集字段别名
     * @param {Number} index -索引值
     * @param {String} name -字段别名
     *
     * @memberOf FeatureDataset#
     * @returns {Boolean} 如果设置成功返回true，否则返回false
     */
    setFieldForignNameAt: function setFieldForignNameAt(index, name) {
      var strName = new PIEString$1(name);
      var res = Module._FDataset_SetFieldForignNameAt(this.handle, index, strName.getHandle());
      strName.dispose();
      return Boolean(res);
    },
    // /**
    //  * 同一参考系正转换(椭球体相同，地理坐标到投影坐标)
    //  * @param {PIESpatialReference} spatialReference -空间参考坐标系
    //  *
    //  * @memberOf FeatureDataset#
    //  * @returns {Boolean} 如果转换成功返回true，否则返回false
    //  */
    forWard: function forWard(spatialReference) {
      return Boolean(Module._FDataset_PJForward(this.handle, spatialReference.getHandle()));
    },
    // /**
    //  * 同一参考系反转换(椭球体相同，投影坐标到地理坐标)
    //  * @param {PIESpatialReference} spatialReference -空间参考坐标系
    //  *
    //  * @memberOf FeatureDataset#
    //  * @returns {Boolean} 如果转换成功返回true，否则返回false
    //  */
    inverse: function inverse(spatialReference) {
      return Boolean(Module._FDataset_PJInverse(this.handle, spatialReference.getHandle()));
    },
    // /**
    //  * 不同空间参考系转换
    //  * @param {PIEReferenceTranslator} refTranslator -参考系转换器
    //  *
    //  * @memberOf FeatureDataset#
    //  * @returns {Boolean} 如果转换成功返回true，否则返回false
    //  */
    convert: function convert(refTranslator) {
      return Module._FDataset_PJConvert(this.handle, refTranslator.getHandle());
    },
    /**
     * 获取空间参考系对象
     *
     * @memberOf FeatureDataset#
     * @returns {PIESpatialReference} 如果获取成功返回空间参考系对象，否则返回null
     */
    getSpatialReference: function getSpatialReference() {
      var handle = Module._FDataset_GetSpatialReference(this.handle);
      if (handle) {
        return new PIESpatialReference(handle);
      }
      return null;
    },
    //暂时注释
    // /**
    //  * 建立空间索引
    //  *
    //  * @memberOf FeatureDataset#
    //  * @returns {Boolean} 如果索引创建成功返回true，否则返回false
    //  */
    // buildSpatialIndex: function () {
    //     return Module._FDataset_BuildSpatialIndex(this.handle);
    // },

    //暂时注释
    // /**
    //  * 删除空间索引
    //  *
    //  * @memberOf FeatureDataset#
    //  * @returns {Boolean} 返回空间索引删除是否成功(删除成功返回true，否则返回false)
    //  */
    // dropSpatialIndex: function () {
    //     return Module._FDataset_DropSpatialIndex(this.handle);
    // },

    /**
     * 返回数据集字符编码方式
     * @memberOf FeatureDataset#
     * @returns {PIECharsetType} 返回数据集字符编码方式
     */
    getCharset: function getCharset() {
      return Module._FDataset_GetCharset(this.handle);
    },
    /**
     * 设置数据集字符编码方式
     * @param {PIECharsetType} charset -字符编码方式
     * @memberOf FeatureDataset#
     * @returns {Boolean} 设置成功返回true，否则返回false
     */
    setCharset: function setCharset(charset) {
      return Boolean(Module._FDataset_SetCharset(this.handle, charset));
    },
    fromGeojson: function fromGeojson(featureDatasetjson) {
      var featureSet = this.queryByGeneral("");
      featureSet.deleteAll();
      featureSet.editBulk(true);
      var features = featureDatasetjson.features;
      for (var featureIndex = 0; featureIndex < features.length; featureIndex++) {
        featureSet.edit();
        featureSet.fromGeojson(features[featureIndex]);
        featureSet.update();
      }
      featureSet.update();
      featureSet.editBulk(false);
      return featureSet;
    },
    toGeojson: function toGeojson() {
      var featureSet = this.queryByGeneral("");
      var featureDataset = {
        "type": "FeatureCollection"
      };
      var features = [];
      featureSet.moveFirst();
      while (!featureSet.isEOF()) {
        var featureGeojson = featureSet.toGeojson();
        features.push(featureGeojson);
        featureSet.moveNext();
      }
      featureDataset.features = features;
      return featureDataset;
    }
  });

  /**
   * 栅格数据集对象
   * @name RasterDataset
   * @extends Dataset
   */
  function PIERasterDataset(handle) {
    PIEDataset.call(this, handle);
  }
  PIERasterDataset.prototype = Object.assign(Object.create(PIEDataset.prototype), {
    /**
     * 获取栅格数据集图像宽度
     * @memberOf RasterDataset#
     * @returns {Number} 返回图像宽度
     */
    getWidth: function getWidth() {
      return Module._RDataset_GetWidth(this.handle);
    },
    /**
     * 获取栅格数据集图像高度
     * @memberOf RasterDataset#
     * @returns {Number} 返回图像高度
     */
    getHeight: function getHeight() {
      return Module._RDataset_GetHeight(this.handle);
    },
    /**
     * 获取波段数
     * @memberOf RasterDataset#
     * @returns {Number} 返回波段数
     */
    getBandCount: function getBandCount() {
      return Module._RDataset_GetBandCount(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 模型数据集操作函数
   * @name ModelDataset
   *@extends Dataset
   *
   */
  function PIEModelDataset(handle) {
    PIEDataset.call(this, handle);
  }
  PIEModelDataset.prototype = Object.assign(Object.create(PIEDataset.prototype), {
    /**
     * 设置OSGB数据集坐标
     * @param {(Array/PIEVector3)} position -坐标
     * @memberOf ModelDataset#
     */
    setPosition: function setPosition(position) {
      var array = null;
      if (position instanceof PIEVector3) {
        array = position.toArray();
      } else if (position instanceof Array) {
        array = position;
      }
      if (array) {
        var positionArray = new PIEArray(array, PIEArrayType.Float64);
        Module._MDataset_SetPosition(this.handle, positionArray.getHandle());
        positionArray.dispose();
      }
    },
    /**
     * 获取OSGB数据集坐标
     * @returns {PIEVector3} 返回数据集坐标
     *
     * @memberOf ModelDataset#
     */
    getPosition: function getPosition() {
      var positionArray = new PIEArray(3, PIEArrayType.Float64);
      Module._MDataset_GetPosition(this.handle, positionArray.getHandle());
      positionArray.updateData();
      var position = positionArray.toArray();
      positionArray.dispose();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     * 设置OSGB数据集高度
     * @param {Number} height -高度
     * @memberOf ModelDataset#
     */
    setHeight: function setHeight(height) {
      var position = this.getPosition();
      this.setPosition([position.x, position.y, height]);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * GE数据集操作函数
   * @name GEDataset
   *@extends Dataset
   *
   */
  function PIEGEDataset(handle) {
    PIEDataset.call(this, handle);
  }
  PIEGEDataset.prototype = Object.assign(Object.create(PIEDataset.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * Mapbox矢量瓦片数据集操作函数
   * @name MVTDataset
   *@extends Dataset
   *
   */
  function PIEMVTDataset(handle) {
    PIEDataset.call(this, handle);
  }
  PIEMVTDataset.prototype = Object.assign(Object.create(PIEDataset.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * Tiles3D数据集操作函数
   * @name Tiles3DDataset
   * @extends ModelDataset
   *
   */
  function PIETiles3DDataset(handle) {
    PIEModelDataset.call(this, handle);
  }
  PIETiles3DDataset.prototype = Object.assign(Object.create(PIEModelDataset.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * FHBH数据集操作函数
   * @name FHBHDataset
   * @extends FeatureDataset
   */
  function PIEFHBHDataset(handle, autoRelease) {
    PIEFeatureDataset.call(this, handle, autoRelease);
  }
  PIEFHBHDataset.prototype = Object.assign(Object.create(PIEFeatureDataset.prototype), {});

  function PIEDatasetFactory() {}
  Object.assign(PIEDatasetFactory.prototype, {});
  PIEDatasetFactory.CreateInstance = function (hDataset) {
    var datasetType = Module._Dataset_GetType(hDataset);
    if (datasetType == PIEDatasetType.Raster) {
      return new PIERasterDataset(hDataset);
    } else if (datasetType == PIEDatasetType.Model) {
      return new PIEModelDataset(hDataset);
    } else if (datasetType == PIEDatasetType.Tiles3D) {
      return new PIETiles3DDataset(hDataset);
    } else if (datasetType == PIEDatasetType.GEDataModel) {
      return new PIEGEDataset(hDataset);
    } else if (datasetType == PIEDatasetType.Point || datasetType == PIEDatasetType.Line || datasetType == PIEDatasetType.LineM || datasetType == PIEDatasetType.Region || datasetType == PIEDatasetType.Text || datasetType == PIEDatasetType.Complex || datasetType == PIEDatasetType.Attribute) {
      return new PIEFeatureDataset(hDataset);
    } else if (datasetType == PIEDatasetType.MVT) {
      return new PIEMVTDataset(hDataset);
    } else if (datasetType == PIEDatasetType.Plot) {
      return new PIEFHBHDataset(hDataset);
    }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 数据源操作函数
   * @name DataSource
   */
  function PIEDataSource(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEDataSource.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 删除数据源
     *
     * @memberOf DataSource#
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._DataSource_Close(this.handle);
        Module._DataSource_Delete(this.handle);
      }
      this.handle = null;
    },
    //父类不开放Create接口
    // /**
    //  * 通过文件路径新建数据源
    //  * @param {Object} options -
    //  * @param {String} options.database -数据源
    //  * @param {String} options.server -数据源的服务地址
    //  *
    //  * @memberOf DataSource#
    //  *
    //  * @returns {Boolean} 如果创建成功返回true，否则返回false
    //  */
    create: function create(options) {
      if (options != null) {
        if (this.handle == null && options.database != null) {
          var strPath = new PIEString$1(options.database);
          this.handle = Module._DataSource_Create(strPath.getHandle());
          strPath.dispose();
        }
        if (this.handle != null && options.server != null) {
          var strServer = new PIEString$1(options.server);
          Module._DataSource_SetServer(this.handle, strServer.getHandle());
          strServer.dispose();
        }
        this.autoRelease = true;
      }
      return this.handle != null;
    },
    /**
     * 通过数据源路径打开数据源
     * @param {Object} options -
     * @param {String} options.database -数据源
     * @param {String} options.server -数据源的服务地址
     * @param {String} options.alias -数据源别名
     *
     * @memberOf DataSource#
     * @returns {Boolean} 如果打开成功返回true，否则返回false
     *
     */
    open: function open(options) {
      if (options != null) {
        if (this.handle == null && options.database != null) {
          var strPath = new PIEString$1(options.database);
          this.handle = Module._DataSource_Open(strPath.getHandle());
          strPath.dispose();
        }
        if (this.handle && options.server != null) {
          var strServer = new PIEString$1(options.server);
          Module._DataSource_SetServer(this.handle, strServer.getHandle());
          strServer.dispose();
        }
        if (this.handle && options.alias != null) {
          var strAlias = new PIEString$1(options.alias);
          Module._DataSource_SetAlias(this.handle, strAlias.getHandle());
          strAlias.dispose();
        }
        this.autoRelease = true;
      }
      return Boolean(this.handle);
    },
    /**
     * 判断数据源是否打开
     *
     * @memberOf DataSource#
     * @returns {Boolean} 如果已经打开返回true，否则返回false
     */
    isOpen: function isOpen() {
      return Boolean(Module._DataSource_IsOpen(this.handle));
    },
    /**
     * 关闭数据源
     *
     * @memberOf DataSource#
     */
    close: function close() {
      Module._DataSource_Close(this.handle);
    },
    /**
     * 获取数据源类型
     *
     * @memberOf DataSource#
     * @return {String} 返回数据源类型
     */
    getType: function getType() {
      var strType = new PIEString$1(256);
      Module._DataSource_GetType(this.handle, strType.getHandle());
      var type = strType.toString();
      strType.dispose();
      return type;
    },
    /**
     * 获取数据源名称
     *
     * @memberOf DataSource#
     * @return {String} 返回数据源名称
     */
    getName: function getName() {
      var strName = new PIEString$1(512);
      Module._DataSource_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 获取数据源别名
     *
     * @memberOf DataSource#
     * @return {String} 返回数据源别名
     */
    getAlias: function getAlias() {
      var strAlias = new PIEString$1(256);
      Module._DataSource_GetAlias(this.handle, strAlias.getHandle());
      var alias = strAlias.toString();
      strAlias.dispose();
      return alias;
    },
    /**
     * 设置数据源别名
     * @param {String} alias -数据源别名
     *
     * @memberOf DataSource#
     */
    setAlias: function setAlias(alias) {
      var strAlias = new PIEString$1(alias);
      Module._DataSource_SetAlias(this.handle, strAlias.getHandle());
      strAlias.dispose();
    },
    // /**
    //  * 设置数据源服务地址
    //  * @param {String} server -新设置数据源服务地址
    //  * @memberOf DataSource#
    //  *
    //  */
    setServer: function setServer(server) {
      var strServer = new PIEString$1(server);
      Module._DataSource_SetServer(this.handle, strServer.getHandle());
      strServer.dispose();
    },
    /**
     * 获取数据集（一般数据源只有一个数据集，所以提供此接口方便使用）
     * @memberOf DataSource#
     * @returns {PIEDataset} 如果获取成功返回数据集对象，否则返回NULL
     */
    getDataset: function getDataset() {
      var hDataset = Module._DataSource_GetDatasetAt(this.handle, 0);
      if (hDataset) {
        return PIEDatasetFactory.CreateInstance(hDataset);
      }
      return null;
    },
    /**
     * 获取数据源中数据集的个数
     *
     * @memberOf DataSource#
     * @returns {Number} 返回数据源中数据集的个数
     */
    getDatasetCount: function getDatasetCount() {
      return Module._DataSource_GetDatasetCount(this.handle);
    },
    /**
     * 通过数据集名称获取数据集
     * @param {String} name -数据集名称
     *
     * @memberOf DataSource#
     * @returns {PIEDataset} 如果获取成功返回数据集对象，否则返回null
     */
    getDatasetByName: function getDatasetByName(name) {
      var strName = new PIEString$1(name);
      var hDataset = Module._DataSource_GetDataset(this.handle, strName.getHandle());
      strName.dispose();
      if (hDataset) {
        return PIEDatasetFactory.CreateInstance(hDataset);
      }
      return null;
    },
    /**
     * 通过索引获取数据集
     * @param {Number} index -数据集索引
     *
     * @memberOf DataSource#
     * @returns {PIEDataset} 如果获取成功返回数据集对象，否则返回null
     */
    getDatasetAt: function getDatasetAt(index) {
      var hDataset = Module._DataSource_GetDatasetAt(this.handle, index);
      if (hDataset) {
        return PIEDatasetFactory.CreateInstance(hDataset);
      }
      return null;
    },
    /**
     * 获取数据源服务地址
     *
     * @memberOf DataSource#
     * @returns {String} 数据源服务地址
     */
    getServer: function getServer() {
      var strServer = new PIEString$1(512);
      Module._DataSource_GetServer(this.handle, strServer.getHandle());
      var server = strServer.toString();
      strServer.dispose();
      return server;
    },
    /**
     * 获取数据源数据库名称
     *
     * @memberOf DataSource#
     * @returns {String} 数据源数据库名称
     */
    getDatabase: function getDatabase() {
      var strDatabase = new PIEString$1(512);
      Module._DataSource_GetDatabase(this.handle, strDatabase.getHandle());
      var dataBase = strDatabase.toString();
      strDatabase.dispose();
      return dataBase;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 数据源集合操作
   * @name DataSources
   */
  function PIEDataSources(handle) {
    this.handle = handle;
  }
  Object.assign(PIEDataSources.prototype, {
    /**
     * 向工作空间中添加数据源
     * @param {PIEDataSource} datasource -需要加入的数据源
     * @memberOf DataSources#
     *
     * @returns {Boolean} 如果添加成功返回true,否则返回false
     *
     */
    addDataSource: function addDataSource(datasource) {
      var result = Module._Document_AddDataSource(this.handle, datasource.getHandle());
      if (result) {
        datasource.setAutoRelease(false);
      }
      return Boolean(result);
    },
    /**
     * 获取工作空间中数据源的数量
     *
     * @memberOf DataSources#
     * @returns {Number} 返回工作空间中数据源的数量
     */
    getDataSourceCount: function getDataSourceCount() {
      var count = Module._Document_GetDataSourceCount(this.handle);
      return count;
    },
    /**
     * 获取工作空间中指定别名的数据源
     * @param {String} alias -数据源别名
     * @memberOf DataSources#
     *
     * @returns {PIEDataSource} 如果获取成功返回指定名称的数据源，否则返回null;如果别名为空或不存在，返回null
     *
     */
    getDataSource: function getDataSource(alias) {
      var strAlias = new PIEString$1(alias);
      var hDataSource = Module._Document_GetDataSource(this.handle, strAlias.getHandle());
      strAlias.dispose();
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    },
    /**
     * 获取工作空间中指定索引的数据源
     * @param {Number} index -需要获取的数据源的索引值
     * @memberOf DataSources#
     *
     * @returns {PIEDataSource} 如果获取成功返回指定索引值的数据源，否则返回null
     *
     */
    getDataSourceAt: function getDataSourceAt(index) {
      var hDataSource = Module._Document_GetDataSourceAt(this.handle, index);
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    },
    /**
     * 通过数据源查找数据源别名
     * @param {PIEDataSource} datasource -数据源
     * @memberOf DataSources#
     * @returns {String} 返回数据源的别名
     *
     */
    getDataSourceAlias: function getDataSourceAlias(datasource) {
      var strAlias = new PIEString$1(256);
      Module._Document_GetDataSourceAlias(this.handle, datasource.getHandle(), strAlias.getHandle());
      var alias = strAlias.toString();
      strAlias.dispose();
      return alias;
    },
    /**
     * 得到指定索引位置的数据源别名
     * @param {Number} index -索引位置
     * @memberOf DataSources#
     *
     * @returns {String} 返回数据源的别名
     */
    getDataSourceAliasAt: function getDataSourceAliasAt(index) {
      var strAlias = new PIEString$1(256);
      Module._Document_GetDataSourceAliasAt(this.handle, index, strAlias.getHandle());
      var alias = strAlias.toString();
      strAlias.dispose();
      return alias;
    },
    // /**
    //  * 从XML中序列化数据源
    //  * @param {String} xml -数据源xml
    //  * @memberOf DataSources#
    //  * @return {Boolean} 返回是否成功序列化数据源
    //  */
    // dataSourceFromXML: function (xml) {
    //     var strXml = new PIEString(xml);
    //     var result = Module._Document_DataSourceFromXML(this.handle, strXml.getHandle());
    //     strXml.dispose();
    //     return result;
    // },
    //
    // /**
    //  * 把数据源序列化成xml
    //  * @memberOf DataSources#
    //  * @returns {String} 返回数据源xml
    //  */
    // dataSourceToXML: function () {
    //     var strXml = new PIEString(1024);
    //     Module._Document_DataSourceToXML(this.handle, strXml.getHandle());
    //     var xml = strXml.toString();
    //     strXml.dispose();
    //     return xml;
    // },

    /**
     * 重命名数据源
     * @param {String} oldAlias -原数据源别名
     * @param {String} newAlias -新数据源别名
     * @memberOf DataSources#
     *
     * @returns {Boolean} 如果重命名成功返回true，否则返回false；如果数据源为null，或者原别名为空或者新别名为空，那么返回false；如果数据源新别名和原别名相同，返回true；如果数据源新别名与已存在的其他数据源名称相同，返回false；
     *
     */
    renameDataSource: function renameDataSource(oldAlias, newAlias) {
      var strOldAlias = new PIEString$1(oldAlias);
      var strNewAlias = new PIEString$1(newAlias);
      var result = Module._Document_RenameDataSource(this.handle, strOldAlias.getHandle(), strNewAlias.getHandle());
      strOldAlias.dispose();
      strNewAlias.dispose();
      return Boolean(result);
    },
    /**
     * 根据数据源别名移除数据源
     * @param {String} alias -数据源别名
     * @memberOf DataSources#
     *
     * @returns {PIEDataSource} 如果移除成功返回数据源的对象，否则返回null。 如果别名为空，返回null；如果不存在名称为strAlias的数据源，那么返回null。
     */
    removeDataSource: function removeDataSource(alias) {
      var strAlias = new PIEString$1(alias);
      var hDataSource = Module._Document_RemoveDataSource(this.handle, strAlias.getHandle());
      strAlias.dispose();
      var dataSource = PIEDataSourceFactory.CreateInstance(hDataSource);
      if (dataSource != null) {
        dataSource.setAutoRelease(true);
      }
      return dataSource;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 地形数据源操作函数
   * @name TerrainDataSource
   *
   * @extends DataSource
   */
  function PIETerrainDataSource(handle, autoRelease) {
    PIEDataSource.call(this, handle, autoRelease);
  }
  PIETerrainDataSource.prototype = Object.assign(Object.create(PIEDataSource.prototype), {
    // /**
    //  * 创建栅格瓦片
    //  * @param {Object} options -
    //  * @param {String} options.server -url地址
    //  * @param {String} options.cachePath -缓存路径
    //  * @param {String} options.alias -数据源别名
    //  * @param {Number} options.epsg -坐标系EPSG
    //  * @param {PIEBounds} options.indexBounds -加载数据范围
    //  * @param {PIEBounds} options.bounds -数据范围
    //  * @param {Number} options.dpi -地图显示Dpi
    //  * @param {Number} options.tileSize -瓦片大小
    //  * @param {Array} options.scales -缩放比例数组
    //  *
    //  * @memberOf TerrainDataSource#
    //  */
    // create: function (options) {
    //     if (options != null) {
    //         var provider = options.server;
    //         var urlFormat = null;
    //         var cachePath = options.cachePath;
    //         var name = options.alias;
    //         var epsg = options.epsg;
    //         var indexBounds = options.indexBounds;
    //         var bounds = options.bounds;
    //         var dpi = options.dpi;
    //         var tileSize = options.tileSize;
    //         var scales = options.scales;
    //         var scaleCount = 0;
    //         if (provider == null || name == null) {
    //             return;
    //         }
    //         if (epsg == null) {
    //             epsg = 3857;
    //         }
    //         if (bounds == null) {
    //             bounds = [-20037508.342789244, 20037508.342789244, 20037508.342789244, -20037508.342789244];
    //         }
    //         indexBounds = indexBounds == null ? bounds : indexBounds;
    //         dpi = dpi == null ? 96 : dpi;
    //         tileSize = tileSize == null ? 256 : tileSize;
    //
    //
    //         var strProvider = new PIEString(provider);
    //         var strName = new PIEString(name);
    //         var strCachePath = null;
    //         if (cachePath != null) {
    //             strCachePath = new PIEString(cachePath);
    //         }
    //         var arrayBounds = null;
    //         var arrayIndexBounds = null;
    //         var arrayScales = null;
    //         var spatialRef = PIESpatialReference.fromEpsg(epsg);
    //         if (bounds instanceof Array) {
    //             arrayBounds = new PIEArray(bounds, PIEArrayType.Float64);
    //         } else if (bounds instanceof PIEBounds) {
    //             arrayBounds = PIEBounds.toArray(bounds);
    //         }
    //         if (indexBounds instanceof Array) {
    //             arrayIndexBounds = new PIEArray(indexBounds, PIEArrayType.Float64);
    //         } else if (indexBounds instanceof PIEBounds) {
    //             arrayIndexBounds = PIEBounds.toArray(indexBounds);
    //         }
    //         if (scales != null && scales instanceof Array) {
    //             scaleCount = scales.length;
    //             arrayScales = new PIEArray(scales, PIEArrayType.Float64);
    //         }
    //
    //         var cachePathPar = null;
    //         if (strCachePath != null) {
    //             cachePathPar = strCachePath.getHandle();
    //         }
    //         var scalesPar = null;
    //         if (arrayScales) {
    //             scalesPar = arrayScales.getHandle();
    //         }
    //         if (strProvider && arrayBounds && arrayIndexBounds) {
    //             this.handle = Module._DataSource_CreateTileDataSourceEx(strProvider.getHandle(), urlFormat, cachePathPar, strName.getHandle(), spatialRef.getHandle(), arrayIndexBounds.getHandle(),
    //                 arrayBounds.getHandle(), dpi, tileSize, scalesPar, scaleCount);
    //             if (this.handle != null) {
    //                 this.dataset = Module._DataSource_GetDatasetAt(this.handle, 0);
    //             }
    //         }
    //
    //         strProvider.dispose();
    //         strName.dispose();
    //         if(strCachePath){
    //             strCachePath.dispose();
    //         }
    //         if(arrayBounds){
    //             arrayBounds.dispose();
    //         }
    //         if(arrayIndexBounds){
    //             arrayIndexBounds.dispose();
    //         }
    //         if(arrayScales){
    //             arrayScales.dispose();
    //         }
    //
    //     }
    // },
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建栅格瓦片数据源
   * @name TileRasterDataSource
   * @class TileRasterDataSource
   * 栅格瓦片数据源操作函数
   * @extends RasterDataSource
   */
  function PIETileRasterDataSource(handle, autoRelease) {
    PIERasterDataSource.call(this, handle, autoRelease);
  }
  PIETileRasterDataSource.prototype = Object.assign(Object.create(PIERasterDataSource.prototype), {
    /**
     * 创建栅格瓦片
     * @param {Object} options -
     * @param {String} options.server -url地址(必输)
     * @param {String} options.alias -栅格瓦片数据源别名(必输)
     * @param {Number} options.epsg -坐标系EPSG(支持3857、4326、4490，默认为3857)
     * @param {PIEBounds/Array} options.bounds -数据范围(默认全球范围)
     * @param {Number} options.dpi -地图显示dpi(默认为96)
     * @param {Number} options.tileSize -瓦片大小(默认256)
     * @param {Number} options.levelOffset -层级偏移(默认为0)
     * @param {Boolean} options.tms -是否是tms瓦片协议(默认false)
     * @param {Number} options.maxLevel -瓦片最大层级(默认24)
     * @memberOf TileRasterDataSource#
     */
    create: function create(options) {
      if (options != null) {
        var provider = options.server;
        var urlFormat = null;
        var cachePath = options.cachePath;
        var name = options.alias;
        var epsg = options.epsg;
        var indexBounds = null;
        var bounds = options.bounds;
        var dpi = options.dpi;
        var tileSize = options.tileSize;
        var scales = options.scales;
        var tileRowInverseMode = options.tms;
        var bottomLevel = options.maxLevel != null ? options.maxLevel : 24;
        var scaleCount = 0;
        var levelOffset = 0;
        if (provider == null || name == null) {
          return;
        }
        if (epsg == null) {
          epsg = 3857;
        }
        if (bounds == null) {
          bounds = [-20037508.342789244, 20037508.342789244, 20037508.342789244, -20037508.342789244];
          if (epsg == 4326 || epsg == 4490) {
            bounds = [-180, 90, 180, -90];
          }
        }
        if (indexBounds == null) {
          indexBounds = [-20037508.342789244, 20037508.342789244, 20037508.342789244, -20037508.342789244];
          if (epsg == 4326 || epsg == 4490) {
            indexBounds = [-180, 90, 180, -90];
          }
        }
        if (options.levelOffset != null) {
          levelOffset = options.levelOffset;
        }
        dpi = dpi == null ? 96 : dpi;
        tileSize = tileSize == null ? 256 : tileSize;
        var strProvider = new PIEString$1(provider);
        var strName = new PIEString$1(name);
        var strCachePath = null;
        if (cachePath != null) {
          strCachePath = new PIEString$1(cachePath);
        }
        var arrayBounds = null;
        var arrayIndexBounds = null;
        var arrayScales = null;
        var spatialRef = PIESpatialReference.fromEpsg(epsg);
        if (bounds instanceof Array) {
          arrayBounds = new PIEArray(bounds, PIEArrayType.Float64);
        } else if (bounds instanceof PIEBounds) {
          arrayBounds = PIEBounds.toArray(bounds);
        }
        if (indexBounds instanceof Array) {
          arrayIndexBounds = new PIEArray(indexBounds, PIEArrayType.Float64);
        } else if (indexBounds instanceof PIEBounds) {
          arrayIndexBounds = PIEBounds.toArray(indexBounds);
        }
        if (scales != null && scales instanceof Array) {
          scaleCount = scales.length;
          arrayScales = new PIEArray(scales, PIEArrayType.Float64);
        }
        var cachePathPar = null;
        if (strCachePath != null) {
          cachePathPar = strCachePath.getHandle();
        }
        var scalesPar = null;
        if (arrayScales) {
          scalesPar = arrayScales.getHandle();
        }
        if (tileRowInverseMode == null) {
          tileRowInverseMode = false;
        }
        var tileType = "raster";
        var strTileType = new PIEString$1(tileType);
        if (strProvider && arrayBounds && arrayIndexBounds) {
          this.handle = Module._DataSource_CreateTileDataSourceEx(strProvider.getHandle(), urlFormat, cachePathPar, strName.getHandle(), spatialRef.getHandle(), arrayIndexBounds.getHandle(), arrayBounds.getHandle(), dpi, tileSize, scalesPar, scaleCount, strTileType.getHandle(), levelOffset, tileRowInverseMode, bottomLevel);
        }
        spatialRef.dispose();
        strProvider.dispose();
        strName.dispose();
        strTileType.dispose();
        if (strCachePath) {
          strCachePath.dispose();
        }
        if (arrayBounds) {
          arrayBounds.dispose();
        }
        if (arrayIndexBounds) {
          arrayIndexBounds.dispose();
        }
        if (arrayScales) {
          arrayScales.dispose();
        }
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建Map地形数据源
   * @name MapTerrainDataSource
   * @class MapTerrainDataSource
   * Map地形数据源操作函数
   * @extends TerrainDataSource
   */
  function PIEMapTerrainDataSource(handle, autoRelease) {
    PIETerrainDataSource.call(this, handle, autoRelease);
  }
  PIEMapTerrainDataSource.prototype = Object.assign(Object.create(PIETerrainDataSource.prototype), {
    /**
     * 创建栅格瓦片
     * @param {Object} options -
     * @param {String} options.server -url地址(必输)
     * @param {String} options.alias -栅格瓦片数据源别名(必输)
     * @param {Number} options.epsg -坐标系EPSG(支持3857、4326、4490，默认为3857)
     * @param {PIEBounds/Array} options.bounds -数据范围(默认全球范围)
     * @param {Number} options.dpi -地图显示Dpi(默认为96)
     * @param {Number} options.tileSize -瓦片大小(默认256)
     * @param {Number} options.levelOffset -层级偏移(默认为0)
     * @param {Boolean} options.tms -是否是tms瓦片协议(默认false)
     * @param {Number} options.maxLevel -瓦片最大层级(默认13，如果地形精度大于13层级，需要自行设置此参数)
     * @param {String} options.tileType -瓦片类型(默认png)
     * @param {String} options.urlFormat -瓦片格式
     * @memberOf MapTerrainDataSource#
     */
    create: function create(options) {
      if (options != null) {
        var provider = options.server;
        var urlFormat = options.urlFormat;
        var cachePath = options.cachePath;
        var name = options.alias;
        var epsg = options.epsg;
        var indexBounds = null;
        var bounds = options.bounds;
        var dpi = options.dpi;
        var tileSize = options.tileSize;
        var scales = options.scales;
        var tileRowInverseMode = options.tms;
        var bottomLevel = options.maxLevel != null ? options.maxLevel : 24;
        var scaleCount = 0;
        var levelOffset = 0;
        var tileType = options.tileType;
        if (!provider || provider == "") {
          throw new Error('PIE.MapTerrainDataSource.create: input server is NULL');
        }
        if (!name || name == "") {
          throw new Error('THREE.MapTerrainDataSource.create: input alias is NULL');
        }
        if (epsg == null) {
          epsg = 3857;
        }
        if (bounds == null) {
          bounds = [-20037508.342789244, 20037508.342789244, 20037508.342789244, -20037508.342789244];
          if (epsg == 4326 || epsg == 4490) {
            bounds = [-180, 90, 180, -90];
          }
        }
        if (indexBounds == null) {
          indexBounds = [-20037508.342789244, 20037508.342789244, 20037508.342789244, -20037508.342789244];
          if (epsg == 4326 || epsg == 4490) {
            indexBounds = [-180, 90, 180, -90];
          }
        }
        if (options.levelOffset != null) {
          levelOffset = options.levelOffset;
        }
        dpi = dpi == null ? 96 : dpi;
        tileSize = tileSize == null ? 256 : tileSize;
        if (tileType == null) {
          tileType = "png";
        }
        var strTileType = new PIEString$1(tileType);
        if (urlFormat == null) {
          urlFormat = "";
        }
        var strUrlFormat = new PIEString$1(urlFormat);
        var strProvider = new PIEString$1(provider);
        var strName = new PIEString$1(name);
        var strCachePath = null;
        if (cachePath != null) {
          strCachePath = new PIEString$1(cachePath);
        }
        var arrayBounds = null;
        var arrayIndexBounds = null;
        var arrayScales = null;
        var spatialRef = PIESpatialReference.fromEpsg(epsg);
        if (bounds instanceof Array) {
          arrayBounds = new PIEArray(bounds, PIEArrayType.Float64);
        } else if (bounds instanceof PIEBounds) {
          arrayBounds = PIEBounds.toArray(bounds);
        }
        if (indexBounds instanceof Array) {
          arrayIndexBounds = new PIEArray(indexBounds, PIEArrayType.Float64);
        } else if (indexBounds instanceof PIEBounds) {
          arrayIndexBounds = PIEBounds.toArray(indexBounds);
        }
        if (scales != null && scales instanceof Array) {
          scaleCount = scales.length;
          arrayScales = new PIEArray(scales, PIEArrayType.Float64);
        }
        var cachePathPar = null;
        if (strCachePath != null) {
          cachePathPar = strCachePath.getHandle();
        }
        var scalesPar = null;
        if (arrayScales) {
          scalesPar = arrayScales.getHandle();
        }
        if (tileRowInverseMode == null) {
          tileRowInverseMode = false;
        }
        if (strProvider && arrayBounds && arrayIndexBounds) {
          this.handle = Module._DataSource_CreateTileDataSourceEx(strProvider.getHandle(), strUrlFormat.getHandle(), cachePathPar, strName.getHandle(), spatialRef.getHandle(), arrayIndexBounds.getHandle(), arrayBounds.getHandle(), dpi, tileSize, scalesPar, scaleCount, strTileType.getHandle(), levelOffset, tileRowInverseMode, bottomLevel);
        }
        spatialRef.dispose();
        strProvider.dispose();
        strName.dispose();
        strUrlFormat.dispose();
        strTileType.dispose();
        if (strCachePath) {
          strCachePath.dispose();
        }
        if (arrayBounds) {
          arrayBounds.dispose();
        }
        if (arrayIndexBounds) {
          arrayIndexBounds.dispose();
        }
        if (arrayScales) {
          arrayScales.dispose();
        }
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维相机操作相关函数
   * @name WorldCamera
   */
  function PIEWorldCamera(handle) {
    this.handle = handle;
  }
  Object.assign(PIEWorldCamera.prototype, {
    /**
     * 设置相机平滑效果
     *@param {Boolean} smooth -是否需要相机平滑效果
     * @memberOf WorldCamera#
     */
    setSmooth: function setSmooth(smooth) {
      Module._WorldCamera_SetSmooth(this.handle, smooth);
    },
    /**
     * 获取是否需要相机平滑效果
     *
     * @memberOf WorldCamera#
     *@returns {Boolean} true 需要平滑效果,false 不需要平滑效果
     *
     */
    isSmooth: function isSmooth() {
      return Module._WorldCamera_IsSmooth(this.handle);
    },
    /**
     * 设置相机缓冲效果的缩放惯性大小
     *@param {Number} speedRatio -缩放动作被分步执行的次数(默认为30，speedRatio越大惯性越大，speedRatio=1时惯性消失)
     * @memberOf WorldCamera#
     *
     */
    setZoomSpeed: function setZoomSpeed(speedRatio) {
      Module._WorldCamera_SetZoomSpeed(this.handle, speedRatio);
    },
    /**
     * 获取相机缓冲效果的缩放惯性大小
     *
     * @memberOf WorldCamera#
     *@returns {Number} 成功返回缩放惯性大小 , 失败返回-1
     *
     */
    getZoomSpeed: function getZoomSpeed() {
      return Module._WorldCamera_GetZoomSpeed(this.handle);
    },
    /**
     *设置相机缓冲效果的俯仰惯性大小
     *@param {speedRatio} speedRatio -俯仰动作被分步执行的次数(speedRatio默认值为30，speedRatio越大惯性越大，speedRatio=1时惯性消失)
     * @memberOf WorldCamera#
     *
     */
    setPitchSpeed: function setPitchSpeed(speedRatio) {
      Module._WorldCamera_SetPitchSpeed(this.handle, speedRatio);
    },
    /**
     *获取相机缓冲效果的俯仰惯性大小
     *
     * @memberOf WorldCamera#
     *@returns {Number} 成功返回俯仰惯性大小，失败返回-1
     *
     */
    getPitchSpeed: function getPitchSpeed() {
      return Module._WorldCamera_GetPitchSpeed(this.handle);
    },
    /**
     *设置相机缓冲效果的偏航惯性大小
     *@param {Number} speedRatio -偏航动作被分步执行的次数(speedRatio默认值为30，speedRatio越大惯性越大，speedRatio=1时惯性消失)
     * @memberOf WorldCamera#
     *
     */
    setHeadSpeed: function setHeadSpeed(speedRatio) {
      Module._WorldCamera_SetHeadSpeed(this.handle, speedRatio);
    },
    /**
     *获取相机缓冲效果的偏航惯性大小
     *
     * @memberOf WorldCamera#
     *@returns {Number} 成功返回偏航惯性大小，失败返回-1
     *
     */
    getHeadSpeed: function getHeadSpeed() {
      return Module._WorldCamera_GetHeadSpeed(this.handle);
    },
    /**
     *设置相机缓冲效果的平移惯性大小
     *@param {Number} speedRatio -平移动作被分步执行的次数(speedRatio默认值为30，speedRatio越大惯性越大，speedRatio=1时惯性消失)
     * @memberOf WorldCamera#
     *
     */
    setMoveSpeed: function setMoveSpeed(speedRatio) {
      Module._WorldCamera_SetMoveSpeed(this.handle, speedRatio);
    },
    /**
     *获取相机缓冲效果的平移惯性大小
     *
     * @memberOf WorldCamera#
     *@returns {Number} 成功返回俯仰惯性大小，失败返回-1
     *
     */
    getMoveSpeed: function getMoveSpeed() {
      return Module._WorldCamera_GetMoveSpeed(this.handle);
    },
    /**
     *获取相机距离
     *
     * @memberOf WorldCamera#
     *@returns {Number} 相机距离
     *
     */
    getDistance: function getDistance() {
      return Module._WorldCamera_GetDistance(this.handle);
    },
    /**
     *设置相机距离
     *@param {Number} distance -相机距离
     * @memberOf WorldCamera#
     *
     */
    setDistance: function setDistance(distance) {
      Module._WorldCamera_SetDistance(this.handle, distance);
    },
    // /**
    //  *设置是否开启水下浏览
    //  *@param {Boolean} enable -是否开启水下浏览
    //  * @memberOf WorldCamera#
    //  *
    //  */
    setEnableUnderWater: function setEnableUnderWater(enable) {
      Module._WorldCamera_SetEnableUnderWater(this.handle, enable);
    },
    // /**
    //  *获取是否开启水下浏览
    //  *
    //  * @memberOf WorldCamera#
    //  *@returns {Boolean} 返回是否开启水下浏览
    //  *
    //  */
    isEnableUnderWater: function isEnableUnderWater() {
      return Module._WorldCamera_IsEnableUnderWater(this.handle);
    },
    /**
     *设置是否开启场景深度分割渲染
     *@param {Boolean} enable -是否开启场景深度分割渲染
     * @memberOf WorldCamera#
     *
     */
    setEnableDepthPartition: function setEnableDepthPartition(enable) {
      Module._WorldCamera_SetEnableDepthPartition(this.handle, enable);
    },
    /**
     *获取是否开启场景深度分割渲染
     *
     * @memberOf WorldCamera#
     *@returns {Boolean} 返回是否开启场景深度分割渲染
     *
     */
    isEnableDepthPartition: function isEnableDepthPartition() {
      return Boolean(Module._WorldCamera_IsEnableDepthPartition(this.handle));
    },
    /**
     *设置是否开启地形雾化效果
     *@param {Boolean} enable -是否开启地形雾化效果
     * @memberOf WorldCamera#
     *
     */
    setEnableFog: function setEnableFog(enable) {
      Module._WorldCamera_SetEnableFog(this.handle, enable);
    },
    /**
     *获取是否开启地形雾化效果
     *
     * @memberOf WorldCamera#
     *@returns {Boolean} 返回是否开启地形雾化效果
     *
     */
    isEnableFog: function isEnableFog() {
      return Boolean(Module._WorldCamera_IsEnableFog(this.handle));
    },
    /**
     *设置地形雾化距离比率
     *@param {Number} ratio -设置地形雾化距离比率
     * @memberOf WorldCamera#
     *
     */
    setFogDistanceRatio: function setFogDistanceRatio(ratio) {
      Module._WorldCamera_SetFogDistanceRatio(this.handle, ratio);
    },
    /**
     *获取地形雾化距离比率
     *
     * @memberOf WorldCamera#
     *@returns {Number} 返回地形雾化距离比率
     *
     */
    getFogDistanceRatio: function getFogDistanceRatio() {
      return Module._WorldCamera_GetFogDistanceRatio(this.handle);
    },
    /**
     *获取指定地图坐标对应的地形高度
     *@param {PIESceneMode} sceneMode -场景模式
     *@param {(Array/PIEVector2)} point -地图坐标
     * @memberOf WorldCamera#
     *
     * @returns {Number} 地形高度
     *
     */
    getHPElevation: function getHPElevation(sceneMode, point) {
      var array = [];
      if (point instanceof Array) {
        array = point;
      } else if (point instanceof PIEVector2) {
        array = [point.x, point.y];
      }
      if (array.length) {
        var arrayPoint = new PIEArray(array, PIEArrayType.Float64);
        var res = Module._WorldCamera_GetHPElevation(this.handle, sceneMode, arrayPoint.getHandle());
        arrayPoint.dispose();
        return res;
      }
      return -1;
    },
    /**
     *获取指定世界坐标对应的地形高度
     *@param {PIESceneMode} sceneMode -场景模式
     *@param {(Array/PIEVector3)} point -世界坐标
     * @memberOf WorldCamera#
     *
     * @returns {Number} {Number} 地形高度
     */
    getHPElevationEx: function getHPElevationEx(sceneMode, point) {
      var array = [];
      if (point instanceof Array) {
        array = point;
      } else if (point instanceof PIEVector3) {
        array = [point.x, point.y, point.z];
      }
      if (array.length) {
        var arrayPoint = new PIEArray(array, PIEArrayType.Float64);
        var res = Module._WorldCamera_GetHPElevationEx(this.handle, sceneMode, arrayPoint.getHandle());
        arrayPoint.dispose();
        return res;
      }
      return -1;
    },
    /**
     * 设置视锥体开关
     * @param {Boolean} enableFarClipping -是否关闭
     * @memberOf WorldCamera#
     *
     */
    setEnableFarClipping: function setEnableFarClipping(enableFarClipping) {
      Module._WorldCamera_SetEnableFarClipping(this.handle, enableFarClipping);
    },
    /**
     * 读取视锥体当前的状态
     *
     * @memberOf WorldCamera#
     * @returns {Boolean} 返回视锥体的当前状态(true表示视锥体的状态开启,false表示视锥体的状态关闭)
     *
     */
    isEnableFarClipping: function isEnableFarClipping() {
      return Boolean(Module._WorldCamera_IsEnableFarClipping(this.handle));
    },
    /**
     *设置相机自动跟踪效果
     *@param {Boolean} lockPosition -是否锁定位置
     *@param {Boolean} lockDistance -是否锁定距离
     * @param {Boolean} lockHeading -是否锁定旋转
     * @param {Boolean} lockPitch -是否锁定俯仰
     * @param {Boolean} lockBank -是否锁定翻滚
     * @param {(PIEVector3/Array)} offset3d -偏移距离
     * @param {PIERenderable} target -跟踪物体
     * @memberOf WorldCamera#
     *
     */
    setAutoTracking: function setAutoTracking(lockPosition, lockDistance, lockHeading, lockPitch, lockBank, offset3d, target) {
      var array = [];
      if (offset3d instanceof Array) {
        array = offset3d;
      } else if (offset3d instanceof PIEVector3) {
        array = [offset3d.x, offset3d.y, offset3d.z];
      }
      if (array.length) {
        var arrayOffset3d = new PIEArray(array, PIEArrayType.Float64);
        if (target == null) {
          Module._WorldCamera_SetAutoTracking(this.handle, lockPosition, lockDistance, lockHeading, lockPitch, lockBank, arrayOffset3d.getHandle(), null);
        } else {
          Module._WorldCamera_SetAutoTracking(this.handle, lockPosition, lockDistance, lockHeading, lockPitch, lockBank, arrayOffset3d.getHandle(), target.getHandle());
        }
        arrayOffset3d.dispose();
      }
    },
    // /**
    //  *获取相机跟随本地坐标
    //  *
    //  * @memberOf WorldCamera#
    //  * @returns {Boolean} true 获取成功,false 获取失败
    //  */
    autoTrack: function autoTrack() {
      return Module._WorldCamera_AutoTrack(this.handle);
    },
    /**
     *获取相机跟随本地坐标
     *
     * @memberOf WorldCamera#
     * @returns {PIEVector3} 返回跟随本地坐标
     */
    getTrackTargetPosition: function getTrackTargetPosition() {
      var arrayTargetPosition = new PIEArray(3, PIEArrayType.Float64);
      Module._WorldCamera_GetTrackTargetPosition(this.handle, arrayTargetPosition.getHandle());
      arrayTargetPosition.updateData();
      var vecArray = arrayTargetPosition.toArray();
      var vector3d = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
      arrayTargetPosition.dispose();
      return vector3d;
    },
    /**
     *设置相机跟随本地坐标
     * @param {(PIEVector3/Array)} position -跟随本地坐标
     * @memberOf WorldCamera#
     *
     */
    setTrackTargetPosition: function setTrackTargetPosition(position) {
      var array = [];
      if (position instanceof Array) {
        array = position;
      } else if (position instanceof PIEVector3) {
        array = [position.x, position.y, position.z];
      }
      if (array.length) {
        var arrayPosition = new PIEArray(array, PIEArrayType.Float64);
        Module._WorldCamera_SetTrackTargetPosition(this.handle, arrayPosition.getHandle());
        arrayPosition.dispose();
      }
    },
    /**
     *获取相机跟随旋转角度
     *
     * @memberOf WorldCamera#
     * @returns {PIEVector3} 返回跟随旋转角度
     */
    getTrackTargetRotation: function getTrackTargetRotation() {
      var arrayTargetRotation = new PIEArray(3, PIEArrayType.Float64);
      Module._WorldCamera_GetTrackTargetRotation(this.handle, arrayTargetRotation.getHandle());
      arrayTargetRotation.updateData();
      var vecArray = arrayTargetRotation.toArray();
      var vector3d = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
      arrayTargetRotation.dispose();
      return vector3d;
    },
    /**
     *设置相机跟随旋转角度
     * @param {(PIEVector3/Array)} rotation -跟随旋转角度
     * @memberOf WorldCamera#
     *
     */
    setTrackTargetRotation: function setTrackTargetRotation(rotation) {
      var array = [];
      if (rotation instanceof Array) {
        array = rotation;
      } else if (rotation instanceof PIEVector3) {
        array = [rotation.x, rotation.y, rotation.z];
      }
      if (array.length) {
        var arrayRotation = new PIEArray(array, PIEArrayType.Float64);
        Module._WorldCamera_SetTrackTargetRotation(this.handle, arrayRotation.getHandle());
        arrayRotation.dispose();
      }
    },
    /**
     *获取相机跟随世界坐标
     *
     * @memberOf WorldCamera#
     * @returns {PIEVector3} 返回跟随世界坐标
     */
    getTrackTargetWorldPosition: function getTrackTargetWorldPosition() {
      var arrayTargetPosition = new PIEArray(3, PIEArrayType.Float64);
      Module._WorldCamera_GetTrackTargetWorldPosition(this.handle, arrayTargetPosition.getHandle());
      arrayTargetPosition.updateData();
      var vecArray = arrayTargetPosition.toArray();
      var vector3d = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
      arrayTargetPosition.dispose();
      return vector3d;
    },
    /**
     *设置相机跟随世界坐标
     * @param {(PIEVector3/Array)} position -跟随世界坐标
     * @memberOf WorldCamera#
     *
     */
    setTrackTargetWorldPosition: function setTrackTargetWorldPosition(position) {
      var array = [];
      if (position instanceof Array) {
        array = position;
      } else if (position instanceof PIEVector3) {
        array = [position.x, position.y, position.z];
      }
      if (array.length) {
        var arrayPosition = new PIEArray(array, PIEArrayType.Float64);
        Module._WorldCamera_SetTrackTargetWorldPosition(this.handle, arrayPosition.getHandle());
        arrayPosition.dispose();
      }
    },
    /**
     * 设置是否自定义相机参数
     * @param {Boolean} custom -是否自定义
     * @memberOf WorldCamera#
     *
     */
    setCustomCamera: function setCustomCamera(custom) {
      Module._WorldCamera_SetCustomCamera(this.handle, custom);
    },
    /**
     * 获取是否自定义相机参数
     *
     * @memberOf WorldCamera#
     * @returns {Boolean}  true 是自定义相机 ,false 不是自定义相机
     */
    isCustomCamera: function isCustomCamera() {
      return Boolean(Module._WorldCamera_IsCustomCamera(this.handle));
    },
    /**
     *设置相机视场角度
     * @param {Number} fov -视场角度
     * @memberOf WorldCamera#
     *
     */
    setFov: function setFov(fov) {
      Module._WorldCamera_SetFov(this.handle, fov);
    },
    /**
     *获取相机视场角度
     *
     * @memberOf WorldCamera#
     * @returns {Number} 视场角度
     */
    getFov: function getFov() {
      return Module._WorldCamera_GetFov(this.handle);
    },
    /**
     *获取相机视口宽高比
     *
     * @memberOf WorldCamera#
     * @returns {Number} 视口宽高比
     */
    getAspect: function getAspect() {
      return Module._WorldCamera_GetAspect(this.handle);
    },
    /**
     *获取相机近裁剪面距离
     *
     * @memberOf WorldCamera#
     * @returns {Number} 近裁剪面距离
     */
    getNearClipDistance: function getNearClipDistance() {
      return Module._WorldCamera_GetNearClipDistance(this.handle);
    },
    /**
     *获取相机远裁剪面距离
     *
     * @memberOf WorldCamera#
     * @returns {Number} 远裁剪面距离
     */
    getFarClipDistance: function getFarClipDistance() {
      return Module._WorldCamera_GetFarClipDistance(this.handle);
    },
    /**
     *获取相机相对视图矩阵
     *
     * @memberOf WorldCamera#
     * @returns {PIEMatrix4} 相机相对视图矩阵
     */
    getRelativeViewMatrix: function getRelativeViewMatrix() {
      var matrix = new PIEArray(16, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetRelativeViewMatrix(this.handle, matrix.getHandle());
      matrix.updateData();
      if (res) {
        var viewArray = matrix.toArray();
        var viewMatrix = PIEMatrix4.fromArray(viewArray);
        matrix.dispose();
        return viewMatrix;
      }
      matrix.dispose();
      return null;
    },
    // /**
    //  *获取相机相对视图矩阵
    //  *
    //  * @memberOf WorldCamera#
    //  * @returns {PIEMatrix4} 相机相对视图矩阵
    //  *
    //  */
    getRelativeViewMatrixF: function getRelativeViewMatrixF() {
      var matrix = new PIEArray(16, PIEArrayType.Float32);
      var res = Module._WorldCamera_GetRelativeViewMatrixF(this.handle, matrix.getHandle());
      matrix.updateData();
      if (res) {
        var viewArray = matrix.toArray();
        var viewMatrix = PIEMatrix4.fromArray(viewArray);
        matrix.dispose();
        return viewMatrix;
      }
      matrix.dispose();
      return null;
    },
    /**
     *获取相机自定义相对中心
     *
     * @memberOf WorldCamera#
     * @returns {PIEVector3} 自定义相对中心(获取失败返回null)
     */
    getReferenceCenter: function getReferenceCenter() {
      var arrayCenter3d = new PIEArray(3, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetReferenceCenter(this.handle, arrayCenter3d.getHandle());
      if (res) {
        arrayCenter3d.updateData();
        var vecArray = arrayCenter3d.toArray();
        var vector3 = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
        arrayCenter3d.dispose();
        return vector3;
      }
      arrayCenter3d.dispose();
      return null;
    },
    /**
     *获取相机位置
     *
     * @memberOf WorldCamera#
     * @returns {PIEVector3} 相机位置(获取失败返回null)
     */
    getCameraPosition: function getCameraPosition() {
      var array = new PIEArray(3, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetCameraPosition(this.handle, array.getHandle());
      if (res) {
        array.updateData();
        var vecArray = array.toArray();
        var vector3 = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
        array.dispose();
        return vector3;
      }
      array.dispose();
      return null;
    },
    /**
     *设置相机自定义相对中心
     * @param {Boolean} custom -是否自定义
     * @param {(PIEVector3/Array)} center3d -自定义相对中心
     * @returns {Boolean} 设置是否成功
     * @memberOf WorldCamera#
     */
    setCustomReferenceCenter: function setCustomReferenceCenter(custom, center3d) {
      var array = [];
      var res = false;
      if (center3d instanceof Array) {
        array = center3d;
      } else if (center3d instanceof PIEVector3) {
        array = [center3d.x, center3d.y, center3d.z];
      }
      if (array.length) {
        var arrayCenter = new PIEArray(array, PIEArrayType.Float64);
        res = Module._WorldCamera_SetCustomReferenceCenter(this.handle, custom, arrayCenter.getHandle());
        arrayCenter.dispose();
      }
      return Boolean(res);
    },
    /**
     *获取相机自定义相对中心
     * @memberOf WorldCamera#
     * @returns {PIEVector3} 相机自定义相对中心(获取失败返回null)
     */
    getCustomReferenceCenter: function getCustomReferenceCenter() {
      var array = new PIEArray(3, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetCustomReferenceCenter(this.handle, array.getHandle());
      if (res) {
        array.updateData();
        var vecArray = array.toArray();
        var vector3 = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
        array.dispose();
        return vector3;
      }
      array.dispose();
      return null;
    },
    /** 设置相机自定义视图矩阵
     *  @param {Boolean} custom -是否自定义
     *  @param {PIEMatrix4} matrix -自定义视图矩阵
     *  @return {Boolean} 设置是否成功
     *  @memberOf WorldCamera#
     */
    setCustomViewMatrix: function setCustomViewMatrix(custom, matrix) {
      if (matrix instanceof PIEMatrix4) {
        var arrayMatrix = new PIEArray(matrix.m, PIEArrayType.Float64);
        var res = Module._WorldCamera_SetCustomViewMatrix(this.handle, custom, arrayMatrix.getHandle());
        arrayMatrix.dispose();
        return Boolean(res);
      }
      return false;
    },
    /** 获取相机自定义视图矩阵
     *  @return {PIEMatrix4}自定义视图矩阵(获取失败返回null)
     *  @memberOf WorldCamera#
     */
    getCustomViewMatrix: function getCustomViewMatrix() {
      var matrix = new PIEArray(16, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetCustomViewMatrix(this.handle, matrix.getHandle());
      if (res) {
        matrix.updateData();
        var viewArray = matrix.toArray();
        var viewMatrix = PIEMatrix4.fromArray(viewArray);
        matrix.dispose();
        return viewMatrix;
      }
      matrix.dispose();
      return null;
    },
    /** 设置相机自定义投影矩阵
     *  @param {Boolean} custom -是否自定义
     *  @param {PIEMatrix4}  matrix -自定义投影矩阵
     *  @return {Boolean} 设置是否成功
     *  @memberOf WorldCamera#
     */
    setCustomProjectionMatrix: function setCustomProjectionMatrix(custom, matrix) {
      if (matrix instanceof PIEMatrix4) {
        var arrayMatrix = new PIEArray(matrix.m, PIEArrayType.Float64);
        var res = Module._WorldCamera_SetCustomProjectionMatrix(this.handle, custom, arrayMatrix.getHandle());
        arrayMatrix.dispose();
        return Boolean(res);
      }
      return false;
    },
    /** 获取相机自定义投影矩阵
     *  @return {PIEMatrix4} 自定义投影矩阵(获取失败返回null)
     *  @memberOf WorldCamera#
     */
    getCustomProjectionMatrix: function getCustomProjectionMatrix() {
      var matrix = new PIEArray(16, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetCustomProjectionMatrix(this.handle, matrix.getHandle());
      if (res) {
        matrix.updateData();
        var viewArray = matrix.toArray();
        var viewMatrix = PIEMatrix4.fromArray(viewArray);
        matrix.dispose();
        return viewMatrix;
      }
      matrix.dispose();
      return null;
    },
    /** 获取相机视图矩阵
     *  @return {PIEMatrix4}相机视图矩阵(获取失败返回null)
     *  @memberOf WorldCamera#
     */
    getViewMatrix: function getViewMatrix() {
      var matrix = new PIEArray(16, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetViewMatrix(this.handle, matrix.getHandle());
      if (res) {
        matrix.updateData();
        var viewArray = matrix.toArray();
        var viewMatrix = PIEMatrix4.fromArray(viewArray);
        matrix.dispose();
        return viewMatrix;
      }
      matrix.dispose();
      return null;
    },
    /** 获取相机投影矩阵
     *  @return {PIEMatrix4} 相机投影矩阵(获取失败返回null)
     *  @memberOf WorldCamera#
     */
    getProjectionMatrix: function getProjectionMatrix() {
      var matrix = new PIEArray(16, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetProjectionMatrix(this.handle, matrix.getHandle());
      if (res) {
        matrix.updateData();
        var projectionArray = matrix.toArray();
        var projectionMatrix = PIEMatrix4.fromArray(projectionArray);
        matrix.dispose();
        return projectionMatrix;
      }
      matrix.dispose();
      return null;
    },
    /** 获取相机相对投影矩阵
     *  @return {PIEMatrix4} 相对投影矩阵(获取失败返回null)
     *  @memberOf WorldCamera#
     */
    getRelativeProjectionMatrix: function getRelativeProjectionMatrix() {
      var matrix = new PIEArray(16, PIEArrayType.Float64);
      var res = Module._WorldCamera_GetRelativeProjectionMatrix(this.handle, matrix.getHandle());
      var projectionMatrix = null;
      if (res) {
        matrix.updateData();
        var projectionArray = matrix.toArray();
        projectionMatrix = PIEMatrix4.fromArray(projectionArray);
      }
      matrix.dispose();
      return projectionMatrix;
    },
    // /** 获取相机相对投影矩阵
    //  *  @return {PIEMatrix4} 相对投影矩阵(获取失败返回null)
    //  *  @memberOf WorldCamera#
    //  */
    getRelativeProjectionMatrixF: function getRelativeProjectionMatrixF() {
      var matrix = new PIEArray(16, PIEArrayType.Float32);
      var res = Module._WorldCamera_GetRelativeProjectionMatrixF(this.handle, matrix.getHandle());
      var projectionMatrix = null;
      if (res) {
        matrix.updateData();
        var projectionArray = matrix.toArray();
        projectionMatrix = PIEMatrix4.fromArray(projectionArray);
      }
      matrix.dispose();
      return projectionMatrix;
    },
    /**
     *刷新相机
     * @memberOf WorldCamera#
     *
     */
    refresh: function refresh() {
      Module._WorldCamera_Refresh(this.handle);
    },
    // /**
    //  *刷新相机俯仰参数
    //  * @memberOf WorldCamera#
    //  *
    //  */
    refreshPitch: function refreshPitch() {
      Module._WorldCamera_RefreshPitch(this.handle);
    },
    // /** 刷新相机俯仰参数
    //  *  @param {PIEVector3/Array} center -相机观察中心点
    //  *  @memberOf WorldCamera#
    //  */
    refreshCenterPitch: function refreshCenterPitch(center) {
      var centerArray = null;
      if (center instanceof PIEVector3) {
        centerArray = center.toArray();
      } else if (center instanceof Array) {
        centerArray = center;
      }
      if (centerArray) {
        var arrayCenter = new PIEArray(centerArray, PIEArrayType.Float64);
        Module._WorldCamera_RefreshCenterPitch(this.handle, arrayCenter.getHandle());
        arrayCenter.dispose();
      }
    },
    /** 相机观察点定位
     *  @param {PIEVector3/Array} center -相机观察中心点
     *  @param {Number}  distance -相机距离
     *  @param {Number}  headingAngle -相机旋转角度
     *  @param {Number}  pitchAngle -相机俯仰角度
     *  @param {Number}  bankAngle -相机偏转角度
     *  @memberOf WorldCamera#
     */
    setLookAt: function setLookAt(center, distance) {
      var headingAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var pitchAngle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var bankAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var centerArray = null;
      if (center instanceof PIEVector3) {
        centerArray = center.toArray();
      } else if (center instanceof Array) {
        centerArray = center;
      }
      if (centerArray) {
        var headingRadian = headingAngle * Math.PI / 180;
        var pitchRadian = pitchAngle * Math.PI / 180;
        var bankRadian = bankAngle * Math.PI / 180;
        var arrayCenter = new PIEArray(centerArray, PIEArrayType.Float64);
        Module._WorldCamera_SetLookAt(this.handle, arrayCenter.getHandle(), distance, headingRadian, pitchRadian, bankRadian);
        arrayCenter.dispose();
      }
    },
    // /** 开始相机俯仰
    //  *  @memberOf WorldCamera#
    //  */
    beginPitch: function beginPitch() {
      Module._WorldCamera_BeginPitch(this.handle);
    },
    // /** 结束相机俯仰
    //  *  @memberOf WorldCamera#
    //  */
    endPitch: function endPitch() {
      Module._WorldCamera_EndPitch(this.handle);
    },
    /**
     *计算相机矩阵
     * @memberOf WorldCamera#
     *
     */
    computeMatrix: function computeMatrix() {
      Module._WorldCamera_ComputeMatrix(this.handle);
    },
    // setRenderCamera: function (referenceCenter3d, viewMatrix, projectionMatrix) {
    //     var arrayReferenceCenter3d = new PIEArray(referenceCenter3d, PIEArrayType.Float64);
    //     var arrayViewMatrix = new PIEArray(viewMatrix, PIEArrayType.Float64);
    //     var arrayProjectionMatrix = new PIEArray(projectionMatrix, PIEArrayType.Float64);
    //     var res = Module._WorldCamera_SetRenderCamera(this.handle, arrayReferenceCenter3d.getHandle(), arrayViewMatrix.getHandle(), arrayProjectionMatrix.getHandle());
    //     arrayReferenceCenter3d.dispose();
    //     arrayViewMatrix.dispose();
    //     arrayProjectionMatrix.dispose();
    //     return res;
    // },
    // /**
    //  *设置是否支持线程渲染
    //  * @param {Boolean} threadRendering -否线程渲染
    //  * @memberOf WorldCamera#
    //  *
    //  */
    setThreadRendering: function setThreadRendering(threadRendering) {
      Module._WorldCamera_SetThreadRendering(this.handle, threadRendering);
    },
    // /**
    //  *获取是否支持线程渲染
    //  *
    //  * @memberOf WorldCamera#
    //  * @returns {Boolean} true 是线程渲染 ,false 不是线程渲染
    //  */
    isThreadRendering: function isThreadRendering() {
      return Module._WorldCamera_IsThreadRendering(this.handle);
    },
    /**
     *设置是否自定义相机平滑
     * @param {Boolean} custom -是否自定义
     * @memberOf WorldCamera#
     *
     */
    setCustomSmooth: function setCustomSmooth(custom) {
      Module._WorldCamera_SetCustomSmooth(this.handle, custom);
    },
    /**
     *获取是否自定义相机平滑
     * @memberOf WorldCamera#
     * @return {Boolean} 返回是否自定义相机平滑
     */
    isCustomSmooth: function isCustomSmooth() {
      return Boolean(Module._WorldCamera_IsCustomSmooth(this.handle));
    },
    /**
     *设置是否刷新相机
     * @param {Boolean} refresh -是否刷新相机
     * @memberOf WorldCamera#
     *
     */
    setRefreshCamera: function setRefreshCamera(refresh) {
      Module._WorldCamera_SetRefreshCamera(this.handle, refresh);
    },
    /**
     *获取是否刷新相机
     *
     * @memberOf WorldCamera#
     * @returns {Boolean} refresh -是否刷新相机
     */
    isRefreshCamera: function isRefreshCamera() {
      return Boolean(Module._WorldCamera_IsRefreshCamera(this.handle));
    },
    /**
     *平滑移动相机(当IsSmooth时false时用户可在外部调用)
     * @memberOf WorldCamera#
     *
     */
    smooth: function smooth() {
      return Boolean(Module._WorldCamera_Smooth(this.handle));
    },
    /**
     * 设置瓦片多层级拉伸比例
     * @param {Number} lodScale -瓦片多层级拉伸比例
     * @memberOf WorldCamera#
     *
     */
    setTileLodScale: function setTileLodScale(lodScale) {
      Module._WorldCamera_SetTileLodScale(this.handle, lodScale);
    },
    /**
     * 获取瓦片多层级拉伸比例
     * @memberOf WorldCamera#
     * @returns {Number} lodScale -瓦片多层级拉伸比例
     */
    getTileLodScale: function getTileLodScale() {
      return Module._WorldCamera_GetTileLodScale(this.handle);
    },
    /**
     * 设置观察点位置
     * @param {(PIEVector3/Array)} lookAt -观察点位置
     * @memberOf WorldCamera#
     */
    setLookAtCenter: function setLookAtCenter(lookAt) {
      var lookAtArray = null;
      if (lookAt instanceof PIEVector3) {
        lookAtArray = lookAt.toArray();
      } else if (lookAt instanceof Array) {
        lookAtArray = lookAt;
      }
      if (lookAtArray) {
        var arrayLookAt = new PIEArray(lookAtArray, PIEArrayType.Float64);
        Module._WorldCamera_SetLookAtCenter(this.handle, arrayLookAt.getHandle());
        arrayLookAt.dispose();
      }
    },
    /**
     * 获取观察点位置
     *
     * @memberOf WorldCamera#
     * @returns {PIEVector3} 返回观察点位置
     */
    getLookAtCenter: function getLookAtCenter() {
      var arrayLookAt = new PIEArray(3, PIEArrayType.Float64);
      Module._WorldCamera_GetLookAtCenter(this.handle, arrayLookAt.getHandle());
      arrayLookAt.updateData();
      var array = arrayLookAt.toArray();
      arrayLookAt.dispose();
      return new PIEVector3(array[0], array[1], array[2]);
    },
    /**
     *执行相机动画
     * @param {PIEAction} action -动画对象
     * @memberOf WorldCamera#
     *
     */
    runAction: function runAction(action) {
      Module._WorldCamera_RunAction(this.handle, action.getHandle());
    },
    /**
     *停止相机动画
     * @param {PIEAction} action -动画对象
     * @memberOf WorldCamera#
     *
     */
    stopAction: function stopAction(action) {
      Module._WorldCamera_StopAction(this.handle, action.getHandle());
    },
    /**
     *停止所有相机动画
     * @memberOf WorldCamera#
     *
     */
    stopAllActions: function stopAllActions() {
      Module._WorldCamera_StopAllActions(this.handle);
    },
    /**
     *相机动画是否完成
     * @memberOf WorldCamera#
     * @returns {Boolean} 返回是否完成
     *
     */
    isAllActionsDone: function isAllActionsDone() {
      return Module._WorldCamera_IsAllActionsDone(this.handle);
    }

    // /**
    //  * 设置是否支持VR渲染
    //  * @param {Boolean} vRRendering -是否线程渲染
    //  * @memberOf WorldCamera#
    //  */
    // setVRRendering: function (vRRendering) {
    //     Module._WorldCamera_SetVRRendering(this.handle, vRRendering);
    // },

    // /**
    //  * 获取是否支持VR渲染
    //  *
    //  * @memberOf WorldCamera#
    //  * @returns {Boolean} 返回是否线程渲染(true-是线程渲染， false-不是线程渲染)
    //  *
    //  */
    // isVRRendering: function () {
    //     return Module._WorldCamera_IsVRRendering(this.handle);
    // },
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *  场景图层类型枚举
   * @readonly
   * @enum {number}
   */
  var PIEGlobeLayerType = {
    /** 未知图层 */
    UnKnown: -1,
    /** 基本要素图层 */
    BaseFeature: 1,
    /** 要素图层 */
    Feature: 3,
    /** 要素图层 */
    FeatureMap: 4,
    /** 基本栅格图层*/
    BaseRaster: 17,
    /** 栅格图层*/
    Raster: 19,
    /** 瓦片栅格图层*/
    TileRaster: 21,
    /**  高程图层*/
    Elevation: 31,
    /**  图形图层*/
    Graphics: 33,
    /**  渲染对象图层*/
    Renderable: 35,
    /**  渲染对象图层*/
    Plot: 37,
    /**  组合图层*/
    Composite: 65,
    /** 组图层*/
    Group: 67,
    // /** 基础地图图层*/
    // BaseMap: 69,
    // /** MVT图层*/
    // MVT: 70,
    /** 模型图层*/
    OSGBModel: 71,
    /** GE图层*/
    TileGEData: 72,
    /** 动态图层*/
    Dynamic: 257,
    /** 海图图层*/
    SeaMap: 73,
    /**mapbox矢量瓦片 */
    MapBoxData: 390
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维场景过滤器效果相关操作函数
   * @name GlobeEffectFilter
   * @class GlobeEffectFilter
   *
   */
  function PIEGlobeEffectFilter(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEGlobeEffectFilter.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 获取名称
     *
     * @memberOf GlobeEffectFilter#
     * @returns {String} 返回名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Globe_EffectFilter_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置名称
     * @param {String} name -名称
     * @memberOf GlobeEffectFilter#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      var res = Module._Globe_EffectFilter_SetName(this.handle, strName);
      strName.dispose();
      return res;
    },
    /**
     * 获取是否可用
     *
     * @memberOf GlobeEffectFilter#
     * @returns {Boolean} 返回是否可用
     */
    isEnable: function isEnable() {
      return Module._Globe_EffectFilter_IsEnable(this.handle);
    },
    /**
     * 设置是否可用
     * @param {Boolean} enable -是否可用
     * @memberOf GlobeEffectFilter#
     */
    setEnable: function setEnable(enable) {
      Module._Globe_EffectFilter_SetEnable(this.handle, enable);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 效果组合器
   * @name GlobeEffectComposer
   */
  function PIEGlobeEffectComposer(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEGlobeEffectComposer.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     *添加过滤器
     * @param {PIEGlobeEffectFilter} hEffectFilter -过滤器
     * @memberOf GlobeEffectComposer#
     */
    addFilter: function addFilter(hEffectFilter) {
      Module._Globe_EffectComposer_AddFilter(this.handle, hEffectFilter.getHandle());
    },
    /**
     * 获取过滤器
     * @param {Number} nIndex -索引
     * @memberOf GlobeEffectComposer#
     * @returns {PIEGlobeEffectFilter} 返回过滤器
     */
    getFilter: function getFilter(nIndex) {
      var handle = Module._Globe_EffectComposer_GetFilter(this.handle, nIndex);
      if (handle) {
        return new PIEGlobeEffectFilter(handle);
      }
    },
    /**
     * 移除过滤器
     * @param {Number} nIndex -索引
     * @memberOf GlobeEffectComposer#
     */
    removeFilter: function removeFilter(nIndex) {
      Module._Globe_EffectComposer_RemoveFilter(this.handle, nIndex);
    },
    /**
     * 移除所有的过滤器
     * @memberOf GlobeEffectComposer#
     */
    removeAllFilters: function removeAllFilters() {
      Module._Globe_EffectComposer_RemoveAllFilters(this.handle);
    },
    /**
     * 获取过滤器个数
     *
     * @memberOf GlobeEffectComposer#
     * @returns {Number} -过滤器个数
     */
    getFilterCount: function getFilterCount() {
      return Module._Globe_EffectComposer_GetFilterCount(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维组合图层操作函数
   * @name GlobeCompositeLayer
   * @extends GlobeLayer

   */
  function PIEGlobeCompositeLayer(handle, autoRelease) {
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeCompositeLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    /**
     * 添加图层
     * @param {PIEGlobeLayer} globeLayer - 目标图层对象
     * @param {Boolean} addToHead -是否添加到图层顶部
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} 如果成功返回true 失败返回false
     *
     */
    addLayer: function addLayer(globeLayer, addToHead) {
      if (!addToHead) {
        addToHead = true;
      }
      return Boolean(Module._GlobeCompositeLayer_AddLayer(this.handle, globeLayer.getHandle(), addToHead));
    },
    /**
     * 根据图层名移除图层
     * @param {PIEGlobeLayer} globeLayer -目标图层对象
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} 如果成功返回true，失败返回false
     *
     */
    removeLayer: function removeLayer(globeLayer) {
      return Boolean(Module._GlobeCompositeLayer_RemoveLayer(this.handle, globeLayer.getHandle()));
    },
    /**
     * 根据图层序列号移除图层
     * @param {Number} index -目标图层序列号
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} 如果成功返回true，失败返回false
     *
     */
    removeLayerAt: function removeLayerAt(index) {
      return Boolean(Module._GlobeCompositeLayer_RemoveLayerAt(this.handle, index));
    },
    /**
     * 根据图层名获取图层
     * @param {String} name -目标图层名称
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {PIEGlobeLayer} 返回图层对象
     *
     */
    getLayer: function getLayer(name) {
      var strName = new PIEString$1(name);
      var hLayer = Module._GlobeCompositeLayer_GetLayer(this.handle, strName.getHandle());
      strName.dispose();
      return PIEGlobeLayerFactory.CreateInstance(hLayer);
    },
    /**
     * 根据图层序列号获取图层
     * @param {Number} index -目标图层名称
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {PIEGlobeLayer} 返回图层对象
     *
     */
    getLayerAt: function getLayerAt(index) {
      var hLayer = Module._GlobeCompositeLayer_GetLayerAt(this.handle, index);
      return PIEGlobeLayerFactory.CreateInstance(hLayer);
    },
    /**
     * 获取图层索引
     * @param {PIEGlobeLayer} globeLayer -图层对象
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Number} 成功返回当前图层的索引，失败返回-1
     *
     */
    getLayerIndex: function getLayerIndex(globeLayer) {
      return Module._GlobeCompositeLayer_GetLayerIndex(this.handle, globeLayer.getHandle());
    },
    /**
     * 获取图层总数
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Number} 如果成功返回图层总数
     *
     */
    getLayerCount: function getLayerCount() {
      return Module._GlobeCompositeLayer_GetLayerCount(this.handle);
    },
    /**
     * 移除所有图层
     * @memberOf GlobeCompositeLayer#
     *
     */
    removeAllLayers: function removeAllLayers() {
      Module._GlobeCompositeLayer_RemoveAllLayers(this.handle);
    },
    /**
     * 将指定图层上移
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} true 移动成功,false 移动失败
     *
     */
    moveLayerUp: function moveLayerUp(index) {
      return Boolean(Module._GlobeCompositeLayer_MoveLayerUp(this.handle, index));
    },
    /**
     * 将指定图层下移
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} true 移动成功,false 移动失败
     *
     */
    moveLayerDown: function moveLayerDown(index) {
      return Boolean(Module._GlobeCompositeLayer_MoveLayerDown(this.handle, index));
    },
    /**
     * 将指定图层移到最顶端
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} true 移动成功,false 移动失败
     *
     */
    moveLayerTop: function moveLayerTop(index) {
      return Boolean(Module._GlobeCompositeLayer_MoveLayerTop(this.handle, index));
    },
    /**
     * 将指定图层移到最底端
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} true 移动成功,false 移动失败
     *
     */
    moveLayerBottom: function moveLayerBottom(index) {
      return Boolean(Module._GlobeCompositeLayer_MoveLayerBottom(this.handle, index));
    },
    /**
     * 将指定图层移到指定位置
     * @param {Number} indexSrc -源图层索引
     * @param {Number} indexDest -目标位置索引
     *
     * @memberOf GlobeCompositeLayer#
     * @returns {Boolean} true 移动成功,false 移动失败
     *
     */
    moveLayerTo: function moveLayerTo(indexSrc, indexDest) {
      return Boolean(Module._GlobeCompositeLayer_MoveLayerTo(this.handle, indexSrc, indexDest));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维组图层
   * @name GlobeGroupLayer
   * @class GlobeGroupLayer
   *  三维组图层操作函数
   * @extends GlobeCompositeLayer
   *
   * @example
   * let globeGroupLayer = new PIE.GlobeGroupLayer()
   */
  function PIEGlobeGroupLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_GroupLayer_Create();
      autoRelease = true;
    }
    PIEGlobeCompositeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeGroupLayer.prototype = Object.assign(Object.create(PIEGlobeCompositeLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维图层基础操作函数
   * @name GlobeLayer
   *
   */
  function PIEGlobeLayer(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEGlobeLayer.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 销毁对象
     * @memberOf GlobeLayer#
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._GlobeLayer_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 获取图层的类型
     *
     * @memberOf GlobeLayer#
     * @returns {PIEGlobeLayerType} 成功返回类型，失败返回NULL
     */
    getType: function getType() {
      return Module._GlobeLayer_GetType(this.handle);
    },
    /**
     * 设置图层的名字
     * @param {String} name -图层名
     * @memberOf GlobeLayer#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeLayer_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取图层的名字
     *
     * @memberOf GlobeLayer#
     * @returns {String} 图层名
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._GlobeLayer_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置图层是否可见
     * @param {Boolean} visible -是否可见
     * @memberOf GlobeLayer#
     */
    setVisible: function setVisible(visible) {
      Module._GlobeLayer_SetVisible(this.handle, visible);
    },
    /**
     * 获取图层是否可见
     *
     * @memberOf GlobeLayer#
     * @returns {Boolean} 可见返回true,不可见返回false
     */
    isVisible: function isVisible() {
      return Boolean(Module._GlobeLayer_IsVisible(this.handle));
    },
    /**
     * 设置图层的最大比例尺
     * @param {Number} scale -最大比例尺
     * @memberOf GlobeLayer#
     */
    setMaxVisibleScale: function setMaxVisibleScale(scale) {
      Module._GlobeLayer_SetMaxVisibleScale(this.handle, scale);
    },
    /**
     * 获取图层的最大比例尺
     *
     * @memberOf GlobeLayer#
     * @returns {Number} 如果成功返回比例尺值，失败返回0.0
     */
    getMaxVisibleScale: function getMaxVisibleScale() {
      return Module._GlobeLayer_GetMaxVisibleScale(this.handle);
    },
    /**
     * 设置图层的最小比例尺
     * @param {Number} scale -最小比例尺
     * @memberOf GlobeLayer#
     */
    setMinVisibleScale: function setMinVisibleScale(scale) {
      Module._GlobeLayer_SetMinVisibleScale(this.handle, scale);
    },
    /**
     * 获取图层的最小比例尺
     *
     * @memberOf GlobeLayer#
     * @returns {Number} 如果成功返回比例尺值，失败返回0.0
     */
    getMinVisibleScale: function getMinVisibleScale() {
      return Module._GlobeLayer_GetMinVisibleScale(this.handle);
    },
    /**
     * 设置图层是否总是可见
     * @param {Boolean} visible -是否总是可见
     * @memberOf GlobeLayer#
     */
    setAlwaysVisible: function setAlwaysVisible(visible) {
      Module._GlobeLayer_SetAlwaysVisible(this.handle, visible);
    },
    /**
     * 获取图层是否总是可见
     *
     * @memberOf GlobeLayer#
     * @returns {Boolean} 如果可见返回true，不可见返回false
     */
    isAlwaysVisible: function isAlwaysVisible() {
      return Boolean(Module._GlobeLayer_IsAlwaysVisible(this.handle));
    },
    /**
     * 获取图层范围
     *
     * @memberOf GlobeLayer#
     * @returns {PIEBounds} 图层范围
     */
    getBounds: function getBounds() {
      var arrayBounds = new PIEArray(4, PIEArrayType.Float64);
      Module._GlobeLayer_GetBounds(this.handle, arrayBounds.getHandle());
      arrayBounds.updateData();
      var bounds = PIEBounds.fromArray(arrayBounds);
      arrayBounds.dispose();
      return bounds;
    },
    /**
     * 获取图层投影对象
     *
     * @memberOf GlobeLayer#
     * @returns {PIESpatialReference} 投影对象
     */
    getSpatialReference: function getSpatialReference() {
      var handle = Module._GlobeLayer_GetSpatialReference(this.handle);
      if (handle) {
        return new PIESpatialReference(handle);
      }
      return null;
    },
    /**
     * 获取图层的父图层
     *
     * @memberOf GlobeLayer#
     * @returns {PIEGlobeLayer} 图层的父图层
     */
    getParent: function getParent() {
      var handle = Module._GlobeLayer_GetParent(this.handle);
      if (handle) {
        return PIEGlobeLayerFactory.CreateInstance(handle);
      }
      return null;
    },
    /**
     * 获取特效组合对象
     *
     * @memberOf GlobeLayer#
     * @returns {PIEGlobeEffectComposer} 返回特效组合对象  （不支持PIEGlobeGraphicsLayer）
     */
    getEffectComposer: function getEffectComposer() {
      var handle = Module._Globe_Layer_GetEffectComposer(this.handle);
      if (handle) {
        return new PIEGlobeEffectComposer(handle);
      }
      return null;
    },
    /**
     * 判断图层缓存是否已经准备好
     *
     * @memberOf GlobeLayer#
     * @returns {Boolean} 缓存是否已经准备好
     */
    isCacheReady: function isCacheReady() {
      return Module._Globe_Layer_IsCacheReady(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 图层选择集基础操作相关函数
   * @name Selection
   *
   */
  function PIESelection(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESelection.prototype, {
    /**
     * 取消选中所有对象
     * @memberOf Selection#
     *
     */
    removeAll: function removeAll() {
      Module._Selection_RemoveAll(this.handle);
    },
    /**
     * 获取选中集大小
     *
     * @memberOf Selection#
     * @returns {Number} 返回选中对象集中选中对象的数量
     *
     */
    getSize: function getSize() {
      return Module._Selection_GetSize(this.handle);
    },
    /**
     * 获取选中对象集中指定索引值的选中对象的ID
     * @param {Number} index -选中对象的索引值
     * @memberOf Selection#
     *
     * @returns {Number} 返回选中对象集中指定索引值的选中对象的ID
     *
     */
    getAt: function getAt(index) {
      return Module._Selection_GetAt(this.handle, index);
    },
    /**
     * 设置选中对象集中指定索引值的选中对象的ID
     * @param {Number} index -选中对象的索引值
     * @param {Number} ID -选中对象的ID
     * @memberOf Selection#
     *
     * @returns {Boolean} 返回是否成功设置选中对象集中指定索引值的选中对象的ID
     *
     */
    setAt: function setAt(index, ID) {
      return Module._Selection_SetAt(this.handle, index, ID);
    },
    /**
     * 选中对象集中增加选中对象ID
     * @param {Number} ID -选中对象的ID
     * @memberOf Selection#
     *
     * @returns {Number} 返回选中对象集中对象的个数
     *
     */
    add: function add(ID) {
      return Module._Selection_Add(this.handle, ID);
    },
    /**
     * 选中对象集中指定索引值处插入选中对象的ID
     * @param {Number} index -选中对象的索引值
     * @param {Number} ID -选中对象的ID
     * @memberOf Selection#
     *
     * @returns {Boolean} 返回选中对象集中指定索引处插入选中对象的ID是否成功
     *
     */
    insertAt: function insertAt(index, ID) {
      return Module._Selection_InsertAt(this.handle, index, ID);
    },
    /**
     * 查找指定ID在选择集中的索引
     * @param {Number} ID -选中对象的ID值
     * @param {Number} searchCount -查询个数
     * @memberOf Selection#
     *
     * @returns {Number} 返回索引
     *
     */
    findID: function findID(ID, searchCount) {
      return Module._Selection_FindID(this.handle, ID, searchCount);
    },
    /**
     * 删除指定索引后的count个选中对象
     * @param {Number} index -选中对象的索引值
     * @param {Number} count -索引后的count选中对象
     * @memberOf Selection#
     *
     * @returns {Number} 返回真正删除的个数
     *
     */
    removeAt: function removeAt(index, count) {
      return Module._Selection_RemoveAt(this.handle, index, count);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *  矢量渲染器类型枚举
   * @readonly
   * @enum {String}
   */
  var PIEFeatureRenderType = {
    /**  未知渲染器  */
    Null: -1,
    /**  简单矢量渲染器  */
    Simple: 1,
    /** 分段专题图  */
    ThemeRange: 3,
    /** 标签专题图  */
    ThemeLabel: 5,
    /** 唯一值专题图  */
    ThemeUnique: 7,
    /** 分类渲染器 只有分类渲染器才支持矢量沿模型显示或者分类显示  */
    Classify: 8,
    /** 军图渲染器 */
    SMS: 10,
    /** 海图渲染器 */
    Seamap: 11
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   *
   * 矢量渲染器操作函数
   * @name FeatureRenderer
   *
   */
  function PIEFeatureRenderer(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEFeatureRenderer.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     *
     * 删除渲染器对象
     * @memberOf FeatureRenderer#
     *
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._FeatureRenderer_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     *
     * 获取渲染器类型
     *
     * @memberOf FeatureRenderer#
     * @returns {PIEFeatureRendererType} 返回渲染器类型
     */
    getType: function getType() {
      return Module._FeatureRenderer_GetType(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   *创建简单渲染器对象
   * @name SimpleFeatureRenderer
   *@class SimpleFeatureRenderer
   * 简单矢量渲染器操作函数
   *
   * @extends FeatureRenderer
   * @example
   *
   *let simpleFeatureRenderer = new PIE.SimpleFeatureRenderer();
   */
  function PIESimpleFeatureRenderer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._SFeatureRenderer_Create();
      autoRelease = true;
    }
    PIEFeatureRenderer.call(this, handle, autoRelease);
  }
  PIESimpleFeatureRenderer.prototype = Object.assign(Object.create(PIEFeatureRenderer.prototype), {
    /**
     *设置渲染器的风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格句柄内部是否克隆(如果是true，风格句柄需要外部释放，否则会出现内存泄露；如果是false，风格句柄由内部保存并释放，外部不能释放，否则会出现崩溃) 默认值（false）
     * @memberOf SimpleFeatureRenderer#
     */
    setStyle: function setStyle(style) {
      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      Module._SFeatureRenderer_SetStyle(this.handle, style.getHandle(), clone);
    },
    /**
     *获取渲染器风格
     *
     * @memberOf SimpleFeatureRenderer#
     * @returns {PIEStyle} 返回风格对象，失败返回NULL
     */
    getStyle: function getStyle() {
      var hStyle = Module._SFeatureRenderer_GetStyle(this.handle);
      return PIEStyleFactory.CreateInstance(hStyle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 创建分类矢量渲染器对象
   * @name ClassifyFeatureRenderer
   *@class ClassifyFeatureRenderer
   * 分类矢量渲染器操作函数
   *
   * @extends SimpleFeatureRenderer
   * @example
   *
   *let classifyFeatureRenderer = PIE.ClassifyFeatureRenderer();
   */
  function PIEClassifyFeatureRenderer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._ClassifyFeatureRenderer_Create();
      autoRelease = true;
    }
    PIESimpleFeatureRenderer.call(this, handle, autoRelease);
  }
  PIEClassifyFeatureRenderer.prototype = Object.assign(Object.create(PIESimpleFeatureRenderer.prototype), {
    /**
     *设置渲染器的底部字段名称
     * @param {String} strField -字段名称
     * @memberOf ClassifyFeatureRenderer#
     */
    setBottomField: function setBottomField(strField) {
      var Field = new PIEString$1(strField);
      Module._ClassifyFeatureRenderer_SetBottomField(this.handle, Field.handle);
    },
    /**
     *获取渲染器的底部字段名称
     * @returns {String} 返回字段名称
     * @memberOf ClassifyFeatureRenderer#
     */
    getBottomField: function getBottomField() {
      var BottomField = new PIEString$1(256);
      Module._ClassifyFeatureRenderer_GetBottomField(this.handle, BottomField.getHandle());
      var strBottomField = BottomField.toString();
      BottomField.dispose();
      return strBottomField;
    },
    /**
     *设置渲染器的顶部字段名称
     * @param {String} field -字段名称
     * @memberOf ClassifyFeatureRenderer#
     */
    setTopField: function setTopField(field) {
      var strField = new PIEString$1(field);
      Module._ClassifyFeatureRenderer_SetTopField(this.handle, strField.getHandle());
      strField.dispose();
    },
    /**
     *获取渲染器的顶部字段名称
     * @returns {String} 返回字段名称
     * @memberOf ClassifyFeatureRenderer#
     */
    getTopField: function getTopField() {
      var BottomField = new PIEString$1(256);
      Module._ClassifyFeatureRenderer_GetTopField(this.handle, BottomField.getHandle());
      var strBottomField = BottomField.toString();
      BottomField.dispose();
      return strBottomField;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 创建分段项对象
   * @name RangeItem
   * @class RangeItem
   * 分段项操作函数
   *
   * @example
   * let rangeItem = new PIE.RangeItem()
   */
  function PIERangeItem(handle, autoRelease) {
    if (handle == null) {
      this.handle = Module._RangeItem_Create();
      this.autoRelease = true;
    } else {
      this.handle = handle;
      this.autoRelease = false;
    }
  }
  Object.assign(PIERangeItem.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._RangeItem_Delete(this.handle);
        this.handle = null;
      } else {
        this.handle = null;
      }
    },
    /**
     * 设置分段项是否可见
     * @param {Boolean} visible -分段项是否可见
     * @memberOf RangeItem#
     */
    setVisible: function setVisible(visible) {
      Module._RangeItem_SetVisible(this.handle, visible);
    },
    /**
     * 获取分段项是否可见
     * @memberOf RangeItem#
     * @returns {Boolean} 返回分段项是否可见
     */
    isVisible: function isVisible() {
      return Boolean(Module._RangeItem_IsVisible(this.handle));
    },
    /**
     * 设置分段项标题
     * @param {String} caption -分段项标题
     * @memberOf RangeItem#
     */
    setCaption: function setCaption(caption) {
      var strCaption = new PIEString$1(caption);
      Module._RangeItem_SetCaption(this.handle, strCaption.getHandle());
      strCaption.dispose();
    },
    /**
     * 获取分段项标题
     *
     * @memberOf RangeItem#
     * @returns {String} 返回分段项标题
     * @example
     * let rangeItem = new PIE.RangeItem()
     * var caption = rangeItem.getCaption()
     */
    getCaption: function getCaption() {
      var strCaption = new PIEString$1(256);
      Module._RangeItem_GetCaption(this.handle, strCaption.getHandle());
      var caption = strCaption.toString();
      strCaption.dispose();
      return caption;
    },
    /**
     * 设置分段项风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格句柄内部是否克隆(如果是true，风格句柄需要外部释放，否则会出现内存泄露；如果是false，风格句柄由内部保存并释放，外部不能释放，否则会出现崩溃) 默认值（false）
     * @memberOf RangeItem#
     */
    setStyle: function setStyle(style) {
      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      Module._RangeItem_SetStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取分段项风格
     *
     * @memberOf RangeItem#
     * @returns {PIEVectorStyle|PIETextStyle|PIESymbolStyle|PIEModelStyle} 返回分段项对象，失败返回NULL
     *
     */
    getStyle: function getStyle() {
      var hStyle = Module._RangeItem_GetStyle(this.handle);
      return PIEStyleFactory.CreateInstance(hStyle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 创建分段专题图渲染器对象
   * @name ThemeRangeFeatureRenderer
   * @class ThemeRangeFeatureRenderer
   * 分段专题图渲染器对象
   *
   * @returns {PIEThemeRangeFeatureRenderer} 成功返回渲染器对象，否则返回NULL
   * @extends FeatureRenderer
   * @example
   * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
   */
  function PIEThemeRangeFeatureRenderer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._TRFeatureRenderer_Create();
      autoRelease = true;
    }
    PIEFeatureRenderer.call(this, handle, autoRelease);
  }
  PIEThemeRangeFeatureRenderer.prototype = Object.assign(Object.create(PIEFeatureRenderer.prototype), {
    /**
     * 制作分段专题图
     * @param {PIEDataSource} dataSource -数据源对象
     * @param {Number} count -分段个数
     *
     * @memberOf ThemeRangeFeatureRenderer#
     * @returns {Boolean} 成功返回true，否则返回false
     */
    makeDefault: function makeDefault(dataSource, count) {
      return Boolean(Module._TRFeatureRenderer_MakeDefault(this.handle, dataSource.getDataset().getHandle(), count));
    },
    /**
     * 查询数据集中字段值的最小值和最大值
     * @param {PIEDataset} dataset -数据集对象
     * @param {String} expression -分段专题图字段
     * @memberOf ThemeRangeFeatureRenderer#
     *
     * @returns {Array} 返回最小值和最大值
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var extremes = themeRangeFeatureRenderer.queryExtremes(dataset, expression);
     */
    queryExtremes: function queryExtremes(dataset, expression) {
      var strExpression = new PIEString$1(expression);
      var arrayExtremes = new PIEArray(2, PIEArrayType.Float64);
      Module._TRFeatureRenderer_QueryExtremes(this.handle, dataset.getHandle(), strExpression.getHandle(), arrayExtremes.getHandle());
      strExpression.dispose();
      arrayExtremes.updateData();
      var extremes = arrayExtremes.toArray();
      arrayExtremes.dispose();
      return extremes;
    },
    /**
     * 设置渲染器的分段专题图字段
     * @param {String} expression -分段专题图字段
     * @memberOf ThemeRangeFeatureRenderer#
     */
    setRangeExpression: function setRangeExpression(expression) {
      var strExpression = new PIEString$1(expression);
      Module._TRFeatureRenderer_SetRangeExpression(this.handle, strExpression.getHandle());
      strExpression.dispose();
    },
    /**
     * 获取渲染器的分段专题图字段
     *
     * @memberOf ThemeRangeFeatureRenderer#
     * @returns {String} 返回分段专题图字段
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var expression = themeRangeFeatureRenderer.getRangeExpression();
     */
    getRangeExpression: function getRangeExpression() {
      var strExpression = new PIEString$1(256);
      Module._TRFeatureRenderer_GetRangeExpression(this.handle, strExpression.getHandle());
      var expression = strExpression.toString();
      strExpression.dispose();
      return expression;
    },
    /**
     * 是否降序排列分段范围数组
     *
     * @memberOf ThemeRangeFeatureRenderer#
     * @returns {Boolean} 返回是否是降序排列分段范围的数组
     *
     */
    isDescending: function isDescending() {
      return Boolean(Module._TRFeatureRenderer_IsDescending(this.handle));
    },
    /**
     * 设置降序排列分段范围数组
     * @param {Boolean} bDescending 是否降序排列
     * @memberOf ThemeRangeFeatureRenderer#
     */
    setDescending: function setDescending(descending) {
      Module._TRFeatureRenderer_SetDescending(this.handle, descending);
    },
    /**
     * 获取分段范围值数组个数
     *
     * @memberOf ThemeRangeFeatureRenderer#
     * @returns {Number} 返回分段范围值数组个数
     */
    getRangeValueCount: function getRangeValueCount() {
      return Module._TRFeatureRenderer_GetRangeValueCount(this.handle);
    },
    /**
     * 设置分段范围值数组
     * @param {Array} RangeValueArray -分段范围值数组
     * @memberOf ThemeRangeFeatureRenderer#
     */
    setRangeValues: function setRangeValues(RangeValueArray) {
      var arrayRange = new PIEArray(RangeValueArray, PIEArrayType.Float64);
      Module._TRFeatureRenderer_SetRangeValues(this.handle, arrayRange.getHandle(), RangeValueArray.length);
      arrayRange.dispose();
    },
    /**
     * 获取分段范围值数组
     *
     * @memberOf ThemeRangeFeatureRenderer#
     * @returns {Array} 返回分段范围值数组
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var rangeValues = themeRangeFeatureRenderer.getRangeValues();
     */
    getRangeValues: function getRangeValues() {
      var count = this.getRangeValueCount();
      if (count) {
        var arrayRangeValues = new PIEArray(count, PIEArrayType.Float64);
        Module._TRFeatureRenderer_GetRangeValues(this.handle, arrayRangeValues.getHandle(), count);
        arrayRangeValues.updateData();
        var rangeValues = arrayRangeValues.toArray();
        arrayRangeValues.dispose();
        return rangeValues;
      }
      return null;
    },
    /**
     * 设置分段项数组
     * @param {Array} rangeItems -分段项数组(PIERangeItem为数组对象)
     * @memberOf ThemeRangeFeatureRenderer#
     *
     */
    setRangeItems: function setRangeItems(rangeItems) {
      var arrayRangeItem = [];
      for (var i = 0; i < rangeItems.length; i++) {
        var item = rangeItems[i];
        arrayRangeItem.push(item.getHandle());
      }
      if (arrayRangeItem.length > 0) {
        var rangeItemArray = new PIEArray(arrayRangeItem, PIEArrayType.UInt32);
        Module._TRFeatureRenderer_SetRangeItems(this.handle, rangeItemArray.getHandle(), rangeItems.length);
        rangeItemArray.dispose();
      }
    },
    /**
     * 获取分段项数组个数(段范围数组比分段项数组的个数>1)
     *
     * @memberOf ThemeRangeFeatureRenderer#
     * @returns {Number} 返回分段项数组个数
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var rangeItemCount = themeRangeFeatureRenderer.getRangeItemCount();
     */
    getRangeItemCount: function getRangeItemCount() {
      return Module._TRFeatureRenderer_GetRangeItemCount(this.handle);
    },
    /**
     * 获取分段项数组
     *
     * @memberOf ThemeRangeFeatureRenderer#
     * @returns {Array} 返回分段项
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var rangeItems = themeRangeFeatureRenderer.getRangeItems();
     */
    getRangeItems: function getRangeItems() {
      var count = this.getRangeItemCount();
      if (count) {
        var arrayRangeItems = new PIEArray(count, PIEArrayType.UInt32);
        Module._TRFeatureRenderer_GetRangeItems(this.handle, arrayRangeItems.getHandle(), count);
        arrayRangeItems.updateData();
        var items = arrayRangeItems.toArray();
        var rangeItems = [];
        for (var i = 0; i < count; i++) {
          var item = new PIERangeItem(items[i]);
          rangeItems.push(item);
        }
        arrayRangeItems.dispose();
        return rangeItems;
      }
      return null;
    },
    /**
     * 获取指定索引分段范围值
     * @param {Number} index -分段范围值数组索引
     * @memberOf ThemeRangeFeatureRenderer#
     *
     * @returns {Number} 返回指定索引的分段范围值
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var rangeValueAt = themeRangeFeatureRenderer.getRangeValueAt();
     */
    getRangeValueAt: function getRangeValueAt(index) {
      return Module._TRFeatureRenderer_GetRangeValueAt(this.handle, index);
    },
    /**
     * 设置指定索引分段项
     * @param {Number} index -分段范围值数组索引
     * @param {Number} value -分段范围值
     * @memberOf ThemeRangeFeatureRenderer#
     */
    setRangeValueAt: function setRangeValueAt(index, value) {
      Module._TRFeatureRenderer_SetRangeValueAt(this.handle, index, value);
    },
    /**
     * 获取指定索引分段项
     * @param {Number} index -分段项数组索引
     * @memberOf ThemeRangeFeatureRenderer#
     *
     * @returns {PIERangeItem} 返回指定索引的分段项
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var rangeItemAt = themeRangeFeatureRenderer.getRangeItemAt(index);
     */
    getRangeItemAt: function getRangeItemAt(index) {
      var hRangeItem = Module._TRFeatureRenderer_GetRangeItemAt(this.handle, index);
      if (hRangeItem) {
        return new PIERangeItem(hRangeItem);
      }
      return null;
    },
    /**
     * 设置指定索引分段项
     * @param {Number} index -分段项数组索引
     * @param {PIERangeItem} rangeItem -分段项
     * @memberOf ThemeRangeFeatureRenderer#
     */
    setRangeItemAt: function setRangeItemAt(index, rangeItem) {
      if (rangeItem instanceof PIERangeItem) {
        Module._TRFeatureRenderer_SetRangeItemAt(this.handle, index, rangeItem.getHandle());
      }
    },
    /**
     * 通过字段值查找项
     * @param {Number} value -字段值
     * @memberOf ThemeRangeFeatureRenderer#
     *
     * @returns {PIERangeItem} 返回指定字段值的分段项
     * @example
     * let themeRangeFeatureRenderer = new PIE.ThemeRangeFeatureRenderer();
     * var rangeItem = themeRangeFeatureRenderer.findRangeItem(value);
     */
    findRangeItem: function findRangeItem(value) {
      var hRangeItem = Module._TRFeatureRenderer_FindRangeItem(this.handle, value);
      if (hRangeItem) {
        return new PIERangeItem(hRangeItem);
      }
      return null;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 创建标签专题图渲染器对象
   * @name ThemeLabelFeatureRenderer
   * @class ThemeLabelFeatureRenderer
   * 标签专题图渲染器操作函数
   *
   * @returns {PIEThemeLabelFeatureRenderer} 成功返回渲染器对象，否则返回NULL
   * @extends FeatureRenderer
   * @example
   * let themeLabelFeatureRenderer = new PIE.ThemeLabelFeatureRenderer()
   */
  function PIEThemeLabelFeatureRenderer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._TLFeatureRenderer_Create();
      autoRelease = true;
    }
    PIEFeatureRenderer.call(this, handle, autoRelease);
  }
  PIEThemeLabelFeatureRenderer.prototype = Object.assign(Object.create(PIEFeatureRenderer.prototype), {
    /**
     * 制作标签专题图
     * @param {PIEFeatureDatasource} featureDataSource -矢量数据源对象
     * @memberOf ThemeLabelFeatureRenderer#
     * @return {Boolean} 成功返回true，否则返回false
     */
    makeDefault: function makeDefault(featureDataSource) {
      return Boolean(Module._TLFeatureRenderer_MakeDefault(this.handle, featureDataSource.getDataset().getHandle()));
    },
    /**
     * 设置渲染器的标签专题图字段
     * @param {String} expression -标签专题图字段
     * @memberOf ThemeLabelFeatureRenderer#
     */
    setTextExpression: function setTextExpression(expression) {
      var strExpression = new PIEString$1(expression);
      Module._TLFeatureRenderer_SetTextExpression(this.handle, strExpression.getHandle());
      strExpression.dispose();
    },
    /**
     * 获取渲染器的标签专题图字段
     * @memberOf ThemeLabelFeatureRenderer#
     * @returns {String} 返回标签专题图字段
     *
     */
    getTextExpression: function getTextExpression() {
      var strExpression = new PIEString$1(256);
      Module._TLFeatureRenderer_GetTextExpression(this.handle, strExpression.getHandle());
      var expression = strExpression.toString();
      strExpression.dispose();
      return expression;
    },
    /**
     * 设置渲染器的风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格句柄内部是否克隆(如果是true，风格句柄需要外部释放，否则会出现内存泄露；如果是false，风格句柄由内部保存并释放，外部不能释放，否则会出现崩溃) 默认值（false）
     * @memberOf ThemeLabelFeatureRenderer#
     */
    setStyle: function setStyle(style) {
      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      Module._TLFeatureRenderer_SetStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取渲染器的风格
     *
     * @memberOf ThemeLabelFeatureRenderer#
     * @returns {PIEStyle}  返回渲染器的风格，异常返回NULL
     */
    getStyle: function getStyle() {
      var hStyle = Module._TLFeatureRenderer_GetStyle(this.handle);
      return PIEStyleFactory.CreateInstance(hStyle);
    }
  });

  function PIEFeatureRenderFactory() {}
  Object.assign(PIEFeatureRenderFactory.prototype, {});
  PIEFeatureRenderFactory.CreateInstance = function (hRender) {
    var render = new PIEFeatureRenderer(hRender);
    var type = render.getType();
    if (type == PIEFeatureRenderType.Simple) {
      return new PIESimpleFeatureRenderer(hRender);
    } else if (type == PIEFeatureRenderType.Classify) {
      return new PIEClassifyFeatureRenderer(hRender);
    } else if (type == PIEFeatureRenderType.ThemeRange) {
      return new PIEThemeRangeFeatureRenderer(hRender);
    } else if (type == PIEFeatureRenderType.ThemeLabel) {
      return new PIEThemeLabelFeatureRenderer(hRender);
    }
    //  } else if (strRenderableType == PIEFeatureRenderType.ThemePie) {
    //     return new PIERenderPolyline3D(hRender);
    // }
    else {
      return new PIEFeatureRenderer(hRender);
    }
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 三维矢量图层基本操作函数
   * @name GlobeBaseFeatureLayer
   * @extends GlobeLayer
   *
   */
  function PIEGlobeBaseFeatureLayer(handle, autoRelease) {
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeBaseFeatureLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    // /**
    //  * 设置数据源名称
    //  * @param {String} name -目标数据源名称
    //  * @memberOf GlobeBaseFeatureLayer#
    //  *
    //  */
    setDataSourceName: function setDataSourceName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeBaseFeatureLayer_SetDataSourceName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取数据源名称
    //  *
    //  * @memberOf GlobeBaseFeatureLayer#
    //  * @returns {String}  -返回数据源名称
    //  *
    //  */
    getDataSourceName: function getDataSourceName() {
      var strName = new PIEString$1(256);
      Module._GlobeBaseFeatureLayer_GetDataSourceName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    // /**
    //  * 设置数据集名称
    //  * @param {String} name -目标数据集名称
    //  * @memberOf GlobeBaseFeatureLayer#
    //  *
    //  */
    setDatasetName: function setDatasetName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeBaseFeatureLayer_SetDatasetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取数据集名称
    //  *
    //  * @memberOf GlobeBaseFeatureLayer#
    //  * @returns {String} -返回数据集名称
    //  *
    //  */
    getDatasetName: function getDatasetName() {
      var strName = new PIEString$1(256);
      Module._GlobeBaseFeatureLayer_GetDatasetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 获取数据源
     *
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {PIEFeatureDataSource}  -返回数据源
     *
     */
    getDataSource: function getDataSource() {
      var hDataset = Module._GlobeBaseFeatureLayer_GetDataset(this.handle);
      var hDataSource = Module._Dataset_GetDataSource(hDataset);
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    },
    /**
     * 设置数据源
     * @param {PIEDataSource} datasource -数据源对象
     * @memberOf GlobeBaseFeatureLayer#
     *
     */
    setDataSource: function setDataSource(datasource) {
      Module._GlobeBaseFeatureLayer_SetDataset(this.handle, datasource.getDataset().getHandle());
    },
    setDataset: function setDataset(dataset) {
      Module._GlobeBaseFeatureLayer_SetDataset(this.handle, dataset.getHandle());
    },
    getDataset: function getDataset() {
      var hDataset = Module._GlobeBaseFeatureLayer_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(hDataset);
    },
    /**
     * 设置要素图层渲染器
     * @param {PIEFeatureRenderer} featureRenderer -要素渲染器对象
     * @memberOf GlobeBaseFeatureLayer#
     *
     */
    setRenderer: function setRenderer(featureRenderer) {
      Module._GlobeBaseFeatureLayer_SetRenderer(this.handle, featureRenderer.getHandle());
    },
    /**
     * 获取要素图层渲染器
     * @memberOf GlobeBaseFeatureLayer#
     *
     * @returns {PIEFeatureRenderer} 成功返回要素渲染器对象，失败返回null
     */
    getRenderer: function getRenderer() {
      var handle = Module._GlobeBaseFeatureLayer_GetRenderer(this.handle);
      if (handle) {
        return PIEFeatureRenderFactory.CreateInstance(handle);
      }
    },
    /**
     * 设置图层是否可选择
     * @param {Boolean} isSelectable -是否可选择
     * @memberOf GlobeBaseFeatureLayer#
     *
     */
    setSelectable: function setSelectable(isSelectable) {
      Module._GlobeBaseFeatureLayer_SetSelectable(this.handle, isSelectable);
    },
    /**
     * 判断图层是否可选
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Boolean} 可见返回true，不可见返回false
     */
    isSelectable: function isSelectable() {
      return Boolean(Module._GlobeBaseFeatureLayer_IsSelectable(this.handle));
    },
    /**
     * 获取图层选择集
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {PIESelection} 成功返回选中的对象，失败返回null
     */
    getSelection: function getSelection() {
      var handle = Module._GlobeBaseFeatureLayer_GetSelection(this.handle);
      return new PIESelection(handle);
    },
    /**
     * 清空要素图层选择集
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Boolean} 是否清空成功
     */
    clearSelection: function clearSelection() {
      return Boolean(Module._GlobeBaseFeatureLayer_ClearSelection(this.handle));
    },
    /**
     * 添加几何对象
     * @param {PIEGeometry} geometry -几何对象
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Number} 几何对象id
     */
    addGemetry: function addGemetry(geometry) {
      geometry.setAutoRelease(false);
      return Module._GlobeBaseFeatureLayer_AddGeometry(this.handle, geometry.getHandle());
    },
    /**
     * 添加几何对象数组
     * @param {Array} geometrys -几何对象数组
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Boolean} 是否添加成功
     */
    addGemetrys: function addGemetrys(geometrys) {
      var arrayHandles = [];
      for (var i = 0; i < geometrys.length; ++i) {
        var geometry = geometrys[i];
        geometry.setAutoRelease(false);
        arrayHandles.push(geometry.getHandle());
      }
      var arrays = new PIEArray(arrayHandles, PIEArrayType.Int32);
      var result = Module._GlobeBaseFeatureLayer_AddGeometrys(this.handle, arrays.getHandle(), geometrys.length);
      arrays.dispose();
      return Boolean(result);
    },
    /**
     * 更新几何对象
     * @param {PIEGeometry} geometry -几何对象
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Boolean} 是否更新成功
     */
    updateGeometry: function updateGeometry(geometry) {
      return Boolean(Module._GlobeBaseFeatureLayer_UpdateGeometry(this.handle, geometry.getHandle()));
    },
    /**
     * 更新几何对象数组
     * @param {Array} geometrys -几何对象数组
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Boolean} 是否更新成功
     */
    updateGeometrys: function updateGeometrys(geometrys) {
      var arrayHandles = [];
      for (var i = 0; i < geometrys.length; ++i) {
        var geometry = geometrys[i];
        arrayHandles.push(geometry.getHandle());
      }
      var arrays = new PIEArray(arrayHandles, PIEArrayType.Int32);
      var result = Module._GlobeBaseFeatureLayer_UpdateGeometrys(this.handle, arrays.getHandle(), geometrys.length);
      arrays.dispose();
      return Boolean(result);
    },
    /**
     * 删除几何对象
     * @param {Number} id -几何对象id
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Boolean} 是否更新成功
     */
    deleteGeometry: function deleteGeometry(id) {
      return Boolean(Module._GlobeBaseFeatureLayer_DeleteGeometry(this.handle, id));
    },
    /**
     * 删除几何对象数组
     * @param {Array} idList -几何对象id数组
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {Boolean} 是否删除成功
     */
    deleteGeometrys: function deleteGeometrys(idList) {
      var arrayRange = new PIEArray(idList, PIEArrayType.Int32);
      var result = Module._GlobeBaseFeatureLayer_DeleteGeometrys(this.handle, arrayRange.getHandle(), idList.length);
      arrayRange.dispose();
      return Boolean(result);
    },
    /**
     * 获取几何对象
     * @param {Number} id -几何对象id
     * @memberOf GlobeBaseFeatureLayer#
     * @returns {PIEGeometry} 几何对象
     */
    getGeometry: function getGeometry(id) {
      var hGeometry = Module._GlobeBaseFeatureLayer_GetGeometry(this.handle, id);
      return PIEGeometryFactory.CreateInstance(hGeometry);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维矢量数据图层
   * @name GlobeFeatureLayer
   * @class GlobeFeatureLayer
   * 三维矢量数据图层操作函数
   * @extends GlobeBaseFeatureLayer
   *
   * @example
   * let globeFeatureLayer = new PIE.GlobeFeatureLayer()
   */
  function PIEGlobeFeatureLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_FeatureLayer_Create();
      autoRelease = true;
    }
    PIEGlobeBaseFeatureLayer.call(this, handle, autoRelease);
  }
  PIEGlobeFeatureLayer.prototype = Object.assign(Object.create(PIEGlobeBaseFeatureLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 创建三维矢量图层
   * @name GlobeFeatureMapLayer
   * @class GlobeFeatureMapLayer
   * 三维矢量图层基本操作函数
   * @extends GlobeCompostieLayer
   *
   */

  function PIEGlobeFeatureMapLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._GlobeFeatureMapLayer_Create();
      autoRelease = true;
    }
    PIEGlobeCompositeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeFeatureMapLayer.prototype = Object.assign(Object.create(PIEGlobeCompositeLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 栅格渲染模块
   * ---
   */

  /**
   * 栅格渲染器基础操作函数
   * @name RasterRenderer
   *
   */
  function PIERasterRenderer(handle) {
    this.handle = handle;
  }
  function PIEPreRasterFilter(handle) {
    this.handle = handle;
  }
  function PIEAfterRasterFilter$1(handle) {
    this.handle = handle;
  }
  Object.assign(PIERasterRenderer.prototype, {
    /**
     * 获取栅格渲染器类型
     *
     * @memberOf RasterRenderer#
     * @returns {PIERasterRendererType} 返回栅格渲染器类型
     *
     */
    getType: function getType() {
      return Module._RasterRenderer_GetType(this.handle);
    },
    /**
     * 释放栅格渲染器对象
     * @memberOf RasterRenderer#
     *
     */
    "delete": function _delete() {
      Module._RasterRenderer_Delete(this.handle);
    },
    /**
     * 获取前置过滤器数量
     *
     * @memberOf RasterRenderer#
     * @returns {Number} 前置过滤器数量
     *
     */
    getPreRasterFilterCount: function getPreRasterFilterCount() {
      return Module._RasterRenderer_GetPreRasterFilterCount(this.handle);
    },
    /**
     * 根据索引获取前置过滤器
     * @param {Number} index -前置过滤器索引
     * @memberOf RasterRenderer#
     *
     * @returns {PIEPreRasterFilter} 前置过滤器索引
     *
     */
    getPreRasterFilterAt: function getPreRasterFilterAt(index) {
      var handle = Module._RasterRenderer_GetPreRasterFilterAt(this.handle, index);
      if (handle) {
        return new PIEPreRasterFilter(handle);
      }
    },
    /**
     * 根据类ID获取前置过滤器
     * @param {String} classID -前置过滤器ID
     * @memberOf RasterRenderer#
     *
     * @returns {PIEPreRasterFilter} 前置过滤器
     *
     */
    getPreRasterFilter: function getPreRasterFilter(classID) {
      var strClassID = new PIEString$1(classID);
      var handle = Module._RasterRenderer_GetPreRasterFilter(this.handle, strClassID.getHandle());
      strClassID.dispose();
      if (handle) {
        return new PIEPreRasterFilter(handle);
      }
    },
    /**
     * 添加前置过滤器
     * @param {PIEPreRasterFilter} preFilter -前置过滤器对象
     * @memberOf RasterRenderer#
     *
     * @returns {Boolean} 添加是否成功
     *
     */
    addPreRasterFilter: function addPreRasterFilter(preFilter) {
      return Module._RasterRenderer_AddPreRasterFilter(this.handle, preFilter.getHandle());
    },
    /**
     * 移除前置过滤器
     * @param {PIEPreRasterFilter} preFilter 前置过滤器对象
     * @memberOf RasterRenderer#
     *
     * @returns {Boolean} 是否移除成功
     *
     */
    removePreRasterFilter: function removePreRasterFilter(preFilter) {
      return Module._RasterRenderer_RemovePreRasterFilter(this.handle, preFilter.getHandle());
    },
    /**
     * 移除所有的前置过滤器
     * @memberOf RasterRenderer#
     *
     */
    removeAllPreRasterFilters: function removeAllPreRasterFilters() {
      Module._RasterRenderer_RemoveAllPreRasterFilters(this.handle);
    },
    /**
     * 获取后置过滤器数量
     *
     * @memberOf RasterRenderer#
     * @returns {Number} 后置过滤器数量
     *
     */
    getAfterRasterFilterCount: function getAfterRasterFilterCount() {
      return Module._RasterRenderer_GetAfterRasterFilterCount(this.handle);
    },
    /**
     * 根据索引获取后置过滤器
     * @param {Number} index -后置过滤器索引
     * @memberOf RasterRenderer#
     *
     * @returns {PIEAfterRasterFilter} 后置过滤器
     *
     */
    getAfterRasterFilterAt: function getAfterRasterFilterAt(index) {
      var handle = Module._RasterRenderer_GetAfterRasterFilterAt(this.handle, index);
      if (handle) {
        return new PIEAfterRasterFilter$1(handle);
      }
    },
    /**
     * 根据类ID获取后置过滤器
     * @param {String} classID -后置过滤器ID
     * @memberOf RasterRenderer#
     *
     * @returns {PIEAfterRasterFilter} 后置过滤器
     *
     */
    getAfterRasterFilter: function getAfterRasterFilter(classID) {
      var strClassID = new PIEString$1(classID);
      var handle = Module._RasterRenderer_GetAfterRasterFilter(this.handle, strClassID.getHandle());
      strClassID.dispose();
      if (handle) {
        return new PIEAfterRasterFilter$1(handle);
      }
    },
    /**
     * 添加后置过滤器
     * @param {PIEAfterRasterFilter} afterFilter 后置过滤器对象
     * @memberOf RasterRenderer#
     *
     * @returns {Boolean} 添加是否成功
     *
     */
    addAfterRasterFilter: function addAfterRasterFilter(afterFilter) {
      return Module._RasterRenderer_AddAfterRasterFilter(this.handle, afterFilter.getHandle());
    },
    /**
     * 移除后置过滤器
     * @param {PIEAfterRasterFilter} afterFilter -后置过滤器对象
     * @memberOf RasterRenderer#
     *
     * @returns {Boolean} 是否移除成功
     *
     */
    removeAfterRasterFilter: function removeAfterRasterFilter(afterFilter) {
      return Module._RasterRenderer_RemoveAfterRasterFilter(this.handle, afterFilter.getHandle());
    },
    /**
     * 移除所有的后置过滤器
     * @memberOf RasterRenderer#
     *
     */
    removeAllAfterRasterFilters: function removeAllAfterRasterFilters() {
      Module._RasterRenderer_RemoveAllAfterRasterFilters(this.handle);
    },
    /**
     * 获取xml中配置参数
     * @param {String} xML -xml数据
     * @memberOf RasterRenderer#
     *
     * @returns {Boolean} 是否成功
     *
     */
    fromXML: function fromXML(xML) {
      var strXML = new PIEString$1(xML);
      var res = Module._RasterRenderer_FromXML(this.handle, strXML.getHandle());
      strXML.dispose();
      return res;
    },
    /**
     * 配置参数导出xml
     * @memberOf RasterRenderer#
     * @returns {PIEString} 返回配置数据
     *
     */
    toXML: function toXML() {
      var handle = Module._RasterRenderer_ToXML(this.handle);
      if (handle) {
        return PIEString$1(handle);
      }
    },
    /**
     * 设置共用属性，常用于滤波器共用参数交换
     * @param {String} name -属性名称
     * @param {String} value -属性值
     * @memberOf RasterRenderer#
     *
     */
    setProperty: function setProperty(name, value) {
      var strName = new PIEString$1(name);
      var strValue = new PIEString$1(value);
      Module._RasterRenderer_SetProperty(this.handle, strName.getHandle(), strValue.getHandle());
      strName.dispose();
      strValue.dispose();
    },
    /**
     * 获取是否为GPU渲染
     *
     * @memberOf RasterRenderer#
     * @returns {Boolean} GPU渲染返回true，否则返回false
     *
     */
    isSupportGPU: function isSupportGPU() {
      return Module._RasterRenderer_IsSupportGPU(this.handle);
    },
    /**
     * 获取是否请求（采样）全部波段数据
     *
     * @memberOf RasterRenderer#
     * @returns {Boolean} 请求全部波段返回true，否则返回false，结果由滤波器和NeedAllBand设置共同决定
     *
     */
    isRequestAllBands: function isRequestAllBands() {
      return Module._RasterRenderer_IsRequestAllBands(this.handle);
    },
    /**
     * 设置请求（采样）全部波段数据
     * @param {Boolean} needAllBand -请求全部波段为true，否则为false
     * @memberOf RasterRenderer#
     *
     */
    setNeedAllBand: function setNeedAllBand(needAllBand) {
      Module._RasterRenderer_SetNeedAllBand(this.handle, needAllBand);
    },
    /**
     * 设置允许渲染的最大数据范围
     * @param {PIERect} bounds -最大数据范围
     * @memberOf RasterRenderer#
     *
     */
    setMaxDataBounds: function setMaxDataBounds(bounds) {
      var arrayBounds = new PIEArray(bounds, PIEArrayType.Float64);
      Module._RasterRenderer_SetMaxDataBounds(this.handle, arrayBounds.getHandle());
      arrayBounds.dispose();
    },
    /**
     * 设置最大绘制范围无效，会触发最大绘制范围更新
     * @memberOf RasterRenderer#
     *
     *
     */
    dirtyMaxDrawBounds: function dirtyMaxDrawBounds() {
      Module._RasterRenderer_DirtyMaxDrawBounds(this.handle);
    },
    /**
     * 设置对比度
     * @param {Number} contrast -对比度（-100~100），默认值：0
     * @memberOf RasterRenderer#
     *
     */
    setContrast: function setContrast(contrast) {
      Module._RasterRenderer_SetContrast(this.handle, contrast);
    },
    /**
     * 获取对比度
     *
     * @memberOf RasterRenderer#
     * @returns {Number} 对比度（-100~100），默认值：0
     *
     */
    getContrast: function getContrast() {
      return Module._RasterRenderer_GetContrast(this.handle);
    },
    /**
     * 设置亮度
     * @param {Number} brightness -亮度（-255~255），默认值：0
     * @memberOf RasterRenderer#
     *
     */
    setBrightness: function setBrightness(brightness) {
      Module._RasterRenderer_SetBrightness(this.handle, brightness);
    },
    /**
     * 获取亮度
     *
     * @memberOf RasterRenderer#
     * @returns {Number} 亮度（-255~255），默认值：0
     *
     */
    getBrightness: function getBrightness() {
      return Module._RasterRenderer_GetBrightness(this.handle);
    },
    /**
     * 设置透明度
     * @param {Number} transparent -透明度（0~255），默认值：255
     * @memberOf RasterRenderer#
     *
     */
    setTransparent: function setTransparent(transparent) {
      Module._RasterRenderer_SetTransparent(this.handle, transparent);
    },
    /**
     * 获取透明度
     *
     * @memberOf RasterRenderer#
     * @returns {Number} 透明度（0~255），默认值：255
     *
     */
    getTransparent: function getTransparent() {
      return Module._RasterRenderer_GetTransparent(this.handle);
    },
    /**
     * 设置渲染采样类型
     * @param {PIEDataSampleType} resampleType -采样类型
     * @memberOf RasterRenderer#
     *
     * @returns {Boolean} 返回设置是否成功
     */
    setResampleType: function setResampleType(resampleType) {
      return Module._RasterRenderer_SetResampleType(this.handle, resampleType);
    },
    /**
     * 获取渲染采样类型
     *
     * @memberOf RasterRenderer#
     * @returns {PIEDataSampleType} 返回采样类型
     *
     */
    getResampleType: function getResampleType() {
      return Module._RasterRenderer_GetResampleType(this.handle);
    },
    /**
     * 获取自动投影转换启用状态
     *
     * @memberOf RasterRenderer#
     * @returns {Boolean} 自动投影转换是否启用
     *
     */
    getProjConvertEnabled: function getProjConvertEnabled() {
      return Module._RasterRenderer_GetProjConvertEnabled(this.handle);
    },
    /**
     * 设置自动投影转换启用状态
     * @param {Boolean} enabled -是否启用自动投影转换
     * @memberOf RasterRenderer#
     *
     */
    setProjConvertEnabled: function setProjConvertEnabled(enabled) {
      Module._RasterRenderer_SetProjConvertEnabled(this.handle, enabled);
    },
    /**
     * 设置无值颜色
     * @param {PIEColor/Array} color -无值对应的颜色
     * @memberOf RasterRenderer#
     *
     */
    setNoDataColor: function setNoDataColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RasterRenderer_SetNoDataColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    /**
     * 获取无值颜色
     *
     * @memberOf RasterRenderer#
     * @returns {PIEColor} 无值对应的颜色
     *
     */
    getNoDataColor: function getNoDataColor() {
      var arrayColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._RasterRenderer_GetNoDataColor(this.handle, arrayColor.getHandle());
      arrayColor.updateData();
      var color = arrayColor.toArray();
      arrayColor.dispose();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 栅格渲染模块
   * ---
   */

  /**
   * 栅格渲染器类型
   * @readonly
   * @enum {number}
   */
  var PIERasterRendererType = {
    /** 未知渲染器 */
    Null: 0,
    /** 多波段渲染器 */
    Bands: 10,
    /** 颜色带渲染器 */
    ColorBar: 20,
    /**分级渲染器*/
    ClassifyColorRampRender: 30,
    /** 颜色对照表渲染器*/
    ColormapRender: 50
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 栅格渲染模块
   * ---
   */

  /**
   * 创建栅格多波段（RGB）渲染器
   * @name BandRasterRenderer
   * @class BandRasterRenderer
   *  栅格多波段（RGB）渲染器操作函数
   * @extends RasterRenderer
   */
  function PIEBandRasterRenderer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._BRasterRenderer_Create();
      autoRelease = true;
    }
    PIERasterRenderer.call(this, handle, autoRelease);
  }
  PIEBandRasterRenderer.prototype = Object.assign(Object.create(PIERasterRenderer.prototype), {
    /**
     * 设置RGB通道的波段索引
     * @param {Number} RGBType -RGB通道类型, R:0,G:1,B:2
     * @param {Number} bandIndex -RGB通道使用的波段索引
     * @memberOf BandRasterRenderer#
     *
     */
    setBandIndex: function setBandIndex(RGBType, bandIndex) {
      Module._BRasterRenderer_SetRGBBandIndex(this.handle, RGBType, bandIndex);
    },
    /**
     * 获取渲染波段索引
     * @param {Number} RGBType -RGB通道类型, R:0,G:1,B:2
     * @memberOf BandRasterRenderer#
     * @returns {Number} 返回RGB通道使用的波段索引
     *
     */
    getBandIndex: function getBandIndex(RGBType) {
      return Module._BRasterRenderer_GetRGBBandIndex(this.handle, RGBType);
    },
    /**
     * 设置RGB通道使用的无值
     * @param {Number} RGBType -RGB通道类型, R:0,G:1,B:2
     * @param {Number} value -无效值
     * @memberOf BandRasterRenderer#
     *
     */
    setRGBNoValue: function setRGBNoValue(RGBType, value) {
      Module._BRasterRenderer_SetRGBNoValue(this.handle, RGBType, value);
    },
    /**
     * 设置RGB通道使用的无值
     * @param {Number} RGBType -RGB通道类型, R:0,G:1,B:2
     * @memberOf BandRasterRenderer#
     * @returns {Number} 返回对应的无效值
     */
    getRGBNoValue: function getRGBNoValue(RGBType) {
      return Module._BRasterRenderer_GetRGBNoValue(this.handle, RGBType);
    },
    /**
     * 设置拉伸类型
     * @param {PIEStretchType} stretchType -拉伸类型
     * @param {Number} RGBType -RGB通道类型, R:0,G:1,B:2（全部通道: -1）
     * @memberOf BandRasterRenderer#
     *
     */
    setBandStrethType: function setBandStrethType(stretchType, RGBType) {
      Module._BRasterRenderer_SetBandStrethType(this.handle, stretchType, RGBType);
    },
    /**
     * 获取拉伸类型
     * @param {Number} RGBType -RGB通道类型, R:0,G:1,B:2（全部通道: -1）
     * @memberOf BandRasterRenderer#
     * @returns {PIEStretchType} 返回对应的拉伸类型
     */
    getBandStrethType: function getBandStrethType(RGBType) {
      return Module._BRasterRenderer_GetBandStrethType(this.handle, RGBType);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 栅格渲染模块
   * ---
   */

  /**
   * 创建拉伸渲染器对象
   * @name ColorBarRasterRenderer
   * @class ColorBarRasterRenderer
   * 拉伸渲染器操作函数
   *
   *
   * @extends RasterRenderer
   * @example
   * let colorBarRasterRenderer = new PIE.ColorBarRasterRenderer();
   *
   */
  function PIEColorBarRasterRenderer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._CBRasterRenderer_Create();
      autoRelease = true;
    }
    PIERasterRenderer.call(this, handle, autoRelease);
  }
  PIEColorBarRasterRenderer.prototype = Object.assign(Object.create(PIERasterRenderer.prototype), {
    /**
     * 获取是否为颜色平滑拉伸
     *
     * @memberOf ColorBarRasterRenderer#
     * @returns {Boolean} 颜色平滑拉伸返回TRUE，否则返回FALSE
     *
     */
    isStretchColor: function isStretchColor() {
      return Module._CBRasterRenderer_IsStretchColor(this.handle);
    },
    /**
     * 设置为颜色平滑拉伸
     * @param {Boolean} stretch 颜色平滑拉伸返回TRUE，否则返回FALSE
     * @memberOf ColorBarRasterRenderer#
     *
     */
    setStretchColor: function setStretchColor(stretch) {
      Module._CBRasterRenderer_SetStretchColor(this.handle, stretch);
    },
    /**
     * 设置有效值范围
     * @param {Number} minValue -最小值
     * @param {Number} maxValue -最大值
     * @param {Number} useRangeValue -是否应用设置的有效值范围
     * @memberOf ColorBarRasterRenderer#
     *
     */
    setValueRange: function setValueRange(minValue, maxValue, useRangeValue) {
      Module._CBRasterRenderer_SetValueRange(this.handle, minValue, maxValue, useRangeValue);
    },
    /**
     * 设置渲染波段索引
     * @param {Number} bandIndex -渲染波段索引
     * @memberOf ColorBarRasterRenderer#
     *
     */
    setBandIndex: function setBandIndex(bandIndex) {
      Module._CBRasterRenderer_SetBandIndex(this.handle, bandIndex);
    },
    /**
     * 获取渲染波段索引
     *
     * @memberOf ColorBarRasterRenderer#
     * @returns {Number} 返回渲染波段索引
     *
     */
    getBandIndex: function getBandIndex() {
      return Module._CBRasterRenderer_GetBandIndex(this.handle);
    },
    /**
     * 设置无效值
     * @param {Number} value -返回渲染波段索引
     * @memberOf ColorBarRasterRenderer#
     *
     */
    setNoValue: function setNoValue(value) {
      Module._CBRasterRenderer_SetNoValue(this.handle, value);
    },
    /**
     * 获取无效值
     *
     * @memberOf ColorBarRasterRenderer#
     * @returns {Number}  返回无效值
     *
     */
    getNoValue: function getNoValue() {
      return Module._CBRasterRenderer_GetNoValue(this.handle);
    },
    /**
     * 设置拉伸类型
     *
     * @memberOf ColorBarRasterRenderer#
     * @returns {PIEStretchType} -返回渲染波段索引
     *
     */
    getBandStrethType: function getBandStrethType() {
      return Module._CBRasterRenderer_GetBandStrethType(this.handle);
    }
  });

  function PIERasterRenderFactory() {}
  Object.assign(PIERasterRenderFactory.prototype, {});
  PIERasterRenderFactory.CreateInstance = function (hRender) {
    var render = new PIERasterRenderer(hRender);
    var type = render.getType();
    if (type == PIERasterRendererType.Bands) {
      return new PIEBandRasterRenderer(hRender);
    } else if (type == PIERasterRendererType.ColorBar) {
      return new PIEColorBarRasterRenderer(hRender);
    } else if (type == PIERasterRendererType.ClassifyColorRampRender) ; else if (type == PIERasterRendererType.ColormapRender) {
      return new PIEColormapRasterRenderer(hRender);
    } else {
      return new PIERasterRenderer(hRender);
    }
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 三维矢量图层基本操作函数
   * @name GlobeBaseRasterLayer
   * @extends GlobeLayer
   *
   */
  function PIEGlobeBaseRasterLayer(handle, autoRelease) {
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeBaseRasterLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    // /**
    //  * 设置数据源名称
    //  * @param {String} name -目标数据源名称
    //  * @memberOf GlobeBaseRasterLayer#
    //  *
    //  */
    setDataSourceName: function setDataSourceName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeBaseRasterLayer_SetDataSourceName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取数据源名称
    //  *
    //  * @memberOf GlobeBaseRasterLayer#
    //  * @returns {String} 如果成功返回数据源名称，失败返回NULL
    //  *
    //  */
    getDataSourceName: function getDataSourceName() {
      var strName = new PIEString$1(256);
      Module._GlobeBaseRasterLayer_GetDataSourceName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    // /**
    //  * 设置数据集名称
    //  * @param {String} name -目标数据集名称
    //  * @memberOf GlobeBaseRasterLayer#
    //  *
    //  */
    setDatasetName: function setDatasetName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeBaseRasterLayer_SetDatasetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取数据集名称
    //  *
    //  * @memberOf GlobeBaseRasterLayer#
    //  * @returns {String} 如果成功返回数据集名称，失败返回NULL
    //  *
    //  */
    getDatasetName: function getDatasetName() {
      var strName = new PIEString$1(256);
      Module._GlobeBaseRasterLayer_GetDatasetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置数据源
     * @param {PIEDataSource} datasource -数据源对象
     * @memberOf GlobeBaseRasterLayer#
     *
     */
    setDataSource: function setDataSource(datasource) {
      Module._GlobeBaseRasterLayer_SetDataset(this.handle, datasource.getDataset().getHandle());
    },
    /**
     * 获取数据源
     *
     * @memberOf GlobeBaseRasterLayer#
     * @returns {PIERasterDataSource}  -返回数据源
     *
     */
    getDataSource: function getDataSource() {
      var hDataset = Module._GlobeBaseRasterLayer_GetDataset(this.handle);
      var hDataSource = Module._Dataset_GetDataSource(hDataset);
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    },
    setDataset: function setDataset(dataset) {
      Module._GlobeBaseRasterLayer_SetDataset(this.handle, dataset.getHandle());
    },
    getDataset: function getDataset() {
      var hDataset = Module._GlobeBaseRasterLayer_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(hDataset);
    },
    getRenderer: function getRenderer() {
      var hRender = Module._GlobeBaseRasterLayer_GetRenderer(this.handle);
      return PIERasterRenderFactory.CreateInstance(hRender);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * @name GlobeRasterLayer
   * 三维栅格图层操作函数
   *
   * @extends GlobeBaseRasterLayer
   * @example
   * let globeRasterLayer = new PIE.GlobeRasterLayer()
   */
  function PIEGlobeRasterLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_RasterLayer_Create();
      autoRelease = true;
    }
    PIEGlobeBaseRasterLayer.call(this, handle, autoRelease);
  }
  PIEGlobeRasterLayer.prototype = Object.assign(Object.create(PIEGlobeBaseRasterLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建栅格瓦片图层
   * @name GlobeTileRasterLayer
   * @class GlobeTileRasterLayer
   * 栅格瓦片图层操作函数
   *
   * @extends GlobeRasterLayer
   * @example
   * let globeTileRasterLayer = new PIE.GlobeTileRasterLayer()
   */
  function PIEGlobeTileRasterLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_TileRasterLayer_Create();
      autoRelease = true;
    }
    PIEGlobeRasterLayer.call(this, handle, autoRelease);
  }
  PIEGlobeTileRasterLayer.prototype = Object.assign(Object.create(PIEGlobeRasterLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维高程图层
   * @name GlobeElevationLayer
   * @class GlobeElevationLayer
   * 三维高程图层操作函数
   * @extends GlobeLayer
   *
   * @example
   * let globeElevationLayer = new PIE.GlobeElevationLayer()
   */
  function PIEGlobeElevationLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._GlobeElevationLayer_Create();
      autoRelease = true;
    }
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeElevationLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    // /**
    //  * 设置数据源名称
    //  * @param {String} name -目标数据源名称
    //  * @memberOf GlobeElevationLayer#
    //  *
    //  */
    setDataSourceName: function setDataSourceName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeElevationLayer_SetDataSourceName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取数据源名称
    //  *
    //  * @memberOf GlobeElevationLayer#
    //  * @returns {String} 返回数据源名称
    //  *
    //  */
    getDataSourceName: function getDataSourceName() {
      var strName = new PIEString$1(256);
      Module._GlobeElevationLayer_GetDataSourceName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    // /**
    //  * 设置数据集名称
    //  * @param {String} name -数据集名称
    //  * @memberOf GlobeElevationLayer#
    //  */
    setDatasetName: function setDatasetName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeElevationLayer_SetDatasetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取数据集名称
    //  *
    //  * @memberOf GlobeElevationLayer#
    //  * @returns {String} 返回数据集名称
    //  */
    getDatasetName: function getDatasetName() {
      var strName = new PIEString$1(256);
      Module._GlobeElevationLayer_GetDatasetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置图层数据集
     * @param {PIEDataSource} datasource -图层数据集
     * @memberOf GlobeElevationLayer#
     *
     */
    setDataSource: function setDataSource(datasource) {
      Module._GlobeElevationLayer_SetDataset(this.handle, datasource.getDataset().getHandle());
    },
    /**
     * 获取数据源
     *
     * @memberOf GlobeElevationLayer#
     * @returns {PIEDataSource}  -返回数据源
     *
     */
    getDataSource: function getDataSource() {
      var hDataset = Module._GlobeElevationLayer_GetDataset(this.handle);
      var hDataSource = Module._Dataset_GetDataSource(hDataset);
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    },
    setDataset: function setDataset(dataset) {
      Module._GlobeElevationLayer_SetDataset(this.handle, dataset.getHandle());
    },
    getDataset: function getDataset() {
      var hDataset = Module._GlobeElevationLayer_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(hDataset);
    },
    /**
     * 设置夸张系数
     * @param {Number} value -夸张系数 [1,3]
     * @memberOf GlobeElevationLayer#
     *
     */
    setExaggeration: function setExaggeration(value) {
      Module._GlobeElevationLayer_SetExaggeration(this.handle, value);
    },
    /**
     * 获取夸张系数
     * @memberOf GlobeElevationLayer#
     * @returns {Number} 返回夸张系数
     */
    getExaggeration: function getExaggeration() {
      return Module._GlobeElevationLayer_GetExaggeration(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维地图元素模块
   * ---
   */

  /**
   * 三维地图元素操作函数
   * @name GlobeElement
   *
   */
  function PIEGlobeElement(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEGlobeElement.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 删除地图元素
     * @memberOf GlobeElement#
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._GlobeElement_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 获取地图元素类型
     *
     * @memberOf GlobeElement#
     * @returns {PIEGlobeElementType} 成功返回类型，失败返回Null
     */
    getType: function getType() {
      return Module._GlobeElement_GetType(this.handle);
    },
    /**
     * 获取地图元素里的ID
     *
     * @memberOf GlobeElement#
     * @returns {Number} 如果成功返回集合元素里的ID，失败返回NULL
     */
    getID: function getID() {
      return Module._GlobeElement_GetID(this.handle);
    },
    /**
     * 设置地图元素里的ID
     * @param {Number} id -地图元素Id
     * @memberOf GlobeElement#
     */
    setID: function setID(id) {
      Module._GlobeElement_SetID(this.handle, id);
    },
    /**
     * 判断地图元素是否可见
     *
     * @memberOf GlobeElement#
     * @returns {Boolean} 如果可见返回true，不可见或失败返回false
     */
    isVisible: function isVisible() {
      return Boolean(Module._GlobeElement_IsVisible(this.handle));
    },
    /**
     * 设置地图元素是否可见
     * @param {Boolean} isVisible -是否可见
     * @memberOf GlobeElement#
     */
    setVisible: function setVisible(isVisible) {
      Module._GlobeElement_SetVisible(this.handle, isVisible);
    },
    /**
     * 获取地图元素的范围
     *
     * @memberOf GlobeElement#
     * @returns {PIEBounds} 如果成功返回地图元素范围，失败返回默认范围
     */
    getBounds: function getBounds() {
      var array = new PIEArray(4, PIEArrayType.Float64);
      Module._GlobeElement_GetBounds(this.handle, array.getHandle());
      var bounds = PIEBounds.fromArray(array);
      array.dispose();
      return bounds;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维地图元素模块
   * ---
   */

  /**
   * 创建三维地图几何元素
   * @name GlobeFeatureElement
   * @class GlobeFeatureElement
   * 三维地图几何元素操作函数
   * @param {Object} options -
   * @param {(PIEFeature)} options.feature -要素对象（参数二选一）
   * @param {(PIEGeometry)} options.geometry -几何对象 只支持二维对象（参数二选一）
   * @extends GlobeElement
   */
  function PIEGlobeFeatureElement(options) {
    var handle = null;
    var autoRelease = false;
    var feature = options.feature;
    var geometry = options.geometry;
    if (feature != null) {
      if (feature instanceof PIEFeature) {
        handle = Module._GlobeFeatureElement_CreateByFeature(feature.getHandle());
        autoRelease = true;
      } else {
        throw new Error('PIE.GlobeModel.addLayer: input feature is error');
      }
    } else if (geometry != null) {
      if (geometry instanceof PIEGeometry) {
        handle = Module._GlobeFeatureElement_CreateByGeometry(geometry.getHandle());
        autoRelease = true;
      } else {
        throw new Error('PIE.GlobeModel.addLayer: input geometry is error');
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIEGlobeElement.call(this, handle, autoRelease);
  }
  PIEGlobeFeatureElement.prototype = Object.assign(Object.create(PIEGlobeElement.prototype), {
    /**
     * 设置要素对象
     * @param {PIEFeature} feature -要素对象
     * @memberOf GlobeFeatureElement#
     * @returns {Boolean} 如果设置成功，返回true,如果设置失败，返回false
     */
    setFeature: function setFeature(feature) {
      return Module._GlobeFeatureElement_SetFeature(this.handle, feature.getHandle());
    },
    // /**
    //  * 设置要素对象显隐
    //  * @param {Boolean} visible -是否显示(true为显示，false为隐藏)
    //  * @memberOf GlobeFeatureElement#
    //  * @returns {Boolean} 如果设置成功，返回true,如果设置失败，返回false
    //  */
    // setVisible: function (visible){
    //     return Module._GlobeFeatureElement_SetVisible(this.handle, visible);
    // },
    //
    // /**
    //  * 判断要素对象元素是否可见
    //  *
    //  * @memberOf GlobeFeatureElement#
    //  * @returns {Boolean} 如果可见返回true，不可见或失败返回false
    //  */
    // isVisible: function (){
    //     return Module._GlobeFeatureElement_IsVisible(this.handle);
    // },

    /**
     * 获取几何元素里的要素对象
     *
     * @memberOf GlobeFeatureElement#
     * @returns {PIEFeature} 如果成功，返回要素对象,失败返回null
     */
    getFeature: function getFeature() {
      var handle = Module._GlobeFeatureElement_GetFeature(this.handle);
      if (handle) {
        return new PIEFeature(handle);
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建图源层图层
   * @name GlobeGraphicsLayer
   * @class GlobeGraphicsLayer
   * 图源图层操作函数
   * @extends GlobeLayer
   *
   * @example
   * let globeGraphicsLayer = new PIE.GlobeGraphicsLayer();
   */
  function PIEGlobeGraphicsLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_GraphicsLayer_Create();
      autoRelease = true;
    }
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeGraphicsLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    /**
     * 获取跟踪图层元素个数
     *
     * @memberOf GlobeGraphicsLayer#
     * @returns {Number} 如果成功返回元素总数
     *
     */
    getCount: function getCount() {
      return Module._Globe_GraphicsLayer_GetCount(this.handle);
    },
    /**
     * 添加元素
     * @param {PIEGlobeElement} globeElement -元素对象
     *
     * @memberOf GlobeGraphicsLayer#
     * @returns {Number} 如果成功返回元素的ID 失败返回-1
     *
     */
    add: function add(globeElement) {
      if (globeElement instanceof PIEGlobeElement) {
        return Module._Globe_GraphicsLayer_Add(this.handle, globeElement.getHandle());
      }
      return -1;
    },
    /**
     * 根据索引获取元素
     * @param {Number} index -元素索引
     *
     * @memberOf GlobeGraphicsLayer#
     * @returns {PIEGlobeFeatureElement} 如果成功返回元素对象 失败返回NULL
     *
     */
    getAt: function getAt(index) {
      var element = Module._Globe_GraphicsLayer_GetAt(this.handle, index);
      if (element) {
        return new PIEGlobeFeatureElement({
          handle: element
        });
      }
      return null;
    },
    /**
     * 根据id获取元素
     * @param {Number} id -元素id
     *
     * @memberOf GlobeGraphicsLayer#
     * @returns {PIEGlobeFeatureElement} 如果成功返回元素对象 失败返回NULL
     *
     */
    get: function get(id) {
      var element = Module._Globe_GraphicsLayer_Get(this.handle, id);
      if (element) {
        return new PIEGlobeFeatureElement({
          handle: element
        });
      }
      return null;
    },
    /**
     * 根据id移除元素
     * @param {Number} id -元素id
     *
     * @memberOf GlobeGraphicsLayer#
     * @returns {Boolean} 如果成功返回true 失败返回false
     *
     */
    remove: function remove(id) {
      return Boolean(Module._Globe_GraphicsLayer_Remove(this.handle, id));
    },
    /**
     * 根据索引移除元素
     * @param {Number} index -元素索引
     *
     * @memberOf GlobeGraphicsLayer#
     * @returns {Boolean} 如果成功返回true 失败返回false
     */
    removeAt: function removeAt(index) {
      return Boolean(Module._Globe_GraphicsLayer_RemoveAt(this.handle, index));
    },
    /**
     * 移除所有元素
     * @memberOf GlobeGraphicsLayer#
     */
    removeAll: function removeAll() {
      Module._Globe_GraphicsLayer_RemoveAll(this.handle);
    },
    /**
     * 设置图层是否可选择
     * @param {Boolean} selectable -是否可选择
     * @memberOf GlobeGraphicsLayer#
     */
    setSelectable: function setSelectable(selectable) {
      Module._Globe_GraphicsLayer_SetSelectable(this.handle, selectable);
    },
    /**
     * 获取图层选择集
     *
     * @memberOf GlobeGraphicsLayer#
     * @returns {PIESelection} 成功返回selection对象，失败返回null
     */
    getSelection: function getSelection() {
      var handle = Module._Globe_GraphicsLayer_GetSelection(this.handle);
      return new PIESelection(handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * Renderable 类型枚举
   * @readonly
   * @enum {String}
   */
  var PIERenderableType = {
    /** 标签  */
    RenderLabel: 'RenderLabel',
    /** 点  */
    RenderPoint: 'RenderPoint',
    /** 3D点  */
    RenderPoint3D: 'RenderPoint3D',
    /** 多边形  */
    RenderPolygon: 'RenderPolygon',
    /** 3D多边形  */
    RenderPolygon3D: 'RenderPolygon3D',
    /** 多段线  */
    RenderPolyline: 'RenderPolyline',
    /** 3D 多段线  */
    RenderPolyline3D: 'RenderPolyline3D',
    /** 文字  */
    RenderText: 'RenderText',
    /** 3D 文字  */
    RenderText3D: 'RenderText3D',
    /** 模型 */
    RenderModel: 'RenderModel',
    /** 网格  */
    RenderMesh: 'RenderMesh',
    /** 非矢量 文字  */
    RenderNonFeatureText: 'RenderNonFeatureText',
    /** 面片  */
    RenderPatch: 'RenderPatch',
    /**  几何对象 */
    RenderGeometry: 'RenderGeometry',
    /**  节点 */
    RenderNode: 'RenderNode',
    /**  标绘 */
    RenderPlot: 'RenderPlot',
    /**  贴地标绘 */
    RenderSurfacePlot: 'RenderSurfacePlot',
    /**  三维标绘 */
    Render3DPlot: 'Render3DPlot'
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 渲染对象操作函数
   * @name Renderable
   *
   */
  function PIERenderable(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIERenderable.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放渲染对象
     * @memberOf Renderable#
     *
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._Renderable_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 获取渲染类型
     *
     * @memberOf Renderable#
     * @returns {String} 渲染类型
     *
     */
    getType: function getType() {
      var strType = new PIEString$1(56);
      Module._Renderable_GetType(this.handle, strType.getHandle());
      var type = strType.toString();
      return type;
    },
    /**
     * 设置渲染对象可见性
     * @param {Boolean} visible -是否可见
     * @memberOf Renderable#
     *
     */
    setVisible: function setVisible(visible) {
      Module._Renderable_SetVisible(this.handle, visible);
    },
    /**
     *  获取渲染对象可见性
     *
     *  @memberOf Renderable#
     * @returns {Boolean} 是否可见,可见返回true，不可见返回false
     *
     */
    isVisible: function isVisible() {
      return Boolean(Module._Renderable_IsVisible(this.handle));
    },
    /**
     *  设置渲染对象ID
     * @param {Number} id -渲染对象ID
     * @memberOf Renderable#
     *
     */
    setID: function setID(id) {
      Module._Renderable_SetID(this.handle, id);
    },
    /**
     *  获取渲染对象ID
     *
     * @memberOf Renderable#
     * @returns {Number} 返回渲染对象ID
     *
     */
    getID: function getID() {
      return Module._Renderable_GetID(this.handle);
    },
    // /**
    //  * 设置渲染对象优先级
    //  * @param {Number} id -渲染优先级priorityID
    //  * @memberOf Renderable#
    //  *
    //  */
    setRenderPriorityID: function setRenderPriorityID(id) {
      Module._Renderable_SetRenderPriorityID(this.handle, id);
    },
    // /**
    //  * 获取渲染对象优先级
    //  *
    //  * @memberOf Renderable#
    //  * @returns {Number} 返回渲染优先级ID
    //  *
    //  */
    getRenderPriorityID: function getRenderPriorityID() {
      return Module._Renderable_GetRenderPriorityID(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 几何对象渲染操作函数
   * @name RenderGeometry
   *
   * @extends Renderable
   *
   */
  function PIERenderGeometry(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIERenderGeometry.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 设置矢量要素
     * @param {PIEFeature} feature -矢量要素对象
     * @memberOf RenderGeometry#
     */
    setFeature: function setFeature(feature) {
      if (!feature) {
        return;
      }
      if (!feature.getHandle() || !(feature instanceof PIEFeature)) {
        throw new Error('PIE.RenderGeometry.setFeature: input feature is invalid.');
      }
      Module._RenderGeometry_SetFeature(this.handle, feature.getHandle());
    },
    /**
     * 获取矢量要素
     *
     * @memberOf RenderGeometry#
     * @returns {PIEFeature} 返回矢量要素对象
     */
    getFeature: function getFeature() {
      var hFeature = Module._RenderGeometry_GetFeature(this.handle);
      if (hFeature) {
        return new PIEFeature(hFeature);
      }
      return null;
    },
    /**
     * 设置风格
     * @param {PIEStyle} style -风格
     * @memberOf RenderGeometry#
     *
     */
    setStyle: function setStyle(style) {
      var feature = this.getFeature();
      var geometry = feature.getGeometry();
      if (geometry instanceof PIEPoint || geometry instanceof PIEPolyline || geometry instanceof PIEPolygon) {
        style.setFillStyle(3); //特殊处理 临时方案
      }

      geometry.setStyle(style);
    },
    /**
     * 获取风格
     *
     * @memberOf RenderGeometry#
     * @returns {PIEVectorStyle} 返回的风格
     */
    getStyle: function getStyle() {
      var feature = this.getFeature();
      var geometry = feature.getGeometry();
      return geometry.getStyle();
    },
    /**
     * 运行动画
     * @param {PIEAction} action -动画对象(不能为NULL)
     * @memberOf RenderGeometry#
     *
     */
    runAction: function runAction(action) {
      return Module._RenderGeometry_RunAction(this.handle, action.getHandle());
    },
    /**
     * 启动指定动画
     * @param {PIEAction} action -动画对象(不能为NULL)
     * @memberOf RenderGeometry#
     *
     */
    startAction: function startAction(action) {
      return Module._RenderGeometry_StartAction(this.handle, action.getHandle());
    },
    /**
     * 停止指定动画
     * @param {PIEAction} action -动画对象(不能为NULL)
     * @memberOf RenderGeometry#
     *
     */
    stopAction: function stopAction(action) {
      return Module._RenderGeometry_StopAction(this.handle, action.getHandle());
    },
    /**
     * 设置标绘位置
     * @param {(PIEVector3/Array)} pos -坐标位置
     * @memberOf RenderGeometry#
     */
    setPosition: function setPosition(pos) {
      var array = null;
      if (pos instanceof PIEVector3) {
        array = pos.toArray();
      } else if (pos instanceof Array) {
        array = pos;
      }
      if (array) {
        var point3Array = new PIEArray(array, PIEArrayType.Float64);
        Module._RenderGeometry_SetPosition(this.handle, point3Array.getHandle());
        point3Array.dispose();
      }
    },
    /**
     * 获取标绘位置
     *
     * @memberOf RenderGeometry#
     * @returns {PIEVector3} 返回标绘位置
     */
    getPosition: function getPosition() {
      var point3Array = new PIEArray(3, PIEArrayType.Float64);
      Module._RenderGeometry_GetPosition(this.handle, point3Array.getHandle());
      point3Array.updateData();
      var array = point3Array.toArray();
      point3Array.dispose();
      return new PIEVector3(array[0], array[1], array[2]);
    },
    /**
     * 设置渲染对象的高度
     * @param {Number} height -高度
     * @memberOf RenderGeometry#
     */
    setHeight: function setHeight(height) {
      var pos = this.getPosition();
      var newPos = [pos.x, pos.y, height];
      this.setPosition(newPos);
    },
    /**
     * 获取渲染对象的高度
     * @memberOf RenderGeometry#
     * @returns {Number} 返回渲染对象的高度
     */
    getHeight: function getHeight() {
      var pos = this.getPosition();
      return pos.z;
    },
    /**
     * 设置旋转弧度
     * @param {PIEVector3/Array} rotation -旋转弧度
     * @memberOf RenderGeometry#
     */
    setRotation: function setRotation(rotation) {
      var array = null;
      if (rotation instanceof PIEVector3) {
        array = rotation.toArray();
      } else if (rotation instanceof Array) {
        array = rotation;
      }
      if (array) {
        var rotationArray = new PIEArray(array, PIEArrayType.Float64);
        Module._RenderGeometry_SetRotation(this.handle, rotationArray.getHandle());
        rotationArray.dispose();
      }
    },
    /**
     * 获取旋转弧度
     *
     * @memberOf RenderGeometry#
     * @returns {PIEVector3} 返回标绘位置
     */
    getRotation: function getRotation() {
      var rotationArray = new PIEArray(3, PIEArrayType.Float64);
      Module._RenderGeometry_GetRotation(this.handle, rotationArray.getHandle());
      rotationArray.updateData();
      var array = rotationArray.toArray();
      rotationArray.dispose();
      return new PIEVector3(array[0], array[1], array[2]);
    },
    /**
     * 刷新地球
     * @param {PIEGlobe} globe -地球
     * @memberOf RenderGeometry#
     *
     * @returns {Boolean} 是否刷新成功
     */
    refresh: function refresh(globe) {
      return Boolean(Module._RenderGeometry_Refresh(this.handle, globe.handle));
    },
    /**
     * 设置数据是否改变
     * @param {Boolean} dirty -数据是否改变
     * @memberOf RenderGeometry#
     *
     */
    setDirty: function setDirty(dirty) {
      Module._RenderGeometry_SetDirty(this.handle, dirty);
    },
    /**
     * 获取数据是否改变
     *
     * @memberOf RenderGeometry#
     * @returns {Boolean} 返回是否成功改变的数据
     */
    getDirty: function getDirty() {
      return Boolean(Module._RenderGeometry_GetDirty(this.handle));
    },
    /**
     * 设置是否选中
     * @param {Boolean} selected -是否选中
     * @memberOf RenderGeometry#
     */
    setSelected: function setSelected(selected) {
      Module._RenderGeometry_SetSelected(this.handle, selected);
    },
    /**
     * 获取是否选中
     *
     * @memberOf RenderGeometry#
     * @returns {Boolean} 返回是否选中
     */
    isSelected: function isSelected() {
      return Boolean(Module._RenderGeometry_IsSelected(this.handle));
    },
    /**
     * 设置是否固定大小
     * @param {Boolean} fixedSize -是否固定大小
     * @memberOf RenderGeometry#
     */
    setFixedSize: function setFixedSize(fixedSize) {
      Module._RenderGeometry_SetFixedSize(this.handle, fixedSize);
    },
    /**
     * 获取是否固定大小
     * @memberOf RenderGeometry#
     * @returns {Boolean} 返回是否固定大小
     */
    isFixedSize: function isFixedSize() {
      return Boolean(Module._RenderGeometry_IsFixedSize(this.handle));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 点符号对齐方式
   * @readonly
   * @enum {number}
   */
  var PIEPointAlignType = {
    /** 左上对齐*/
    LeftTop: 0,
    /** 中上对齐*/
    TopCenter: 1,
    /** 右上对齐*/
    RightTop: 2,
    /** 左下对齐*/
    LeftBottom: 3,
    /** 中下对齐*/
    BottomCenter: 4,
    /** 右下对齐*/
    RightBottom: 5,
    /** 左中对齐*/
    LeftCenter: 6,
    /** 中心对齐*/
    Center: 7,
    /** 右中对齐*/
    RightCenter: 8
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建点渲染对象
   * @param {Object} options -
   * @param {PIEPoint} options.point -点
   * @param {PIEColor/Array} options.color -点颜色
   * @param {PIEPointType} options.type -点类型
   * @param {PIEVector2/Array} options.size -点大小
   * @param {Number} options.style -点风格id(当type为PIE.PointType.Icon时，需要设置id)
   * @param {PIEPointAlignType} options.align -点对齐方式
   * @name RenderPoint
   * @class RenderPoint
   * 点渲染操作函数
   * @extends RenderGeometry
   *
   */
  function PIERenderPoint(options) {
    var handle = null;
    var autoRelease = false;
    var point = null;
    if (options != null) {
      if (options.point != null) {
        point = options.point;
        if (point && point instanceof PIEPoint) {
          var color = options.color;
          var size = options.size;
          var type = options.type;
          var style = options.style;
          var align = options.align;
          if (color || size || type || style || align) {
            var vectorStyle = new PIEVectorStyle();
            vectorStyle.setAutoRelease(true);
            vectorStyle.setPointColor(color);
            vectorStyle.setPointSize(size);
            vectorStyle.setPointStyle(style);
            vectorStyle.setPointType(type);
            vectorStyle.setPointAlign(align);
            vectorStyle.setAltitudeMode(PIEAltitudeMode.ClampToGround);
            point.setStyle(vectorStyle);
            vectorStyle.dispose();
          }
          handle = Module._RenderGeometry_Create(point.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderPoint.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维点渲染对象
   * @param {Object} options -
   * @param {PIEPoint3D} options.point3D - 三维点
   * @param {PIEColor/Array} options.color -点颜色
   * @param {Number} options.size -点大小
   * @param {PIEPointType} options.type -点类型
   * @param {PIEStyle} options.style -点风格
   * @param {PIEPointAlignType} options.align -点对齐
   * @param {PIEAltitudeMode} options.altitudeMode -依地模式 默认值（PIEAltitudeMode.AbsoluteAltitude）
   *
   * @name RenderPoint3D
   * @class RenderPoint3D
   * 三维点渲染操作函数
   * @extends RenderGeometry
   */
  function PIERenderPoint3D(options) {
    var handle = null;
    var autoRelease = false;
    var point3D = null;
    if (options != null) {
      if (options.point3D != null) {
        point3D = options.point3D;
        if (point3D && point3D && point3D instanceof PIEPoint3D) {
          var color = options.color;
          var size = options.size;
          var type = options.type;
          var style = options.style;
          var align = options.align;
          var altitudeMode = options.altitudeMode;
          if (altitudeMode == null) altitudeMode = PIEAltitudeMode.AbsoluteAltitude;
          if (color || size || type || style || align) {
            var vectorStyle = new PIEVectorStyle();
            vectorStyle.setAutoRelease(false);
            vectorStyle.setPointStyle(style);
            vectorStyle.setPointType(type);
            vectorStyle.setPointAlign(align);
            vectorStyle.setPointColor(color);
            vectorStyle.setPointSize(size);
            vectorStyle.setAltitudeMode(altitudeMode);
            point3D.setStyle(vectorStyle);
          }
          handle = Module._RenderGeometry_Create(point3D.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderPoint3D.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建面渲染对象
   * @param {Object} options -
   * @param {PIEPolygon} options.polygon -面
   * @param {PIEColor/Array} options.color -面颜色
   *
   * @name RenderPolygon
   * @class RenderPolygon
   *  面渲染操作函数
   * @extends RenderGeometry
   *
   */
  function PIERenderPolygon(options) {
    var handle = null;
    var autoRelease = false;
    var polygon = null;
    if (options != null) {
      if (options.polygon != null) {
        polygon = options.polygon;
        if (polygon.isCounterClockwise(0)) {
          polygon.reverseSubPolygon(0);
        }
        if (polygon && polygon instanceof PIEPolygon) {
          var color = options.color;
          var type = PIEFillType.Null;
          var style = 3;
          if (color) {
            var vectorStyle = new PIEVectorStyle();
            vectorStyle.setAutoRelease(true);
            vectorStyle.setFillStyle(style);
            vectorStyle.setFillType(type);
            vectorStyle.setForeFillColor(color);
            polygon.setStyle(vectorStyle);
            vectorStyle.dispose();
          }
          handle = Module._RenderGeometry_Create(polygon.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderPolygon.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维面渲染对象
   * @param {Object} options -
   * @param {PIEPolygon3D} options.polygon3D -三维面
   * @param {PIEColor/Array} options.color -面颜色
   * @param {PIEFillType} options.type -面类型
   *
   * @name RenderPolygon3D
   * @class RenderPolygon3D
   *  三维面渲染操作函数
   * @extends RenderGeometry
   *
   */
  function PIERenderPolygon3D(options) {
    var handle = null;
    var autoRelease = null;
    var polygon3D = null;
    if (options != null) {
      if (options.polygon3D != null) {
        polygon3D = options.polygon3D;
        if (polygon3D && polygon3D && polygon3D instanceof PIEPolygon3D) {
          var color = options.color;
          var type = options.type;
          var style = 0;
          var vectorStyle = new PIEVectorStyle();
          vectorStyle.setAutoRelease(true);
          vectorStyle.setFillStyle(style);
          vectorStyle.setForeFillColor(color);
          vectorStyle.setFillType(type);
          polygon3D.setStyle(vectorStyle);
          vectorStyle.dispose();
          handle = Module._RenderGeometry_Create(polygon3D.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = options.autoRelease != null ? options.autoRelease : false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderPolygon3D.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建多段线渲染对象
   * @param {Object} options -
   * @param {PIEPolyline} options.polyline -多段线
   * @param {PIEColor/Array} options.color -线条颜色
   * @param {Number} options.width -线条宽度
   * @name RenderPolyline
   * @class RenderPolyline
   * 多段线渲染操作函数
   * @extends RenderGeometry
   *
   */
  function PIERenderPolyline(options) {
    var handle = null;
    var autoRelease = false;
    var polyline = null;
    if (options != null) {
      if (options.polyline != null) {
        polyline = options.polyline;
        if (polyline && polyline instanceof PIEPolyline) {
          var color = options.color;
          var width = options.width;
          var type = PIELineType.Null;
          var style = 3;
          if (color || width) {
            var vectorStyle = new PIEVectorStyle();
            vectorStyle.setAutoRelease(true);
            vectorStyle.setLineColor(color);
            vectorStyle.setLineWidth(width);
            vectorStyle.setLineType(type);
            vectorStyle.setLineStyle(style);
            polyline.setStyle(vectorStyle);
            vectorStyle.dispose();
          }
          handle = Module._RenderGeometry_Create(polyline.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderPolyline.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维多段线渲染对象
   * @param {Object} options -
   * @param {PIEPolyline3D} options.polyline3D -三维多段线
   * @param {PIEColor/Array} options.color -线条颜色
   * @param {Number} options.width -线条宽度
   * @param {PIELineType} options.type -线条类型
   * @name RenderPolyline3D
   * @class RenderPolyline3D
   * 三维多段线渲染操作函数
   * @extends RenderGeometry
   *
   */
  function PIERenderPolyline3D(options) {
    var handle = null;
    var autoRelease = null;
    var polyline3D = null;
    if (options != null) {
      if (options.polyline3D != null) {
        polyline3D = options.polyline3D;
        if (polyline3D && polyline3D && polyline3D instanceof PIEPolyline3D) {
          var color = options.color;
          var width = options.width;
          var type = options.type;
          var style = options.style != null ? options.style : 0;
          var vectorStyle = new PIEVectorStyle();
          vectorStyle.setAutoRelease(true);
          vectorStyle.setLineColor(color);
          vectorStyle.setLineWidth(width);
          vectorStyle.setLineStyle(style);
          vectorStyle.setLineType(type);
          polyline3D.setStyle(vectorStyle);
          vectorStyle.dispose();
          handle = Module._RenderGeometry_Create(polyline3D.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderPolyline3D.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 创建文本渲染对象
   * @param {Object} options -
   * @param {PIEText} options.text -文本
   * @param {PIEColor/Array} options.color -文本颜色
   * @param {Number} options.width -文本宽度
   * @param {Number} options.height -文本高度
   * @param {PIETextAlignType} options.align -文本对齐
   *
   * @name RenderText
   * @class RenderText
   * 文本渲染操作函数
   * @extends RenderGeometry
   *
   */
  function PIERenderText(options) {
    var handle = null;
    var autoRelease = false;
    var text = null;
    if (options != null) {
      if (options.text != null) {
        text = options.text;
        if (text && text instanceof PIEText) {
          var color = options.color;
          var width = options.width;
          var height = options.height;
          var align = options.align;
          if (color || width || height || align) {
            var textStyle = new PIETextStyle();
            textStyle.setAutoRelease(false);
            textStyle.setForeColor(color);
            textStyle.setWidth(width);
            textStyle.setHeight(height);
            textStyle.setAlign(align);
            text.setTextStyle(textStyle);
          }
          handle = Module._RenderGeometry_Create(text.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderText.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {
    /**
     * 设置选择文本风格
     * @param {PIETextStyle} style -几何对象风格
     * @memberOf RenderText#
     *
     */
    setTextStyle: function setTextStyle(style) {
      var feature = this.getFeature();
      var geometry = feature.getGeometry();
      if (geometry instanceof PIEText) {
        geometry.setTextStyle(style);
      }
    },
    /**
     * 获取选择文本风格
     *
     * @memberOf RenderText#
     * @returns {PIETextStyle} 返回的文本对象风格
     *
     */
    getTextStyle: function getTextStyle() {
      var feature = this.getFeature();
      var geometry = feature.getGeometry();
      return geometry.getTextStyle();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维文本渲染对象
   * @param {Object} options -
   * @param {PIEText3D} options.text3D - 三维文本
   * @param {PIEColor/Array} options.color -文本颜色
   * @param {Number} options.width -文本宽度
   * @param {Number} options.height -文本高度
   * @param {PIETextAlignType} options.align -文本对齐
   *
   * @name RenderText3D
   * @class RenderText3D
   * 三维文本渲染操作函数
   * @extends RenderGeometry
   */
  function PIERenderText3D(options) {
    var handle = null;
    var autoRelease = null;
    var text3D = null;
    if (options != null) {
      if (options.text3D != null) {
        text3D = options.text3D;
        if (text3D || text3D || text3D instanceof PIEText3D) {
          var color = options.color;
          var width = options.width;
          var height = options.height;
          var align = options.align;
          if (color || width || height || align) {
            var textStyle = new PIETextStyle();
            textStyle.setAutoRelease(false);
            textStyle.setForeColor(color);
            textStyle.setWidth(width);
            textStyle.setHeight(height);
            textStyle.setAlign(align);
          }
          handle = Module._RenderGeometry_Create(text3D.getHandle());
          autoRelease = true;
        }
      }
    }
    if (options.handle != null) {
      handle = options.handle;
      autoRelease = false;
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderText3D.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {
    /**
     * 设置选择文本风格
     * @param {PIETextStyle} style -几何对象风格
     * @memberOf RenderText3D#
     *
     */
    setTextStyle: function setTextStyle(style) {
      var feature = this.getFeature();
      var geometry = feature.getGeometry();
      if (geometry instanceof PIEText3D) {
        geometry.setTextStyle(style);
      }
    },
    /**
     * 获取选择文本风格
     *
     * @memberOf RenderText3D#
     * @returns {PIETextStyle} 返回的文本对象风格
     *
     */
    getTextStyle: function getTextStyle() {
      var feature = this.getFeature();
      var geometry = feature.getGeometry();
      return geometry.getTextStyle();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建模型渲染对象
   * @param {Object} options
   * @param {PIEModel3D} options.model -模型
   * @param {PIEVector3/Array} options.position -坐标位置
   * @param {PIEVector3/Array} options.scale -缩放比例
   * @param {PIEVector3/Array} options.rotation -旋转角度
   *
   * @name RenderModel
   * @class RenderModel
   * 模型渲染操作函数
   * @extends RenderGeometry
   *
   */
  function PIERenderModel(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      if (options.model != null) {
        var model = options.model;
        if (model && model instanceof PIEModel3D) {
          var position = options.position;
          var scale = options.scale;
          var rotation = options.rotation;
          model.setPosition(position);
          model.setScale(scale);
          model.setRotation(rotation);
          handle = Module._RenderGeometry_Create(model.getHandle());
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderModel.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 标绘模块
   * ---
   */

  /**
   * 创建标绘渲染类对象
   * @name RenderPlot
   *@class RenderPlot
   *标绘对象渲染操作函数
   *
   * @param {Object} options -
   * @param {Object} options.plot -军标对象
   * @param {PIEVector4} options.color -军标线符号颜色
   * @param {Number} options.width -几何对象的宽度
   * @param {Number} options.style -线风格
   * @param {Number} options.fillMode -填充模式
   * @param {Number} options.fillForeColor -填充颜色
   *
   * @extends RenderGeometry
   * @example
   * var plotPtsWgs84 = [118, 39.5];
     var posGlobeSR = patialReference.forward(plotPtsWgs84);
     var geoPlot = new PIE.GeoPlot({code:10107, points:posGlobeSR, unitLength:1})
     var renderPlot = new PIE.RenderPlot({plot:geoPlot, color:[255, 255, 0, 255], width:3, style:0});
   */
  function PIERenderPlot(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var plot = options.plot;
      if (plot != null) {
        if (plot instanceof PIEGeoPlot) {
          var color = options.color;
          var width = options.width;
          var style = options.style;
          var fillMode = options.fillMode;
          var fillForeColor = options.fillForeColor;
          if (color || width || style || fillMode || fillForeColor) {
            var plotStyle = plot.getStyle();
            // plotStyle.setAutoRelease(false);
            plotStyle.setLineColor(color);
            plotStyle.setLineWidth(width);
            plotStyle.setLineStyle(style);
            plotStyle.setFillMode(fillMode);
            plotStyle.setFillForeColor(fillForeColor);
            //plot.setStyle(plotStyle);
          }

          handle = Module._RenderPlot_Create(plot.getHandle());
          autoRelease = true;
        }
      }
      if (options.handle != null) {
        handle = options.handle;
        autoRelease = false;
      }
    }
    PIERenderGeometry.call(this, handle, autoRelease);
  }
  PIERenderPlot.prototype = Object.assign(Object.create(PIERenderGeometry.prototype), {
    /**
     * 获取几何对象
     *
     * @memberOf RenderPlot#
     * @returns {PIEGeoPlot} 返回几何对象
     */
    getGeometry: function getGeometry() {
      var hGeometry = Module._RenderPlot_GetGeometry(this.handle);
      if (hGeometry) {
        return new PIEGeoPlot({
          handle: hGeometry
        });
      }
      return null;
    },
    /**
     *设置标绘位置
     * @param {(Array/PIEVector3)} position -标绘位置
     * @memberOf RenderPlot#
     */
    setPosition: function setPosition(position) {
      var posArray = [];
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = [position.x, position.y, position.z];
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._RenderPlot_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     *获取标绘位置
     *
     * @memberOf RenderPlot#
     * @returns {PIEVector3} position -标绘位置
     */
    getPosition: function getPosition() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._RenderPlot_GetPosition(this.handle, arrayPos.getHandle());
      arrayPos.updateData();
      var position = arrayPos.toArray();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     *设置是否可见
     * @param {Boolean} visible -是否可见
     * @memberOf RenderPlot#
     */
    setVisible: function setVisible(visible) {
      Module._RenderPlot_SetVisible(this.handle, visible);
    },
    /**
     *获取是否可见
     *
     * @memberOf RenderPlot#
     * @returns {Boolean} 返回是否可见
     */
    getVisible: function getVisible() {
      return Module._RenderPlot_GetVisible(this.handle);
    }
  });

  function PIERenderableFactory() {}
  Object.assign(PIERenderableFactory.prototype, {});
  PIERenderableFactory.CreateInstance = function (hRenderable) {
    var renderable = new PIERenderable(hRenderable);
    var type = renderable.getType();
    if (type == PIERenderableType.RenderPoint) {
      return new PIERenderPoint({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderPoint3D) {
      return new PIERenderPoint3D({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderPolygon) {
      return new PIERenderPolygon({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderPolygon3D) {
      return new PIERenderPolygon3D({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderPolyline) {
      return new PIERenderPolyline({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderPolyline3D) {
      return new PIERenderPolyline3D({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderText) {
      return new PIERenderText({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderText3D) {
      return new PIERenderText3D({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderModel) {
      return new PIERenderModel({
        handle: hRenderable
      });
    } else if (type == PIERenderableType.RenderPlot || type == PIERenderableType.RenderSurfacePlot || type == PIERenderableType.Render3DPlot) {
      return new PIERenderPlot({
        handle: hRenderable
      });
    } else {
      return new PIERenderable(hRenderable);
    }
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建绘制对象图层
   * @name GlobeRenderableLayer
   * @class GlobeRenderableLayer
   * 三维渲染图层操作函数
   *
   * @extends GlobeLayer
   * @example
   * let globeRenderableLayer = new PIE.GlobeRenderableLayer()
   */
  function PIEGlobeRenderableLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._GlobeRenderableLayer_Create();
      autoRelease = true;
    }
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeRenderableLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    /**
     * 获取绘制对象图层元素个数
     *
     * @memberOf GlobeRenderableLayer#
     * @returns {Number} 如果成功返回元素个数
     */
    getCount: function getCount() {
      return Module._GlobeRenderableLayer_GetCount(this.handle);
    },
    /**
     * 添加绘制对象
     *
     * @param {PIERenderable} renderable -绘制对象
     * @memberOf GlobeRenderableLayer#
     * @returns {Boolean} 如果成功返回true，失败返回false
     */
    add: function add(renderable) {
      return Boolean(Module._GlobeRenderableLayer_Add(this.handle, renderable.getHandle()));
    },
    /**
     * 根据序列号获取绘制对象
     * @param {Number} index -绘制对象序列号
     * @memberOf GlobeRenderableLayer#
     * @returns {PIERenderable} 如果成功返回绘制对象，失败返回NULL
     */
    getAt: function getAt(index) {
      var handle = Module._GlobeRenderableLayer_GetAt(this.handle, index);
      return PIERenderableFactory.CreateInstance(handle);
    },
    /**
     * 根据id获取绘制对象
     * @param {Number} id -绘制对象id
     * @memberOf GlobeRenderableLayer#
     * @returns {PIERenderable} 如果成功返回绘制对象，失败返回NULL
     */
    get: function get(id) {
      var handle = Module._GlobeRenderableLayer_Get(this.handle, id);
      if (handle) {
        return PIERenderableFactory.CreateInstance(handle);
      }
      return null;
    },
    /**
     * 根据id移除绘制对象(id对应的几何对象将被删除，不能继续使用)
     * @param {Number} id -绘制对象id
     * @memberOf GlobeRenderableLayer#
     * @returns {Boolean} 如果成功返回 true 失败返回false
     */
    remove: function remove(id) {
      return Boolean(Module._GlobeRenderableLayer_Remove(this.handle, id));
    },
    /**
     * 根据序列号移除绘制对象
     * @param {Number} index -绘制对象序列号
     * @memberOf GlobeRenderableLayer#
     *
     * @returns {Boolean} 如果成功返回 true 失败返回false
     */
    removeAt: function removeAt(index) {
      return Boolean(Module._GlobeRenderableLayer_RemoveAt(this.handle, index));
    },
    /**
     * 移除所有绘制对象
     * @memberOf GlobeRenderableLayer#
     *
     */
    removeAll: function removeAll() {
      Module._GlobeRenderableLayer_RemoveAll(this.handle);
    },
    // /**
    //  * 添加军标数据源
    //  * @param {PIEFeatureDataSource} plotDatasource -添加军标数据源对象
    //  * @param {PIEGlobe} globe -三维图像对象
    //  * @memberOf GlobeRenderableLayer#
    //  *
    //  * @example
    //  * let globeRenderableLayer = new PIE.GlobeRenderableLayer();
    //  * globeRenderableLayer.addPlotDatasource(plotDataSource, globe);
    //  */
    addPlotDatasource: function addPlotDatasource(plotDatasource, globe) {
      if (plotDatasource instanceof PIEDataSource) {
        var count = plotDatasource.getDatasetCount();
        for (var i = 0; i < count; i++) {
          var dataSet = Module._DataSource_GetDatasetAt(plotDatasource.getHandle(), i);
          Module._GlobeRenderableLayer_AddPlotDataset(this.handle, dataSet, globe.handle);
        }
      }
    },
    /**
     * 获取图层选择集
     *
     * @memberOf GlobeRenderableLayer#
     * @returns {PIESelection} 成功返回selection对象，失败返回null
     */
    getSelection: function getSelection() {
      var handle = Module._Globe_RenderableLayer_GetSelection(this.handle);
      return new PIESelection(handle);
    },
    /**
     * 清空要素图层选择集
     *
     * @memberOf GlobeRenderableLayer#
     * @returns {Boolean} 是否清空成功 成功返回 true 失败返回false
     */
    clearSelection: function clearSelection() {
      return Module._Globe_RenderableLayer_ClearSelection(this.handle);
    },
    // /**
    //  * 要素图层渲染器更新几何对象
    //  * @param {PIEGeometry} geometry -几何对象对象
    //  * @memberOf GlobeRenderableLayer#
    //  *
    //  * @returns {Boolean} 如果成功返回true，失败返回false
    //  *
    //  * @example
    //  * let globeRenderableLayer = new PIE.GlobeRenderableLayer();
    //  * globeRenderableLayer.updateGeometry(geometry);
    //  */
    updateGeometry: function updateGeometry(geometry) {
      return Module._Globe_RenderableLayer_UpdateGeometry(this.handle, geometry.getHandle());
    },
    /**
     * 根据id删除几何对象
     * @param {Number} id -几何对象id
     * @memberOf GlobeRenderableLayer#
     * @returns {Boolean} 如果成功返回 true 失败返回false
     */
    deleteGeometry: function deleteGeometry(id) {
      return Module._Globe_RenderableLayer_DeleteGeometry(this.handle, id);
    },
    /**
     * 设置图层是否可选择
     * @param {Boolean} selectable -是否可选择
     * @memberOf GlobeRenderableLayer#
     */
    setSelectable: function setSelectable(selectable) {
      Module._GlobeRenderableLayer_SetSelectable(this.handle, selectable);
    },
    /**
     * 判断图层是否可选
     * @memberOf GlobeRenderableLayer#
     * @returns {Boolean} 可选返回true，不可选返回false
     */
    isSelectable: function isSelectable() {
      return Boolean(Module._GlobeRenderableLayer_IsSelectable(this.handle));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 渲染对象操作函数
   * @name Projector
   * @class Projector
   * 创建渲染对象
   */
  function PIEProjector(handle, autoRelease) {
    if (handle == null) {
      this.handle = Module._Projector_Create();
      this.autoRelease = true;
    }
  }
  Object.assign(PIEProjector.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 设置名称
     * @param {String}  strName -名称
     * @memberOf Projector#
     */
    setName: function setName(strName) {
      var name = new PIEString$1(strName);
      Module._Projector_SetName(this.handle, name.getHandle());
      name.dispose();
    },
    /**
     * 获取名称
     *
     * @memberOf Projector#
     * @returns {String} 返回名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Projector_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置是否正投影
     * @param {Boolean} ortho -是否是正投影
     * @memberOf Projector#
     */
    setOrtho: function setOrtho(ortho) {
      Module._Projector_SetOrtho(this.handle, ortho);
    },
    /**
     * 获取是否正投影
     *
     * @memberOf Projector#
     * @returns {Boolean} 返回是否正投影(正投影返回true,否则返回false)
     */
    isOrtho: function isOrtho() {
      return Boolean(Module._Projector_IsOrtho(this.handle));
    },
    /**
     * 设置视场角度
     * @param {Number} fov -视场角度
     * @memberOf Projector#
     */
    setFov: function setFov(fov) {
      Module._Projector_SetFov(this.handle, fov);
    },
    /**
     * 获取视场角度
     *
     * @memberOf Projector#
     * @returns {Number} 返回视场角度
     */
    getFov: function getFov() {
      return Module._Projector_GetFov(this.handle);
    },
    /**
     * 设置宽高比
     * @param {Number} aspectRatio -宽高比
     * @memberOf Projector#
     */
    setAspectRatio: function setAspectRatio(aspectRatio) {
      Module._Projector_SetAspectRatio(this.handle, aspectRatio);
    },
    /**
     * 获取宽高比
     *
     * @memberOf Projector#
     * @returns {Number} 返回宽高比
     */
    getAspectRatio: function getAspectRatio() {
      return Module._Projector_GetAspectRatio(this.handle);
    },
    /**
     * 设置近裁剪面距离
     * @param {Number} distance -近裁剪面距离
     * @memberOf Projector#
     */
    setNearDistance: function setNearDistance(distance) {
      Module._Projector_SetNearDistance(this.handle, distance);
    },
    /**
     * 获取近裁剪面距离
     *
     * @memberOf Projector#
     * @returns {Number}  返回近裁剪面距离
     */
    getNearDistance: function getNearDistance() {
      return Module._Projector_GetNearDistance(this.handle);
    },
    /**
     * 设置远裁剪面距离
     * @param {Number}  distance -远裁剪面距离
     * @memberOf Projector#
     */
    setFarDistance: function setFarDistance(distance) {
      Module._Projector_SetFarDistance(this.handle, distance);
    },
    /**
     * 获取远裁剪面距离
     *
     * @memberOf Projector#
     * @returns {Number} 返回远裁剪面距离
     */
    getFarDistance: function getFarDistance() {
      return Module._Projector_GetFarDistance(this.handle);
    },
    /**
     * 设置视点位置
     * @param {(Array/PIEVector3)} position -视点位置
     * @memberOf Projector#
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._Projector_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取视点位置
     *
     * @memberOf Projector#
     * @returns {PIEVector3} 返回视点位置
     */
    getPosition: function getPosition() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._Projector_GetPosition(this.handle, arrayPos.getHandle());
      arrayPos.updateData();
      var position = arrayPos.toArray();
      arrayPos.dispose();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     * 设置视点方向
     * @param {(Array/PIEVector3)} direction -视点方向
     * @memberOf Projector#
     */
    setDirection: function setDirection(direction) {
      var posArray = null;
      if (direction instanceof Array) {
        posArray = direction;
      } else if (direction instanceof PIEVector3) {
        posArray = direction.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._Projector_SetDirection(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取视点方向
     *
     * @memberOf Projector#
     * @returns {PIEVector3} 返回视点方向
     */
    getDirection: function getDirection() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._Projector_GetDirection(this.handle, arrayPos.getHandle());
      arrayPos.updateData();
      var position = arrayPos.toArray();
      arrayPos.dispose();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     * 设置视点向上方向
     * @param {(Array/PIEVector3)} up -视点向上方向
     * @memberOf Projector#
     */
    setUp: function setUp(up) {
      var posArray = null;
      if (up instanceof Array) {
        posArray = direction;
      } else if (up instanceof PIEVector3) {
        posArray = up.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._Projector_SetUp(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取视点向上方向
     *
     * @memberOf Projector#
     * @returns {PIEVector3} 返回视点向上方向
     */
    getUp: function getUp() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._Projector_GetUp(this.handle, arrayPos.getHandle());
      arrayPos.updateData();
      var up = arrayPos.toArray();
      arrayPos.dispose();
      return new PIEVector3(up[0], up[1], up[2]);
    },
    /**
     * 设置投射纹理
     * @param {PIETexture} texture -投射纹理
     * @memberOf Projector#
     */
    setTexture: function setTexture(texture) {
      Module._Projector_SetTexture(this.handle, texture.getHandle());
    },
    /**
     * 获取投射纹理
     *
     * @memberOf Projector#
     * @returns {PIETexture} 返回投射纹理
     */
    getTexture: function getTexture() {
      var handle = Module._Projector_GetTexture(this.handle);
      if (handle) {
        return new PIETexture(handle);
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维模型图层操作函数
   * @name GlobeModelLayer
   * @extends GlobeLayer
   */
  function PIEGlobeModelLayer(handle, autoRelease) {
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeModelLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    // /**
    //  * 设置倾斜摄影模型数据源名称
    //  * @param {String} name -数据源名称
    //  * @memberOf GlobeModelLayer#
    //  */
    setDataSourceName: function setDataSourceName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeModelLayer_SetDataSourceName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取倾斜摄影模型数据源名称
    //  *
    //  * @memberOf GlobeModelLayer#
    //  * @returns {String} 返回数据源名称
    //  */
    getDataSourceName: function getDataSourceName() {
      var strName = new PIEString$1(256);
      Module._GlobeModelLayer_GetDataSourceName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    // /**
    //  * 设置倾斜摄影模型数据集名称
    //  * @param {String} name -数据集名称
    //  * @memberOf GlobeModelLayer#
    //  */
    setDatasetName: function setDatasetName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeModelLayer_SetDatasetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    // /**
    //  * 获取倾斜摄影模型数据集名称
    //  *
    //  * @memberOf GlobeModelLayer#
    //  * @returns {String} 返回数据集名称
    //  */
    getDatasetName: function getDatasetName() {
      var strName = new PIEString$1(256);
      Module._GlobeModelLayer_GetDatasetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置倾斜摄影数据源
     * @param {PIEDataSource} datasource -数据源
     * @memberOf GlobeModelLayer#
     */
    setDataSource: function setDataSource(datasource) {
      Module._GlobeModelLayer_SetDataset(this.handle, datasource.getDataset().getHandle());
    },
    /**
     * 获取数据源
     *
     * @memberOf GlobeModelLayer#
     * @returns {PIEDataSource}  -返回数据源
     *
     */
    getDataSource: function getDataSource() {
      var hDataset = Module._GlobeModelLayer_GetDataset(this.handle);
      var hDataSource = Module._Dataset_GetDataSource(hDataset);
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    },
    setDataset: function setDataset(dataset) {
      Module._GlobeModelLayer_SetDataset(this.handle, dataset.getHandle());
    },
    getDataset: function getDataset() {
      var hDataset = Module._GlobeModelLayer_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(hDataset);
    },
    /**
     * 添加压平区域
     * @param {String} name -压平区域名称
     * @param {PIEPolygon3D} polygon -压平区域对象
     * @memberOf GlobeModelLayer#
     */
    addFlatten: function addFlatten(name, polygon) {
      var strName = new PIEString$1(name);
      Module._Globe_ModelLayer_AddFlatten(this.handle, strName.getHandle(), polygon.getHandle());
      strName.dispose();
    },
    /**
     * 根据名称获取压平区域
     * @param {String} name -压平区域名称
     * @memberOf GlobeModelLayer#
     * @returns {PIEPolygon3D} 返回压平区域
     */
    getFlatten: function getFlatten(name) {
      var strName = new PIEString$1(name);
      var handle = Module._Globe_ModelLayer_GetFlatten(this.handle, strName.getHandle());
      strName.dispose();
      if (handle) {
        return new PIEPolygon3D(handle);
      }
    },
    /**
     * 移除压平区域
     * @param {String} name -压平区域名称
     * @memberOf GlobeModelLayer#
     */
    removeFlatten: function removeFlatten(name) {
      var strName = new PIEString$1(name);
      Module._Globe_ModelLayer_RemoveFlatten(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 移除所有压平区域
     * @memberOf GlobeModelLayer#
     */
    removeAllFlattens: function removeAllFlattens() {
      Module._Globe_ModelLayer_RemoveAllFlattens(this.handle);
    },
    /**
     * 获取压平区域数量
     *
     * @memberOf GlobeModelLayer#
     * @returns {Number} 返回压平区域数量
     */
    getFlattenCount: function getFlattenCount() {
      return Module._Globe_ModelLayer_GetFlattenCount(this.handle);
    },
    /**
     * 添加渲染对象
     * @param {PIEProjector} projector -渲染对象
     * @memberOf GlobeModelLayer#
     */
    addProjector: function addProjector(projector) {
      Module._Globe_ModelLayer_AddProjector(this.handle, projector.getHandle());
    },
    /**
     * 获取渲染对象
     * @param {String} name -渲染对象名称
     * @memberOf GlobeModelLayer#
     * @returns {PIEProjector} 返回渲染对象
     */
    getProjector: function getProjector(name) {
      var strName = new PIEString$1(name);
      var handle = Module._Globe_ModelLayer_GetProjector(this.handle, strName.getHandle());
      strName.dispose();
      return new PIEProjector(handle);
    },
    /**
     * 移除渲染对象
     * @param {String} name -渲染对象名称
     * @memberOf GlobeModelLayer#
     */
    removeProjector: function removeProjector(name) {
      var strName = new PIEString$1(name);
      Module._Globe_ModelLayer_RemoveProjector(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 移除所有渲染对象
     * @memberOf GlobeModelLayer#
     */
    removeAllProjectors: function removeAllProjectors() {
      Module._Globe_ModelLayer_RemoveAllProjectors(this.handle);
    },
    /**
     * 获取渲染对象数量
     *
     * @memberOf GlobeModelLayer#
     * @returns {Number} 返回渲染对象数量
     */
    getProjectorCount: function getProjectorCount() {
      return Module._Globe_ModelLayer_GetProjectorCount(this.handle);
    },
    /**
     * 设置模型图层的饱和度
     * @param {Number} contrast -饱和度
     * @memberOf GlobeModelLayer#
     */
    setContrast: function setContrast(contrast) {
      Module._Globe_ModelLayer_SetContrast(this.handle, contrast);
    },
    /**
     * 获取模型图层的饱和度
     * @memberOf GlobeModelLayer#
     * @returns {Number} 返回饱和度
     */
    getContrast: function getContrast() {
      return Module._Globe_ModelLayer_GetContrast(this.handle);
    },
    /**
     * 设置模型图层的对比度
     * @param {Number} saturation -对比度
     * @memberOf GlobeModelLayer#
     */
    setSaturation: function setSaturation(saturation) {
      Module._Globe_ModelLayer_SetSaturation(this.handle, saturation);
    },
    /**
     * 获取模型图层的对比度
     * @memberOf GlobeModelLayer#
     * @returns {Number} 返回对比度
     */
    getSaturation: function getSaturation() {
      return Module._Globe_ModelLayer_GetSaturation(this.handle);
    },
    /**
     * 设置模型图层的亮度
     * @param {Number} brightness -亮度
     * @memberOf GlobeModelLayer#
     */
    setBrightness: function setBrightness(brightness) {
      Module._Globe_ModelLayer_SetBrightness(this.handle, brightness);
    },
    /**
     * 获取模型图层的亮度
     * @memberOf GlobeModelLayer#
     * @returns {Number} 返回亮度
     */
    getBrightness: function getBrightness() {
      return Module._Globe_ModelLayer_GetBrightness(this.handle);
    },
    /**
     * 判断模型图层是否自动投影转换
     * @memberOf GlobeModelLayer#
     * @returns {Boolean} 返回是否自动投影转换
     */
    IsAutoProjection: function IsAutoProjection() {
      Module._Globe_ModelLayer_IsAutoProjection(this.handle);
    },
    /**
     * 设置模型图层是否自动投影转换
     * @param {Boolean} autoProjection -是否自动投影转换
     * @memberOf GlobeModelLayer#
     */
    setAutoProjection: function setAutoProjection(autoProjection) {
      Module._Globe_ModelLayer_SetAutoProjection(this.handle, autoProjection);
    },
    /**
     * 设置模型图层高度
     * @param {Number} height -高度值
     * @memberOf GlobeModelLayer#
     */
    setHeight: function setHeight(height) {
      var offsetArray = [0, 0, height];
      var offsetArr = new PIEArray(offsetArray, PIEArrayType.Float64);
      Module._Globe_ModelLayer_SetOffset(this.handle, offsetArr.getHandle());
      offsetArr.dispose();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建倾斜摄影模型图层
   * @name GlobeOSGBModelLayer
   * @class GlobeOSGBModelLayer
   * 倾斜摄影模型图层
   *
   * @extends GlobeModelLayer
   * @example
   * let globeTiltModelLayer = new PIE.GlobeTiltModelLayer()
   */
  function PIEGlobeOSGBModelLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_TiltModelLayer_Create();
      autoRelease = true;
    }
    PIEGlobeModelLayer.call(this, handle, autoRelease);
  }
  PIEGlobeOSGBModelLayer.prototype = Object.assign(Object.create(PIEGlobeModelLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建谷歌数据图层对象
   * @name GlobeTileGEDataLayer
   * @class GlobeTileGEDataLayer
   * 谷歌数据图层
   *
   * @extends GlobeLayer
   * @example
   * let globeTileGEDataLayer = new PIE.GlobeTileGEDataLayer()
   */
  function PIEGlobeTileGEDataLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._GlobeTileGEDataLayer_Create();
      autoRelease = true;
    }
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeTileGEDataLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    /**
     * 设置谷歌数据图层数据源名称
     * @param {String} name -数据源名称
     * @memberOf GlobeTileGEDataLayer#
     *
     * @example
     * let globeTileGEDataLayer = new PIE.GlobeTileGEDataLayer();
     * globeTileGEDataLayer.setDataSourceName(name);
     */
    setDataSourceName: function setDataSourceName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeTileGEDataLayer_SetDataSourceName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取谷歌数据图层数据源名称
     *
     * @memberOf GlobeTileGEDataLayer#
     * @returns {String} 返回数据源名称
     *
     * @example
     * let globeTileGEDataLayer = new PIE.GlobeTileGEDataLayer();
     * var name = globeTileGEDataLayer.getDataSourceName();
     */
    getDataSourceName: function getDataSourceName() {
      var strName = new PIEString$1(256);
      Module._GlobeTileGEDataLayer_GetDataSourceName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置谷歌数据图层数据集名称
     * @param {String} name -数据集名称
     * @memberOf GlobeTileGEDataLayer#
     *
     * @example
     * let globeTileGEDataLayer = new PIE.GlobeTileGEDataLayer();
     * globeTileGEDataLayer.setDatasetName(name);
     */
    setDatasetName: function setDatasetName(name) {
      var strName = new PIEString$1(name);
      Module._GlobeTileGEDataLayer_SetDatasetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取谷歌数据图层数据集名称
     *
     * @memberOf GlobeTileGEDataLayer#
     * @returns {String} 数据集名称
     *
     * @example
     * let globeTileGEDataLayer = new PIE.GlobeTileGEDataLayer();
     * var name = globeTileGEDataLayer.getDatasetName();
     */
    getDatasetName: function getDatasetName() {
      var strName = new PIEString$1(256);
      Module._GlobeTileGEDataLayer_GetDatasetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置数据源
     * @param {PIEDataSources} datasource -数据源
     * @memberOf GlobeTileGEDataLayer#
     *
     * @example
     * let globeTileGEDataLayer = new PIE.GlobeTileGEDataLayer();
     * globeTileGEDataLayer.setDataSource(datasource);
     */
    setDataSource: function setDataSource(datasource) {
      Module._GlobeTileGEDataLayer_SetDataset(this.handle, datasource.getDataset().getHandle());
    },
    setDataset: function setDataset(dataset) {
      Module._GlobeTileGEDataLayer_SetDataset(this.handle, dataset.getHandle());
    },
    getDataset: function getDataset() {
      var hDataset = Module._GlobeTileGEDataLayer_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(hDataset);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 创建海图图层
   * @name GlobeSeamapLayer
   * @class GlobeSeamapLayer
   * 海图图层基本操作函数
   * @extends GlobeFeatureMapLayer
   *
   */

  function PIEGlobeSeamapLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_SeamapLayer_Create();
      autoRelease = true;
    }
    PIEGlobeCompositeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeSeamapLayer.prototype = Object.assign(Object.create(PIEGlobeCompositeLayer.prototype), {
    /**
     * 打开图层
     * @param {PIEDataSource} dataSource -海图数据源
     * @memberOf GlobeSeamapLayer#
     * @returns {Boolean} 返回是否成功
     */
    setDataSource: function setDataSource(dataSource) {
      return Module._Globe_SeamapLayer_Open(this.handle, dataSource.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建瓦片地图图层对象
   * @name GlobeTileMapLayer
   * @class GlobeTileMapLayer
   * 三维瓦片地图图层操作函数
   *
   * @extends GlobeCompositeLayer
   */
  function PIEGlobeTileMapLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_TileMapLayer_Create();
      autoRelease = true;
    }
    PIEGlobeCompositeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeTileMapLayer.prototype = Object.assign(Object.create(PIEGlobeCompositeLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 标绘图层
   * @name GlobeRenderPlotLayer
   *
   * @extends GlobeRenderableLayer
   */
  function PIEGlobeRenderPlotLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._GlobeRenderPlotLayer_Create();
      autoRelease = true;
    }
    PIEGlobeRenderableLayer.call(this, handle, autoRelease);
  }
  PIEGlobeRenderPlotLayer.prototype = Object.assign(Object.create(PIEGlobeRenderableLayer.prototype), {
    /**
     * 添加军标数据集
     * @param {PIEDataset} plotdataset -数据集
     * @memberOf GlobeRenderPlotLayer#
     *
     */
    setPlotDataset: function setPlotDataset(plotdataset) {
      return Module._Globe_RenderPlotLayer_SetPlotDataset(this.handle, plotdataset.getHandle());
    },
    /**
     * 获取军标数据集
     * @return {PIEDataset}  -数据集
     * @memberOf GlobeRenderPlotLayer#
     */
    getPlotDataset: function getPlotDataset() {
      var hDataset = Module._Globe_RenderPlotLayer_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(hDataset);
    },
    /**
     * 重新开始动画
     *  * @return {Boolean}  -成功或失败
     * @memberOf GlobeRenderPlotLayer#
     */
    reBeginAction: function reBeginAction() {
      return Boolean(Module._Globe_RenderPlotLayer_ReBeginAction(this.handle));
    },
    /**
     * 停止动画
     *  * @return {Boolean}  -成功或失败
     * @memberOf GlobeRenderPlotLayer#
     */
    stopAction: function stopAction() {
      return Boolean(Module._Globe_RenderPlotLayer_StopAction(this.handle));
    },
    /**
     * 暂停/开始动画
     *  * @param {Boolean}  -暂停/开始
     * @memberOf GlobeRenderPlotLayer#
     */
    pauseAction: function pauseAction(IsPause) {
      Module._Globe_RenderPlotLayer_PauseAction(this.handle, IsPause);
    },
    /**
     * 获取动画速度
     *  * @return {Number}  -动画速度
     * @memberOf GlobeRenderPlotLayer#
     */
    getActionSpeed: function getActionSpeed() {
      return Module._Globe_RenderPlotLayer_GetActionSpeed(this.handle);
    },
    /**
     * 设置动画速度
     *  @param {Number}  -动画速度
     * @memberOf GlobeRenderPlotLayer#
     */
    setActionSpeed: function setActionSpeed(speed) {
      Module._Globe_RenderPlotLayer_SetActionSpeed(this.handle, speed);
    },
    /**
     * 获取当前时间
     * @return {Number}  -当前时间
     * @memberOf GlobeRenderPlotLayer#
     */
    getCurTime: function getCurTime() {
      return Module._Globe_RenderPlotLayer_GetCurTime(this.handle);
    },
    /**
     * 跳转到指定时间
     * @param {Number}  time -指定时间
     * @memberOf GlobeRenderPlotLayer#
     */
    seek: function seek(time) {
      Module._Globe_RenderPlotLayer_Seek(this.handle, time);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建动态对象
   * @name DynamicFeature
   * @class DynamicFeature
   * 动态对象操作函数
   *
   * @param {Object} options -
   * @param {Number} options.id -动态对象ID
   * @param {(Array/PIEVector2)} options.position -对象定位点
   * @param {PIEGeometry} options.geometry -几何对象
   * @param {Number} options.blinkType -闪烁类型
   * @param {Number} options.plotType -军标类型
   * @example
   * var point = patialReference.forward([x, y]);
   var geoTexture = new PIE.GeoTexture({
                          texture: 11800,
                          point: point,
                          size: [32, 32],
                          color: [255, 0, 0, 255],
                          angle: 60
                      });

   var featurePos = [point[0], point[1], 0];
   var dynamicFeature = new PIE.DynamicFeature({
                          id: i,
                          position: featurePos,
                          geometry: geoTexture,
                          blinkType: 0,
                          plotType: 0
                      });
   *
   */

  function PIEDynamicFeature(options) {
    var handle = null;
    var autoRelease = false;
    if (options) {
      var id = options.id;
      var position = options.position;
      var geometry = options.geometry;
      var blinkType = options.blinkType;
      var plotType = options.plotType;
      if (id != null && position && geometry && blinkType != null && plotType != null) {
        var arrayPos = null;
        if (position instanceof Array) {
          arrayPos = new PIEArray(position, PIEArrayType.Float64);
        } else if (position instanceof PIEVector2) {
          arrayPos = new PIEArray([position.x, position.y], PIEArrayType.Float64);
        }
        if (arrayPos) {
          handle = Module._DynamicFeature_Make(id, arrayPos.getHandle(), geometry.getHandle(), blinkType, plotType);
          arrayPos.dispose();
          autoRelease = true;
        }
      }
    }
    if (options.handle) {
      handle = options.handle;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEDynamicFeature.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 删除动态对象
     * @memberOf DynamicFeature#
     */
    dispose: function dispose() {
      if (this.autoRelease) ;
      this.handle = null;
    },
    /**
     * 获取动态对象的ID
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 返回动态对象的ID
     *
     */
    getID: function getID() {
      return Module._DynamicFeature_GetID(this.handle);
    },
    /**
     * 设置动态对象的ID
     * @param {Number} id -输入的ID
     * @memberOf DynamicFeature#
     *
     */
    setID: function setID(id) {
      Module._DynamicFeature_SetID(this.handle, id);
    },
    /**
     * 获取动态对象的定位点
     *
     * @memberOf DynamicFeature#
     * @returns {PIEVector3} 返回对象定位点
     *
     */
    getPosition: function getPosition() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._DynamicFeature_GetPosition(this.handle, arrayPos.getHandle());
      arrayPos.updateData();
      var position = arrayPos.toArray();
      arrayPos.dispose();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     * 设置动态对象的定位点
     * @param {(Array/PIEVector3)} position -定位点
     * @memberOf DynamicFeature#
     *
     */
    setPosition: function setPosition(position) {
      var arrayPos = null;
      if (position instanceof Array) {
        arrayPos = new PIEArray(position, PIEArrayType.Float64);
      } else if (position instanceof PIEVector3) {
        arrayPos = new PIEArray(position.toArray(), PIEArrayType.Float64);
      }
      if (arrayPos) {
        Module._DynamicFeature_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取动态对象的纹理ID
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 返回对象纹理ID
     *
     */
    getTexture: function getTexture() {
      return Module._DynamicFeature_GetTexture(this.handle);
    },
    /**
     * 设置动态对象的纹理ID
     * @param {Number} textureId -纹理ID
     * @memberOf DynamicFeature#
     *
     */
    setTexture: function setTexture(textureId) {
      Module._DynamicFeature_SetTexture(this.handle, textureId);
    },
    /**
     *获取动态对象的旋转角度
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 返回动态对象的旋转角度
     *
     */
    getRotation: function getRotation() {
      return Module._DynamicFeature_GetRotation(this.handle);
    },
    /**
     * 设置动态对象的旋转角度
     * @param {Number} rotation -旋转角度
     * @memberOf DynamicFeature#
     *
     */
    setRotation: function setRotation(rotation) {
      Module._DynamicFeature_SetRotation(this.handle, rotation);
    },
    /**
     * 设置动态对象是否可见
     * @param {Boolean} visible -是否可见
     * @memberOf DynamicFeature#
     *
     */
    setVisible: function setVisible(visible) {
      Module._DynamicFeature_SetVisible(this.handle, visible);
    },
    /**
     * 获取动态对象是否可见
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否可见(true-可见，false-不可见)
     *
     */
    isVisible: function isVisible() {
      return Module._DynamicFeature_IsVisible(this.handle);
    },
    /**
     * 设置动态对象是否可选
     * @param {Boolean} selectable -是否可选
     * @memberOf DynamicFeature#
     *
     */
    setSelectable: function setSelectable(selectable) {
      Module._DynamicFeature_SetSelectable(this.handle, selectable);
    },
    /**
     * 设置动态对象是否闪烁
     * @param {Boolean} visible -是否闪烁
     * @memberOf DynamicFeature#
     *
     */
    setVisibleBlink: function setVisibleBlink(visible) {
      Module._DynamicFeature_SetVisibleBlink(this.handle, visible);
    },
    /**
     * 获取动态对象是否可选
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} -返回是否可选(true-可选，false-不可选)
     *
     */
    isSelectable: function isSelectable() {
      return Module._DynamicFeature_IsSelectable(this.handle);
    },
    /**
     * 设置动态对象是否颜色闪烁
     * @param {Boolean} colorBlink -是否颜色闪烁
     * @memberOf DynamicFeature#
     *
     */
    setColorBlink: function setColorBlink(colorBlink) {
      Module._DynamicFeature_SetColorBlink(this.handle, colorBlink);
    },
    /**
     * 获取动态对象是否颜色闪烁
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} -返回是否颜色闪烁(true-闪烁，false-不闪烁)
     *
     */
    isColorBlink: function isColorBlink() {
      return Module._DynamicFeature_IsColorBlink(this.handle);
    },
    /**
     *设置动态对象是否执行动画
     * @param {Boolean} animation -是否执行动画
     * @memberOf DynamicFeature#
     *
     */
    setAnimation: function setAnimation(animation) {
      Module._DynamicFeature_SetAnimation(this.handle, animation);
    },
    /**
     *获取动态对象是否执行动画
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否执行动画(true-执行，false-不执行)
     *
     */
    isAnimation: function isAnimation() {
      return Module._DynamicFeature_IsAnimation(this.handle);
    },
    /**
     *设置闪烁图标
     * @param {Number} iconIds -图标ID
     * @memberOf DynamicFeature#
     *
     */
    setBlinkIcons: function setBlinkIcons(iconIds) {
      var arrayId = new PIEArray(iconIds, PIEArrayType.Int32);
      Module._DynamicFeature_SetBlinkIcons(this.handle, arrayId.getHandle(), iconIds.length);
    },
    /**
     *设置动态对象是否显示轨迹
     * @param {Boolean} visible -是否显示轨迹
     * @memberOf DynamicFeature#
     *
     */
    setLocusVisible: function setLocusVisible(visible) {
      Module._DynamicFeature_SetLocusVisible(this.handle, visible);
    },
    /**
     *获取动态对象是否显示轨迹
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否显示轨迹(true-显示，false-不显示)
     *
     */
    isLocusVisible: function isLocusVisible() {
      return Module._DynamicFeature_IsLocusVisible(this.handle);
    },
    /**
     *设置是否渲染尾迹
     *
     * @param {Boolean} bWake -是否渲染尾迹
     * @memberOf DynamicFeature#
     *
     */
    setWakeVisible: function setWakeVisible(bWake) {
      Module._DynamicFeature_SetWakeVisible(this.handle, bWake);
    },
    /**
     *获取是否渲染尾迹
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否渲染尾迹(true-渲染，false-不渲染)
     *
     */
    isWakeVisible: function isWakeVisible() {
      return Module._DynamicFeature_IsWakeVisible(this.handle);
    },
    /**
     *设置尾迹线起始点
     * @param {Number} nWakeStartPixel -距离图标起始点像素坐标位置
     * @memberOf DynamicFeature#
     *
     */
    setWakeStartPixel: function setWakeStartPixel(nWakeStartPixel) {
      Module._DynamicFeature_SetWakeStartPixel(this.handle);
    },
    /**
     *获取尾迹线起始点
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 距离图标起始点像素坐标位置
     *
     */
    getWakeStartPixel: function getWakeStartPixel() {
      return Module._DynamicFeature_GetWakeStartPixel(this.handle);
    },
    /**
     *设置尾迹线终止点
     * @param {Number} nWakeEndPixel -距离图标终止点像素坐标位置
     * @memberOf DynamicFeature#
     *
     */
    setWakeEndPixel: function setWakeEndPixel(nWakeEndPixel) {
      Module._DynamicFeature_SetWakeEndPixel(this.handle, nWakeEndPixel);
    },
    /**
     *获取尾迹线终止点
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 距离图标终止点像素坐标位置
     *
     */
    getWakeEndPixel: function getWakeEndPixel() {
      return Module._DynamicFeature_GetWakeEndPixel(this.handle);
    },
    /**
     *设置尾迹线宽
     * @param {Number} nWakeWidth -尾迹线宽
     * @memberOf DynamicFeature#
     *
     */
    setWakeLineWidth: function setWakeLineWidth(nWakeWidth) {
      Module._DynamicFeature_SetWakeLineWidth(this.handle, nWakeWidth);
    },
    /**
     *获取尾迹线终止点
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 返回尾迹线宽
     *
     */
    getWakeLineWidth: function getWakeLineWidth() {
      return Module._DynamicFeature_GetWakeLineWidth(this.handle);
    },
    /**
     *设置尾迹线色
     * @param {(PIEColor/Array)} color -尾迹线色
     * @memberOf DynamicFeature#
     *
     */
    setWakeLineColor: function setWakeLineColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._DynamicFeature_SetWakeLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     *获取尾迹线色
     *
     * @memberOf DynamicFeature#
     * @returns {PIEColor} 尾迹线色
     *
     */
    getWakeLineColor: function getWakeLineColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._DynamicFeature_GetWakeLineColor(this.handle, colorArray);
      colorArray.updateData();
      var array = colorArray.toArray();
      var Color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return Color;
    },
    /**
     *设置是否启用点画轨迹
     * @param {Boolean} bPoint -是否启用
     * @memberOf DynamicFeature#
     *
     */
    setLocusPointsMode: function setLocusPointsMode(bPoint) {
      Module._DynamicFeature_SetLocusPointsMode(this.handle, bPoint);
    },
    /**
     *获取是否启用点画轨迹
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否启用点画轨迹(true-启用点画轨迹，false-不启用点画轨迹)
     *
     */
    isLocusPointsMode: function isLocusPointsMode() {
      return Module._DynamicFeature_IsLocusPointsMode(this.handle);
    },
    /**
     *设置是否启用虚线模式
     * @param {Boolean} bStipple -是否启用
     * @memberOf DynamicFeature#
     *
     */
    setLocusStippleMode: function setLocusStippleMode(bStipple) {
      Module._DynamicFeature_SetLocusStippleMode(this.handle, bStipple);
    },
    /**
     *获取是否启用虚线模式
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否启用虚线模式(true-启用，false-不启用)
     *
     */
    isLocusStippleMode: function isLocusStippleMode() {
      return Module._DynamicFeature_IsLocusStippleMode(this.handle);
    },
    /**
     *设置点的大小或线的宽度
     * @param {Number} nWidth -点的大小或线的宽度
     * @memberOf DynamicFeature#
     *
     */
    setLineWidth: function setLineWidth(nWidth) {
      Module._DynamicFeature_SetLineWidth(this.handle, nWidth);
    },
    /**
     *获取点的大小或线的宽度
     *
     * @memberOf DynamicFeature#
     *@returns {Number} 返回点的大小或线的宽度
     *
     */
    getLineWidth: function getLineWidth() {
      return Module._DynamicFeature_GetLineWidth(this.handle);
    },
    /**
     *设置虚线点画模式
     *@param {Number} pattern 轨迹点画模式
     * @memberOf DynamicFeature#
     *
     */
    setLinePattern: function setLinePattern(pattern) {
      Module._DynamicFeature_SetLinePattern(this.handle, pattern);
    },
    /**
     *设置虚线点画模式
     *@param {Number} nFactor -轨迹点画模式重复系数
     *@param {Number} pattern -轨迹点画模式
     * @memberOf DynamicFeature#
     *
     */
    setLinePatternWithFactor: function setLinePatternWithFactor(nFactor, pattern) {
      Module._DynamicFeature_SetLinePatternWithFactor(this.handle, nFactor, pattern);
    },
    /**
     *设置点或线的颜色
     *@param {(PIEColor/Array)} Color -颜色值
     * @memberOf DynamicFeature#
     *
     */
    setLocusLineColor: function setLocusLineColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._DynamicFeature_SetLocusLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     *删除动态对象
     *
     * @memberOf DynamicFeature#
     */
    "delete": function _delete() {
      Module._DynamicFeature_Delete(this.handle);
    },
    /**
     *向集合中添加角度不变对象
     *@param {Number} code -添加对象
     * @memberOf DynamicFeature#
     *
     */
    addKeepAngleSet: function addKeepAngleSet(code) {
      Module._DynamicFeature_AddKeepAngleSet(code);
    },
    /**
     *设置是否显示广告牌
     *@param {Boolean} billBoard -是否显示广告牌
     * @memberOf DynamicFeature#
     *
     */
    setEnableBillboard: function setEnableBillboard(billBoard) {
      Module._DynamicFeature_SetEnableBillboard(this.handle, billBoard);
    },
    /**
     *获取是否显示广告牌
     *
     * @memberOf DynamicFeature#
     *@returns {Boolean} 返回是否显示广告牌(true-显示广告牌，false-不显示广告牌)
     *
     */
    isEnableBillboard: function isEnableBillboard() {
      return Module._DynamicFeature_SetEnableBillboard(this.handle);
    },
    /**
     * 设置广告牌边框颜色
     * @param {(PIEColor/Array)} color -颜色值
     * @memberOf DynamicFeature#
     *
     */
    setBillboardLineColor: function setBillboardLineColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._DynamicFeature_SetBillboardLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     *获取广告牌边框颜色
     *
     * @memberOf DynamicFeature#
     *@returns {PIEColor} 返回广告牌边框颜色
     *
     */
    getBillboardLineColor: function getBillboardLineColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._DynamicFeature_GetBillboardLineColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return color;
    },
    /**
     *设置广告牌填充颜色
     *@param {(PIEColor/Array)} color -颜色值
     * @memberOf DynamicFeature#
     *
     */
    setBillboardFillColor: function setBillboardFillColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._DynamicFeature_SetBillboardFillColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     *获取广告牌填充颜色
     *
     * @memberOf DynamicFeature#
     * @returns {PIEColor} 返回广告牌填充颜色
     *
     */
    getBillboardFillColor: function getBillboardFillColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._DynamicFeature_GetBillboardFillColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return color;
    },
    /**
     *设置广告牌文本颜色
     * @param {(PIEColor/Array)} color -颜色值
     * @memberOf DynamicFeature#
     *
     */
    setBillboardTextColor: function setBillboardTextColor(color) {
      var arrayColor = null;
      if (color instanceof Array) {
        arrayColor = new PIEArray(color, PIEArrayType.UInt8);
      } else if (color instanceof PIEColor) {
        arrayColor = new PIEArray(color.toArray(), PIEArrayType.UInt8);
      }
      if (arrayColor) {
        Module._DynamicFeature_SetBillboardTextColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    /**
     *获取广告牌文本颜色
     *
     * @memberOf DynamicFeature#
     * @returns {PIEColor} 返回广告牌文本颜色
     *
     */
    getBillboardTextColor: function getBillboardTextColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._DynamicFeature_GetBillboardTextColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return color;
    },
    /**
     *设置广告牌内容
     *@param {Number} nAlign -点的对齐方式
     *@param {String} pText -广告牌的内容
     * @memberOf DynamicFeature#
     */
    setBillboardText: function setBillboardText(nAlign, pText) {
      Module._DynamicFeature_SetBillboardText(this.handle, nAlign, pText);
    },
    /**
     *获取广告牌内容
     *
     * @memberOf DynamicFeature#
     *@returns {String} 返回广告牌的内容
     */
    getBillboardText: function getBillboardText() {
      var strText = new PIEString$1(256);
      Module._DynamicFeature_GetBillboardText(this.handle, strText.getHandle());
      var text = strText.toString();
      strText.dispose();
      return text;
    },
    /**
     *添加标牌文字
     *
     * @param {PIEPointAlignType} alignType -指定的标牌对齐方式
     * @param {String} text -指定的标牌内容
     * @memberOf DynamicFeature#
     *
     * @returns {Boolean} 是否添加成功
     */
    addBillboardText: function addBillboardText(alignType, text) {
      var strText = new PIEString$1(text);
      return Module._DynamicFeature_AddBillboardText(this.handle, alignType, strText.getHandle());
    },
    /**
     *获取标牌文字
     *
     * @param {Number} nAlignType -指定的标牌对齐方式
     * @memberOf DynamicFeature#
     *
     * @returns {String} 返回指定的标牌文字
     */
    getBillboardTextEx: function getBillboardTextEx(nAlignType) {
      var strText = new PIEString$1(256);
      Module._DynamicFeature_GetBillboardTextEx(this.handle, nAlignType, strText);
      var text = strText.toString();
      strText.dispose();
      return text;
    },
    /**
     *改变标牌文字
     * @param {Number} nAlignType -指定的标牌对齐方式
     * @param {String} pText -指定的标牌内容
     * @memberOf DynamicFeature#
     *
     * @returns {Boolean} 是否设置成功
     */
    changeBillboardText: function changeBillboardText(nAlignType, pText) {
      return Module._DynamicFeature_ChangeBillboardText(this.handle, nAlignType, pText);
    },
    /**
     *移除标牌文字
     * @param {Number} nAlignType -指定的标牌对齐方式
     * @memberOf DynamicFeature#
     *
     * @returns {Boolean} 是否移除成功
     */
    removeBillboardText: function removeBillboardText(nAlignType) {
      return Module._DynamicFeature_RemoveBillboardText(this.handle, nAlignType);
    },
    /**
     *设置标牌聚合后的文字
     * @param {Number} nAlignType -指定的标牌对齐方式
     * @param {String} pText -指定的标牌牌聚合后的文字
     * @memberOf DynamicFeature#
     *
     * @returns {Boolean} 是否添加成功
     */
    setBillboardPolyText: function setBillboardPolyText(nAlignType, pText) {
      return Module._DynamicFeature_SetBillboardPolyText(this.handle, nAlignType, pText);
    },
    /**
     *获取标牌文字
     * @param {Number} nAlignType -指定的标牌对齐方式
     * @memberOf DynamicFeature#
     *
     * @returns {String} 指定的标牌文字
     */
    getBillboardPolyText: function getBillboardPolyText(nAlignType) {
      var strText = new PIEString$1(256);
      Module._DynamicFeature_GetBillboardPolyText(this.handle, nAlignType, strText);
      var text = strText.toString();
      strText.dispose();
      return text;
    },
    /**
     *设置聚合后的纹理
     * @param {Number} pText -聚合后的纹理
     * @memberOf DynamicFeature#
     *
     * @returns {Boolean} 是否设置成功
     */
    setBillboardPolyTexture: function setBillboardPolyTexture(pText) {
      return Module._DynamicFeature_SetBillboardPolyTexture(this.handle, pText);
    },
    /**
     *获取聚合后的纹理
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 聚合后的纹理
     */
    getBillboardPolyTexture: function getBillboardPolyTexture() {
      return Module._DynamicFeature_GetBillboardPolyTexture(this.handle);
    },
    /**
     *显示隐藏标牌文字
     * @param {Number} nAlign -指定的标牌对齐方式
     * @param {Boolean} bShow -是否显示
     * @memberOf DynamicFeature#
     *
     * @returns {Boolean} 是否成功显示
     */
    showBillboardText: function showBillboardText(nAlign, bShow) {
      return Module._DynamicFeature_ShowBillboardText(this.handle, nAlign, bShow);
    },
    /**
     *标牌文字是否显示
     * @param {Number} nAlign -指定的标牌对齐方式
     * @memberOf DynamicFeature#
     *
     *@returns {Boolean} 是否显示标牌文字
     */
    isBillboardTextShown: function isBillboardTextShown(nAlign) {
      return Module._DynamicFeature_IsBillboardTextShown(this.handle, nAlign);
    },
    /**
     *从集合中移除角度不变对象
     *
     * @param {Number} code -移除对象
     * @memberOf DynamicFeature#
     */
    removeCode: function removeCode(code) {
      Module._DynamicFeature_RemoveCode(code);
    },
    /**
     *设置布告板的显示模式
     * @param {PIEBillBoardModeType} modeType -布告板的显示模式(只能设置PIE.BillBoardModeType.ScreenAlignMode或者PIE.BillBoardModeType.AngleFixedMode)
     * @memberOf DynamicFeature#
     */
    setBillboardMode: function setBillboardMode(modeType) {
      Module._DynamicFeature_SetBillboardMode(this.handle, modeType);
    },
    /**
     * 获取布告板的显示模式
     * @memberOf DynamicFeature#
     * @returns {PIEBillBoardModeType} 返回布告板的显示模式
     */
    getBillboardMode: function getBillboardMode() {
      return Module._DynamicFeature_GetBillboardMode(this.handle);
    },
    /**
     *设置标牌文字的大小
     * @param {(Array/PIESize)} size -文字大小
     * @memberOf DynamicFeature#
     */
    setBillboardTextSize: function setBillboardTextSize(size) {
      var TextSize = null;
      if (size instanceof Array) {
        TextSize = new PIEArray(size, PIEArrayType.Float64);
      } else if (size instanceof PIESize) {
        TextSize = new PIEArray(size.toArray(), PIEArrayType.Float64);
      }
      if (TextSize) {
        Module._DynamicFeature_SetBillBoardTextSize(this.handle, TextSize.getHandle());
        TextSize.dispose();
      }
    },
    /**
     *设置渲染是否聚合
     * @param {Boolean} bRenderPolymerization -是否聚合
     * @memberOf DynamicFeature#
     */
    setRenderPolymerization: function setRenderPolymerization(bRenderPolymerization) {
      Module._DynamicFeature_SetRenderPolymerization(this.handle, bRenderPolymerization);
    },
    /**
     *判断是否渲染聚合
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否聚合
     */
    isIsRenderPolymerization: function isIsRenderPolymerization() {
      return Module._DynamicFeature_IsIsRenderPolymerization(this.handle);
    },
    /**
     * 设置动态对象是否闪烁颜色
     * @param {Boolean} colorBlink -是否闪烁
     * @memberOf DynamicFeature#
     */
    setBlinkColor: function setBlinkColor(colorBlink) {
      Module._DynamicFeature_SetBlinkColor(this.handle, colorBlink);
    },
    /**
     * 获取动态对象是否闪烁颜色
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回动态对象是否闪烁颜色
     */
    isBlinkColor: function isBlinkColor() {
      return Module._DynamicFeature_IsBlinkColor(this.handle);
    },
    /**
     * 获取选中对象个数
     *
     * @memberOf DynamicFeature#
     * @return {Number} 返回选中对象个数
     */
    getPolymerizationCount: function getPolymerizationCount() {
      return Module._DynamicFeature_GetPolymerizationCount(this.handle);
    },
    /**
     * 获取选中聚合对象中所有的对象
     * @param {Array} polymerizedObjects -聚合对象中所有的对象
     *
     * @memberOf DynamicFeature#
     * @return {Boolean} 是否返回选中聚合对象中所有的对象
     */
    getPolymerizedObjects: function getPolymerizedObjects(polymerizedObjects) {
      var arrayObjects = new PIEArray(polymerizedObjects, PIEArrayType.Int32);
      var result = Module._DynamicFeature_GetPolymerizedObjects(this.handle, arrayObjects.getHandle(), polymerizedObjects.length);
      arrayObjects.dispose();
      return Boolean(result);
    },
    addCutomPlotCode: function addCutomPlotCode(desPlotCode, srcPlotCode) {
      Module._Globe_CP_AddCutomPlotCode(desPlotCode, srcPlotCode);
    },
    removeCustomPlotCode: function removeCustomPlotCode(desPlotCode, srcPlotCode) {
      Module._Globe_CP_RemoveCustomPlotCode(desPlotCode, srcPlotCode);
    },
    removeCustomPlots: function removeCustomPlots(desPlotCode) {
      Module._Globe_CP_RemoveCustomPlots(desPlotCode);
    },
    removeAllCustomPlotCodes: function removeAllCustomPlotCodes() {
      Module._Globe_CP_RemoveAllCustomPlotCodes();
    },
    addDefaultPlotCode: function addDefaultPlotCode(plotType, plotCode) {
      Module._Globe_CP_AddDefaultPlotCode(plotType, plotCode);
    },
    removeDefaultPlotCode: function removeDefaultPlotCode(plotType) {
      Module._Globe_CP_RemoveDefaultPlotCode(plotType);
    },
    removeAllDefaultPlotCode: function removeAllDefaultPlotCode() {
      Module._Globe_CP_RemoveAllDefaultPlotCode();
    },
    findPolymerizationCode: function findPolymerizationCode(plotCode) {
      Module._Globe_CP_FindPolymerizationCode(plotCode);
    },
    findDefaultPolymerizationCode: function findDefaultPolymerizationCode(plotType) {
      Module._Globe_CP_FindDefaultPolymerizationCode(plotType);
    },
    /**
     * 获取风格颜色
     *
     * @memberOf DynamicFeature#
     * @returns {PIEColor} 返回风格颜色
     */
    getStyleColor: function getStyleColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._DynamicFeature_GetStyleColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      colorArray.dispose();
      return new PIEColor(array[0], array[1], array[2], array[3]);
    },
    /**
     * 设置风格颜色
     * @param {(PIEColor/Array)} color -风格颜色
     * @memberOf DynamicFeature#
     */
    setStyleColor: function setStyleColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._DynamicFeature_SetStyleColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取风格高度
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 返回风格高度
     */
    getStyleHeight: function getStyleHeight() {
      return Module._DynamicFeature_GetStyleHeight(this.handle);
    },
    /**
     * 设置风格高度
     * @param {Number} height -风格高度
     *
     * @memberOf DynamicFeature#
     * @returns {Boolean} 返回是否设置成功
     */
    setStyleHeight: function setStyleHeight(height) {
      return Module._DynamicFeature_SetStyleHeight(this.handle, height);
    },
    /**
     * 获取风格宽度
     *
     * @memberOf DynamicFeature#
     * @returns {Number} 返回风格宽度
     */
    getStyleWidth: function getStyleWidth() {
      return Module._DynamicFeature_GetStyleWidth(this.handle);
    },
    /**
     * 设置风格宽度
     * @param {Number} width -风格宽度
     * @memberOf DynamicFeature#
     *
     * @returns {Boolean} 返回是否设置成功
     */
    setStyleWidth: function setStyleWidth(width) {
      return Module._DynamicFeature_SetStyleWidth(this.handle, width);
    },
    /**
     * 获取轨迹数组
     * @memberOf DynamicFeature#
     *
     * @returns {Array} 返回轨迹数组
     */
    getLocusPoints: function getLocusPoints() {
      var PointsArray = null;
      var count = Module._DynamicFeature_GetLocusPointsCount(this.handle);
      PointsArray = new PIEArray(count, PIEArrayType.Float64);
      Module._DynamicFeature_GetLocusPoints(this.handle, PointsArray.getHandle(), count);
      PointsArray.updateData();
      var LocusPoints = PointsArray.toArray();
      PointsArray.dispose();
      return LocusPoints;
    },
    /**
     * 设置轨迹数组
     * @param {Array} pLocusPoints -轨迹数组点
     * @param {Number} count -点个数
     * @memberOf DynamicFeature#
     *
     */
    setLocusPoints: function setLocusPoints(pLocusPoints, count) {
      var PointsArray = null;
      if (pLocusPoints instanceof Array) {
        PointsArray = new PIEArray(pLocusPoints, PIEArrayType.Float64);
      }
      if (PointsArray) {
        Module._DynamicFeature_SetLocusPoints(this.handle, PointsArray.getHandle(), count);
        PointsArray.dispose();
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建动态层图层
   * @name GlobeDynamicLayer
   * @class GlobeDynamicLayer
   * 动态层图层操作函数
   * @extends GlobeLayer
   *
   * @example
   * let globeDynamicLayer = new PIE.GlobeDynamicLayer()
   */
  function PIEGlobeDynamicLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_DynamicLayer_Create();
      autoRelease = true;
    }
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeDynamicLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    /**
     * 获取动态层个数
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {Number} 返回动态层个数
     *
     */
    getCount: function getCount() {
      return Module._Globe_DynamicLayer_GetCount(this.handle);
    },
    /**
     * 向图层中添加几何对象
     * @param {PIEDynamicFeature} dynamicFeature - 几何对象
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {Boolean} 是否添加成功
     *
     */
    add: function add(dynamicFeature) {
      return Module._Globe_DynamicLayer_Add(this.handle, dynamicFeature.getHandle());
    },
    /**
     * 获取指定索引的对象
     * @param {Number} iD -几何对象索引
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {PIEDynamicFeature} 返回动态层图层对象
     *
     */
    get: function get(iD) {
      var handle = Module._Globe_DynamicLayer_Get(this.handle, iD);
      if (handle) {
        return new PIEDynamicFeature({
          handle: handle
        });
      }
    },
    /**
     * 移除指定索引的对象
     * @param {Number} iD -几何对象索引
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {Boolean} 返回是否移除成功
     *
     */
    remove: function remove(iD) {
      return Module._Globe_DynamicLayer_Remove(this.handle, iD);
    },
    /**
     * 移除所有索引的对象
     * @memberOf GlobeDynamicLayer#
     */
    removeAll: function removeAll() {
      Module._Globe_DynamicLayer_RemoveAll(this.handle);
    },
    /**
     * 设置是否聚合显示
     * @param {Boolean} polymerization 是否聚合显示
     * @memberOf GlobeDynamicLayer#
     */
    setPolymerization: function setPolymerization(polymerization) {
      Module._Globe_DynamicLayer_SetPolymerization(this.handle, polymerization);
    },
    /**
     * 获取是否聚合显示
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {Boolean} 返回是否聚合显示
     *
     */
    getPolymerization: function getPolymerization() {
      return Module._Globe_DynamicLayer_GetPolymerization(this.handle);
    },
    /**
     * 设置广告牌边框颜色
     * @param {(PIEColor/Array)} color -颜色值
     * @memberOf GlobeDynamicLayer#
     */
    setBillboardLineColor: function setBillboardLineColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._Globe_DynamicLayer_SetBillboardLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取广告牌边框颜色
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {PIEColor} 返回广告牌边框颜色
     *
     */
    getBillboardLineColor: function getBillboardLineColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._Globe_DynamicLayer_GetBillboardLineColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return color;
    },
    /**
     * 设置广告牌填充颜色
     * @param {(PIEColor/Array)} color -颜色值
     * @memberOf GlobeDynamicLayer#
     *
     */
    setBillboardFillColor: function setBillboardFillColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._Globe_DynamicLayer_SetBillboardFillColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取广告牌填充颜色
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {PIEColor} 广告牌填充颜色
     *
     */
    getBillboardFillColor: function getBillboardFillColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._Globe_DynamicLayer_GetBillboardFillColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return color;
    },
    /**
     * 设置广告牌文本颜色
     * @param {(PIEColor/Array)} color -广告牌填充颜色
     * @memberOf GlobeDynamicLayer#
     *
     */
    setBillboardTextColor: function setBillboardTextColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      if (colorArray) {
        Module._Globe_DynamicLayer_SetBillboardTextColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 获取广告牌文本颜色
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {PIEColor} 广告牌文本颜色
     *
     */
    getBillboardTextColor: function getBillboardTextColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._Globe_DynamicLayer_GetBillboardTextColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return color;
    },
    /**
     * 设置聚合容限
     * @param {Number} value -聚合容限
     * @memberOf GlobeDynamicLayer#
     *
     */
    setDistanceThreshold: function setDistanceThreshold(value) {
      Module._Globe_DynamicLayer_SetDistanceThreshold(this.handle, value);
    },
    /**
     * 获取聚合容限
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {Number} 返回聚合容限
     *
     */
    getDistanceThreshold: function getDistanceThreshold() {
      return Module._Globe_DynamicLayer_GetDistanceThreshold(this.handle);
    },
    /**
     * 创建一个自定义聚合组
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {Number} 返回自定义聚合组的ID
     *
     */
    createGroup: function createGroup() {
      return Module._Globe_DynamicLayer_CreateGroup(this.handle);
    },
    /**
     * 销毁一个自定义聚合组
     * @param {Number} groupID -自定义聚合组的ID
     * @memberOf GlobeDynamicLayer#
     *
     */
    destroyGroup: function destroyGroup(groupID) {
      Module._Globe_DynamicLayer_DestroyGroup(this.handle, groupID);
    },
    /**
     * 获取自定义聚合组数目
     * @memberOf GlobeDynamicLayer#
     * @returns {Number} 返回自定义聚合组数目
     */
    getGroupCount: function getGroupCount() {
      return Module._Globe_DynamicLayer_GetGroupCount(this.handle);
    },
    /**
     * 将一个动态对象添加到自定义聚合组
     * @param {Number} groupID -自定义聚合组的ID
     * @param {PIEDynamicFeature} dynamicFeature -需要添加到自定义聚合组的动态对象
     * @memberOf GlobeDynamicLayer#
     *
     */
    addFeatureToGroup: function addFeatureToGroup(groupID, dynamicFeature) {
      Module._Globe_DynamicLayer_AddFeatureToGroup(this.handle, groupID, dynamicFeature.getHandle());
    },
    /**
     * 将一个动态对象从自定义聚合组中删除
     * @param {Number} groupID -自定义聚合组的ID
     * @param {PIEDynamicFeature} dynamicFeature -需要从自定义聚合组删除的动态对象
     *
     * @memberOf GlobeDynamicLayer#
     *@returns {Boolean} 成功返回true，失败返回false
     *
     */
    removeFeatureFromGroup: function removeFeatureFromGroup(groupID, dynamicFeature) {
      return Module._Globe_DynamicLayer_RemoveFeatureFromGroup(this.handle, groupID, dynamicFeature.getHandle());
    },
    /**
     * 获取自定义聚合组的成员数目
     * @param {Number} groupID -自定义聚合组的ID
     *
     * @memberOf GlobeDynamicLayer#
     *@returns {Number} 返回自定义聚合组的数目
     *
     */
    getGroupFeatureCount: function getGroupFeatureCount(groupID) {
      return Module._Globe_DynamicLayer_GetGroupFeatureCount(this.handle, groupID);
    },
    /**
     * 获取自定义聚合组的成员
     * @param {Number} groupID -自定义聚合组的ID
     *@param {Number} index -动态对象的索引
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {PIEDynamicFeature} 返回自定义聚合组的成员
     *
     */
    getGroupFeature: function getGroupFeature(groupID, index) {
      var handle = Module._Globe_DynamicLayer_GetGroupFeature(this.handle, groupID, index);
      if (handle) {
        return new PIEDynamicFeature(handle);
      }
    },
    /**
     * 启用自定义聚合组
     * @param {Number} groupID -自定义聚合组的ID
     * @memberOf GlobeDynamicLayer#
     */
    enableGroup: function enableGroup(groupID) {
      Module._Globe_DynamicLayer_EnableGroup(this.handle, groupID);
    },
    /**
     * 禁用自定义聚合组
     * @param {Number} groupID -自定义聚合组的ID
     * @memberOf GlobeDynamicLayer#
     */
    disableGroup: function disableGroup(groupID) {
      Module._Globe_DynamicLayer_DisableGroup(this.handle, groupID);
    },
    /**
     * 判断自定义聚合组是否已经启用
     * @param {Number} groupID -自定义聚合组的ID
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {Boolean} 返回自定义聚合组是否已经启用
     *
     */
    isGroupEnabled: function isGroupEnabled(groupID) {
      return Module._Globe_DynamicLayer_IsGroupEnabled(this.handle, groupID);
    },
    /**
     * 根据聚合类别向聚合目标字典添加对象ID
     * @param {Number} plotCode -标绘的ID
     * @param {Number} iD -对象ID
     * @memberOf GlobeDynamicLayer#
     */
    addTagFeature: function addTagFeature(plotCode, iD) {
      return Module._Globe_DynamicLayer_AddTagFeature(this.handle, plotCode, iD);
    },
    /**
     * 设置是否可选择
     * @param {Boolean} bSelectable -是否可选择
     * @memberOf GlobeDynamicLayer#
     */
    setSelectable: function setSelectable(bSelectable) {
      return Module._Globe_DynamicLayer_SetSelectable(this.handle, bSelectable);
    },
    /**
     * 判断是否可选择
     * @memberOf GlobeDynamicLayer#
     * @returns {Boolean} 返回是否可选择
     */
    isSelectable: function isSelectable() {
      return Boolean(Module._Globe_DynamicLayer_IsSelectable(this.handle));
    },
    /**
     * 获取图层选择集
     *
     * @memberOf GlobeDynamicLayer#
     * @returns {PIESelection} 成功返回selection对象，失败返回null
     */
    getSelection: function getSelection() {
      var handle = Module._Globe_DynamicLayer_GetSelection(this.handle);
      return new PIESelection(handle);
    },
    /**
     * 查询布告板范围
     * @param {PIEVector2|Array} screenPoint -像素坐标
     * @memberOf GlobeDynamicLayer#
     * @returns {Object} 返回查询结果(id为动态对象id，rect为布告板像素范围)
     */
    queryBillboard: function queryBillboard(screenPoint) {
      if (screenPoint == null) {
        return null;
      }
      var pointArray = null;
      if (screenPoint instanceof PIEVector2) {
        pointArray = screenPoint.toArray();
      } else if (screenPoint instanceof Array) {
        pointArray = screenPoint;
      }
      if (pointArray) {
        var arrPoint = new PIEArray(pointArray, PIEArrayType.Int32);
        var arrRect = new PIEArray(4, PIEArrayType.Int32);
        var id = Module._Globe_DynamicLayer_QueryBillboard(this.handle, arrPoint.getHandle(), arrRect.getHandle());
        arrRect.updateData();
        var rect = arrRect.toArray();
        var resRect = new PIERect(rect[0], rect[1], rect[2], rect[3]);
        arrPoint.dispose();
        arrRect.dispose();
        return {
          id: id,
          rect: resRect
        };
      }
      return null;
    }
  });

  function PIEGlobeLayerFactory() {}
  Object.assign(PIEGlobeLayerFactory.prototype, {});
  PIEGlobeLayerFactory.CreateInstance = function (hGlobeLayer) {
    var globeType = Module._GlobeLayer_GetType(hGlobeLayer);
    if (globeType == PIEGlobeLayerType.Feature) {
      return new PIEGlobeFeatureLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.FeatureMap) {
      return new PIEGlobeFeatureMapLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.Raster) {
      return new PIEGlobeRasterLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.TileRaster) {
      return new PIEGlobeTileRasterLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.Elevation) {
      return new PIEGlobeElevationLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.Graphics) {
      return new PIEGlobeGraphicsLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.Renderable) {
      return new PIEGlobeRenderableLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.Group) {
      return new PIEGlobeGroupLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.OSGBModel) {
      return new PIEGlobeOSGBModelLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.TileGEData) {
      return new PIEGlobeTileGEDataLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.Plot) {
      return new PIEGlobeRenderPlotLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.SeaMap) {
      return new PIEGlobeSeamapLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.MapBoxData) {
      return new PIEGlobeTileMapLayer(hGlobeLayer);
    }
    if (globeType == PIEGlobeLayerType.Dynamic) {
      return new PIEGlobeDynamicLayer(hGlobeLayer);
    }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *三维地表模型操作相关函数
   * @name GlobeModel
   */
  function PIEGlobeModel(handle) {
    this.handle = handle;
  }
  Object.assign(PIEGlobeModel.prototype, {
    /**
     * 添加图层
     * @param {PIEGlobeElevationLayer} globeLayer -高程图层对象
     * @param {Boolean} addToHead -是否添加到图层顶部
     * @memberOf GlobeModel#
     * @returns {Boolean} 返回是否成功添加图层
     */
    addLayer: function addLayer(globeLayer, addToHead) {
      if (globeLayer instanceof PIEGlobeElevationLayer) {
        var result = Module._GlobeModel_AddLayer(this.handle, globeLayer.getHandle(), addToHead);
        if (result) {
          globeLayer.autoRelease = false;
        }
        return Boolean(result);
      }
      throw new Error('PIE.GlobeModel.addLayer: input globeLayer is error');
    },
    /**
     * 获取高程图层数量
     * @memberOf GlobeModel#
     * @returns {Number} 返回图层数量
     */
    getLayerCount: function getLayerCount() {
      return Module._GlobeModel_GetLayerCount(this.handle);
    },
    /**
     *获取高程图层索引
     * @param {PIEGlobeElevationLayer} globeLayer -高程图层对象
     * @memberOf GlobeModel#
     * @returns {Number}返回图层索引
     */
    getLayerIndex: function getLayerIndex(globeLayer) {
      return Module._GlobeModel_GetLayerIndex(this.handle, globeLayer.getHandle());
    },
    /**
     * 根据名称获取高程图层对象
     * @param {String} layerName -高程图层名称
     * @memberOf GlobeModel#
     * @returns {PIEGlobeElevationLayer}返回图层对象
     */
    getLayer: function getLayer(layerName) {
      var strName = new PIEString$1(layerName);
      var hGlobeLayer = Module._GlobeModel_GetLayer(this.handle, strName.getHandle());
      strName.dispose();
      return PIEGlobeLayerFactory.CreateInstance(hGlobeLayer);
    },
    /**
     * 根据索引获取高程图层对象
     * @param {Number} index -高程图层索引
     * @memberOf GlobeModel#
     * @returns {PIEGlobeElevationLayer}返回图层对象
     */
    getLayerAt: function getLayerAt(index) {
      var hGlobeLayer = Module._GlobeModel_GetLayerAt(this.handle, index);
      return PIEGlobeLayerFactory.CreateInstance(hGlobeLayer);
    },
    /**
     * 移除高程图层
     * @param {PIEGlobeElevationLayer} globeLayer -高程图层对象
     * @memberOf GlobeModel#
     * @returns {Boolean}成功返回true，失败返回false
     */
    removeLayer: function removeLayer(globeLayer) {
      var result = Module._GlobeModel_RemoveLayer(this.handle, globeLayer.getHandle());
      if (result) {
        globeLayer.handle = null;
      }
      return Boolean(result);
    },
    /**
     * 根据索引移除高程图层
     * @param {Number} index -高程图层索引
     * @memberOf GlobeModel#
     * @returns {Boolean}成功返回true，失败返回false
     */
    removeLayerAt: function removeLayerAt(index) {
      var result = Module._GlobeModel_RemoveLayerAt(this.handle, index);
      if (result) {
        globeLayer.handle = null;
      }
      return Boolean(result);
    },
    /**
     * 移除全部高程图层
     * @memberOf GlobeModel#
     */
    removeAllLayers: function removeAllLayers() {
      Module._GlobeModel_RemoveAllLayers(this.handle);
    },
    /**
     * 将指定高程图层上移
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeModel#
     * @returns {Boolean} true 移动成功， false 移动失败
     */
    moveLayerUp: function moveLayerUp(index) {
      return Module._GlobeModel_MoveLayerUp(this.handle, index);
    },
    /**
     * 将指定高程图层下移
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeModel#
     * @returns {Boolean} true 移动成功， false 移动失败
     */
    moveLayerDown: function moveLayerDown(index) {
      return Module._GlobeModel_MoveLayerDown(this.handle, index);
    },
    /**
     * 将指定高程图层移到最顶端
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeModel#
     * @returns {Boolean} true 移动成功， false 移动失败
     */
    moveLayerTop: function moveLayerTop(index) {
      return Module._GlobeModel_MoveLayerTop(this.handle, index);
    },
    /**
     * 将指定高程图层移到最底端
     * @param {Number} index -指定图层索引
     *
     * @memberOf GlobeModel#
     * @returns {Boolean} true 移动成功， false 移动失败
     */
    moveLayerBottom: function moveLayerBottom(index) {
      return Module._GlobeModel_MoveLayerBottom(this.handle, index);
    },
    /**
     * 将指定高程图层移动到指定位置
     * @param {Number} indexSrc -源图层索引
     * @param {Number} indexDest -目标位置索引
     *
     * @memberOf GlobeModel#
     * @returns {Boolean} true 移动成功， false 移动失败
     */
    moveLayerTo: function moveLayerTo(indexSrc, indexDest) {
      return Module._GlobeModel_MoveLayerTo(this.handle, indexSrc, indexDest);
    },
    /**
     * 设置地形的夸张系数（不需要刷新地形）
     * @param {Number} terrainScale -地形的夸张系数 [0,3]
     *
     * @memberOf GlobeModel#
     */
    setTerrainScale: function setTerrainScale(terrainScale) {
      Module._GlobeModel_SetTerrainScale(this.handle, terrainScale);
    },
    /**
     * 获取地形的夸张系数
     *
     * @memberOf GlobeModel#
     * @returns {Number} 返回地形的夸张系数
     */
    getTerrainScale: function getTerrainScale() {
      return Module._GlobeModel_GetTerrainScale(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 三维经纬网操作函数
   * @name GlobeGridLine
   *
   */
  function PIEGlobeGridLine(handle) {
    this.handle = handle;
  }
  Object.assign(PIEGlobeGridLine.prototype, {
    /**
     * 设置格网层是否可见
     * @param {Boolean} visible -是否可见
     * @memberOf GlobeGridLine#
     */
    setVisible: function setVisible(visible) {
      Module._GlobeGridLine_SetVisible(this.handle, visible);
    },
    /**
     * 获取格网层是否可见
     *
     * @memberOf GlobeGridLine#
     * @returns {Boolean} 可见返回true,不可见返回false
     */
    isVisible: function isVisible() {
      return Boolean(Module._GlobeGridLine_IsVisible(this.handle));
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *
   * 海洋特效控制函数
   * @name GlobeOcean
   *
   */
  function PIEGlobeOcean(handle) {
    this.handle = handle;
  }
  Object.assign(PIEGlobeOcean.prototype, {
    /**
     * 设置海洋特效的可见性
     * @param {Boolean} visible -海洋特效是否可见
     * @memberOf GlobeOcean#
     *
     */
    setVisible: function setVisible(visible) {
      Module._Ocean_SetVisible(this.handle, visible);
    },
    /**
     * 获取海洋特效是否可见
     *
     * @memberOf GlobeOcean#
     * @returns {Boolean} 可见返回true,不可见返回false
     */
    isVisible: function isVisible() {
      return Module._Ocean_GetVisible(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 场景集合
   * @name Globes
   */
  function PIEGlobes(handle) {
    this.handle = handle;
  }
  Object.assign(PIEGlobes.prototype, {
    /**
      * 添加工作空间中指定名称的场景路径
      * @param {String} name -指定的场景名称
      * @param {String} path - 场景路径
     *
     * @memberOf Globes#
      * @returns {Boolean} 如果添加成功返回true，否则返回false
      */
    addGlobe: function addGlobe(name, path) {
      var strName = new PIEString$1(name);
      var strPath = new PIEString$1(path);
      var result = Module._Document_AddGlobe(this.handle, strName.getHandle(), strPath.getHandle());
      strName.dispose();
      strPath.dispose();
      return result;
    },
    /**
     * 获取工作空间中场景的数量
     *
     * @memberOf Globes#
     * @returns {Number} 返回场景的数量
     */
    getGlobeCount: function getGlobeCount() {
      var count = Module._Document_GetGlobeCount(this.handle);
      return count;
    },
    /**
     * 添加工作空间中指定索引的场景路径
     * @param {Number} index -指定的场景索引值
     * @memberOf Globes#
     * @returns {String} 返回的场景名称
     */
    getGlobeNameAt: function getGlobeNameAt(index) {
      var strName = new PIEString$1(256);
      Module._Document_GetGlobeNameAt(this.handle, index, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 获取工作空间中指定名称的场景索引值
     * @param {String} name -场景名称
     * @memberOf Globes#
     * @returns {Number} 如果获取成功返回指定名称的场景索引值，否则返回-1。
     *
     */
    getGlobeNameIndex: function getGlobeNameIndex(name) {
      var strName = new PIEString$1(name);
      var index = Module._Document_GetGlobeNameIndex(this.handle, strName.getHandle());
      strName.dispose();
      return index;
    },
    /**
     * 获取工作空间中指定索引的场景路径
     * @param {Number} index -指定的场景索引值
     * @memberOf Globes#
     * @returns {String} 返回的场景路径
     *
     */
    getGlobePathAt: function getGlobePathAt(index) {
      var strPath = new PIEString$1(256);
      Module._Document_GetGlobePathAt(this.handle, index, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    /**
     * 获取工作空间中指定名称的场景路径
     * @param {String} name -指定的场景名称
     * @memberOf Globes#
     * @returns {String} 返回指定名称的场景路径
     *
     */
    getGlobePath: function getGlobePath(name) {
      var strPath = new PIEString$1(256);
      Module._Document_GetGlobePath(this.handle, name, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    /**
     * 场景另存时在工作空间中设置新的场景节点
     * @param {String} name -指定的场景名称
     * @param {String} path -指定的场景路径
     * @memberOf Globes#
     *
     * @returns {Boolean} 设置成功返回true，设置失败返回false
     *
     */
    setGlobePath: function setGlobePath(name, path) {
      var strPath = new PIEString$1(path);
      var result = Module._Document_SetGlobePath(this.handle, name, strPath.getHandle());
      strPath.dispose();
      return result;
    },
    /**
     * 重命名场景
     * @param {String} oldName -场景原名称
     * @param {String} newName -场景新名称
     * @memberOf Globes#
     *
     * @returns {Boolean} 如果重命名成功返回true，否则返回false,如果原名为空或者新名为空，那么返回false；如果新名和原名相同，返回true；如果新名与已存在的其他名称相同，返回false；
     *
     */
    renameGlobe: function renameGlobe(oldName, newName) {
      var strOldName = new PIEString$1(oldName);
      var strNewName = new PIEString$1(newName);
      var result = Module._Document_RenameGlobe(this.handle, strOldName.getHandle(), strNewName.getHandle());
      strOldName.dispose();
      strNewName.dispose();
      return result;
    },
    /**
     * 移除场景
     * @param {String} name -场景名称
     * @memberOf Globes#
     *
     * @returns {String} 如果移除成功返回true，否则返回false。(如果名称为空或者找不到，那么返回false)
     *
     */
    removeGlobe: function removeGlobe(name) {
      var strName = new PIEString$1(name);
      var result = Module._Document_RemoveGlobe(this.handle, strName.getHandle());
      strName.dispose();
      return result;
    },
    /**
     * 移除指定索引场景
     * @param {Number} index -场景索引值
     * @memberOf Globes#
     *
     * @returns {String} 如果移除成功返回true，否则返回false(nIndex若小于0或者大于等于工作空中地图总数，那么返回false)
     *
     */
    removeGlobeAt: function removeGlobeAt(index) {
      var result = Module._Document_RemoveGlobeAt(this.handle, index);
      return result;
    },
    /**
     * 移除全部场景
     * @memberOf Globes#
     *
     */
    removeAllGlobe: function removeAllGlobe() {
      Module._Document_RemoveAllGlobe(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   *  符号基类操作函数
   * @name Symbol
   */
  function PIESymbol(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESymbol.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放符号对象
     * @memberOf Symbol#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._Symbol_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 获取符号的类型
     *
     * @memberOf Symbol#
     * @returns {PIESymbolType} 成功返回类型
     */
    getType: function getType() {
      return Module._Symbol_GetType(this.handle);
    },
    /**
     * 获取符号的ID
     * @memberOf Symbol#
     * @returns {Number} 返回符号id
     */
    getID: function getID() {
      return Module._Symbol_GetID(this.handle);
    },
    /**
     * 设置符号的ID
     * @param {Number} id -符号ID
     * @memberOf Symbol#
     */
    setID: function setID(id) {
      Module._Symbol_SetID(this.handle, id);
    },
    /**
     * 获取符号的名称
     *
     * @memberOf Symbol#
     * @returns {String} 返回符号名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Symbol_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置符号的名称
     * @param {String} name -符号名称
     * @memberOf Symbol#
     *
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._Symbol_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取符号的类别
     * @memberOf Symbol#
     * @returns {String} 返回符号类别
     */
    getCategory: function getCategory() {
      var strCategory = new PIEString$1(256);
      Module._Symbol_GetCategory(this.handle, strCategory.getHandle());
      var category = strCategory.toString();
      strCategory.dispose();
      return category;
    },
    /**
     * 设置符号的类别
     * @param {String} category 符号类别
     * @memberOf Symbol#
     */
    setCategory: function setCategory(category) {
      var strCategory = new PIEString$1(category);
      Module._Symbol_SetCategory(this.handle, strCategory.getHandle());
      strCategory.dispose();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 符号组操作函数
   * @name SymbolGroup
   */
  function PIESymbolGroup(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESymbolGroup.prototype, {
    /**
     * 获取符号数量
     *
     * @memberOf SymbolGroup#
     * @returns {Number} 如果获取成功，返回符号数量
     *
     */
    getCount: function getCount() {
      return Module._SymbolGroup_GetCount(this.handle);
    },
    /**
     * 添加符号对象
     * @param {PIESymbol} symbol -符号对象
     *
     * @memberOf SymbolGroup#
     * @returns {Boolean} 如果添加成功，返回true，否则返回false
     *
     */
    add: function add(symbol) {
      return Boolean(Module._SymbolGroup_Add(this.handle, symbol.getHandle()));
    },
    /**
     * 通过ID获取符号对象
     * @param {Number} id -符号ID
     *
     * @memberOf SymbolGroup#
     * @returns {PIESymbol} 如果获取成功，返回符号对象，否则返回空
     *
     */
    getByID: function getByID(id) {
      var hSymbol = Module._SymbolGroup_GetByID(this.handle, id);
      if (hSymbol) {
        return new PIESymbol(hSymbol);
      }
      return null;
    },
    /**
     * 根据符号组的索引号获取符号对象
     * @param {Number} index -索引号
     *
     * @memberOf SymbolGroup#
     * @returns {PIESymbol} 如果获取成功，返回符号对象，否则返回空
     *
     */
    getAt: function getAt(index) {
      var hSymbol = Module._SymbolGroup_GetAt(this.handle, index);
      if (hSymbol) {
        return new PIESymbol(hSymbol);
      }
      return null;
    },
    /**
     * 通过ID移除符号对象
     * @param {Number} id -符号ID
     *
     * @memberOf SymbolGroup#
     */
    removeByID: function removeByID(id) {
      Module._SymbolGroup_RemoveByID(this.handle, id);
    },
    /**
     * 根据符号组的索引号移除符号对象
     * @param {Number} index -索引号
     *
     * @memberOf SymbolGroup#
     */
    removeAt: function removeAt(index) {
      Module._SymbolGroup_RemoveAt(this.handle, index);
    },
    /**
     * 移除所有的符号对象
     * @memberOf SymbolGroup#
     */
    removeAll: function removeAll() {
      Module._SymbolGroup_RemoveAll(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 符号库操作函数（id:1~100,内部资源ID请勿使用）
   * @name SymbolLib
   */
  function PIESymbolLib(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESymbolLib.prototype, {
    // /**
    //  * 打开符号库
    //  * @param {String} path -符号库路径
    //  *
    //  * @memberOf SymbolLib#
    //  * @returns {Boolean} 打开成功返回true，失败返回false
    //  */
    open: function open(path) {
      var strPath = new PIEString$1(path);
      var res = Module._SymbolLib_Open(this.handle, strPath.getHandle());
      strPath.dispose();
      return res;
    },
    // /**
    //  * 关闭符号库
    //  *
    //  * @memberOf SymbolLib#
    //  * @returns {Boolean} 关闭成功返回true，失败返回false
    //  */
    close: function close() {
      return Module._SymbolLib_Close(this.handle);
    },
    /**
     * 获取符号组对象
     * @param {PIESymbolGroupType} groupType -符号组类型
     *
     * @memberOf SymbolLib#
     * @returns {PIESymbolGroup} 如果获取成功，返回符号组,获取失败返回NULL
     */
    getGroup: function getGroup(groupType) {
      var hSymbolGroup = Module._SymbolLib_GetGroup(this.handle, groupType);
      if (hSymbolGroup) {
        return new PIESymbolGroup(hSymbolGroup);
      }
      return null;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建工作空间
   * @name Document
   * @class Document
   * 工作空间操作函数
   *
   * @example
   * let document = new PIE.Document()
   */
  function PIEDocument(handle, autoRelease) {
    if (!handle) {
      this.handle = Module._Document_Create();
      this.autoRelease = true;
    } else {
      this.handle = handle;
      this.autoRelease = false;
    }
  }
  Object.assign(PIEDocument.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     *删除工作空间
     *
     *@memberOf Document#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._Document_Close(this.handle);
        Module._Document_Delete(this.handle);
        this.handle = null;
      }
    },
    // /**
    //  * 打开工作空间
    //  *
    //  *@memberOf Document#
    //  * @param {String} path -工作空间路径
    //  * @returns {Boolean} 如果打开成功返回true，否则返回false
    //  */
    // open: function (path) {
    //     var strPath = new PIEString(path);
    //     var res = Module._Document_Open(this.handle, strPath.getHandle());
    //     strPath.dispose();
    //     return res;
    // },
    //
    // // /**
    // //  * 关闭工作空间
    // //  *@memberOf Document#
    // //  *
    // //  * @example
    // //  * let document = new PIE.Document()
    // //  * document.close()
    // //  */
    // close: function () {
    //     Module._Document_Close(this.handle);
    // },

    // /**
    //  * 保存工作空间
    //  * @returns {Boolean}如果保存成功返回true，否则返回false
    //  * @memberOf Document#
    //  */
    // save: function () {
    //     return Module._Document_Save(this.handle);
    // },
    // /**
    //  * 工作空间另存为
    //  * @param {String} path - 工作空间另存的路径
    //  * @memberOf Document#
    //  * @returns {Boolean} 如果另存为成功返回true，否则返回false
    //  */
    // saveAs: function (path) {
    //     var strPath = new PIEString(path);
    //     var res = Module._Document_SaveAs(this.handle, strPath.getHandle());
    //     strPath.dispose();
    //     return res;
    // },
    // /**
    //  * 设置工作空间的路径
    //  * @param {String} path -工作空间路径
    //  * @memberOf Document#
    //  */
    // setPath: function (path) {
    //     var strPath = new PIEString(path);
    //     Module._Document_SetPath(this.handle, strPath.getHandle());
    //     strPath.dispose();
    // },
    // /**
    //  * 获取工作空间的路径
    //  * @returns {String} 返回的工作空间路径
    //  * @memberOf Document#
    //  */
    // getPath: function () {
    //     var strPath = new PIEString(256);
    //     Module._Document_GetPath(this.handle, strPath.getHandle());
    //     var path = strPath.toString();
    //     strPath.dispose();
    //     return path;
    // },
    // /**
    //  * 获取工作空间的名称
    //  * @memberOf Document#
    //  * @returns {String} 返回的工作空间名称
    //  *
    //  */
    // getName: function () {
    //     var strName = new PIEString(256);
    //     Module._Document_GetName(this.handle, strName.getHandle());
    //     var name = strName.toString();
    //     strName.dispose();
    //     return name;
    // },
    /**
     * 获取符号库
     *
     * @memberOf Document#
     * @returns {PIESymbolLib} 返回符号库对象
     *
     */
    getSymbolLib: function getSymbolLib() {
      var hSymbolLib = Module._Document_GetSymbolLib(this.handle);
      return new PIESymbolLib(hSymbolLib);
    },
    /**
     * 获取数据源管理器
     *
     * @memberOf Document#
     * @returns {PIEDataSources} 返回数据源管理器
     */
    getDataSourceManager: function getDataSourceManager() {
      return new PIEDataSources(this.handle);
    },
    /**
     * 获取场景管理器
     *
     * @memberOf Document#
     * @returns {PIEGlobes} 返回场景管理器
     *
     */
    getGlobeManager: function getGlobeManager() {
      return new PIEGlobes(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 水下特效控制函数
   * @name UnderWater
   *
   * @extends Renderable
   */
  function PIEUnderWater(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIEUnderWater.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 获取UnderWater的可见性
     *
     * @memberOf UnderWater#
     * @returns {Boolean} 返回UnderWater是否可见(true-可见，false-不可见)
     */
    getUnderWaterVisible: function getUnderWaterVisible() {
      return Module._UW_GetUnderWaterVisible(this.handle);
    },
    /**
     * 设置UnderWater的可见性
     * @param {Boolean} visible -海洋水下特效是否可见
     * @memberOf UnderWater#
     */
    setUnderWaterVisible: function setUnderWaterVisible(visible) {
      Module._UW_SetUnderWaterVisible(this.handle, visible);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维球面场景背景板控制函数
   * @name GlobeBackground
   *
   */
  function PIEGlobeBackground(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIEGlobeBackground.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 获取背景板的颜色
     *
     * @memberOf GlobeBackground#
     * @returns {PIEColor} 返回背景板当前颜色
     */
    getColor: function getColor() {
      var arrayColor = new PIEArray(4, PIEArrayType.Float64);
      Module._GlobeBackground_GetColor(this.handle, arrayColor.getHandle());
      arrayColor.updateData();
      var color = arrayColor.toArray();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置背景板的颜色
     * @param {PIEVector4} color -背景板颜色
     * @memberOf GlobeBackground#
     */
    setColor: function setColor(color) {
      var arrayColor = new PIEArray(color, PIEArrayType.Float64);
      Module._GlobeBackground_SetColor(this.handle, arrayColor.getHandle());
      arrayColor.dispose();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 太阳特效控制函数
   * @name SunLight
   *
   * @extends Renderable
   */
  function PIESunLight(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIESunLight.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 获取太阳光照的可见性
     *
     * @memberOf SunLight#
     * @returns {Boolean} 太阳光照是否可见
     */
    getVisible: function getVisible() {
      return Module._SunLight_GetVisible(this.handle);
    },
    /**
     * 设置太阳光照的可见性
     * @param {Boolean} visible -太阳光照是否可见
     * @memberOf SunLight#
     */
    setVisible: function setVisible(visible) {
      Module._SunLight_SetVisible(this.handle, visible);
    },
    /**
     * 获取太阳照射的时间
     *
     * @memberOf SunLight#
     * @returns {Date} 成功返回日期，失败返回空日期
     */
    getTime: function getTime() {
      var arrayDateTime = new PIEArray(6, PIEArrayType.Int32);
      Module._SunLight_GetTime(this.handle, arrayDateTime.getHandle());
      arrayDateTime.updateData();
      var times = arrayDateTime.toArray();
      arrayDateTime.dispose();
      var dateTime = new Date(times[0], times[1], times[2], times[3], times[4], times[5]);
      return dateTime;
    },
    /**
     * 设置太阳照射的时间
     * @param {Date} dateTime -日期
     * @memberOf SunLight#
     */
    setTime: function setTime(dateTime) {
      var times = [dateTime.getFullYear(), dateTime.getMonth(), dateTime.getDate(), dateTime.getHours(), dateTime.getMinutes(), dateTime.getSeconds()];
      var arrayDateTime = new PIEArray(times, PIEArrayType.UInt32);
      Module._SunLight_SetTime(this.handle, arrayDateTime.getHandle());
      arrayDateTime.dispose();
    },
    /**
     * 获取太阳照射的时区
     *
     * @memberOf SunLight#
     * @returns {Number} 太阳照射的时区
     */
    getTimeZone: function getTimeZone() {
      return Module._SunLight_GetTimeZone(this.handle);
    },
    /**
     * 设置太阳照射的时区
     * @param {Number} timeZone -照射时区
     *
     * @memberOf SunLight#
     * @returns {Boolean} 返回是否设置成功
     */
    setTimeZone: function setTimeZone(timeZone) {
      return Module._SunLight_SetTimeZone(this.handle, timeZone);
    },
    /**
     * 设置太阳照射的位置
     * @param {PIEVector3/Array} worldPos -太阳光照位置
     *
     * @memberOf SunLight#
     */
    setPosition: function setPosition(worldPos) {
      var posArray = null;
      if (worldPos instanceof PIEVector3) {
        posArray = worldPos.toArray();
      } else if (worldPos instanceof Array) {
        posArray = worldPos;
      }
      if (posArray != null) {
        var arrayPosition = new PIEArray(posArray, PIEArrayType.Float64);
        Module._SunLight_SetPosition(this.handle, arrayPosition.getHandle());
        arrayPosition.dispose();
      }
    },
    /**
     * 获取太阳照射的位置
     * @returns {PIEVector3} 返回太阳光照位置
     * @memberOf SunLight#
     */
    getPosition: function getPosition() {
      var arrayPosition = new PIEArray(3, PIEArrayType.Float64);
      Module._SunLight_GetPosition(this.handle, arrayPosition.getHandle());
      arrayPosition.updateData();
      var postion = arrayPosition.toArray();
      arrayPosition.dispose();
      return new PIEVector3(postion[0], postion[1], postion[2]);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 大气特效控制函数
   * @name Atmosphere
   *
   */
  function PIEAtomsphere(handle) {
    PIERenderable.call(this, handle, false);
  }
  PIEAtomsphere.prototype = Object.assign(Object.create(PIERenderable.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 天空盒操作函数
   * @name SkyDome
   * @extends Renderable
   *
   */
  function PIESkyDome(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIESkyDome.prototype = Object.assign(Object.create(PIERenderable.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 星空操作函数
   * @name Star
   * @extends Renderable
   *
   */
  function PIEStar(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIEStar.prototype = Object.assign(Object.create(PIERenderable.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维反射对象
   * @name GlobeModel
   */
  function PIEReflectManager(handle) {
    this.handle = handle;
  }
  Object.assign(PIEReflectManager.prototype, {
    /**
     * 添加渲染对象
     *  @memberOf ReflectManager#
     * @param {PIERenderable} renderable -渲染对象
     */
    addRenderable: function addRenderable(renderable) {
      Module._ReflectManager_AddRenderable(this.handle, renderable.getHandle());
    },
    /**
     * 移除渲染对象
     * @memberOf ReflectManager#
     * @param {PIERenderable} renderable -渲染对象
     */
    removeRenderable: function removeRenderable(renderable) {
      return Module._ReflectManager_RemoveRenderable(this.handle, renderable.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维场景操作相关函数
   * @name Globe
   */
  function PIEGlobe(handle) {
    this.handle = handle;
    this._pixelRatio = 1;
  }
  Object.assign(PIEGlobe.prototype, {
    setPixelRatio: function setPixelRatio(pixelRatio) {
      this._pixelRatio = pixelRatio;
    },
    /**
     * 获取维度模式
     *
     * @memberOf Globe#
     * @returns {PIEDimensionMode} 返回维度模式
     *
     */
    getDimensionMode: function getDimensionMode() {
      return Module._Globe_GetDimensionMode(this.handle);
    },
    // /**
    //  * 设置设备DPI
    //  * @param {Number} deviceDPI -设备DPI
    //  * @memberOf Globe#
    //  *
    //  */
    setDeviceDPI: function setDeviceDPI(deviceDPI) {
      Module._Globe_SetDeviceDPI(this.handle, deviceDPI);
    },
    // /**
    //  * 获取设备DPI
    //  * @memberOf Globe#
    //  * @returns {Number} 返回设备DPI
    //  */
    getDeviceDPI: function getDeviceDPI() {
      return Module._Globe_GetDeviceDPI(this.handle);
    },
    /**
     * 设置场景模式
     *  @param {PIESceneMode} mode -场景模式
     *  @memberOf Globe#
     *
     */
    setSceneMode: function setSceneMode(mode) {
      Module._Globe_SetSceneMode(this.handle, mode);
    },
    /**
     * 获取场景模式
     *
     * @memberOf Globe#
     *@returns {PIESceneMode} 返回场景模式
     *
     */
    getSceneMode: function getSceneMode() {
      return Module._Globe_GetSceneMode(this.handle);
    },
    // /**
    //  * 设置线程处理模式
    //  * @param {PIEProcessMode} mode -线程处理模式
    //  * @memberOf Globe#
    //  */
    setProcessMode: function setProcessMode(mode) {
      Module._Globe_SetProcessMode(this.handle, mode);
    },
    // /**
    //  * 获取线程处理模式
    //  *
    //  * @memberOf Globe#
    //  * @returns {PIEProcessMode} 返回线程处理模式
    //  *
    //  */
    getProcessMode: function getProcessMode() {
      return Module._Globe_GetProcessMode(this.handle);
    },
    /**
     * 设置场景的缓存半径大小
     * @param {Number} bufferRadius -缓存半径大小
     * @memberOf Globe#
     */
    setTileBufferRadius: function setTileBufferRadius(bufferRadius) {
      Module._Globe_SetTileBufferRadius(this.handle, bufferRadius);
    },
    /**
     *获取场景的缓存半径大小
     *
     * @memberOf Globe#
     * @returns {Number} 场景的缓存半径大小
     *
     */
    getTileBufferRadius: function getTileBufferRadius() {
      return Module._Globe_GetTileBufferRadius(this.handle);
    },
    // /**
    //  *初始化主线程渲染
    //  *
    //  * @memberOf Globe#
    //  * @returns {Boolean} 成功返回主线程渲染对象是否成功，失败返回false
    //  *
    //  */
    initRenderHandles: function initRenderHandles() {
      return Boolean(Module._Globe_InitRenderHandles(this.handle));
    },
    // /**
    //  * 打开指定名称的地图
    //  * @param {String} name -地图名称
    //  *
    //  * @memberOf Globe#
    //  * @returns {Boolean} 返回是否成功打开指定名称的地图
    //  *
    //  */
    // open: function (name) {
    //     var strName = new PIEString(name);
    //     var res = Module._Globe_Open(this.handle, strName.getHandle());
    //     strName.dispose();
    //     return Boolean(res);
    // },
    // /**
    //  * 地图是否已经打开成功
    //  *
    //  * @memberOf Globe#
    //  * @returns {Boolean} 返回地图是否已经打开
    //  *
    //  */
    // isOpened: function () {
    //     return Boolean(Module._Globe_IsOpened(this.handle));
    // },
    /**
     *关闭窗口中的地图
     * @memberOf Globe#
     */
    close: function close() {
      Module._Globe_Close(this.handle);
    },
    // /**
    //  *保存窗口中的地图
    //  * @memberOf Globe#
    //  * @returns {Boolean} 返回是否成功保存窗口中的地图
    //  */
    // save: function () {
    //     return Boolean(Module._Globe_Save(this.handle));
    // },
    // /**
    //  *另存窗口中的地图
    //  * @param {String} path -地图另存的路径
    //  *
    //  * @memberOf Globe#
    //  * @returns {Boolean} 返回是否成功另存窗口中的地图
    //  *
    //  */
    // saveAs: function (path) {
    //     var strPath = new PIEString(path);
    //     var res = Module._Globe_SaveAs(this.handle, strPath.getHandle());
    //     strPath.dispose();
    //     return Boolean(res);
    // },

    // /**
    //  * 从xml中反序列化地图
    //  * @param {String} xML -地图xml
    //  *
    //  * @memberOf Globe#
    //  * @returns {Boolean} 返回是否成功反序列化
    //  */
    fromXML: function fromXML(xML) {
      var strXML = new PIEString$1(xML);
      var res = Module._Globe_FromXML(this.handle, strXML.getHandle());
      strXML.dispose();
      return Boolean(res);
    },
    // /**
    //  * 把地图序列化成xml
    //  *
    //  * @memberOf Globe#
    //  * @returns {String} 返回地图xml
    //  */
    toXML: function toXML() {
      var strXml = new PIEString$1(1024);
      Module._Globe_ToXML(this.handle, strXml.getHandle());
      var xml = strXml.toString();
      strXml.dispose();
      return xml;
    },
    /**
     *绑定工作空间
     * @param {PIEDocument} document -工作空间
     * @memberOf Globe#
     */
    attachDocument: function attachDocument(document) {
      Module._Globe_AttachDocument(this.handle, document.getHandle());
    },
    /**
     *获取工作空间
     *
     * @memberOf Globe#
     * @returns {PIEDocument} 工作空间(返回null时说明三维球没有绑定工作空间)
     *
     */
    getDocument: function getDocument() {
      var handle = Module._Globe_GetDocument(this.handle);
      if (handle) {
        return new PIEDocument(handle);
      } else {
        return null;
      }
    },
    // /**
    //  *在场景中获取海洋
    //  *
    //  * @memberOf Globe#
    //  * @returns {PIEGlobeOcean} 成功返回海洋,失败返回NULL
    //  *
    //  */
    getOcean: function getOcean() {
      var hOcean = Module._Globe_GetOcean(this.handle);
      if (hOcean) {
        return new PIEGlobeOcean(hOcean);
      }
      return null;
    },
    /**
     * 在地图中获取背景板对象
     * @memberOf Globe#
     * @returns {PIEGlobeBackground} 成功返回背景板对象,失败返回NULL
     */
    globeBackground: function globeBackground() {
      var handle = Module._Globe_GlobeBackground(this.handle);
      if (handle) {
        return new PIEGlobeBackground(handle);
      }
      return null;
    },
    // /**
    //  * 获取水下仿真对象
    //  * @memberOf Globe#
    //  * @returns {PIEUnderWater} 成功返回水下仿真对象,失败返回NULL
    //  */
    getUnderWater: function getUnderWater() {
      var handle = Module._Globe_GetUnderWater(this.handle);
      if (handle) {
        return new PIEUnderWater(handle);
      }
      return null;
    },
    /**
     * 获取当前地图跟踪图层
     * @memberOf Globe#
     * @returns {PIEGlobeGroupLayer} 返回当前地图跟踪图层
     */
    getTrackingLayers: function getTrackingLayers() {
      var handle = Module._Globe_GetTrackingLayers(this.handle);
      if (handle) {
        return new PIEGlobeGroupLayer(handle);
      }
    },
    // /**
    //  * 获取RenderableLayer
    //  * @memberOf Globe#
    //  * @returns {PIEGlobeRenderableLayer} 返回RenderableLayer
    //  */
    // getRenderableLayer: function () {
    //     var handle = Module._Globe_GetRenderableLayer(this.handle);
    //     if (handle) {
    //         return new PIEGlobeRenderableLayer(handle);
    //     }
    // },
    /**
     *在场景中获取经纬网
     *
     * @memberOf Globe#
     * @returns {PIEGlobeGridLine} 成功返回经纬网对象,失败返回NULL
     *
     */
    getGridLine: function getGridLine() {
      var hGridLine = Module._Globe_GetGridLine(this.handle);
      if (hGridLine) {
        return new PIEGlobeGridLine(hGridLine);
      }
      return null;
    },
    /**
     *在场景中获取相机
     *
     * @memberOf Globe#
     * @returns {PIEWorldCamera} 返回相机对象
     *
     */
    getWorldCamera: function getWorldCamera() {
      var hCamera = Module._Globe_GetWorldCamera(this.handle);
      if (hCamera) {
        return new PIEWorldCamera(hCamera);
      }
      return null;
    },
    /**
     *启动渲染线程
     * @memberOf Globe#
     */
    startRender: function startRender() {
      Module._Globe_StartRender(this.handle);
    },
    /**
     *停止渲染线程
     * @memberOf Globe#
     */
    stopRender: function stopRender() {
      Module._Globe_StopRender(this.handle);
    },
    /**
     *设置是否可见全球背景图片
     * @param {Boolean} visible -是否可见
     * @memberOf Globe#
     */
    setVisibleGlobeImage: function setVisibleGlobeImage(visible) {
      Module._Globe_SetVisibleGlobeImage(this.handle, visible);
    },
    /**
     * 判断是否可见全球背景图片
     *
     * @memberOf Globe#
     *@returns {Boolean} 返回是否可见全球背景图片
     *
     */
    isVisibleGlobeImage: function isVisibleGlobeImage() {
      return Boolean(Module._Globe_IsVisibleGlobeImage(this.handle));
    },
    /**
     * 设置地图窗口是否显示环境仿真元素
     *@param {Boolean} enable -是否显示环境仿真元素
     * @memberOf Globe#
     */
    setEnableEnvironment: function setEnableEnvironment(enable) {
      Module._Globe_SetEnableEnvironment(this.handle, enable);
    },
    /**
     * 获取地图窗口是否显示环境仿真元素
     *
     * @memberOf Globe#
     *@returns {Boolean} 返回是否显示环境仿真元素
     *
     */
    isEnableEnvironment: function isEnableEnvironment() {
      return Boolean(Module._Globe_IsEnableEnvironment(this.handle));
    },
    /**
     * 设置地图窗口是否显示地图场景
     *@param {Boolean} enable -是否显示地图场景
     * @memberOf Globe#
     */
    setEnableGlobe: function setEnableGlobe(enable) {
      Module._Globe_SetEnableGlobe(this.handle, enable);
    },
    /**
     * 获取地图窗口是否显示地图场景
     *
     * @memberOf Globe#
     *@returns {Boolean} 返回是否显示地图场景
     *
     */
    isEnableGlobe: function isEnableGlobe() {
      return Boolean(Module._Globe_IsEnableGlobe(this.handle));
    },
    // /**
    //  * 设置地图是否启用FrameBuffer
    //  *@param {Boolean} enable -是否启用FrameBuffer
    //  * @memberOf Globe#
    //  */
    setEnableFrameBuffer: function setEnableFrameBuffer(enable) {
      Module._Globe_SetEnableFrameBuffer(this.handle, enable);
    },
    // /**
    //  * 获取地图是否启用FrameBuffer
    //  *
    //  * @memberOf Globe#
    //  *@returns {Boolean} 返回是否启用FrameBuffer
    //  *
    //  */
    isEnableFrameBuffer: function isEnableFrameBuffer() {
      return Boolean(Module._Globe_IsEnableFrameBuffer(this.handle));
    },
    // /**
    //  * 设置当前地图是第几次渲染
    //  * @param {Number} howRenderTimes -第几次渲染
    //  * @memberOf Globe#
    //  */
    setHowRenderTimes: function setHowRenderTimes(howRenderTimes) {
      Module._Globe_SetHowRenderTimes(this.handle, howRenderTimes);
    },
    // /**
    //  * 获取当前地图是第几次渲染
    //  *
    //  * @memberOf Globe#
    //  * @returns {Number} 返回是第几次渲染
    //  */
    getHowRenderTimes: function getHowRenderTimes() {
      return Module._Globe_GetHowRenderTimes(this.handle);
    },
    /**
     * 设置场景窗口是否填充背景颜色
     *@param  {Boolean} enable -是否填充背景颜色
     * @memberOf Globe#
     */
    setEnableBkgColor: function setEnableBkgColor(enable) {
      Module._Globe_SetEnableBkgColor(this.handle, enable);
    },
    /**
     * 判断场景窗口是否填充背景颜色
     *
     * @memberOf Globe#
     *@returns {Boolean} 返回是否填充背景颜色
     *
     */
    isEnableBkgColor: function isEnableBkgColor() {
      return Boolean(Module._Globe_IsEnableBkgColor(this.handle));
    },
    /**
     * 设置地图窗口是否填充背景深度
     *@param {Boolean} write -是否填充背景深度
     * @memberOf Globe#
     */
    setBkgDepthWrite: function setBkgDepthWrite(write) {
      Module._Globe_SetBkgDepthWrite(this.handle, write);
    },
    /**
     * 设置地图窗口背景颜色
     * @param {PIEColor/Array} color -地图窗口颜色
     * @memberOf Globe#
     */
    setBkgColor: function setBkgColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
      } else if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      }
      Module._Globe_SetBkgColor(this.handle, colorArray.getHandle());
      colorArray.dispose();
    },
    /**
     * 获取地图窗口背景颜色
     *
     * @memberOf Globe#
     * @returns {PIEColor} 返回地图窗口颜色
     */
    getBkgColor: function getBkgColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._Globe_GetBkgColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var array = colorArray.toArray();
      var Color = new PIEColor(array[0], array[1], array[2], array[3]);
      colorArray.dispose();
      return Color;
    },
    /**
     * 重置渲染器参数
     * @memberOf Globe#
     */
    resetRenderer: function resetRenderer() {
      Module._Globe_ResetRenderer(this.handle);
    },
    /**
     * 获取三维地球模型
     *
     * @memberOf Globe#
     *@returns {PIEGlobeModel} 三维地球模型
     *
     */
    getGlobeModel: function getGlobeModel() {
      var hGlobeModel = Module._Globe_GetGlobeModel(this.handle);
      return new PIEGlobeModel(hGlobeModel);
    },
    /**
     * 设置自动投影转换
     * @param {Boolean} autoProjection -是否自动转换地图投影
     * @memberOf Globe#
     *
     */
    setAutoProjection: function setAutoProjection(autoProjection) {
      Module._Globe_SetAutoProjection(this.handle, autoProjection);
    },
    /**
     * 判断是否自动转换投影坐标
     *
     * @memberOf Globe#
     *@returns {Boolean} 返回是否是自动转换投影坐标
     *
     */
    isAutoProjection: function isAutoProjection() {
      return Boolean(Module._Globe_IsAutoProjection(this.handle));
    },
    /**
     * 设置场景瓦片是否为按级别固定缩放
     *@param {Boolean} fixedScale -是否为按级别固定缩放
     * @memberOf Globe#
     */
    setFixdScale: function setFixdScale(fixedScale) {
      Module._Globe_SetFixdScale(this.handle, fixedScale);
    },
    /**
     * 判断场景瓦片是否为按级别固定缩放
     *
     * @memberOf Globe#
     *@returns {Boolean} 返回是否为按级别固定缩放
     *
     */
    isFixdScale: function isFixdScale() {
      return Boolean(Module._Globe_IsFixdScale(this.handle));
    },
    /**
     * 获取场景所有缩放级别的比例尺数组
     *
     * @memberOf Globe#
     * @returns {Array} 返回场景所有缩放级别比例尺数组
     *
     */
    getScaleLevels: function getScaleLevels() {
      var scales = new PIEArray(32, PIEArrayType.Float64);
      var count = Module._Globe_GetScaleLevels(this.handle, scales.getHandle(), 32);
      scales.updateData();
      var scaleArray = scales.toArray();
      if (count < scaleArray.length) {
        scaleArray = scaleArray.slice(0, count);
      }
      scales.dispose();
      return scaleArray;
    },
    /**
     * 设置场景所有缩放级别的比例尺数组
     * @param {Array} scales -场景所有缩放级别的比例尺数组
     * @memberOf Globe#
     *
     *@returns {Boolean} 返回是否设置成功
     *
     */
    setScaleLevels: function setScaleLevels(scales) {
      if (scales instanceof Array) {
        var count = scales.length;
        var scalesArr = new PIEArray(scales, PIEArrayType.Float64);
        var res = Module._Globe_SetScaleLevels(this.handle, scalesArr.getHandle(), count);
        scalesArr.dispose();
        return Boolean(res);
      }
      return false;
    },
    /**
     * 设置窗口中的场景的名称
     * @param {String} name -窗口中场景名称
     * @memberOf Globe#
     *
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._Globe_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取窗口中的场景的名称
     * @memberOf Globe#
     * @returns {String} 返回地图的名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._Globe_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    // /**
    //  * 设置投影坐标系统对象
    //  * @param {PIESpatialReference} spatialReference -投影坐标系统对象
    //  * @memberOf Globe#
    //  */
    setSpatialReference: function setSpatialReference(spatialReference) {
      Module._Globe_SetSpatialReference(this.handle, spatialReference.getHandle());
    },
    /**
     * 设置场景显示比例尺
     * @param {Number} scale -显示比例尺
     * @memberOf Globe#
     */
    setScale: function setScale(scale) {
      Module._Globe_SetScale(this.handle, scale);
    },
    /**
     * 获取场景显示比例尺
     *
     * @memberOf Globe#
     * @returns {Number} -返回场景显示比例尺
     */
    getScale: function getScale() {
      return Module._Globe_GetScale(this.handle);
    },
    /**
     * 缩放场景
     * @param {Number} zoomRatio -缩放参数
     *
     * @memberOf Globe#
     * @returns {Number} 返回地图缩放后的比例尺
     *
     */
    zoom: function zoom(zoomRatio) {
      return Module._Globe_Zoom(this.handle, zoomRatio);
    },
    /**
     * 获取地图的缩放级别
     *
     * @memberOf Globe#
     * @returns {Number} 返回地图缩放级别
     */
    getZoom: function getZoom() {
      return Module._Globe_GetZoom(this.handle);
    },
    /**
     * 设置地图的缩放级别
     * @param {Number} zoom -缩放级别
     * @memberOf Globe#
     */
    setZoom: function setZoom(zoom) {
      Module._Globe_SetZoom(this.handle, zoom);
    },
    /**
     * 地图缩放级别转成分辨率
     * @param {Number} zoom -地图缩放级别
     * @memberOf Globe#
     * @returns {Number} 返回地图显示分辨率
     */
    zoomToResolution: function zoomToResolution(zoom) {
      return Module._Globe_ZoomToResolution(this.handle, zoom);
    },
    /**
     * 分辨率转成地图缩放级别
     * @param {Number} resolution -分辨率
     * @memberOf Globe#
     * @returns {Number} 返回地图缩放级别
     */
    resolutionToZoom: function resolutionToZoom(resolution) {
      return Module._Globe_ResolutionToZoom(this.handle, resolution);
    },
    /**
     * 获取投影坐标系统对象
     *
     * @memberOf Globe#
     * @returns {PIESpatialReference} 返回投影坐标系统对象
     *
     */
    getSpatialReference: function getSpatialReference() {
      var handle = Module._Globe_GetSpatialReference(this.handle);
      return new PIESpatialReference(handle);
    },
    /**
     * 获取场景范围
     *
     * @memberOf Globe#
     * @returns {PIEBounds} 返回场景范围
     *
     */
    getBounds: function getBounds() {
      var arrayBounds = new PIEArray(4, PIEArrayType.Float64);
      Module._Globe_GetBounds(this.handle, arrayBounds.getHandle());
      arrayBounds.updateData();
      var recArray = arrayBounds.toArray();
      var bound = new PIEBounds(recArray[0], recArray[1], recArray[2], recArray[3]);
      arrayBounds.dispose();
      return bound;
    },
    /**
     * 设置场景坐标中心点
     * @param {(PIEVector2/PIEArray)} center -中心点
     * @memberOf Globe#
     */
    setCenter: function setCenter(center) {
      var array = null;
      if (center instanceof PIEVector2) {
        array = new PIEArray([center.x, center.y], PIEArrayType.Float64);
      } else {
        array = new PIEArray(center, PIEArrayType.Float64);
      }
      Module._Globe_SetCenter(this.handle, array.getHandle());
      array.dispose();
    },
    /**
     * 获取场景坐标中心点
     *
     * @memberOf Globe#
     * @returns {PIEVector2} 返回场景的中心点
     *
     */
    getCenter: function getCenter() {
      var array = new PIEArray(2, PIEArrayType.Float64);
      Module._Globe_GetCenter(this.handle, array.getHandle());
      array.updateData();
      var vecArray = array.toArray();
      var vector2d = new PIEVector2(vecArray[0], vecArray[1]);
      array.dispose();
      return vector2d;
    },
    /**
     * 通过地理坐标设置场景坐标中心点
     * @param {(PIEVector2/PIEArray)} center -地理坐标中心点
     * @memberOf Globe#
     */
    setGeoCenter: function setGeoCenter(center) {
      var spatialReference = this.getSpatialReference();
      var array = null;
      center = spatialReference.forward(center);
      if (center instanceof PIEVector2) {
        array = new PIEArray([center.x, center.y], PIEArrayType.Float64);
        spatialReference.forward();
      } else {
        array = new PIEArray(center, PIEArrayType.Float64);
      }
      Module._Globe_SetCenter(this.handle, array.getHandle());
      array.dispose();
    },
    /**
     * 获取场景地理坐标中心点
     * @returns {PIEVector2} 返回场景的中心点
     * @memberOf Globe#
     */
    getGeoCenter: function getGeoCenter() {
      var spatialReference = this.getSpatialReference();
      var array = new PIEArray(2, PIEArrayType.Float64);
      Module._Globe_GetCenter(this.handle, array.getHandle());
      array.updateData();
      var centerArray = array.toArray();
      var vecArray = new PIEVector2(centerArray[0], centerArray[1]);
      var geoCenter = spatialReference.inverse(vecArray);
      array.dispose();
      return geoCenter;
    },
    /**
     * 设置场景是否能旋转
     * @param {Boolean} enable -是否能旋转
     * @memberOf Globe#
     */
    setEnableHeading: function setEnableHeading(enable) {
      Module._Globe_SetEnableHeading(this.handle, enable);
    },
    /**
     * 判断场景是否能旋转
     *
     * @memberOf Globe#
     * @returns {Boolean} 返回场景是否能旋转
     *
     */
    isEnableHeading: function isEnableHeading() {
      return Boolean(Module._Globe_IsEnableHeading(this.handle));
    },
    /**
     * 地理坐标转为地图坐标
     * @param {(PIEVector2/Array)} geoPoint -地理坐标点
     * @memberOf Globe#
     * @returns {PIEVector2} 返回地图坐标
     *
     */
    geoToMap: function geoToMap(geoPoint) {
      var inArray = null;
      if (geoPoint instanceof PIEVector2) {
        inArray = new PIEArray([geoPoint.x, geoPoint.y], PIEArrayType.Float64);
      } else {
        inArray = new PIEArray(geoPoint, PIEArrayType.Float64);
      }
      var outArray = new PIEArray(2, PIEArrayType.Float64);
      Module._Globe_GeoToMap(this.handle, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var mapPoint = new PIEVector2(vecArray[0], vecArray[1]);
      inArray.dispose();
      outArray.dispose();
      return mapPoint;
    },
    /**
     * 地图坐标转为地理坐标
     * @param {(PIEVector2/Array)} mapPoint -地图坐标点
     * @memberOf Globe#
     *
     * @returns {PIEVector2} 返回地理坐标点
     *
     */
    mapToGeo: function mapToGeo(mapPoint) {
      var inArray = null;
      if (mapPoint instanceof PIEVector2) {
        inArray = new PIEArray([mapPoint.x, mapPoint.y], PIEArrayType.Float64);
      } else {
        inArray = new PIEArray(mapPoint, PIEArrayType.Float64);
      }
      var outArray = new PIEArray(2, PIEArrayType.Float64);
      Module._Globe_MapToGeo(this.handle, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var geoPoint = new PIEVector2(vecArray[0], vecArray[1]);
      inArray.dispose();
      outArray.dispose();
      return geoPoint;
    },
    /**
     * 地图坐标点转换为像素坐标点
     * @param {(PIEVector2/Array)} mapPoint -地图坐标点
     *
     * @memberOf Globe#
     * @returns {PIEVector2} 像素坐标点(如果传入地图坐标为空，返回null)
     *
     */
    mapToDevice: function mapToDevice(mapPoint) {
      var inArray = null;
      if (!mapPoint) {
        return null;
      }
      if (mapPoint instanceof PIEVector2) {
        inArray = new PIEArray([mapPoint.x, mapPoint.y], PIEArrayType.Float64);
      } else if (mapPoint instanceof Array) {
        inArray = new PIEArray(mapPoint, PIEArrayType.Float64);
      } else {
        return null;
      }
      var outArray = new PIEArray(2, PIEArrayType.Int32);
      Module._Globe_MapPointToDevice(this.handle, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var devicePoint = new PIEVector2(vecArray[0] / this._pixelRatio, vecArray[1] / this._pixelRatio);
      inArray.dispose();
      outArray.dispose();
      return devicePoint;
    },
    /**
     * 像素坐标点转换为地图坐标点
     * @param {(PIEVector2/Array)} devicePoint -像素坐标点
     *
     * @memberOf Globe#
     * @returns {PIEVector2} 地图坐标点
     *
     */
    deviceToMap: function deviceToMap(devicePoint) {
      var inArray = null;
      if (devicePoint instanceof PIEVector2) {
        inArray = new PIEArray([devicePoint.x, devicePoint.y], PIEArrayType.Int32);
      } else {
        inArray = new PIEArray(devicePoint, PIEArrayType.Int32);
      }
      var outArray = new PIEArray(2, PIEArrayType.Float64);
      Module._Globe_DevicePointToMap(this.handle, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var mapPoint = new PIEVector2(vecArray[0], vecArray[1]);
      inArray.dispose();
      outArray.dispose();
      return mapPoint;
    },
    /**
     * 地理坐标转换成世界坐标
     * @param {(PIEVector2/Array)} geoPoint -地理坐标点
     * @param {Number} elevation -高程值
     *
     * @memberOf Globe#
     * @returns {PIEVector3} 像素坐标点
     *
     */
    geoToWorld: function geoToWorld(geoPoint, elevation) {
      var inArray = null;
      if (geoPoint instanceof PIEVector2) {
        inArray = new PIEArray([geoPoint.x, geoPoint.y], PIEArrayType.Float64);
      } else {
        inArray = new PIEArray(geoPoint, PIEArrayType.Float64);
      }
      var outArray = new PIEArray(3, PIEArrayType.Float64);
      var sceneMode = Module._Globe_GetSceneMode(this.handle);
      Module._Globe_GeoToWorld(this.handle, sceneMode, inArray.getHandle(), elevation, outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var worldPoint = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
      inArray.dispose();
      outArray.dispose();
      return worldPoint;
    },
    /**
     * 世界坐标转换成地理坐标
     * @param {(PIEVector3/Array)} worldPoint -世界坐标点
     * @memberOf Globe#
     *
     * @returns {PIEVector2} 地理坐标点
     */
    worldToGeo: function worldToGeo(worldPoint) {
      var inArray = null;
      if (worldPoint instanceof PIEVector3) {
        inArray = new PIEArray([worldPoint.x, worldPoint.y, worldPoint.z], PIEArrayType.Float64);
      } else {
        inArray = new PIEArray(worldPoint, PIEArrayType.Float64);
      }
      var outArray = new PIEArray(2, PIEArrayType.Float64);
      var sceneMode = Module._Globe_GetSceneMode(this.handle);
      Module._Globe_WorldToGeo(this.handle, sceneMode, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var geoPoint = new PIEVector2(vecArray[0], vecArray[1]);
      inArray.dispose();
      outArray.dispose();
      return geoPoint;
    },
    /**
     * 世界坐标换算成像素坐标
     * @param {(PIEVector3/Array)} worldPoint -世界坐标点
     * @memberOf Globe#
     *
     * @returns {PIEVector2} 像素坐标点
     */
    worldToDevice: function worldToDevice(worldPoint) {
      var inArray = null;
      if (worldPoint instanceof PIEVector3) {
        inArray = new PIEArray([worldPoint.x, worldPoint.y, worldPoint.z], PIEArrayType.Float64);
      } else {
        inArray = new PIEArray(worldPoint, PIEArrayType.Float64);
      }
      var outArray = new PIEArray(2, PIEArrayType.Int32);
      Module._Globe_WorldToDevice(this.handle, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var devicePoint = new PIEVector2(vecArray[0] / this._pixelRatio, vecArray[1] / this._pixelRatio);
      inArray.dispose();
      outArray.dispose();
      return devicePoint;
    },
    /**
     * 像素坐标换算成世界坐标
     * @param {(PIEVector2/Array)} devicePoint -像素坐标点
     * @memberOf Globe#
     *
     * @returns {PIEVector3} 世界坐标点
     */
    deviceToWorld: function deviceToWorld(devicePoint) {
      var inArray = null;
      if (devicePoint instanceof PIEVector2) {
        inArray = new PIEArray([devicePoint.x, devicePoint.y], PIEArrayType.Int32);
      } else {
        inArray = new PIEArray(devicePoint, PIEArrayType.Int32);
      }
      var outArray = new PIEArray(3, PIEArrayType.Float64);
      Module._Globe_DeviceToWorld(this.handle, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var worldPoint = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
      inArray.dispose();
      outArray.dispose();
      return worldPoint;
    },
    /**
     * 像素坐标换算成世界坐标
     * @param {(PIEVector2/Array)} devicePoint -像素坐标点
     * @memberOf Globe#
     *
     * @returns {PIEVector3} 世界坐标点
     */
    deviceToWorldEx: function deviceToWorldEx(devicePoint) {
      var inArray = null;
      if (devicePoint instanceof PIEVector2) {
        inArray = new PIEArray([devicePoint.x, devicePoint.y], PIEArrayType.Int32);
      } else {
        inArray = new PIEArray(devicePoint, PIEArrayType.Int32);
      }
      var outArray = new PIEArray(3, PIEArrayType.Float64);
      Module._Globe_DeviceToWorldEx(this.handle, inArray.getHandle(), outArray.getHandle());
      outArray.updateData();
      var vecArray = outArray.toArray();
      var worldPoint = new PIEVector3(vecArray[0], vecArray[1], vecArray[2]);
      inArray.dispose();
      outArray.dispose();
      return worldPoint;
    },
    /**
     * 获取地图翻转（绕z轴旋转）角度
     * @memberOf Globe#
     *
     * @returns {Number} 返回地图翻转（绕z轴旋转）角度
     *
     */
    getHeadingAngle: function getHeadingAngle() {
      return Module._Globe_GetHeadingAngle(this.handle);
    },
    /**
     * 设置地图翻转（绕z轴旋转）角度
     * @param {Number} angle -翻转角度
     * @memberOf Globe#
     */
    setHeadingAngle: function setHeadingAngle(angle) {
      Module._Globe_SetHeadingAngle(this.handle, angle);
    },
    /**
     * 获取地图俯仰（绕x轴旋转）角度
     *
     * @memberOf Globe#
     * @returns {Number} 返回地图俯仰（绕x轴旋转）角度
     *
     */
    getPitchAngle: function getPitchAngle() {
      return Module._Globe_GetPitchAngle(this.handle);
    },
    /**
     * 设置地图俯仰（绕x轴旋转）角度
     * @param {Number} angle -旋转角度
     * @memberOf Globe#
     *
     */
    setPitchAngle: function setPitchAngle(angle) {
      Module._Globe_SetPitchAngle(this.handle, angle);
    },
    /**
     * 设置地图最大俯仰（绕x轴旋转）角度
     * @param {Number} angle -最大俯仰角度[0,90]
     * @memberOf Globe#
     */
    setMaxPitchAngle: function setMaxPitchAngle(angle) {
      Module._Globe_SetMaxPitchAngle(this.handle, angle);
    },
    /**
     * 获取地图最大俯仰（绕x轴旋转）角度
     * @memberOf Globe#
     * @returns {Number} 返回地图最大俯仰（绕x轴旋转）角度
     */
    getMaxPitchAngle: function getMaxPitchAngle() {
      return Module._Globe_GetMaxPitchAngle(this.handle);
    },
    /**
     * 添加图层
     * @param {PIEGlobeLayer} globeLayer -图层对象
     * @param {Boolean} addToHead -是否添加到图层顶部
     * @memberOf Globe#
     * @returns {Boolean} 返回是否成功添加到图层顶部
     */
    addLayer: function addLayer(globeLayer, addToHead) {
      if (addToHead == null) {
        addToHead = true;
      }
      var result = Module._Globe_AddLayer(this.handle, globeLayer.getHandle(), addToHead);
      if (result) {
        globeLayer.setAutoRelease(false);
      }
      return Boolean(result);
    },
    /**
     * 获取指定别名的图层集
     * @param {String} name -图层名称
     * @memberOf Globe#
     * @returns {PIEGlobeLayer} 返回指定名称的图层集
     */
    getLayer: function getLayer(name) {
      var strName = new PIEString$1(name);
      var hGlobeLayer = Module._Globe_GetLayer(this.handle, strName.getHandle());
      strName.dispose();
      return PIEGlobeLayerFactory.CreateInstance(hGlobeLayer);
    },
    /**
     * 获取指定索引的图层
     * @param {Number} index -指定索引
     * @memberOf Globe#
     * @returns {PIEGlobeLayer} 返回指定索引的图层集
     *
     */
    getLayerAt: function getLayerAt(index) {
      var hGlobeLayer = Module._Globe_GetLayerAt(this.handle, index);
      return PIEGlobeLayerFactory.CreateInstance(hGlobeLayer);
    },
    /**
     * 获取图层索引
     * @param {PIEGlobeLayer} globeLayer -图层对象
     * @memberOf Globe#
     * @returns {Number} 成功返回当前图层的索引 失败返回-1
     *
     */
    getLayerIndex: function getLayerIndex(globeLayer) {
      return Module._Globe_GetLayerIndex(this.handle, globeLayer.getHandle());
    },
    /**
     * 获取当前地图图层数量
     * @memberOf Globe#
     * @returns {Number} 返回当前地图图层数量
     *
     */
    getLayerCount: function getLayerCount() {
      return Module._Globe_GetLayerCount(this.handle);
    },
    /**
     * 移除图层(通过图层指针)
     * @param {PIEGlobeLayer} globelayer -图层对象
     * @memberOf Globe#
     * @returns {Boolean} true 移除成功,false 移除失败
     *
     */
    removeLayer: function removeLayer(globelayer) {
      var res = Module._Globe_RemoveLayer(this.handle, globelayer.getHandle());
      if (res) {
        globelayer.handle = null;
      }
      return Boolean(res);
    },
    /**
     *  移除指定图层
     * @param {Number} index -指定图层索引
     * @memberOf Globe#
     * @returns {Boolean} true 移除成功,false 移除失败
     *
     */
    removeLayerAt: function removeLayerAt(index) {
      return Boolean(Module._Globe_RemoveLayerAt(this.handle, index));
    },
    /**
     * 移除当前地图所有图层
     * @memberOf Globe#
     */
    removeAllLayers: function removeAllLayers() {
      Module._Globe_RemoveAllLayers(this.handle);
    },
    /**
     * 将指定图层上移
     * @param {Number} index -指定图层索引
     * @memberOf Globe#
     * @returns {Boolean} true 移动成功,false 移动失败
     */
    moveLayerUp: function moveLayerUp(index) {
      return Boolean(Module._Globe_MoveLayerUp(this.handle, index));
    },
    /**
     * 将指定图层下移
     * @param {Number} index -指定图层索引
     * @memberOf Globe#
     * @returns {Boolean} true 移动成功,false 移动失败
     *
     */
    moveLayerDown: function moveLayerDown(index) {
      return Boolean(Module._Globe_MoveLayerDown(this.handle, index));
    },
    /**
     * 将指定图层移到最顶端
     * @param {Number} index -指定图层索引
     * @memberOf Globe#
     * @returns {Boolean} true 移动成功,false 移动失败
     */
    moveLayerTop: function moveLayerTop(index) {
      return Boolean(Module._Globe_MoveLayerBottom(this.handle, index));
    },
    /**
     * 将指定图层移到最底端
     * @param {Number} index -指定图层索引
     * @memberOf Globe#
     * @returns {Boolean} true 移动成功,false 移动失败
     *
     */
    moveLayerBottom: function moveLayerBottom(index) {
      return Boolean(Module._Globe_MoveLayerTop(this.handle, index));
    },
    /**
     * 将指定图层移到指定位置
     * @param {Number} indexSrc -源图层索引
     * @param {Number} indexDest -目标位置索引
     *
     * @memberOf Globe#
     * @returns {Boolean} 移动成功返回true，失败返回false
     */
    moveLayerTo: function moveLayerTo(indexSrc, indexDest) {
      return Boolean(Module._Globe_MoveLayerTo(this.handle, indexSrc, indexDest));
    },
    /**
     * 清除Selection
     * @memberOf Globe#
     * @returns {Boolean} 成功返回true，失败返回false
     */
    clearSelection: function clearSelection() {
      return Boolean(Module._Globe_ClearSelection(this.handle));
    },
    /**
     * 将源图层组中索引的图层移到目标图层组中索引的位置
     * @param {GlobeGroupLayer} groupSrc -原图层组
     * @param {Number} indexSrc -原索引
     * @param {GlobeGroupLayer} groupDest -目标图层组
     * @param {Number} indexDest -目标索引
     *
     * @memberOf Globe#
     * @returns {Boolean} 移动成功返回true，失败返回false
     */
    moveGroupLayerTo: function moveGroupLayerTo(groupSrc, indexSrc, groupDest, indexDest) {
      var groupSrcHandle = groupSrc != null ? groupSrc.getHandle() : null;
      var groupDestHandle = groupDest != null ? groupDest.getHandle() : null;
      return Boolean(Module._Globe_MoveLayerto(this.handle, groupSrcHandle, indexSrc, groupDestHandle, indexDest));
    },
    /**
     * 获取天空盒对象
     * @memberOf Globe#
     * @returns {PIESkyDome} 成功返回天空盒对象,失败返回null
     *
     */
    getSkyDome: function getSkyDome() {
      var handle = Module._Globe_GetSkyDome(this.handle);
      if (handle) {
        return new PIESkyDome(handle);
      }
      return null;
    },
    /**
     * 获取星空对象
     * @memberOf Globe#
     * @returns {PIEStar} 成功返回星空对象,失败返回null
     *
     */
    getStar: function getStar() {
      var handle = Module._Globe_GetStar(this.handle);
      if (handle) {
        return new PIEStar(handle);
      }
      return null;
    },
    /**
     * 获取太阳光照对象
     *
     * @memberOf Globe#
     * @returns {PIESunLight} 成功返回太阳特效对象,失败返回null
     *
     */
    getSunLight: function getSunLight() {
      var handle = Module._Globe_GetSunLight(this.handle);
      if (handle) {
        return new PIESunLight(handle);
      }
    },
    /**
     * 获取大气圈对象
     *
     * @memberOf Globe#
     * @returns {PIEAtmosphere} 成功返回大气圈对象,失败返回NULL
     *
     */
    getAtmosphere: function getAtmosphere() {
      var handle = Module._Globe_GetAtmosphere(this.handle);
      if (handle) {
        return new PIEAtomsphere(handle);
      }
    },
    // /**
    //  * 获取局部坐标转换球面坐标的矩阵
    //  * @param {Number} scaleRatio -比例尺
    //  * @memberOf Globe#
    //  * @returns {PIEMatrix4f} 返回矩阵
    //  *
    //  */
    // computeMapLocalMatrix: function (scaleRatio) {
    //     var arrayPosition = new PIEArray(3, PIEArrayType.Float64);
    //     var arrayRegerenceCenter = new PIEArray(3, PIEArrayType.Float64);
    //     var arrayMartix = new PIEArray(16, PIEArrayType.Float32);
    //     var res = Module._Globe_ComputeMapLocalMatrix(this.handle, arrayPosition.getHandle(), arrayRegerenceCenter.getHandle(), scaleRatio, arrayMartix.getHandle());
    //     arrayPosition.dispose();
    //     arrayRegerenceCenter.dispose();
    //     arrayMartix.dispose();
    //     return res;
    // },
    /**
     * 窗口地图全屏显示
     * @memberOf Globe#
     *
     */
    viewEntire: function viewEntire() {
      Module._Globe_ViewEntire(this.handle);
    },
    /**
     * 设置视图范围
     * @param {PIEBounds/Array} bounds -视图范围
     * @memberOf Globe#
     */
    setViewBounds: function setViewBounds(bounds) {
      var arrayRect;
      if (bounds instanceof Array) {
        arrayRect = new PIEArray(bounds, PIEArrayType.Float64);
      } else if (bounds instanceof PIEBounds) {
        arrayRect = new PIEArray([bounds.left, bounds.top, bounds.right, bounds.bottom], PIEArrayType.Float64);
      } else {
        return;
      }
      Module._Globe_SetViewBounds(this.handle, arrayRect.getHandle());
      arrayRect.dispose();
    },
    /**
     * 获取视图范围
     * @returns {PIEBounds} 返回视图范围
     * @memberOf Globe#
     */
    getViewBounds: function getViewBounds() {
      var arrayBound = new PIEArray(4, PIEArrayType.Float64);
      Module._Globe_GetViewBounds(this.handle, arrayBound.getHandle());
      arrayBound.updateData();
      var recArray = arrayBound.toArray();
      var bound = new PIEBounds(recArray[0], recArray[1], recArray[2], recArray[3]);
      arrayBound.dispose();
      return bound;
    },
    /**
     * 刷新地图窗口
     * @param {Boolean} forceRefresh -标识是否强制刷新(设置为true时，会主动调用异步绘制，所有图层强制刷新)
     * @param {Boolean} clearCache -标识是否清除缓存(设置为true时，会清除所有图层缓存，图层做的修改会立即生效)
     * @memberOf Globe#
     */
    refresh: function refresh(forceRefresh, clearCache) {
      Module._Globe_Refresh(this.handle, forceRefresh, clearCache);
    },
    /**
     * 刷新地形
     * @param {Boolean} forceRefresh -标识是否强制刷新
     * @param {Boolean} clearCache -标识是否清除缓存
     * @memberOf Globe#
     */
    refreshGlobeModel: function refreshGlobeModel(forceRefresh, clearCache) {
      Module._Globe_RefreshGlobeModel(this.handle, forceRefresh, clearCache);
    },
    /**
     * 地图坐标换算成世界坐标
     * @param {PIESceneMode} sceneMode -场景模式
     * @param {(PIEVector2/Array)} point2d -地图坐标点
     * @param {Number} elevation -高程值
     *
     * @memberOf Globe#
     * @returns {PIEVector3} 世界坐标点
     */
    mapToWorld: function mapToWorld(sceneMode, point2d, elevation) {
      var arrayPoint = [];
      if (point2d instanceof Array) {
        arrayPoint = point2d;
      } else if (point2d instanceof PIEVector2) {
        arrayPoint = [point2d.x, point2d.y];
      }
      if (arrayPoint.length) {
        var arrayPoint2d = new PIEArray(arrayPoint, PIEArrayType.Float64);
        var desArrayPoint = new PIEArray(3, PIEArrayType.Float64);
        Module._Globe_MapToWorld(this.handle, sceneMode, arrayPoint2d.getHandle(), elevation, desArrayPoint.getHandle());
        desArrayPoint.updateData();
        var desPoint = desArrayPoint.toArray();
        desArrayPoint.dispose();
        arrayPoint2d.dispose();
        if (point2d instanceof Array) {
          return desPoint;
        } else if (point2d instanceof PIEVector2) {
          return new PIEVector3(desPoint[0], desPoint[1], desPoint[2]);
        }
      }
    },
    /**
     * 世界坐标换算成地图坐标
     * @param {PIESceneMode} sceneMode -场景模式
     * @param {(PIEVector3/Array)} point3d -世界坐标点
     *
     * @memberOf Globe#
     * @returns {PIEVector2} 地图坐标点
     */
    worldToMap: function worldToMap(sceneMode, point3d) {
      var arrayPoint = [];
      if (point3d instanceof Array) {
        arrayPoint = point3d;
      } else if (point3d instanceof PIEVector3) {
        arrayPoint = [point3d.x, point3d.y, point3d.z];
      }
      if (arrayPoint.length) {
        var arrayPoint3d = new PIEArray(arrayPoint, PIEArrayType.Float64);
        var desArrayPoint = new PIEArray(2, PIEArrayType.Float64);
        Module._Globe_WorldToMap(this.handle, sceneMode, arrayPoint3d.getHandle(), desArrayPoint.getHandle());
        desArrayPoint.updateData();
        var desPoint = desArrayPoint.toArray();
        desArrayPoint.dispose();
        arrayPoint3d.dispose();
        if (point3d instanceof Array) {
          return desPoint;
        } else if (point3d instanceof PIEVector3) {
          return new PIEVector2(desPoint[0], desPoint[1]);
        }
      }
    },
    /**
     * 设备范围转换为地图范围
     * @param {(PIERect/Array)} rect4i -设备范围
     * @memberOf Globe#
     *
     * @returns {PIEBounds}地图范围
     */
    deviceRectToMap: function deviceRectToMap(rect4i) {
      var arrayRect = [];
      if (rect4i instanceof Array) {
        arrayRect = rect4i;
      } else if (rect4i instanceof PIERect) {
        arrayRect = [rect4i.left, rect4i.top, rect4i.right, rect4i.bottom];
      }
      if (arrayRect.length) {
        var arrayRect4i = new PIEArray(arrayRect, PIEArrayType.Int32);
        var desArrayRect = new PIEArray(4, PIEArrayType.Float64);
        Module._Globe_DeviceRectToMap(this.handle, arrayRect4i.getHandle(), desArrayRect.getHandle());
        desArrayRect.updateData();
        var desRect4d = desArrayRect.toArray();
        desArrayRect.dispose();
        arrayRect4i.dispose();
        if (rect4i instanceof Array) {
          return desRect4d;
        } else if (rect4i instanceof PIERect) {
          return new PIEBounds(desRect4d[0], desRect4d[1], desRect4d[2], desRect4d[3]);
        }
      }
    },
    /**
     * 地图范围转换为设备范围
     * @param {(PIEBounds/Array)} rect4d -地图范围
     *
     * @memberOf Globe#
     * @returns {PIERect}设备范围
     */
    mapBoundsToDevice: function mapBoundsToDevice(rect4d) {
      var arrayRect = [];
      if (rect4d instanceof Array) {
        arrayRect = rect4d;
      } else if (rect4d instanceof PIEBounds) {
        arrayRect = [rect4d.left, rect4d.top, rect4d.right, rect4d.bottom];
      }
      if (arrayRect.length) {
        var arrayRect4d = new PIEArray(arrayRect, PIEArrayType.Float64);
        var ArrayRect4i = new PIEArray(4, PIEArrayType.Int32);
        Module._Globe_MapRectToDevice(this.handle, arrayRect4d.getHandle(), ArrayRect4i.getHandle());
        ArrayRect4i.updateData();
        var rect4iarray = ArrayRect4i.toArray();
        ArrayRect4i.dispose();
        arrayRect4d.dispose();
        if (rect4d instanceof Array) {
          return rect4iarray;
        } else if (rect4d instanceof PIEBounds) {
          return new PIERect(rect4iarray[0] / this._pixelRatio, rect4iarray[1] / this._pixelRatio, rect4iarray[2] / this._pixelRatio, rect4iarray[3] / this._pixelRatio);
        }
      }
    },
    /**
     * 设备尺寸转换为地图尺寸
     * @param {(double)} size -设备尺寸
     * @memberOf Globe#
     *
     * @returns {double}地图尺寸
     */
    deviceSizeToMap: function deviceSizeToMap(size) {
      return Module._Globe_DeviceSizeToMap(this.handle, size);
    },
    /**
     * 地图尺寸转换为设备尺寸
     * @param {(double)} size -地图尺寸
     *
     * @memberOf Globe#
     * @returns {double}设备尺寸
     */
    mapSizeToDevice: function mapSizeToDevice(size) {
      return Module._Globe_MapSizeToDevice(this.handle, size);
    },
    /**
     * 设置最小层级
     * @param {Number} zoom -层级
     * @memberOf Globe#
     */
    setMinZoom: function setMinZoom(zoom) {
      var resolution = 256 * Math.pow(2, zoom);
      this.setMinResolution(resolution);
    },
    /**
     * 获取最小层级
     *
     * @memberOf Globe#
     *@returns {Number} 最小层级
     *
     */
    getMinZoom: function getMinZoom() {
      var resolution = Module._Globe_GetMinResolution(this.handle);
      return this.resolutionToZoom(resolution);
    },
    /**
     * 设置最大层级
     * @param {Number} zoom -层级
     * @memberOf Globe#
     */
    setMaxZoom: function setMaxZoom(zoom) {
      var resolution = 256 * Math.pow(2, zoom);
      Module._Globe_SetMaxResolution(this.handle, resolution);
    },
    /**
     * 获取最大层级
     *
     * @memberOf Globe#
     * @returns {Number} 最大层级
     *
     */
    getMaxZoom: function getMaxZoom() {
      var resolution = Module._Globe_GetMaxResolution(this.handle);
      return this.resolutionToZoom(resolution);
    },
    /**
     * 设置最小分辨率
     * @param {Number} resolution -分辨率
     * @memberOf Globe#
     */
    setMinResolution: function setMinResolution(resolution) {
      Module._Globe_SetMinResolution(this.handle, resolution);
    },
    /**
     * 获取最小分辨率
     *
     * @memberOf Globe#
     *@returns {Number} 最小分辨率
     *
     */
    getMinResolution: function getMinResolution() {
      return Module._Globe_GetMinResolution(this.handle);
    },
    /**
     * 设置最大分辨率
     * @param {Number} resolution -分辨率
     * @memberOf Globe#
     */
    setMaxResolution: function setMaxResolution(resolution) {
      Module._Globe_SetMaxResolution(this.handle, resolution);
    },
    /**
     * 获取最大分辨率
     *
     * @memberOf Globe#
     *@returns {Number} 最大分辨率
     *
     */
    getMaxResolution: function getMaxResolution() {
      return Module._Globe_GetMaxResolution(this.handle);
    },
    // /**
    //  * 执行动画
    //  * @param {PIEAction} action -动画对象
    //  * @memberOf Globe#
    //  */
    // runAction: function (action) {
    //     Module._Globe_RunAction(this.handle, action.getHandle());
    // },
    // /**
    //  * 停止动画
    //  * @param {PIEAction} action -动画对象
    //  * @memberOf Globe#
    //  */
    // stopAction: function (action) {
    //     Module._Globe_StopAction(this.handle, action.getHandle());
    // },
    // /**
    //  * 停止所有动画
    //  *
    //  * @memberOf Globe#
    //  *
    //  */
    // stopAllActions: function () {
    //     Module._Globe_StopAllActions(this.handle);
    // },
    // /**
    //  * 判断动画是否完成
    //  *
    //  * @memberOf Globe#
    //  * @returns {PIEAction} 动画对象
    //  *
    //  */
    // isAllActionsDone: function () {
    //     return Module._Globe_IsAllActionsDone(this.handle);
    // },
    /**
     * 刷新图层(当窗口(相机)未发生变化时，添加图层之后需要调用，否则图层不会立即显示)
     * @param {PIEGlobeLayer} layer -需要刷新的图层对象
     * @param {Boolean} clearCache -标识是否清除缓存(图层进行了修改(风格等)，可以设置为true，使修改立即生效)
     * @memberOf Globe#
     */
    refreshLayer: function refreshLayer(layer, clearCache) {
      Module._Globe_RefreshLayer(this.handle, layer.getHandle(), clearCache);
    },
    /**
     * 设置地表网格瓦片层级
     * @param {Number} levelSize -地表网格瓦片层级
     * @memberOf Globe#
     */
    setTileLevelSize: function setTileLevelSize(levelSize) {
      Module._Globe_SetTileLevelSize(this.handle, levelSize);
    },
    /**
     * 获取地表网格瓦片层级
     *
     * @memberOf Globe#
     * @returns {Number} 返回地表网格瓦片层级
     */
    getTileLevelSize: function getTileLevelSize() {
      return Module._Globe_GetTileLevelSize(this.handle);
    },
    // setText: function (text){
    //     var strText = new PIEString(text);
    //     Module._Globe_SetText(this.handle, strText.getHandle());
    //     strText.dispose();
    // },

    /**
     * 获取反射对象
     *
     * @memberOf Globe#
     * @returns {PIEReflectManager} 返回反射对象
     */
    getReflectManager: function getReflectManager() {
      var handle = Module._Globe_GetReflectManager(this.handle);
      return new PIEReflectManager(handle);
    },
    /**
     * 根据层级和坐标获取瓦片行列号
     * @param {Number} zoom -层级
     * @param {PIEVector2/Array} center -点坐标
     * @memberOf Globe#
     * @returns {PIEVector2} 返回瓦片行列号
     */
    computeTilePosition: function computeTilePosition(zoom, center) {
      if (this.handle == null) return null;
      var centerArray = null;
      if (center instanceof PIEVector2) {
        centerArray = center.toArray();
      } else if (center instanceof Array) {
        centerArray = center;
      }
      if (centerArray != null) {
        var posArray = new PIEArray(2, PIEArrayType.Int32);
        Module._Globe_ComputeTilePosition(this.handle, zoom, centerArray[0], centerArray[1], posArray.getHandle());
        posArray.updateData();
        var resPos = posArray.toArray();
        posArray.dispose();
        return new PIEVector2(resPos[0], resPos[1]);
      }
      return null;
    },
    /**
     * 获取标绘内部点格式
     * @param {PIEVector2/Array} center -点数组(可以通过数组传一个点或者多个点,一个点可以支持PIEVector2格式)
     * @memberOf Globe#
     * @returns {PIEVector2} 返回点数组
     */
    getPlotPoint: function getPlotPoint(points) {
      var pointsArray = null;
      if (points instanceof PIEVector2) {
        pointsArray = points.toArray();
      } else if (points instanceof Array) {
        pointsArray = points;
      }
      if (pointsArray != null) {
        var length = pointsArray.length;
        if (length == 0 || length % 2 != 0) {
          return null;
        } else {
          var resPoints = [];
          for (var i = 0; i < length; i += 2) {
            var pointsArr = new PIEArray([pointsArray[i], pointsArray[i + 1]], PIEArrayType.Float64);
            var arrayPoints = new PIEArray(2, PIEArrayType.Float64);
            Module._GeoPlot_GetPlotPoint(this.handle, pointsArr.getHandle(), arrayPoints.getHandle());
            arrayPoints.updateData();
            var _points = arrayPoints.toArray();
            resPoints = resPoints.concat(_points);
            pointsArr.dispose();
            arrayPoints.dispose();
          }
          return resPoints;
        }
      }
      return null;
    }
  });

  // function createEarthModule() {
  //     EarthModule(/* optional default settings */).then(function (earthModule) {
  //         if(window["Module"]){
  //             if("_Environment_Init" in Module){
  //                 return;
  //             }else{
  //                 for (var key in earthModule) {
  //                     Module[key] = earthModule[key];
  //                 }
  //                 Module.onRuntimeInitialized();
  //             }
  //         }
  //     })
  // }
  // createEarthModule();

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   *系统运行环境
   * @name Environment
   * @interface
   */
  var PIEEnvironment = function PIEEnvironment() {};
  // /**
  //  * 设置工作路径
  //  * @param {String} path -工作路径
  //  * @memberOf Environment
  //  *
  //  */
  PIEEnvironment.setWorkPath = function (path) {
    var strPath = new PIEString$1(path);
    Module._Environment_SetWorkPath(strPath.getHandle());
    strPath.dispose();
  };

  // /**
  //  * 获取工作路径
  //  * @memberOf Environment
  //  *@returns {String} 工作路径
  //  *
  //  * @example
  //  * let path = PIE.Environment.getWorkPath();
  //  */
  PIEEnvironment.getWorkPath = function () {
    var strPath = new PIEString$1(256);
    Module._Environment_GetWorkPath(strPath.getHandle());
    var workPath = strPath.toString();
    strPath.dispose();
    return workPath;
  };

  /**
   * 设置资源Url
   * @param {String} url -资源Url
   * @memberOf Environment
   */
  PIEEnvironment.setResourceUrl = function (url) {
    var strUrl = new PIEString$1(url);
    Module._Environment_SetResourceUrl(strUrl.getHandle());
    strUrl.dispose();
  };

  /**
   *  获取资源Url
   *
   *  @memberOf Environment
   *  @returns {String} 资源Url
   *
   * @example
   * let resourceUrl = PIE.Environment.getResourceUrl();
   */
  PIEEnvironment.getResourceUrl = function () {
    var strUrl = new PIEString$1(256);
    Module._Environment_GetResourceUrl(strUrl.getHandle());
    var resourceUrl = strUrl.toString();
    strUrl.dispose();
    return resourceUrl;
  };

  /**
   * 初始化系统
   * @memberOf Environment
   */
  PIEEnvironment.init = function () {
    PIEEnvironment.setWorkPath("");
    if (!window._environmentInit) {
      Module._Environment_Init();
      window._environmentInit = true;
    }
  };

  /**
   * 初始化气象模块
   * @memberOf Environment
   */
  PIEEnvironment.weatherInit = function () {
    Module._PIEWeather_LoadSymbol();
  };

  /**
   * 退出系统
   * @memberOf Environment
   */
  PIEEnvironment.exit = function () {
    Module._Environment_Exit();
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 场景维度模式
   * @readonly
   * @enum {number}
   */
  var PIEDimensionMode = {
    /**二维模式(包括2.5D)*/
    D2D: 0,
    /**三维模式*/
    D3D: 1
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维场景模式枚举
   * @readonly
   * @enum {Number}
   */
  var PIESceneMode = {
    /**未知场景*/
    UnKnown: 0,
    /**球场景*/
    Sphere: 1,
    /**平面的投影场景*/
    Plane: 2
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 编辑模块
   * ---
   */

  /**
   * 编辑器基础操作相关函数
   * @name Editor
   *
   */
  function PIEEditor(handle) {
    this.handle = handle;
    this.addGeometrysEvent = null;
    this.addedGeometrysEvent = null;
    this.updatedGeometrysEvent = null;
    this.hitTestGeometryHandleEvent = null;
  }
  Object.assign(PIEEditor.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 获取添加几何对象之前的回调事件
     *
     * @memberOf Editor#
     * @returns {PIEEvent} 返回添加几何对象之前的回调事件
     */
    getAddGeometrysEvent: function getAddGeometrysEvent() {
      if (this.addGeometrysEvent == null) {
        this.addGeometrysEvent = new PIEEvent();
        Module['setAddGeometrysCallback'](this.handle, this);
      }
      return this.addGeometrysEvent;
    },
    addGeometrysCallback: function addGeometrysCallback(geometrys) {
      var array = [];
      if (geometrys.length > 0) {
        for (var i = 0; i < geometrys.length; i++) {
          var geometry = PIEGeometryFactory.CreateInstance(geometrys[i]);
          array.push(geometry);
        }
      }
      this.addGeometrysEvent.raiseEvent(array);
    },
    /**
     * 获取添加几何对象之后的回调事件
     *
     * @memberOf Editor#
     * @returns {PIEEvent} 返回添加几何对象之后的回调事件
     */
    getAddedGeometrysEvent: function getAddedGeometrysEvent() {
      if (this.addedGeometrysEvent == null) {
        this.addedGeometrysEvent = new PIEEvent();
        Module['setAddedGeometrysCallback'](this.handle, this);
      }
      return this.addedGeometrysEvent;
    },
    addedGeometrysCallback: function addedGeometrysCallback(geometrys) {
      var array = [];
      if (geometrys.length > 0) {
        for (var i = 0; i < geometrys.length; i++) {
          var geometry = PIEGeometryFactory.CreateInstance(geometrys[i]);
          array.push(geometry);
        }
      }
      this.addedGeometrysEvent.raiseEvent(array);
    },
    /**
     * 获取点击几何对象操作的回调事件
     *
     * @memberOf Editor#
     * @returns {PIEEvent} 返回点击几何对象操作的回调事件
     *
     */
    getHitTestGeometryHandleEvent: function getHitTestGeometryHandleEvent() {
      if (this.hitTestGeometryHandleEvent == null) {
        this.hitTestGeometryHandleEvent = new PIEEvent();
        Module['setHitTestGeometryHandleCallBack'](this.handle, this);
      }
      return this.hitTestGeometryHandleEvent;
    },
    hitTestGeometryHandleCallback: function hitTestGeometryHandleCallback(hgeometry, index) {
      if (hgeometry != null) {
        var geometry = PIEGeometryFactory.CreateInstance(hgeometry);
        this.hitTestGeometryHandleEvent.raiseEvent(geometry, index);
      }
    },
    /**
     * 获取更新几何对象之后的回调事件
     *
     * @memberOf Editor#
     * @returns {PIEEvent} 返回更新几何对象之后的回调事件
     */
    getUpatedGeometrysEvent: function getUpatedGeometrysEvent() {
      if (this.updatedGeometrysEvent == null) {
        this.updatedGeometrysEvent = new PIEEvent();
        Module['setUpdatedGeometrysCallback'](this.handle, this);
      }
      return this.updatedGeometrysEvent;
    },
    updatedGeometrysCallback: function updatedGeometrysCallback(geometrys) {
      var array = [];
      if (geometrys.length > 0) {
        for (var i = 0; i < geometrys.length; i++) {
          var geometry = PIEGeometryFactory.CreateInstance(geometrys[i]);
          array.push(geometry);
        }
      }
      this.updatedGeometrysEvent.raiseEvent(array);
    },
    /**
     * 设置编辑模式
     * @param {PIEEditMode} editMode -编辑模式
     * @memberOf Editor#
     */
    setEditMode: function setEditMode(editMode) {
      Module._Editor_SetEditMode(this.handle, editMode);
    },
    /**
     * 获取编辑模式
     *
     * @memberOf Editor#
     * @returns {PIEEditMode} 返回编辑模式
     */
    getEditMode: function getEditMode() {
      return Module._Editor_GetEditMode(this.handle);
    },
    /**
     * 设置节点编辑动作
     * @param {PIEEditAction} editAction -编辑动作
     * @memberOf Editor#
     */
    setEditAction: function setEditAction(editAction) {
      Module._Editor_SetEditAction(this.handle, editAction);
    },
    /**
     * 获取节点编辑动作
     *
     * @memberOf Editor#
     * @returns {PIEEditAction} 返回编辑动作
     */
    getEditAction: function getEditAction() {
      return Module._Editor_GetEditAction(this.handle);
    },
    /**
     * 设置锁定编辑状态
     * @param {Boolean} lockEdit -锁定编辑状态
     * @memberOf Editor#
     */
    setLockEditMode: function setLockEditMode(lockEdit) {
      Module._Editor_SetLockEditMode(this.handle, lockEdit);
    },
    /**
     * 获取锁定编辑状态
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回锁定编辑状态
     */
    isLockEditMode: function isLockEditMode() {
      return Boolean(Module._Editor_IsLockEditMode(this.handle));
    },
    /**
     * 设置是否显示锚点
     * @param {Boolean} visible -是否显示锚点
     * @memberOf Editor#
     */
    setHandleVisible: function setHandleVisible(visible) {
      Module._Editor_SetHandleVisible(this.handle, visible);
    },
    /**
     * 获取是否显示锚点
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否显示锚点
     */
    isHandleVisible: function isHandleVisible() {
      return Boolean(Module._Editor_IsHandleVisible(this.handle));
    },
    /**
     * 设置编辑锚点的大小
     * @param {Number} handleSize -编辑锚点的大小
     * @memberOf Editor#
     */
    setEditHandleSize: function setEditHandleSize(handleSize) {
      Module._Editor_SetEditHandleSize(this.handle, handleSize);
    },
    /**
     * 获取编辑锚点的大小
     *
     * @memberOf Editor#
     * @returns {Number} 返回编辑锚点的大小
     */
    getEditHandleSize: function getEditHandleSize() {
      return Module._Editor_GetEditHandleSize(this.handle);
    },
    // /**
    //  * 设置跟踪编辑几何对象风格
    //  * @param {PIEVectorStyle} style -几何对象风格
    //  * @memberOf Editor#
    //  *
    //  */
    setTrackVectorStyle: function setTrackVectorStyle(style) {
      Module._Editor_SetTrackVectorStyle(this.handle, style.getHandle());
    },
    // /**
    //  * 获取跟踪编辑几何对象风格
    //  *
    //  * @memberOf Editor#
    //  * @returns {PIEVectorStyle} 返回的几何对象风格
    //  */
    getTrackVectorStyle: function getTrackVectorStyle() {
      var handle = Module._Editor_GetTrackVectorStyle(this.handle);
      if (handle) {
        return new PIEVectorStyle(handle);
      }
      return null;
    },
    // /**
    //  * 设置跟踪编辑文本风格
    //  * @param {PIETextStyle} style -几何对象风格
    //  * @memberOf Editor#
    //  */
    setTrackTextStyle: function setTrackTextStyle(style) {
      Module._Editor_SetTrackTextStyle(this.handle, style.getHandle());
    },
    // /**
    //  * 获取跟踪编辑文本风格
    //  *
    //  * @memberOf Editor#
    //  * @returns {PIETextStyle} 返回的文本对象风格
    //  */
    getTrackTextStyle: function getTrackTextStyle() {
      var handle = Module._Editor_GetTrackTextStyle(this.handle);
      if (handle) {
        return new PIETextStyle(handle);
      }
      return null;
    },
    /**
     * 设置创建几何对象风格
     * @param {PIEVectorStyle} style -几何对象风格
     * @memberOf Editor#
     */
    setCreateVectorStyle: function setCreateVectorStyle(style) {
      Module._Editor_SetCreateVectorStyle(this.handle, style.getHandle());
    },
    /**
     * 获取创建几何对象风格
     *
     * @memberOf Editor#
     * @returns {PIEVectorStyle} 返回的几何对象风格
     */
    getCreateVectorStyle: function getCreateVectorStyle() {
      var handle = Module._Editor_GetCreateVectorStyle(this.handle);
      if (handle) {
        return new PIEVectorStyle(handle);
      }
      return null;
    },
    /**
     * 设置创建文本风格
     * @param {PIETextStyle} style -文本风格
     * @memberOf Editor#
     */
    setCreateTextStyle: function setCreateTextStyle(style) {
      Module._Editor_SetCreateTextStyle(this.handle, style.getHandle());
    },
    /**
     * 获取创建文本风格
     *
     * @memberOf Editor#
     * @returns {PIETextStyle} 返回的文本风格对象
     */
    getCreateTextStyle: function getCreateTextStyle() {
      var handle = Module._Editor_GetCreateTextStyle(this.handle);
      if (handle) {
        return new PIETextStyle(handle);
      }
      return null;
    },
    /**
     * 删除当前编辑对象
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功删除当前编辑对象
     */
    deleteEditObject: function deleteEditObject() {
      return Boolean(Module._Editor_DeleteEditObject(this.handle));
    },
    /**
     * 通过id删除当前编辑对象，ID对应上才删除
     * @param {Number} id -对象id
     * @memberOf Editor#
     *
     * @returns {Boolean} 返回是否成功删除当前编辑对象
     */
    deleteEditObjectByID: function deleteEditObjectByID(id) {
      return Boolean(Module._Editor_DeleteEditObjectByID(this.handle, id));
    },
    /**
     * 通过id移除当前编辑对象，ID对应上才移除
     * @param {Number} id -对象id
     * @memberOf Editor#
     *
     * @returns {Boolean} 返回是否成功删除当前编辑对象
     */
    removeEditGeometryByID: function removeEditGeometryByID(id) {
      return Boolean(Module._Editor_RemoveEditGeometryByID(this.handle, id));
    },
    /**
     * 提交当前编辑对象
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功提交当前编辑对象
     */
    submitEditObject: function submitEditObject() {
      return Boolean(Module._Editor_SubmitEditObject(this.handle));
    },
    /**
     * 是否能够进行重做操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否能够进行重做操作
     */
    canRedo: function canRedo() {
      return Boolean(Module._Editor_CanRedo(this.handle));
    },
    /**
     * 是否能进行回退操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否能够进行回退操作
     */
    canUndo: function canUndo() {
      return Boolean(Module._Editor_CanUndo(this.handle));
    },
    /**
     * 是否能够进行拷贝操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否能够进行拷贝操作
     */
    canCopy: function canCopy() {
      return Boolean(Module._Editor_CanCopy(this.handle));
    },
    /**
     * 是否能够进行剪切操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否能够进行剪切操作
     */
    canCut: function canCut() {
      return Boolean(Module._Editor_CanCut(this.handle));
    },
    /**
     * 是否能够进行粘贴操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否能够进行粘贴操作
     */
    canPaste: function canPaste() {
      return Boolean(Module._Editor_CanPaste(this.handle));
    },
    /**
     * 是否能够进行删除操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否能够进行删除操作
     */
    canDelete: function canDelete() {
      return Boolean(Module._Editor_CanDelete(this.handle));
    },
    /**
     * 拷贝操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功拷贝操作
     */
    copy: function copy() {
      return Boolean(Module._Editor_Copy(this.handle));
    },
    /**
     * 剪切操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功剪切操作
     */
    cut: function cut() {
      return Boolean(Module._Editor_Cut(this.handle));
    },
    /**
     * 粘贴操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功粘贴操作
     */
    paste: function paste() {
      return Boolean(Module._Editor_Paste(this.handle));
    },
    /**
     * 删除操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功删除操作
     */
    "delete": function _delete() {
      return Boolean(Module._Editor_Delete(this.handle));
    },
    /**
     * 重做操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功重做操作
     */
    redo: function redo() {
      return Boolean(Module._Editor_Redo(this.handle));
    },
    /**
     * 回退操作
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功回退操作
     */
    undo: function undo() {
      return Boolean(Module._Editor_Undo(this.handle));
    },
    /**
     * 编辑图层刷新操作
     * @param {Boolean} clearCache -是否清除缓存
     *
     * @memberOf Editor#
     * @returns {Boolean} 返回是否成功执行编辑图层刷新操作
     */
    refresh: function refresh(clearCache) {
      return Boolean(Module._Editor_Refresh(this.handle, clearCache));
    },
    // /**
    //  * 设置编辑对象
    //  * @param {PIEGeometry} geometry -几何对象
    //  * @memberOf Editor#
    //  */
    // setEditGeometry: function (geometry) {
    //     Module._Editor_SetEditGeometry(this.handle, geometry.getHandle());
    // },

    /**
     * 清除编辑对象
     * @memberOf GlobeEditor#
     */
    clearEditObject: function clearEditObject() {
      Module._Editor_ClearEditObject(this.handle);
    },
    /**
     * 更新编辑对象
     * @memberOf GlobeEditor#
     */
    updateEditGeometrys: function updateEditGeometrys() {
      Module._Editor_UpdateEditGeometrys(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 编辑模块
   * ---
   */

  /**
   * 三维场景编辑器操作相关函数
   * @name GlobeEditor
   *
   * @extends Editor
   */
  function PIEGlobeEditor(handle) {
    this.selectedGeometryEvent = null;
    PIEEditor.call(this, handle);
  }
  PIEGlobeEditor.prototype = Object.assign(Object.create(PIEEditor.prototype), {
    /**
     * 设置编辑图层
     * @param {PIEGlobeLayer} layer -需要编辑的图层(传null时，取消设置编辑图层)
     * @memberOf GlobeEditor#
     */
    setEditLayer: function setEditLayer(layer) {
      if (!layer) {
        Module._Globe_Editor_SetEditLayer(this.handle, null);
      } else {
        Module._Globe_Editor_SetEditLayer(this.handle, layer.getHandle());
      }
    },
    /**
     * 获取编辑图层
     *
     * @memberOf GlobeEditor#
     * @returns {PIEGlobeLayer} 返回编辑图层
     */
    getEditLayer: function getEditLayer() {
      var handle = Module._Globe_Editor_GetEditLayer(this.handle);
      if (handle) {
        return PIEGlobeLayerFactory.CreateInstance(handle);
      }
    },
    /**
     * 获取选择矢量的回调事件
     *
     * @memberOf GlobeEditor#
     * @returns {PIEEvent} 返回选择矢量的回调事件
     */
    getSelectedGeometryEvent: function getSelectedGeometryEvent() {
      if (this.selectedGeometryEvent == null) {
        this.selectedGeometryEvent = new PIEEvent();
        Module['setSelectedGeometryCallBack'](this.handle, this);
      }
      return this.selectedGeometryEvent;
    },
    selectedGeometryCallBack: function selectedGeometryCallBack(layers) {
      var array = [];
      if (layers.length > 0) {
        for (var i = 0; i < layers.length; i++) {
          var layer = PIEGlobeLayerFactory.CreateInstance(layers[i]);
          array.push(layer);
        }
      }
      this.selectedGeometryEvent.raiseEvent(array);
    },
    /**
     * 清除编辑对象
     * @memberOf GlobeEditor#
     */
    clearEditObject: function clearEditObject() {
      Module._Globe_Editor_ClearEditObject(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 场景工具类型枚举
   * @readonly
   * @enum {String}
   */
  var PIEGlobeToolType = {
    /** 场景平移  */
    Pan: 'PanGlobeTool',
    /** 场景选择  */
    Select: 'SelectGlobeTool',
    /** 场景编辑  */
    Edit: 'EditGlobeTool',
    /** 新建点  */
    CreatePoint: 'CreatePointGlobeTool',
    /** 新建多段线  */
    CreatePolyline: 'CreatePolylineGlobeTool',
    /** 新建多边形  */
    CreatePolygon: 'CreatePolygonGlobeTool',
    /** 新建自由线  */
    CreateFreeLine: 'CreateFreeLineGlobeTool',
    /** 新建自由多边形  */
    CreateFreePolygon: 'CreateFreePolygonGlobeTool',
    /** 新建矩形 */
    CreateRectangle: 'CreateRectangleGlobeTool',
    /** 新建圆  */
    CreateCircle: 'CreateCircleGlobeTool',
    // /** 新建椭圆  */
    //CreateEllipse: 'CreateEllipseGlobeTool',
    /** 新建扇形  */
    CreateSector: 'CreateSectorGlobeTool',
    /** 新建标绘  */
    CreatePlot: 'CreatePlotGlobeTool',
    /** 模型编辑  */
    EditModel: 'EditModelGlobeTool',
    /** 模型水平移动 **/
    EditPan: 'EditPanGlobeTool',
    /** 模型垂直移动 **/
    EditHeight: 'EditHeightGlobeTool',
    /** 模型缩放 **/
    EditScale: 'EditScaleGlobeTool',
    /** 模型旋转 **/
    EditRotate: 'EditRotateGlobeTool',
    /** 长度测量  */
    MeasureLength: 'MeasureLengthGlobeTool',
    /** 面积测量  */
    MeasureArea: 'MeasureAreaGlobeTool',
    /** 角度测量  */
    MeasureAngle: 'MeasureAngleGlobeTool',
    // /** DEM分析  */
    // AnalyseDEM: 'AnalyseDEMTool',
    /** 剖面分析  */
    Profile: 'ProfileGlobeTool',
    /** 挖填方分析  */
    AnalyseExcavation: 'AnalyseExcavationTool',
    /** 雷达分析  */
    AnalysisRadar: 'AnalysisRadarTool',
    /** 天际线分析  */
    Analyse3DSkyline: 'Analyse3DSkylineTool',
    /** 日照分析  */
    Analyse3DSunshine: 'Analyse3DSunshineTool',
    /**模型点线通视*/
    Analyse3DVisibleLine: 'Analyse3DVisibleLineTool',
    /**模型点面通视*/
    Analyse3DVisibleRegion: 'Analyse3DVisibleRegionTool',
    /**地形点线通视*/
    AnalyseVisibleLine: 'AnalyseVisibleLineTool',
    /**地形点面通视*/
    AnalyseVisibleRegion: 'AnalyseVisibleRegionTool',
    /** 空间角度测量  */
    Measure3DAngle: 'Measure3DAngleGlobeTool',
    /** 空间面积测量  */
    Measure3DArea: 'Measure3DAreaGlobeTool',
    /** 空间高度测量 */
    Measure3DHeight: 'Measure3DHeightGlobeTool',
    /** 空间长度测量  */
    Measure3DLength: 'Measure3DLengthGlobeTool',
    /** 淹没分析  */
    AnalyseVisibleFlood: 'AnalyseVisibleFloodTool',
    // /** 新建模型  */
    // CreateModel: 'CreateModelGlobeTool',
    /** 方位角  */
    MeasureAzimuthAngle: 'MeasureAzimuthAngleTool',
    /** 坡度坡向  */
    SlopeAspect: 'SlopeAspectTool',
    /** 三维绘制面  */
    CreatePolygon3D: 'CreatePolygon3DGlobeTool',
    /** 三维绘制线  */
    CreatePolyline3D: 'CreatePolyline3DGlobeTool',
    /** 三维绘制点  */
    CreatePoint3D: 'CreatePoint3DGlobeTool'
    // /** 新建文本  */
    // CreateText: 'CreateTextGlobeTool',
    // /** 贝赛尔曲线 */
    // CreateBezier: 'CreateBezierGlobeTool',
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * @name GlobeTool
   *
   */
  function PIEGlobeTool(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEGlobeTool.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    // /**
    //  * 获取场景工具操作ID
    //  *
    //  * @memberOf GlobeTool#
    //  * @returns {String} 返回场景工作ID
    //  * @example
    //  * let globeTool = new PIE.GlobeTool();
    //  * var actionID = globeTool.getActionID();
    //  */
    getActionID: function getActionID() {
      var strActionID = new PIEString$1(256);
      Module._GlobeTool_GetActionID(this.handle, strActionID.getHandle());
      var actionID = strActionID.toString();
      strActionID.dispose();
      return actionID;
    },
    /**
     * 获取场景工具操作状态
     *
     * @memberOf GlobeTool#
     * @returns {PIEGlobeToolStatus} 返回场景工具操作状态
     */
    getStatus: function getStatus() {
      return Module._GlobeTool_GetStatus(this.handle);
    },
    /**
     * 获取场景工具操作类型
     *
     * @memberOf GlobeTool#
     * @returns {PIEGlobeToolType} 返回场景工具操作类型
     */
    getType: function getType() {
      var strType = new PIEString$1(256);
      Module._GlobeTool_GetActionID(this.handle, strType.getHandle());
      var type = strType.toString();
      strType.dispose();
      return type;
    },
    /**
     * 设置场景工具是否可平移
     *
     * * @param {Boolean} enableTranslate -是否可平移
     * @memberOf GlobeTool#
     */
    setEnableTranslate: function setEnableTranslate(enableTranslate) {
      Module._GlobeTool_SetEnableTranslate(this.handle, enableTranslate);
    },
    /**
     * 设置鼠标是否可以在三维地球外拖动地球
     *
     * * @param {Boolean} enable -是否可拖动
     * @memberOf GlobeTool#
     */
    setEnableFullScreenPan: function setEnableFullScreenPan(enable) {
      Module._GlobeTool_SetEnableFullScreenPan(this.handle, enable);
    },
    /**
     * 设置场景工具是否可旋转
     *
     * * @param {Boolean} enableRotate -是否可旋转
     * @memberOf GlobeTool#
     */
    setEnableRotate: function setEnableRotate(enableRotate) {
      Module._GlobeTool_SetEnableRotate(this.handle, enableRotate);
    },
    /**
     * 设置场景工具是否可缩放
     *
     * * @param {Boolean} enableZoom -是否可缩放
     * @memberOf GlobeTool#
     */
    setEnableZoom: function setEnableZoom(enableZoom) {
      Module._GlobeTool_SetEnableZoom(this.handle, enableZoom);
    },
    /**
     * 获取场景工具是否可旋转
     *
     * @memberOf GlobeTool#
     * @returns {Boolean} 返回场景工具是否可旋转
     */
    getEnableTranslate: function getEnableTranslate() {
      return Boolean(Module._GlobeTool_GetEnableTranslate(this.handle));
    },
    /**
     * 获取场景工具是否可平移
     *
     * @memberOf GlobeTool#
     * @returns {Boolean} 返回场景工具是否可平移
     */
    getEnableRotate: function getEnableRotate() {
      return Boolean(Module._GlobeTool_GetEnableRotate(this.handle));
    },
    /**
     * 获取场景工具是否可缩放
     *
     * @memberOf GlobeTool#
     * @returns {Boolean} 返回场景工具是否可缩放
     */
    getEnableZoom: function getEnableZoom() {
      return Boolean(Module._GlobeTool_GetEnableZoom(this.handle));
    },
    /**
     * 清除绘制结果
     *
     * @memberOf GlobeTool#
     */
    clearResult: function clearResult() {
      Module._GlobeTool_ClearResult(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建三维场景平移工具相关操作函数
   * @name CreatePanGlobeTool
   * @extends GlobeTool
   */
  function PIECreatePanGlobeTool(handle, autoRelease) {
    if (handle == null) {
      handle = Module._PanGlobeTool_GetHandle();
      autoRelease = true;
    }
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePanGlobeTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   *三维场景标绘工具操作相关函数
   * @name CreatePlotGlobeTool
   * @extends GlobeCreateTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreatePlot);
   * var globeTool = globeControl.getGlobeTool();
   *
   */
  function PIECreatePlotGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreatePlotGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIECreatePanGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePlotGlobeTool.prototype = Object.assign(Object.create(PIECreatePanGlobeTool.prototype), {
    /**
     * 设置标绘符号编号
     * @param {Number} shape -编号
     * @memberOf CreatePlotGlobeTool#
     */
    setShape: function setShape(shape) {
      Module._CreatePlotGlobeTool_SetShape(this.handle, shape);
    },
    /**
     * 获取标绘符号编号
     *
     * @memberOf CreatePlotGlobeTool#
     * @returns {Number} 返回编号
     */
    getShape: function getShape() {
      return Module._CreatePlotGlobeTool_GetShape(this.handle);
    },
    /**
     * 设置标绘线颜色
     * @param {PIEColoe|Array} shape -颜色
     * @memberOf CreatePlotGlobeTool#
     */
    setLineColor: function setLineColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray && colorArray.length == 4) {
        var arrColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._CreatePlotGlobeTool_SetLineColor(this.handle, arrColor.getHandle());
        arrColor.dispose();
      }
    },
    /**
     * 设置创建标绘的尺寸
     * @param {Number} size -尺寸大小
     * @memberOf CreatePlotGlobeTool#
     */
    setPlotSize: function setPlotSize(size) {
      Module._CreatePlotGlobeTool_SetPlotSize(this.handle, size);
    },
    /**
     * 设置创建标绘的尺寸类别
     * @param {PIESymbolSizeMode} mode -标绘的尺寸类别
     * @memberOf CreatePlotGlobeTool#
     */
    setSizeMode: function setSizeMode(mode) {
      Module._CreatePlotGlobeTool_SetSizeMode(this.handle, mode);
    },
    /**
     * 设置创建标绘的线宽
     * @param {Number} width -标绘的线宽
     * @memberOf CreatePlotGlobeTool#
     */
    setLineWidth: function setLineWidth(width) {
      Module._CreatePlotGlobeTool_SetLineWidth(this.handle, width);
    },
    /**
     * 设置创建标绘的填充颜色
     * @param {PIEColor|Array} color -填充颜色
     * @memberOf CreatePlotGlobeTool#
     */
    setFillForeColor: function setFillForeColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray && colorArray.length == 4) {
        var arrColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._CreatePlotGlobeTool_SetFillForeColor(this.handle, arrColor.getHandle());
        arrColor.dispose();
      }
    },
    /**
     * 设置创建标绘的填充方式
     * @param {PIEFillModeType} mode -标绘的填充方式
     * @memberOf CreatePlotGlobeTool#
     */
    setFillMode: function setFillMode(mode) {
      Module._CreatePlotGlobeTool_SetFillMode(this.handle, mode);
    },
    /**
     * 设置创建标绘的显风格
     * @param {PIEDisplayType} type -标绘的显示风格
     * @memberOf CreatePlotGlobeTool#
     */
    setDisplayType: function setDisplayType(type) {
      Module._CreatePlotGlobeTool_SetDisplayType(this.handle, type);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 平移工具相关函数
   * @name PanGlobeTool
   * @extends GlobeTool
   */
  function PIEPanGlobeTool(handle, autoRelease) {
    if (handle == null) {
      handle = Module._PanGlobeTool_GetHandle();
      autoRelease = true;
    }
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIEPanGlobeTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {
    // /**
    //  * 单指按下事件响应
    //  * @param {PIEVector2} point -点击位置
    //  * @param {Number} nFlags -附件标识符
    //  * @param {Number} nButton -鼠标左右键标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应单指按下事件
    //  */
    onTouchDown: function onTouchDown(point, nFlags, nButton) {
      var vcrpoint = new PIEArray(point, PIEArrayType.Float32);
      var res = Module._PanGlobeTool_OnTouchDown(this.handle, vcrpoint.getHandle(), nFlags, nButton);
      vcrpoint.dispose();
      return res;
    },
    // /**
    //  * 单指移动事件响应
    //  * @param {PIEVector2} point -点击位置
    //  * @param {Number} nFlags -附件标识符
    //  * @param {Number} nButton -鼠标左右键标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应单指移动事件
    //  */
    onTouchMove: function onTouchMove(point, nFlags, nButton) {
      var vcrpoint = new PIEArray(point, PIEArrayType.Float32);
      var res = Module._PanGlobeTool_OnTouchMove(this.handle, vcrpoint.getHandle(), nFlags, nButton);
      vcrpoint.dispose();
      return res;
    },
    // /**
    //  * 单指抬起事件响应
    //  * @param {PIEVector2} point -点击位置
    //  * @param {Number} nFlags -附件标识符
    //  * @param {Number} nButton -鼠标左右键标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应单指抬起事件
    //  */
    onTouchUp: function onTouchUp(point, nFlags, nButton) {
      var vcrpoint = new PIEArray(point, PIEArrayType.Float32);
      var res = Module._PanGlobeTool_OnTouchUp(this.handle, vcrpoint.getHandle(), nFlags, nButton);
      vcrpoint.dispose();
      return res;
    },
    // /**
    //  * 双指按下事件响应
    //  * @param {PIEVector2} first -点击位置
    //  * @param {PIEVector2} second -点击位置
    //  * @param {Number} nFlags -附件标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应双指按下事件
    //  */
    onPointerTouchDown: function onPointerTouchDown(first, second, nFlags) {
      var vcrfirst = new PIEArray(first, PIEArrayType.Float32);
      var vcrsecond = new PIEArray(second, PIEArrayType.Float32);
      var res = Module._PanGlobeTool_OnPointerTouchDown(this.handle, vcrfirst.getHandle(), vcrsecond.getHandle(), nFlags);
      vcrfirst.dispose();
      vcrsecond.dispose();
      return res;
    },
    // /**
    //  * 双指移动事件响应
    //  * @param {PIEVector2} first -点击位置
    //  * @param {PIEVector2} second -点击位置
    //  * @param {Number} nFlags -附件标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应双指移动事件
    //  */
    onPointerTouchMove: function onPointerTouchMove(first, second, nFlags) {
      var vcrfirst = new PIEArray(first, PIEArrayType.Float32);
      var vcrsecond = new PIEArray(second, PIEArrayType.Float32);
      var res = Module._PanGlobeTool_OnPointerTouchMove(this.handle, vcrfirst.getHandle(), vcrsecond.getHandle(), nFlags);
      vcrfirst.dispose();
      vcrsecond.dispose();
      return res;
    },
    // /**
    //  * 双指抬起事件响应
    //  * @param {PIEVector2} first -点击位置
    //  * @param {PIEVector2} second -点击位置
    //  * @param {Number} nTouchUp -附件标识符
    //  * @param {Number} nFlags -附件标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应双指抬起事件
    //  */
    onPointerTouchUp: function onPointerTouchUp(first, second, nTouchUp, nFlags) {
      var vcrfirst = new PIEArray(first, PIEArrayType.Float32);
      var vcrsecond = new PIEArray(second, PIEArrayType.Float32);
      var res = Module._PanGlobeTool_OnPointerTouchUp(this.handle, vcrfirst.getHandle(), vcrsecond.getHandle(), nTouchUp, nFlags);
      vcrfirst.dispose();
      vcrsecond.dispose();
      return res;
    },
    // /**
    //  * 键盘按键事件响应
    //  * @param {Number} nChar -键盘按键标识
    //  * @param {Number} nRepCnt -连续按键次数
    //  * @param {Number} nFlags -附加标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应键盘按键事件
    //  */
    onKeyDown: function onKeyDown(nChar, nRepCnt, nFlags) {
      return Module._PanGlobeTool_OnKeyDown(this.handle, nChar, nRepCnt, nFlags);
    },
    // /**
    //  * 键盘按键抬起事件响应
    //  * @param {Number} nChar -键盘按键标识
    //  * @param {Number} nRepCnt -连续按键次数
    //  * @param {Number} nFlags -附加标识符
    //  *
    //  * @memberOf PanGlobeTool#
    //  * @returns {Boolean} 返回是否成功响应键盘按键事件
    //  */
    onKeyUp: function onKeyUp(nChar, nRepCnt, nFlags) {
      return Module._PanGlobeTool_OnKeyUp(this.handle, nChar, nRepCnt, nFlags);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建几何对象中间基类相关函数
   * @name PanGeometryGlobeTool
   * @extends PanGlobeTool
   */
  function PIEPanGeometryGlobeTool(handle, autoRelease) {
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEPanGeometryGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 设置工具绘制的几何对象风格
     * @param {PIEVectorStyle} style -几何对象风格(风格对象传入后内部会进行克隆，外部必须释放传入的风格对象，否则会出现内存泄露)
     * @memberOf PanGeometryGlobeTool#
     *
     */
    setStyle: function setStyle(style) {
      if (!(style instanceof PIEVectorStyle)) {
        return;
      }
      if (this.getType() == PIEGlobeToolType.CreatePolyline || this.getType() == PIEGlobeToolType.CreatePolygon) {
        style.setLineStyle(3);
        style.setFillStyle(3);
      }
      Module._PanGeometryGlobeTool_SetStyle(this.handle, style.getHandle());
    },
    /**
     * 获取绘制几何对象风格
     *
     * @memberOf PanGeometryGlobeTool#
     * @returns {PIEVectorStyle} 返回的几何对象风格
     */
    getStyle: function getStyle() {
      var handle = Module._PanGeometryGlobeTool_GetStyle(this.handle);
      return PIEStyleFactory.CreateInstance(handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   *三维场景绘图工具操作相关函数
   * @name CreateCircleGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   *  var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   globeControl.setGlobeTool(PIE.GlobeToolType.CreateCircle);
   *
   */
  function PIECreateCircleGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateCircleGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateCircleGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     *设置半径
     * @param {Number} r -半径
     * @memberOf CreateCircleGlobeTool#
     */
    setRadius: function setRadius(r) {
      Module._CreateCircleGlobeTool_SetRadius(this.handle, r);
    },
    /**
     * 获取创建的回调事件
     * @memberOf CreateCircleGlobeTool#
     * @returns {PIEEvent} 返回创建结束后的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.CreateCallBackEvent == null) {
        this.CreateCallBackEvent = new PIEEvent();
        Module['setCreateCircleCallBack'](this.handle, this);
      }
      return this.CreateCallBackEvent;
    },
    createCircleCallBack: function createCircleCallBack(circle) {
      var geometry = PIEGeometryFactory.CreateInstance(circle);
      this.CreateCallBackEvent.raiseEvent(geometry);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 三维场景模型工具操作相关函数
   * @name CreateModelGlobeTool
   * @extends PanGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateModel);
   * var globeTool = globeControl.getGlobeTool();
   */

  function PIECreateModelGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateModelGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateModelGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 设置风格
     * @param {PIEModelStyle} modelStyle -模型风格
     * @memberOf PIECreateModelGlobeTool#
     *
     */
    setModelStyle: function setModelStyle(modelStyle) {
      return Module._CreateModelGlobeTool_SetModelStyle(this.handle, modelStyle.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建三维场景椭圆工具操作相关函数
   * @name CreateEllipseGlobeTool
   * @extends GlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateEllipse);
   * var globeTool = globeControl.getGlobeTool();
   *
   */
  function PIECreateEllipseGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateEllipseGlobeTool_Gethandle(handle);
      autoRelease = true;
    }
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateEllipseGlobeTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 三维场景自由线工具操作相关函数
   * @name CreateFreeLineGlobeTool
   * @extends GlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateFreeLine);
   * var globeTool = globeControl.getGlobeTool();
   *
   */
  function PIECreateFreeLineGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateFreeLineGlobeTool_Gethandle(handle);
      autoRelease = true;
    }
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateFreeLineGlobeTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 三维场景自由多边形工具操作相关函数
   * @name CreateFreePolygonGlobeTool
   * @extends GlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateFreePolygon);
   * var globeTool = globeControl.getGlobeTool();
   */
  function PIECreateFreePolygonGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateFreePolygonGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateFreePolygonGlobeTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   *
   * 三维场景点工具操作相关函数
   * @name CreatePointGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreatePoint);
   * var globeTool = globeControl.getGlobeTool();
   *
   */
  function PIECreatePointGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreatePointGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePointGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     * 获取添加几何对象之前的回调事件
     *
     * @memberOf CreatePointGlobeTool#
     * @returns {PIEEvent} 返回添加几何对象之前的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.CreatePointEvent == null) {
        this.CreatePointEvent = new PIEEvent();
        Module['setCreatePointCallBack'](this.handle, this);
      }
      return this.CreatePointEvent;
    },
    createPointCallBack: function createPointCallBack(point) {
      var geometry = PIEGeometryFactory.CreateInstance(point);
      this.CreatePointEvent.raiseEvent(geometry);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建三维场景面工具操作相关函数
   * @name CreatePolygonGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreatePolygon);
   * var globeTool = globeControl.getGlobeTool();
   */
  function PIECreatePolygonGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreatePolygonGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePolygonGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     * 获取创建的回调事件
     * @memberOf CreatePolygonGlobeTool#
     * @returns {PIEEvent} 返回创建结束后的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.CreateCallBackEvent == null) {
        this.CreateCallBackEvent = new PIEEvent();
        Module['setCreatePolygonCallBack'](this.handle, this);
      }
      return this.CreateCallBackEvent;
    },
    createPolygonCallBack: function createPolygonCallBack(polygon) {
      var geometry = PIEGeometryFactory.CreateInstance(polygon);
      this.CreateCallBackEvent.raiseEvent(geometry);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建三维场景矩形工具操作相关函数
   * @name CreateRectangleGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateRectangle);
   * var globeTool = globeControl.getGlobeTool();
   */
  function PIECreateRectangleGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateRectangleGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateRectangleGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     * 获取创建的回调事件
     * @memberOf CreateRectangleGlobeTool#
     * @returns {PIEEvent} 返回创建结束后的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.CreateCallBackEvent == null) {
        this.CreateCallBackEvent = new PIEEvent();
        Module['setCreateRectangleCallBack'](this.handle, this);
      }
      return this.CreateCallBackEvent;
    },
    createRectangleCallBack: function createRectangleCallBack(rectangle) {
      var geometry = PIEGeometryFactory.CreateInstance(rectangle);
      this.CreateCallBackEvent.raiseEvent(geometry);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 分析工具相关函数
   * @name AnalyseTool
   *
   * @extends GlobeTool
   */
  function PIEAnalyseTool(handle, autoRelease) {
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIEAnalyseTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 淹没分析工具相关函数
   * @name AnalyseFloodTool
   *
   * @extends AnalyseTool
   */
  function PIEAnalyseFloodTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._AnalyseFloodTool_GetHandle(handle);
    }
    this.analyseOverEvent = null;
    PIEAnalyseTool.call(this, handle, autoRelease);
  }
  PIEAnalyseFloodTool.prototype = Object.assign(Object.create(PIEAnalyseTool.prototype), {
    /**
     * 获取淹没分析计算的回调事件
     * @memberOf AnalyseFloodTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.analyseOverEvent == null) {
        this.analyseOverEvent = new PIEEvent();
        Module['setFloodAnalyseOverSignal'](this.handle, this);
      }
      return this.analyseOverEvent;
    },
    analyseOverCallback: function analyseOverCallback() {
      this.analyseOverEvent.raiseEvent();
    },
    /**
     * 设置淹没高度
     * @param {Number} height -高度值
     * @memberOf AnalyseFloodTool#
     */
    setHeight: function setHeight(height) {
      Module._AnalyseFloodTool_SetFloodHeight(this.handle, height);
    },
    /**
     * 获取淹没高度
     *
     * @memberOf AnalyseFloodTool#
     * @returns {Number} 返回淹没高度
     */
    getHeight: function getHeight() {
      return Module._AnalyseFloodTool_GetFloodHeight(this.handle);
    },
    /**
     * 获取淹没面积
     *
     * @memberOf AnalyseFloodTool#
     * @returns {Number} 返回淹没面积
     */
    getArea: function getArea() {
      return Module._AnalyseFloodTool_GetFloodArea(this.handle);
    },
    /**
     * 获取淹没体积
     *
     * @memberOf AnalyseFloodTool#
     * @returns {Number} 返回淹没体积
     */
    getVolume: function getVolume() {
      return Module._AnalyseFloodTool_GetFloodVolume(this.handle);
    },
    /**
     * 获取最大高度
     *
     * @memberOf AnalyseFloodTool#
     * @returns {Number} 返回最大高度
     */
    getMaximumHeight: function getMaximumHeight() {
      return Module._AnalyseFloodTool_GetFloodMaximumHeight(this.handle);
    },
    /**
     * 获取最小高度
     *
     * @memberOf AnalyseFloodTool#
     * @returns {Number} 返回最小高度
     */
    getMinimumHeight: function getMinimumHeight() {
      return Module._AnalyseFloodTool_GetFloodMinimumHeight(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 挖填方分析工具相关函数
   * @name AnalyseExcavationTool
   *
   * @extends AnalyseTool
   */
  function PIEAnalyseExcavationTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._AnalyseExcavationTool_GetHandle(handle);
    }
    this.analyseOverEvent = null;
    PIEAnalyseTool.call(this, handle, autoRelease);
  }
  PIEAnalyseExcavationTool.prototype = Object.assign(Object.create(PIEAnalyseTool.prototype), {
    /**
     * 获取挖填方分析计算的回调事件
     * @memberOf AnalyseExcavationTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.analyseOverEvent == null) {
        this.analyseOverEvent = new PIEEvent();
        Module['setExcavationAnalyseOverSignal'](this.handle, this);
      }
      return this.analyseOverEvent;
    },
    analyseOverCallback: function analyseOverCallback() {
      this.analyseOverEvent.raiseEvent();
    },
    /**
     * 设置挖填方高度
     * @param {Number} height -高度值
     * @memberOf AnalyseExcavationTool#
     *
     */
    setExcavationBumpHeight: function setExcavationBumpHeight(height) {
      Module._AnalyseExcavationTool_SetExcavationBumpHeight(this.handle, height);
    },
    /**
     * 设置挖填方类型
     * @param {Number} type -挖填方类型(0:挖方 1:填方)
     * @memberOf AnalyseExcavationTool#
     */
    setExcavationBumpType: function setExcavationBumpType(type) {
      Module._AnalyseExcavationTool_SetExcavationBumpType(this.handle, type);
    },
    /**
     * 获取地表面积
     *
     * @memberOf AnalyseExcavationTool#
     * @returns {Number} 返回地表面积
     */
    getSurfaceArea: function getSurfaceArea() {
      return Module._AnalyseExcavationTool_GetSurfaceArea(this.handle);
    },
    /**
     * 获取挖填方体积
     *
     * @memberOf AnalyseExcavationTool#
     * @returns {Number} 返回挖填方体积
     */
    getExcavationBumpVolume: function getExcavationBumpVolume() {
      return Module._AnalyseExcavationTool_GetExcavationBumpVolume(this.handle);
    },
    /**
     * 获取地形最大高度
     *
     * @memberOf AnalyseExcavationTool#
     * @returns {Number} 返回最大高度
     */
    getTerrainMaximumHeight: function getTerrainMaximumHeight() {
      return Module._AnalyseExcavationTool_GetTerrainMaximumHeight(this.handle);
    },
    /**
     * 获取地形最小高度
     *
     * @memberOf AnalyseExcavationTool#
     * @returns {Number} 返回最小高度
     */
    getTerrainMinimumHeight: function getTerrainMinimumHeight() {
      return Module._AnalyseExcavationTool_GetTerrainMinimumHeight(this.handle);
    },
    /**
     * 清除几何对象
     * @memberOf AnalyseExcavationTool#
     */
    deleteObject: function deleteObject() {
      Module._AnalyseExcavationTool_DeleteObject(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 天际线分析工具相关函数
   * @name AnalyseSkylineTool
   *
   * @extends AnalyseTool
   */
  function PIEAnalyseSkylineTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._AnalyseSkylineTool_GetHandle(handle);
    }
    PIEAnalyseTool.call(this, handle, autoRelease);
  }
  PIEAnalyseSkylineTool.prototype = Object.assign(Object.create(PIEAnalyseTool.prototype), {
    /**
     * 设置视面是否可见
     * @param {Boolean} visible -是否可见
     * @memberOf AnalyseSkylineTool#
     */
    setRegionVisible: function setRegionVisible(visible) {
      Module._AnalyseSkylineTool_SetRegionVisible(this.handle, visible);
    },
    /**
     * 设置相机是否可见
     * @param {Boolean} visible -是否可见
     * @memberOf AnalyseSkylineTool#
     */
    setCameraVisible: function setCameraVisible(visible) {
      Module._AnalyseSkylineTool_SetCameraVisible(this.handle, visible);
    },
    /**
     * 绘制
     * @memberOf AnalyseSkylineTool#
     */
    draw: function draw() {
      Module._AnalyseSkylineTool_Draw(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 地形剖面分析工具相关函数
   * @name ProfileGlobeTool
   * @extends PanGlobeTool
   */
  function PIEProfileGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._ProfileGlobeTool_GetHandle(handle);
    }
    this.calculateOverEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEProfileGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取地形剖面分析计算的回调事件
     *
     * @memberOf ProfileGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.calculateOverEvent == null) {
        this.calculateOverEvent = new PIEEvent();
        Module['setProfileCalculateOverSignal'](this.handle, this);
      }
      return this.calculateOverEvent;
    },
    calculateOverCallback: function calculateOverCallback() {
      this.calculateOverEvent.raiseEvent();
    },
    /**
     * 获取高度值数据
     *
     * @memberOf ProfileGlobeTool#
     * @returns {Array} 返回高度值数据
     */
    getAltitudeData: function getAltitudeData() {
      var arrayData = new PIEArray(90, PIEArrayType.Float64);
      Module._PIE_ProfileGlobeTool_GetAltitudeData(this.handle, arrayData.getHandle());
      arrayData.updateData();
      var data = arrayData.toArray();
      arrayData.dispose();
      var altitudeData = [];
      var vecData = null;
      for (var i = 0; i < 90; i += 3) {
        vecData = new PIEVector3(data[i], data[i + 1], data[i + 2]);
        altitudeData.push(vecData);
      }
      return altitudeData;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   *
   * 三维场景线工具操作相关函数
   * @name CreatePolylineGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreatePolyline);
   * var globeTool = globeControl.getGlobeTool();
   *
   */
  function PIECreatePolylineGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreatePolylineGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePolylineGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     * 获取创建的回调事件
     * @memberOf CreatePolylineGlobeTool#
     * @returns {PIEEvent} 返回创建结束后的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.CreatePolylineEvent == null) {
        this.CreatePolylineEvent = new PIEEvent();
        Module['setCreatePolylineCallBack'](this.handle, this);
      }
      return this.CreatePolylineEvent;
    },
    createPolylineCallBack: function createPolylineCallBack(line) {
      var geometry = PIEGeometryFactory.CreateInstance(line);
      this.CreatePolylineEvent.raiseEvent(geometry);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 地表测距分析工具相关函数
   * @name MeasureLengthGlobeTool
   * @extends PanGlobeTool
   */
  function PIEMeasureLengthGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureLengthGlobeTool_GetHandle(handle);
    }
    this.measureLengthEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasureLengthGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取地表测距计算的回调事件
     * @memberOf MeasureLengthGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measureLengthEvent == null) {
        this.measureLengthEvent = new PIEEvent();
        Module['setMeasureLengthCallBack'](this.handle, this);
      }
      return this.measureLengthEvent;
    },
    measureLengthCallback: function measureLengthCallback(length) {
      this.measureLengthEvent.raiseEvent(length);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 地表面积分析工具相关函数
   * @name MeasureAreaGlobeTool
   * @extends PanGlobeTool
   */
  function PIEMeasureAreaGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureAreaGlobeTool_GetHandle(handle);
    }
    this.measureAreaEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasureAreaGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取地表面积计算的回调事件
     * @memberOf MeasureAreaGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measureAreaEvent == null) {
        this.measureAreaEvent = new PIEEvent();
        Module['setMeasureAreaCallBack'](this.handle, this);
      }
      return this.measureAreaEvent;
    },
    measureAreaCallback: function measureAreaCallback(area) {
      this.measureAreaEvent.raiseEvent(area);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 测量方位角分析工具相关函数
   * @name MeasureAzimuthAngleTool
   * @extends PanGlobeTool
   */
  function PIEMeasureAzimuthAngleTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureAzimuthAngleTool_GetHandle(handle);
    }
    this.measureAzimuthAngleEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasureAzimuthAngleTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取测量方位角计算的回调事件
     * @memberOf MeasureAzimuthAngleTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measureAzimuthAngleEvent == null) {
        this.measureAzimuthAngleEvent = new PIEEvent();
        Module['setMeasureAzimuthAngleCallBack'](this.handle, this);
      }
      return this.measureAzimuthAngleEvent;
    },
    measureAzimuthAngleCallback: function measureAzimuthAngleCallback(area) {
      this.measureAzimuthAngleEvent.raiseEvent(area);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 地表角度分析工具相关函数
   * @name MeasureAngleGlobeTool
   * @extends PanGlobeTool
   */
  function PIEMeasureAngleGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureAngleGlobeTool_GetHandle(handle);
    }
    this.measureAngleEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasureAngleGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取地表角度计算的回调事件
     * @memberOf MeasureAngleGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measureAngleEvent == null) {
        this.measureAngleEvent = new PIEEvent();
        Module['setMeasureAngleCallBack'](this.handle, this);
      }
      return this.measureAngleEvent;
    },
    measureAngleCallback: function measureAngleCallback(angle) {
      this.measureAngleEvent.raiseEvent(angle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 坡度坡向分析工具相关函数
   * @name SlopeAspectTool
   * @extends PanGlobeTool
   */
  function PIESlopeAspectTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._SlopeAspectTool_GetHandle(handle);
    }
    this.slopeAspectEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIESlopeAspectTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取坡度坡向计算的回调事件
     * @memberOf SlopeAspectTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.slopeAspectEvent == null) {
        this.slopeAspectEvent = new PIEEvent();
        Module['setSlopeAspectCallBack'](this.handle, this);
      }
      return this.slopeAspectEvent;
    },
    slopeAspectCallback: function slopeAspectCallback(area) {
      this.slopeAspectEvent.raiseEvent(area);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建三维场景面工具操作相关函数
   * @name CreatePolygon3DGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreatePolygon3D);
   * var globeTool = globeControl.getGlobeTool();
   */
  function PIECreatePolygon3DGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreatePolygon3DGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePolygon3DGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     * 获取创建面的回调事件
     * @memberOf CreatePolygon3DGlobeTool#
     * @returns {PIEEvent} 返回创建面结束后的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.createPolygon3DEvent == null) {
        this.createPolygon3DEvent = new PIEEvent();
        Module['setCreatePolygon3DCallBack'](this.handle, this);
      }
      return this.createPolygon3DEvent;
    },
    createPolygon3DCallback: function createPolygon3DCallback(area, Status) {
      this.createPolygon3DEvent.raiseEvent(area, Status);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 空间长度分析工具相关函数
   * @name Measure3DLengthGlobeTool
   * @extends PanGlobeTool
   */
  function PIEMeasure3DLengthGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureOSGBLengthGlobeTool_GetHandle(handle);
    }
    this.measure3DLengthEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasure3DLengthGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取空间长度计算的回调事件
     * @memberOf Measure3DLengthGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measure3DLengthEvent == null) {
        this.measure3DLengthEvent = new PIEEvent();
        Module['setMeasureOSGBLengthCallBack'](this.handle, this);
      }
      return this.measure3DLengthEvent;
    },
    measureOSGBLengthCallback: function measureOSGBLengthCallback(length) {
      this.measure3DLengthEvent.raiseEvent(length);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 空间高度分析工具相关函数
   * @name Measure3DHeightGlobeTool
   * @extends PanGlobeTool
   */
  function PIEMeasure3DHeightGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureOSGBHeightGlobeTool_GetHandle(handle);
    }
    this.measure3DHeightEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasure3DHeightGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取空间高度计算的回调事件
     * @memberOf Measure3DHeightGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measure3DHeightEvent == null) {
        this.measure3DHeightEvent = new PIEEvent();
        Module['setMeasureOSGBHeightCallBack'](this.handle, this);
      }
      return this.measure3DHeightEvent;
    },
    measureOSGBHeightCallback: function measureOSGBHeightCallback(height) {
      this.measure3DHeightEvent.raiseEvent(height);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 空间面积分析工具相关函数
   * @name Measure3DAreaGlobeTool
   * @extends PanGlobeTool
   */
  function PIEMeasure3DAreaGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureOSGBAreaGlobeTool_GetHandle(handle);
    }
    this.measure3DAreaEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasure3DAreaGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取空间面积计算的回调事件
     * @memberOf Measure3DAreaGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measure3DAreaEvent == null) {
        this.measure3DAreaEvent = new PIEEvent();
        Module['setMeasureOSGBAreaCallBack'](this.handle, this);
      }
      return this.measure3DAreaEvent;
    },
    measureOSGBAreaCallback: function measureOSGBAreaCallback(area) {
      this.measure3DAreaEvent.raiseEvent(area);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 空间角度分析工具相关函数
   * @name Measure3DAngleGlobeTool
   * @extends PanGlobeTool
   */
  function PIEMeasure3DAngleGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._MeasureOSGBAngleGlobeTool_GetHandle(handle);
    }
    this.measure3DAngleEvent = null;
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIEMeasure3DAngleGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 获取空间角度计算的回调事件
     * @memberOf Measure3DAngleGlobeTool#
     * @returns {PIEEvent} 返回计算结束的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.measure3DAngleEvent == null) {
        this.measure3DAngleEvent = new PIEEvent();
        Module['setMeasureOSGBAngleCallBack'](this.handle, this);
      }
      return this.measure3DAngleEvent;
    },
    measureOSGBAngleCallback: function measureOSGBAngleCallback(Angle) {
      this.measure3DAngleEvent.raiseEvent(Angle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   *
   * 三维场景线工具操作相关函数
   * @name CreatePolyline3DGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreatePolyline3D);
   * var globeTool = globeControl.getGlobeTool();
   *
   */
  function PIECreatePolyline3DGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreatePolyline3DGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePolyline3DGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     * 获取创建线的回调事件
     * @memberOf CreatePolyline3DGlobeTool#
     * @returns {PIEEvent} 返回创建线结束后的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.createPolyline3DEvent == null) {
        this.createPolyline3DEvent = new PIEEvent();
        Module['setCreatePolyline3DCallBack'](this.handle, this);
      }
      return this.createPolyline3DEvent;
    },
    createPolyline3DCallback: function createPolyline3DCallback(area, Status) {
      this.createPolyline3DEvent.raiseEvent(area, Status);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   *
   * 三维场景点工具操作相关函数
   * @name CreatePoint3DGlobeTool
   * @extends PIEPanGeometryGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreatePoint3D);
   * var globeTool = globeControl.getGlobeTool();
   *
   */
  function PIECreatePoint3DGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreatePoint3DGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGeometryGlobeTool.call(this, handle, autoRelease);
  }
  PIECreatePoint3DGlobeTool.prototype = Object.assign(Object.create(PIEPanGeometryGlobeTool.prototype), {
    /**
     * 获取创建点的回调事件
     * @memberOf CreatePoint3DGlobeTool#
     * @returns {PIEEvent} 返回创建点结束后的回调事件
     */
    getResultEvent: function getResultEvent() {
      if (this.CreatePoint3DEvent == null) {
        this.CreatePoint3DEvent = new PIEEvent();
        Module['setCreatePoint3DCallBack'](this.handle, this);
      }
      return this.CreatePoint3DEvent;
    },
    CreatePoint3DCallback: function CreatePoint3DCallback(area, Status) {
      this.CreatePoint3DEvent.raiseEvent(area, Status);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建绘制扇形工具操作相关函数
   * @name CreateSectorGlobeTool
   * @extends PanGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateSector);
   * var globeTool = globeControl.getGlobeTool();
   */
  function PIECreateSectorGlobeTool(handle, autoRelease) {
    if (handle != null) {
      Module._CreateSectorGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateSectorGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 设置角半径
     * @param {Number} a -角
     * @param {Number} r -半径
     * @memberOf CreateSectorGlobeTool#
     */
    SetAngleRadius: function SetAngleRadius(a, r) {
      return Module._CreateSectorGlobeTool_SetAngleRadius(this.handle, a, r);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建三维场景文本工具操作相关函数
   * @name CreateTextGlobeTool
   * @extends PanGlobeTool
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateText);
   * var globeTool = globeControl.getGlobeTool();
   */
  function PIECreateTextGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateTextGlobeTool_GetHandle(handle);
      autoRelease = true;
    }
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateTextGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 贝赛尔曲线工具操作相关函数
   * @name CreateBezierGlobeTool
   * @extends PanGlobeTool
   *
   * @example
   * var globeControl = new PIE.GlobeControl({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
          });
   * globeControl.setGlobeTool(PIE.GlobeToolType.CreateBezier);
   * var globeTool = globeControl.getGlobeTool();
   */
  function PIECreateBezierGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._CreateBezierGlobeTool_Gethandle(handle);
      autoRelease = true;
    }
    PIEPanGlobeTool.call(this, handle, autoRelease);
  }
  PIECreateBezierGlobeTool.prototype = Object.assign(Object.create(PIEPanGlobeTool.prototype), {
    /**
     * 设置曲线风格
     * @param {PIEVectorStyle} vectorGeoStyle -地理风格
     * @param {PIEVectorStyle} vectorPointStyle -点符号类型
     */
    setStyle: function setStyle(vectorGeoStyle, vectorPointStyle) {
      Module._CreateBezierGlobeTool_SetStyle(this.handle, vectorGeoStyle.getHandle(), vectorPointStyle.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 编辑工具相关函数
   * @name PIEEditGlobeTool
   * @extends EditGlobeTool
   */
  function PIEEditGlobeTool(handle, autoRelease) {
    if (handle != null) {
      handle = Module._EditGlobeTool_GetHandle(handle);
    }
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIEEditGlobeTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {});

  function PIECreateToolFactory() {}
  Object.assign(PIECreateToolFactory.prototype, {});
  PIECreateToolFactory.CreateInstance = function (hGlobeTool) {
    var globeTool = new PIEGlobeTool(hGlobeTool);
    var globeType = globeTool.getType();
    if (globeType == PIEGlobeToolType.CreateCircle) {
      return new PIECreateCircleGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreatePlot) {
      return new PIECreatePlotGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateModel) {
      return new PIECreateModelGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Pan) {
      return new PIECreatePanGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.AnalyseDEM) ; else if (globeType == PIEGlobeToolType.AnalyseExcavation) {
      return new PIEAnalyseExcavationTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateEllipse) {
      return new PIECreateEllipseGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Analyse3DSkyline) {
      return new PIEAnalyseSkylineTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Analyse3DSunshine) ; else if (globeType == PIEGlobeToolType.None) ; else if (globeType == PIEGlobeToolType.Select) {
      return new PIECreateSectorGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Edit) {
      return new PIEEditGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreatePoint) {
      return new PIECreatePointGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreatePolyline) {
      return new PIECreatePolylineGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreatePolygon) {
      return new PIECreatePolygonGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateFreeLine) {
      return new PIECreateFreeLineGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateFreePolygon) {
      return new PIECreateFreePolygonGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateRectangle) {
      return new PIECreateRectangleGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.EditModel) {
      return new PIECreateModelGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.MeasureLength) {
      return new PIEMeasureLengthGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.MeasureArea) {
      return new PIEMeasureAreaGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.MeasureAngle) {
      return new PIEMeasureAngleGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Profile) {
      return new PIEProfileGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Analyse3DVisibleLine) ; else if (globeType == PIEGlobeToolType.Analyse3DVisibleRegion) ; else if (globeType == PIEGlobeToolType.Measure3DAngle) {
      return new PIEMeasure3DAngleGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Measure3DArea) {
      return new PIEMeasure3DAreaGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Measure3DHeight) {
      return new PIEMeasure3DHeightGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.Measure3DLength) {
      return new PIEMeasure3DLengthGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.AnalyseVisibleFlood) {
      return new PIEAnalyseFloodTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.AnalyseVisibleLine) ; else if (globeType == PIEGlobeToolType.AnalyseVisibleRegion) ; else if (globeType == PIEGlobeToolType.MeasureAzimuthAngle) {
      return new PIEMeasureAzimuthAngleTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.SlopeAspect) {
      return new PIESlopeAspectTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreatePolygon3D) {
      return new PIECreatePolygon3DGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreatePolyline3D) {
      return new PIECreatePolyline3DGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreatePoint3D) {
      return new PIECreatePoint3DGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateSector) {
      return new PIECreateSectorGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateText) {
      return new PIECreateTextGlobeTool(hGlobeTool);
    } else if (globeType == PIEGlobeToolType.CreateBezier) {
      return new PIECreateBezierGlobeTool(hGlobeTool);
    }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 编辑模块
   * ---
   */

  /**
   * 地图选择器操作相关函数
   * @name Selector
   *
   */
  function PIESelector(handle, autoReleaase) {
    this.handle = handle;
    this.autoRelease = autoReleaase;
  }
  Object.assign(PIESelector.prototype, {
    /**
     * 设置选择容限
     * @param {Number} tolerance -选择容限
     * @memberOf Selector#
     *
     * @example
     * let selector = new PIE.Selector();
     * selector.setTolerance(tolerance);
     */
    setTolerance: function setTolerance(tolerance) {
      Module._Selector_SetTolerance(this.handle, tolerance);
    },
    /**
     * 获取选择容限
     *
     * @memberOf Selector#
     * @returns {Number} 返回选择容限
     *
     */
    getTolerance: function getTolerance() {
      return Module._Selector_GetTolerance(this.handle);
    },
    /**
     * 设置选择几何风格
     * @param {PIEVectorStyle} style -几何对象风格
     * @memberOf Selector#
     *
     */
    setVectorStyle: function setVectorStyle(style) {
      Module._Selector_SetVectorStyle(this.handle, style.getHandle());
    },
    /**
     * 获取选择几何风格
     *
     * @memberOf Selector#
     * @returns {PIEVectorStyle} 返回的几何对象风格
     *
     */
    getVectorStyle: function getVectorStyle() {
      var handle = Module._Selector_GetVectorStyle(this.handle);
      if (handle) {
        return new PIEVectorStyle(handle);
      }
    },
    /**
     * 设置选择文本风格
     * @param {PIETextStyle} style -几何对象风格
     * @memberOf Selector#
     *
     */
    setTextStyle: function setTextStyle(style) {
      Module._Selector_SetTextStyle(this.handle, style.getHandle());
    },
    /**
     * 获取选择文本风格
     *
     * @memberOf Selector#
     * @returns {PIETextStyle} 返回的文本对象风格
     *
     */
    getTextStyle: function getTextStyle() {
      var handle = Module._Selector_GetTextStyle(this.handle);
      if (handle) {
        return new PIETextStyle(handle);
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建三维场景控制器
   * @param {object} options -
   * @param {Boolean} options.antialias -是否抗锯齿(默认为false)
   * @param {String} options.canvas -画布(必填)
   * @param {Boolean} options.cameraSmooth -是否需要相机缓冲效果(默认为false)
   * @param {PIEDimensionMode} options.dimensionMode -维度模式(PIE.DimensionMode.D3D)
   * @param {PIESceneMode} options.sceneMode -场景模式(默认为PIE.SceneMode.Sphere)
   * @param {Boolean} options.autoProjection -是否自动转换地图投影(默认为true)
   * @param {Number} options.pixelRatio -当前显示设备的物理像素分辨率与CSS像素分辨率之比(默认为1)
   * @param {Boolean} options.enableFarClipping -是否开启远裁剪面(默认为false)
   * @param {Boolean} options.tileLevelSize -瓦片缓存层级(默认为5)
   * @param {Boolean} options.tileBufferRadius -瓦片缓存半径(默认为3)
   * @param {Boolean} options.preserveDrawingBuffer -设置为true时,表示在绘图完成后保留绘图缓冲区,默认值为false
   *
   * @name GlobeControl
   * @class GlobeControl
   *  三维场景控制器操作函数
   *
   */

  function PIEGlobeControl(options) {
    this.options = options;
    this.preRender = new PIEEvent();
    this.postRender = new PIEEvent();
    this.preOnTouchUp = new PIEEvent();
    this.postOnTouchUp = new PIEEvent();
    this.bDisposed = false;
    window.canvasContextListener = function (e) {
      alert('WebGL context lost.');
      e.preventDefault();
    };
    this.canvas = document.getElementById(options.canvas);
    if (!options.canvas || !this.canvas) {
      throw new Error('PIE.GlobeControl: input canvas is not exist.');
    }
    this.context = this.canvas.getContext(options.webgl2 ? "webgl2" : "webgl", {
      antialias: options.antialias != null ? options.antialias : false,
      depth: options.depth != null ? options.depth : true,
      stencil: options.stencil != null ? options.stencil : true,
      preserveDrawingBuffer: options.preserveDrawingBuffer != null ? options.preserveDrawingBuffer : false
    });
    if (!options.webgl2) {
      this.context.getExtension('WEBGL_depth_texture');
      this.context.getExtension('OES_texture_float');
      this.context.getExtension('OES_standard_derivatives');
      this.context.getExtension('OES_element_index_uint');
      this.context.getExtension('ANGLE_instanced_arrays');
    }
    this.handle = Module._GlobeControl_Create(options.dimensionMode != null ? options.dimensionMode : PIEDimensionMode.D3D);
    if (this.handle) {
      var hGlobeEditor = Module._GlobeControl_GetGlobeEditor(this.handle);
      this._globeEditor = new PIEGlobeEditor(hGlobeEditor);
    }
    if (options.tileLevelSize) {
      this.getGlobe().setTileLevelSize(options.tileLevelSize);
    }
    if (options.tileBufferRadius) {
      this.getGlobe().setTileBufferRadius(options.tileBufferRadius);
    }
    this.onCreate(options.canvas, options.antialias != null ? options.antialias : false, options.webgl2 != null ? options.webgl2 : false);
    this.canvasWidth = 0;
    this.canvasHeight = 0;
    this.pixelRatio = options.pixelRatio != null ? options.pixelRatio : 1;
    this.onSize(true);
    this.setSceneMode(options.sceneMode != null ? options.sceneMode : PIESceneMode.Sphere);
    this.getGlobe().setAutoProjection(options.autoProjection != null ? options.autoProjection : true);
    this.getGlobe().getOcean().setVisible(false);
    this.getGlobe().getGridLine().setVisible(false);
    var worldCamera = this.getGlobe().getWorldCamera();
    worldCamera.setSmooth(options.cameraSmooth != null ? options.cameraSmooth : false);
    worldCamera.setEnableFarClipping(options.enableFarClipping != null ? options.enableFarClipping : false);
    var date = null;
    if (options.date != null) {
      date = options.date;
    } else {
      date = new Date();
      date.setHours(6);
    }
    var sunLight = this.getGlobe().getSunLight();
    sunLight.setTime(date);
    this.button = 0;
    this.buttonRealseFlag = 0;
    this.ignoreMouseEvents = false;
    var that = this;
    this.canvas.onclose = function onClose(e) {
      that.onDestroy();
    };
    this.canvas.onmousedown = function onMouseDown(e) {
      if (that.ignoreMouseEvents) {
        return;
      }
      that.buttonRealseFlag = 1;
      e.preventDefault();
      e.stopPropagation();
      that.onMouseDown(e);
    };
    this.canvas.onmouseup = function onMouseUp(e) {
      if (that.ignoreMouseEvents) {
        return;
      }
      that.buttonRealseFlag = 0;
      that.onMouseUp(e);
    };
    this.canvas.onmousemove = function onMouseMove(e) {
      if (that.ignoreMouseEvents) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      that.onMouseMove(e);
    };
    if (navigator.userAgent.indexOf("Firefox") > -1) {
      document.body.addEventListener('DOMMouseScroll', function (e) {
        e.preventDefault();
        e.stopPropagation();
        that.onMouseWheel(e);
      }, false);
    } else {
      this.canvas.onmousewheel = function onMouseWheel(e) {
        e.preventDefault();
        e.stopPropagation();
        that.onMouseWheel(e);
      };
    }
    this.canvas.addEventListener('webglcontextlost', window.canvasContextListener, false);
    this.canvas.addEventListener('webglcontextrestored', function (e) {
      alert('WebGL context restored.');
    }, false);
    this.canvas.addEventListener('mouseleave', function (e) {
      if (that.buttonRealseFlag) {
        that.buttonRealseFlag = 0;
        that.onMouseUp(e);
      }
    });
    this.exaggeration = 1;
    window.addEventListener('resize', function () {
      that.onSize();
    }, false);
  }
  Object.assign(PIEGlobeControl.prototype, {
    /**
     * 忽略鼠标事件
     * @param {Boolean} ignore -反选
     * @memberOf GlobeControl#
     *
     */
    ignoreMouseEvent: function ignoreMouseEvent(ignore) {
      this.ignoreMouseEvents = ignore;
    },
    removeAllCanvasListener: function removeAllCanvasListener() {
      this.canvas.removeEventListener('webglcontextlost', window.canvasContextListener);
    },
    /**
     * 删除三维控制对象
     * @memberOf GlobeControl#
     */
    dispose: function dispose() {
      if (this.handle) {
        //清除canvas的监听事件
        this.removeAllCanvasListener();
        this.makeCurrent();
        this.onDestroy();
        Module._GlobeControl_Delete(this.handle);
        this.doneCurrent();
        this.wglContext = null;
        this.handle = null;
        this.ignoreMouseEvents = true;
      }
    },
    /**
     * 获取绘制地图窗口前事件函数
     * @memberOf GlobeControl#
     * @returns {PIEEvent} 成功返回渲染前事件，失败返回NULL
     */
    getPreRender: function getPreRender() {
      return this.preRender;
    },
    /**
     * 获取绘制地图窗口后事件函数
     * @memberOf GlobeControl#
     * @returns {PIEEvent} 成功返回渲染后事件，失败返回NULL
     */
    getPostRender: function getPostRender() {
      return this.postRender;
    },
    getPreOnTouchUp: function getPreOnTouchUp() {
      return this.preOnTouchUp;
    },
    getPostOnTouchUp: function getPostOnTouchUp() {
      return this.postOnTouchUp;
    },
    getCanvas: function getCanvas() {
      return this.canvas;
    },
    getContext: function getContext() {
      return this.context;
    },
    /**
     * 获取三维场景对象
     *
     * @memberOf GlobeControl#
     * @returns {PIEGlobe} 成功返回场景对象，失败返回NULL
     *
     */
    getGlobe: function getGlobe() {
      var hGlobe = Module._GlobeControl_GetGlobe(this.handle);
      if (hGlobe) {
        var globe = new PIEGlobe(hGlobe);
        if (this.pixelRatio != 1) {
          globe.setPixelRatio(this.pixelRatio);
        }
        return globe;
      }
      return null;
    },
    /**
     * Window 接口的devicePixelRatio返回当前显示设备的物理像素分辨率与CSS像素分辨率之比。
     * 此值也可以解释为像素大小的比率：一个CSS像素的大小与一个物理像素的大小。
     * 简单来说，它告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。
     * 当处理标准显示器与HiDPI或Retina显示器之间的差异时，这很有用，后者使用更多的屏幕像素绘制相同的对象，从而获得更清晰的图像
     *
     * @param pixelRatio -当前显示设备的物理像素分辨率与CSS像素分辨率之比
     * @memberOf GlobeControl#
     *
     */
    setPixelRatio: function setPixelRatio(pixelRatio) {
      if (pixelRatio === undefined) return;
      this.pixelRatio = pixelRatio;
      this.onSize(true);
    },
    /**
     * 获取屏幕分辨率
     *
     * @memberOf GlobeControl#
     * @returns {pixelRatio} 返回屏幕分辨率参数
     *
     */
    getPixelRatio: function getPixelRatio() {
      return this.pixelRatio;
    },
    /**
     * 设置场景模式
     * @param {PIESceneMode} mode -场景模式
     * @memberOf GlobeControl#
     *
     */
    setSceneMode: function setSceneMode(mode) {
      Module._GlobeControl_SetSceneMode(this.handle, mode);
    },
    /**
     * 获取场景模式
     *
     * @memberOf GlobeControl#
     * @returns {PIESceneMode} 返回场景模式
     *
     */
    getSceneMode: function getSceneMode() {
      return Module._GlobeControl_GetSceneMode(this.handle);
    },
    /**
     * 设置用户操作类型
     * @param {PIEGlobeToolType} globeTool -用户操作类型
     * @memberOf GlobeControl#
     *
     */
    setGlobeTool: function setGlobeTool(globeTool) {
      var strGlobeTool = new PIEString$1(globeTool);
      Module._GlobeControl_SetGlobeTool(this.handle, strGlobeTool.getHandle());
      strGlobeTool.dispose();
    },
    /**
     * 获取用户操作类型名称
     * @memberOf GlobeControl#
     * @returns {String} 返回用户操作类型名称
     *
     */
    getGlobeToolName: function getGlobeToolName() {
      var strGlobeTool = new PIEString$1(32);
      Module._GlobeControl_GetGlobeTool(this.handle, strGlobeTool.getHandle());
      var globeTool = strGlobeTool.toString();
      strGlobeTool.dispose();
      return globeTool;
    },
    /**
     * 获取用户操作类型
     * @memberOf GlobeControl#
     * @returns {PIEGlobeTool} 返回用户当前指定工具对象
     *
     */
    getGlobeTool: function getGlobeTool() {
      var hGlobeTool = Module._GlobeControl_GetGlobeToolHandle(this.handle);
      return PIECreateToolFactory.CreateInstance(hGlobeTool);
    },
    /**
     * 创建地图窗口对象
     * @param {String} id -地图窗口对象ID
     * @param {Boolean} antialias -是否抗锯齿
     * @param {Boolean} webgl2 -是否为webgl2
     *
     * @memberOf GlobeControl#
     * @returns {Boolean} 返回创建的地图窗口对象
     */
    onCreate: function onCreate(id, antialias, webgl2) {
      var strID = new PIEString$1(id);
      var result = Module._GlobeControl_OnCreate(this.handle, strID.getHandle(), antialias, webgl2);
      strID.dispose();
      this.wglContext = Module._emscripten_webgl_do_get_current_context();
      return Boolean(result);
    },
    /**
     * 销毁地图窗口
     * @memberOf GlobeControl#
     * @returns {Boolean} 成功返回true，失败返回false
     *
     */
    onDestroy: function onDestroy() {
      var result = Module._GlobeControl_OnDestroy(this.handle);
      return result;
    },
    /**
     * 激活webgl上下文环境
     * @memberOf GlobeControl#
     *
     */
    makeCurrent: function makeCurrent() {
      if (this.wglContext != null) {
        Module._emscripten_webgl_make_context_current(this.wglContext);
      }
    },
    /**
     * 取消激活webgl上下文环境
     * @memberOf GlobeControl#
     *
     */
    doneCurrent: function doneCurrent() {
      if (this.wglContext != null) {
        Module._emscripten_webgl_make_context_current(null);
      }
    },
    /**
     * 场景窗口大小自动变化
     * @memberOf GlobeControl#
     * @param {Boolean} updateStyle -是否更新Canvas的Style属性
     * @returns {Boolean} 成功返回true，否则返回false
     */
    onSize: function onSize(updateStyle) {
      if (!this.handle) {
        return false;
      }
      var canvasWidth = this.canvas.clientWidth * this.pixelRatio;
      var canvasHeight = this.canvas.clientHeight * this.pixelRatio;
      if (canvasWidth != this.canvasWidth || canvasHeight != this.canvasHeight) {
        if (updateStyle || this.pixelRatio != 1) ;
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
        this.canvas.width = this.canvasWidth;
        this.canvas.height = this.canvasHeight;
        return this.onSizeChanged(this.canvas.width, this.canvas.height, true);
      }
      return true;
    },
    /**
     * 改变场景窗口大小
     * @memberOf GlobeControl#
     * @param {Number} width -窗口宽度
     * @param {Number} height -窗口高度
     * @param {Boolean} refresh -是否刷新场景
     * @returns {Boolean} 成功返回true，否则返回false
     */
    onSizeChanged: function onSizeChanged(width, height, refresh) {
      this.makeCurrent();
      var array = new PIEArray([0, 0, width, height], PIEArrayType.Int32);
      var result = Module._GlobeControl_OnSize(this.handle, array.getHandle(), refresh);
      array.dispose();
      return Boolean(result);
    },
    /**
     * 绘制地图窗口
     * @param {Number} time -每一帧的间隔时间
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 如果成功返回true，否则返回false
     */
    onRender: function onRender(time) {
      if (this.handle) {
        this.onSize();
        this.preRender.raiseEvent(this, time);
        this.makeCurrent();
        var result = Module._GlobeControl_OnRender(this.handle);
        this.postRender.raiseEvent(this, time);
        return Boolean(result);
      }
      return false;
    },
    /**
     * 绘制场景深度图
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 如果绘制成功返回true，否则返回false
     */
    onRenderDepth: function onRenderDepth() {
      this.makeCurrent();
      var result = Module._GlobeControl_OnRenderDepth(this.handle);
      this.doneCurrent();
      return Boolean(result);
    },
    /**
     * 设置锁定地图窗口
     * @memberOf GlobeControl#
     * @param {Boolean} lock -是否锁定
     */
    setLock: function setLock(lock) {
      Module._GlobeControl_SetLock(this.handle, lock);
    },
    /**
     * 判断地图窗口是否锁定
     * @memberOf GlobeControl#
     * @returns {Boolean} 如果锁定返回true，否则返回false
     */
    getLock: function getLock() {
      return Boolean(Module._GlobeControl_GetLock(this.handle));
    },
    /**
     * 鼠标滚轮事件响应
     * @param {Number} x -点击位置，x
     * @param {Number} y -点击位置，y
     * @param {Number} delta -标识鼠标滚轮滚动方向
     * @param {Number} flags -附件标识符
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回是否成功响应鼠标滚轮事件
     *
     */
    onTouchWheel: function onTouchWheel(x, y, delta, flags) {
      this.makeCurrent();
      Module._GlobeControl_OnTouchWheel(this.handle, x, y, delta, flags);
    },
    /**
     * 单指按下事件响应
     * @param {Number} x -点击位置，x
     * @param {Number} y -点击位置，y
     * @param {Number} flags -附件标识符
     * @param {Number} button -鼠标左右键标识符
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回是否成功响应单指按下事件
     *
     */
    onTouchDown: function onTouchDown(x, y, flags, button) {
      this.makeCurrent();
      Module._GlobeControl_OnTouchDown(this.handle, x, y, flags, button);
    },
    /**
     * 单指移动事件响应
     * @param {Number} x -点击位置，x
     * @param {Number} y -点击位置，y
     * @param {Number} flags -附件标识符
     * @param {Number} button -鼠标左右键标识符
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回是否成功响应单指移动事件
     *
     */
    onTouchMove: function onTouchMove(x, y, flags, button) {
      this.makeCurrent();
      Module._GlobeControl_OnTouchMove(this.handle, x, y, flags, button);
    },
    /**
     * 单指抬起事件响应
     * @param {Number} x -点击位置，x
     * @param {Number} y -点击位置，y
     * @param {Number} flags -附件标识符
     * @param {Number} button -鼠标左右键标识符
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回是否成功响应单指抬起事件
     *
     */
    onTouchUp: function onTouchUp(x, y, flags, button) {
      this.preOnTouchUp.raiseEvent(x, y);
      this.makeCurrent();
      var res = Module._GlobeControl_OnTouchUp(this.handle, x, y, flags, button);
      this.postOnTouchUp.raiseEvent(x, y);
      return res;
    },
    /**
     * 键盘按键事件响应
     * @param {Number} char -键盘按键标识
     * @param {Number} repCnt -连续按键次数
     * @param {Number} flags -附加标识符
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回是否成功响应键盘按键事件
     *
     */
    onKeyDown: function onKeyDown(_char, repCnt, flags) {
      this.makeCurrent();
      Module._GlobeControl_OnKeyDown(this.handle, _char, repCnt, flags);
    },
    /**
     * 键盘按键抬起事件响应
     * @param {Number} char -键盘按键标识
     * @param {Number} repCnt -连续按键次数
     * @param {Number} flags -附加标识符
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回是否成功响应键盘按键事件
     *
     */
    onKeyUp: function onKeyUp(_char2, repCnt, flags) {
      this.makeCurrent();
      Module._GlobeControl_OnKeyUp(this.handle, _char2, repCnt, flags);
    },
    /**
     * 获取鼠标位置
     * @param {Object} event -
     * @param {Number} event.clientX -返回触发鼠标事件时，鼠标指针相对于当前窗口的水平坐标（根据客户端区域）
     * @param {Number} event.clientY -返回触发鼠标事件时，鼠标指针相对于当前窗口的垂直坐标（根据客户端区域）
     * @memberOf GlobeControl#
     *
     * @returns {Object} 返回鼠标位置 {x, y}
     *
     */
    getMousePosition: function getMousePosition(event) {
      var rect = this.canvas.getBoundingClientRect();
      var x = (event.clientX - rect.left) * (this.canvas.width / rect.width);
      var y = (event.clientY - rect.top) * (this.canvas.height / rect.height);
      return {
        x: x,
        y: y
      };
    },
    /**
     * 鼠标滚轮事件响应
     * @param {Object} e -
     * @param {Number} e.detail -返回数字，表示当前点击次数加一
     * @param {Number} e.wheelDelta -返回鼠标滚轮的滚动量
     * @memberOf GlobeControl#
     *
     */
    onMouseWheel: function onMouseWheel(e) {
      var pos = this.getMousePosition(e);
      if (navigator.userAgent.indexOf("Firefox") > -1) {
        this.onTouchWheel(pos.x, pos.y, e.detail * -40, 0);
      } else {
        this.onTouchWheel(pos.x, pos.y, e.wheelDelta, 0);
      }
    },
    /**
     * 鼠标按下事件响应
     * @param {Object} e -
     * @param {Number} e.button -返回触发鼠标事件时按下的鼠标按钮
     * @memberOf GlobeControl#
     *
     */
    onMouseDown: function onMouseDown(e) {
      var button = e.button;
      if (button == 1) {
        button = 2;
      } else if (button == 2) {
        button = 1;
      }
      this.button = button;
      var pos = this.getMousePosition(e);
      this.onTouchDown(pos.x, pos.y, 0, this.button);
    },
    /**
     * 鼠标移动事件响应
     * @param {Object} event -
     * @param {Number} event.clientX -返回触发鼠标事件时，鼠标指针相对于当前窗口的水平坐标（根据客户端区域）
     * @param {Number} event.clientY -返回触发鼠标事件时，鼠标指针相对于当前窗口的垂直坐标（根据客户端区域）
     * @memberOf GlobeControl#
     *
     */
    onMouseMove: function onMouseMove(e) {
      var pos = this.getMousePosition(e);
      this.onTouchMove(pos.x, pos.y, 0, this.button);
    },
    /**
     * 鼠标抬起事件响应
     * @param {Object} event -
     * @param {Number} event.clientX -返回触发鼠标事件时，鼠标指针相对于当前窗口的水平坐标（根据客户端区域）
     * @param {Number} event.clientY -返回触发鼠标事件时，鼠标指针相对于当前窗口的垂直坐标（根据客户端区域）
     * @memberOf GlobeControl#
     *
     */
    onMouseUp: function onMouseUp(e) {
      var pos = this.getMousePosition(e);
      var flags = 0;
      if (e.shiftKey) {
        flags |= 4;
      }
      if (e.ctrlKey) {
        flags |= 8;
      }
      this.onTouchUp(pos.x, pos.y, flags, this.button);
    },
    /**
     * 获取三维场景编辑器
     *  @memberOf GlobeControl#
     * @returns {PIEGlobeEditor} 如果成功返回编辑器，否则返回NULL
     *
     */
    getGlobeEditor: function getGlobeEditor() {
      var hGlobeEditor = Module._GlobeControl_GetGlobeEditor(this.handle);
      if (hGlobeEditor) {
        return this._globeEditor;
      }
      return null;
    },
    /**
     * 选中点测试
     * @param {Array} pntScreen -屏幕像素点位置
     * @param {Array} pntMap -屏幕点转地图点坐标
     * @param {Number} tolerance -容限
     * @param {Boolean} appendMode -是否追加模式
     * @param {Boolean} controlMode -反选
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回测试是否成功
     */
    hitTestPoint: function hitTestPoint(pntScreen, pntMap, tolerance, appendMode, controlMode) {
      var arrayScreen = null;
      var arrayMap = null;
      if (appendMode == null) {
        appendMode = false;
      }
      if (controlMode == null) {
        controlMode = false;
      }
      if (pntScreen instanceof PIEVector2) {
        arrayScreen = pntScreen.toArray();
      } else if (pntScreen instanceof Array) {
        arrayScreen = pntScreen;
      }
      if (pntMap instanceof PIEVector2) {
        arrayMap = pntMap.toArray();
      } else if (pntMap instanceof Array) {
        arrayMap = pntMap;
      }
      var result = false;
      this.makeCurrent();
      if (arrayScreen && arrayMap) {
        result = Module._GlobeControl_HitTestPoint(this.handle, arrayScreen[0], arrayScreen[1], arrayMap[0], arrayMap[1], tolerance, appendMode, controlMode);
      }
      return result;
    },
    /**
     * 选中范围测试
     * @param {Array|PIERect} rect -屏幕范围
     * @param {Boolean} appendMode -是否追加模式(默认false)
     * @param {Boolean} controlMode -反选(默认false)
     * @memberOf GlobeControl#
     *
     * @returns {Boolean} 返回测试是否成功
     */
    hitTestRect: function hitTestRect(rect, appendMode, controlMode) {
      var rectArray = null;
      if (rect instanceof PIERect) {
        rectArray = rect.toArray();
      } else if (rect instanceof Array) {
        rectArray = rect;
      }
      if (rectArray && rectArray.length == 4) {
        if (appendMode == null) {
          appendMode = false;
        }
        if (controlMode == null) {
          controlMode = false;
        }
        var arrayRect = new PIEArray(rectArray, PIEArrayType.Float64);
        var res = Module._GlobeControl_HitTestRect(this.handle, arrayRect.getHandle(), appendMode, controlMode);
        arrayRect.dispose();
        return res;
      }
      return false;
    },
    // /**
    //  * 选中点测试
    //  * @param {Array} pntScreen -屏幕像素点位置
    //  * @memberOf GlobeControl#
    //  *
    //  * @return {Number} 返回选择的对象ID，失败返回null;
    //  */
    pick: function pick(pntScreen) {
      this.makeCurrent();
      var pointArray = null;
      if (pntScreen instanceof PIEVector2) {
        pointArray = pntScreen.toArray();
      } else if (pntScreen instanceof Array) {
        pointArray = pntScreen;
      }
      var result = null;
      if (pointArray) {
        result = Module._Globe_Control_Pick(this.handle, pointArray[0], pointArray[1]);
      }
      return result;
    },
    // /**
    //  * 获取地图选择器
    //  * @memberOf GlobeControl#
    //  * @return {PIESelector} 返回地图选择器对象
    //  */
    getSelector: function getSelector() {
      var handle = Module._PIE_Globe_Control_GetSelector(this.handle);
      return new PIESelector(handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建场景视图容器
   * @name GlobeViewer
   * @class GlobeViewer
   * 场景视图容器操作函数
   *
   * @param {Object} options -
   * @param {Boolean} options.antialias -是否抗锯齿(默认为false)
   * @param {String} options.canvas -画布(必填)
   * @param {Boolean} options.cameraSmooth -是否需要相机缓冲效果(默认为false)
   * @param {PIEDimensionMode} options.dimensionMode -维度模式(PIE.DimensionMode.D3D)
   * @param {PIESceneMode} options.sceneMode -场景模式(默认为PIE.SceneMode.Sphere)
   * @param {Boolean} options.autoProjection -是否自动转换地图投影(默认为true)
   * @param {Number} options.pixelRatio -当前显示设备的物理像素分辨率与CSS像素分辨率之比(默认为1)
   * @param {Boolean} options.enableFarClipping -是否开启远裁剪面(默认为false)
   * @param {Boolean} options.tileLevelSize -瓦片缓存层级(默认为5)
   * @param {Boolean} options.tileBufferRadius -瓦片缓存半径(默认为3)
   * @param {Boolean} options.preserveDrawingBuffer -设置为true时,表示在绘图完成后保留绘图缓冲区,默认值为 false
   * @param {Array/PIEVector2} options.center -中心点 默认值（116.4, 39.9）
   * @param {Number} options.zoom -缩放层级(0-22)
   * @param {Number} options.scale -比例尺
   * @param {Number} options.useRenderLoop -是否内部控制渲染循环(默认为true)
   * @param {Object} options.rasterDataSource -瓦片数据源(必填)
   * @param {String} options.rasterDataSource.server -url地址(必填)
   * @param {String} options.rasterDataSource.alias -栅格瓦片数据源别名(必填)
   * @param {Number} options.rasterDataSource.epsg -坐标系EPSG(支持3857、4326、4490，默认为3857)
   * @param {PIEBounds} options.rasterDataSource.bounds -数据范围(默认全球范围)
   * @param {Number} options.rasterDataSource.dpi -地图显示dpi(默认为96)
   * @param {Number} options.rasterDataSource.tileSize -瓦片大小(默认256)
   * @param {Number} options.rasterDataSource.maxLevel -瓦片最大层级(默认13，如果地形精度大于13层级，需要自行设置此参数)
   * @param {Object} options.terrainDataSource -地形数据源(需要添加地形时输入)
   * @param {String} options.terrainDataSource.server -url地址(必填)
   * @param {String} options.terrainDataSource.alias -栅格瓦片数据源别名(必填)
   * @param {Number} options.terrainDataSource.epsg -坐标系EPSG(支持3857、4326、4490，默认为3857)
   * @param {PIEBounds} options.terrainDataSource.bounds -数据范围(默认全球范围)
   * @param {Number} options.terrainDataSource.dpi -地图显示Dpi(默认为96)
   * @param {Number} options.terrainDataSource.tileSize -瓦片大小(默认256)
   *
   *@example
   *let globeViewer = new PIE.GlobeViewer({
              canvas: 'canvas',
              dimensionMode: PIE.DimensionMode.D3D,
              sceneMode: PIE.SceneMode.Sphere,
              autoProjection: true,
              center: [116.4, 39.9],
              zoom: 3,
              rasterDataSource: {server:"https://webst03.is.autonavi.com/appmaptile?style=6&z={z}&y={y}&x={x}", alias:"test"},
              terrainDataSource: {server:"https://ds.piesat.cn:20002/pie-cloud/tiles/publish/arcgis/below/d83be590745b4a8fb91d82a864b55e66/{z}/{x}/{y}", alias:"terrain"}
          });
   */
  function PIEGlobeViewer(options) {
    PIEEnvironment.init();
    var tileRasterDatasource = options.rasterDataSource;
    var terrainDatasource = options.terrainDataSource;
    this.workspace = new PIEDocument();
    this.globeControl = new PIEGlobeControl({
      antialias: options.antialias,
      webgl2: options.webgl2,
      canvas: options.canvas,
      depth: options.depth,
      stencil: options.stencil,
      cameraSmooth: options.cameraSmooth,
      dimensionMode: options.dimensionMode,
      sceneMode: options.sceneMode,
      autoProjection: options.autoProjection,
      enableFarClipping: options.enableFarClipping,
      pixelRatio: options.pixelRatio,
      preserveDrawingBuffer: options.preserveDrawingBuffer,
      tileLevelSize: options.tileLevelSize,
      tileBufferRadius: options.tileBufferRadius
    });
    var zoom = options.zoom;
    var scale = options.scale;
    this.globe = this.globeControl.getGlobe();
    this.globe.attachDocument(this.workspace);
    this.globe.setMinResolution(512);
    if (tileRasterDatasource != null && _typeof(tileRasterDatasource) == "object") {
      var dataSource = new PIETileRasterDataSource();
      dataSource.create(tileRasterDatasource);
      this.workspace.getDataSourceManager().addDataSource(dataSource);
      var globeTileRasterLayer = new PIEGlobeTileRasterLayer();
      globeTileRasterLayer.setDataSource(dataSource);
      this.globe.addLayer(globeTileRasterLayer, true);
    }
    if (terrainDatasource != null && _typeof(terrainDatasource) == "object") {
      var terrainDataSource = new PIEMapTerrainDataSource();
      terrainDataSource.create(terrainDatasource);
      this.workspace.getDataSourceManager().addDataSource(terrainDataSource);
      var globeElevationLayer = new PIEGlobeElevationLayer();
      globeElevationLayer.setDataSource(terrainDataSource);
      var globeModel = this.globe.getGlobeModel();
      globeModel.addLayer(globeElevationLayer, true);
    }
    this.globe.viewEntire();
    this.globe.refresh(false, false);
    var patialReference = this.globe.getSpatialReference();
    var point = options.center != null ? options.center : [116.4, 39.9];
    var vecPoint = patialReference.forward(point);
    this.globe.setCenter(vecPoint);
    this.globe.refresh(false, false);
    this.globe.setHeadingAngle(0);
    var scales = this.globe.getScaleLevels();
    if (zoom != null && zoom < scales.length) {
      this.globe.setZoom(zoom);
    } else if (scale != null) {
      this.globe.setScale(scale);
    } else {
      this.globe.setScale(scales[0]);
    }
    this.globe.refresh(false, false);
    var useRenderLoop = options.useRenderLoop != null ? options.useRenderLoop : true;
    if (useRenderLoop) {
      startRenderLoop(this.globeControl);
    }
  }
  Object.assign(PIEGlobeViewer.prototype, {
    /**
     * 获取三维控制对象
     * @memberOf GlobeViewer#
     * @returns {PIEGlobeControl} 返回三维控制对象
     */
    getGlobeControl: function getGlobeControl() {
      return this.globeControl;
    },
    /**
     * 删除三维控制对象
     * @memberOf GlobeViewer#
     */
    dispose: function dispose() {
      this.globe.close();
      if (this.globeControl) {
        this.globeControl.bDisposed = true;
        this.globeControl.dispose();
      }
      if (this.workspace) this.workspace.dispose();
      this.globe = null;
      this.globeControl = null;
      this.workspace = null;
      //PIEEnvironment.exit();
    },

    /**
     * 获取三维场景对象
     * @memberOf GlobeViewer#
     * @returns {PIEGlobe} 返回三维场景对象
     */
    getGlobe: function getGlobe() {
      return this.globe;
    }
  });
  function startRenderLoop(globeControl) {
    function render() {
      if (globeControl.bDisposed == false && globeControl.handle) {
        globeControl.onRender();
        requestAnimationFrame(render);
      }
    }
    requestAnimationFrame(render);
  }

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建Tiles3D模型图层
   * @name GlobeTiles3DModelLayer
   * @class GlobeTiles3DModelLayer
   * Tiles3D模型图层
   * @extends GlobeModelLayer
   */
  function PIEGlobeTiles3DModelLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_Tiles3DModelLayer_Create();
      autoRelease = true;
    }
    PIEGlobeModelLayer.call(this, handle, autoRelease);
  }
  PIEGlobeTiles3DModelLayer.prototype = Object.assign(Object.create(PIEGlobeModelLayer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 颜色效果过滤器
   * @name GlobeColorEffectFilter
   *
   * @extends GlobeEffectFilter
   * @example
   * var globeColorEffectFilter = new PIE.GlobeColorEffectFilter();
   */
  function PIEGlobeColorEffectFilter(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_ColorEffectFilter_Create();
      autoRelease = true;
    }
    PIEGlobeEffectFilter.call(this, handle, autoRelease);
  }
  PIEGlobeColorEffectFilter.prototype = Object.assign(Object.create(PIEGlobeEffectFilter.prototype), {
    /**
     * 设置不透明度
     * @param {Number} opacity -不透明度
     * @memberOf GlobeColorEffectFilter#
     */
    setOpacity: function setOpacity(opacity) {
      Module._Globe_ColorEffectFilter_SetOpacity(this.handle, opacity);
    },
    /**
     * 获取不透明度
     *
     * @memberOf GlobeColorEffectFilter#
     * @returns {Number} 不透明度
     */
    getOpacity: function getOpacity() {
      return Module._Globe_ColorEffectFilter_GetOpacity(this.handle);
    }
  });

  Object.assign(Object.create(PIEGlobeEffectFilter.prototype), {
    /**
     * 设置是否反选
     * @param {Boolean} enable -是否反选
     * @memberOf globeFragMaskEffectFilter#
     */
    setEnableReverseMask: function setEnableReverseMask(enable) {
      Module._Globe_FragMaskEffectFilter_SetEnableReverseMask(this.handle, enable);
    },
    /**
     * 获取是否反选
     *
     * @memberOf globeFragMaskEffectFilter#
     * @returns {Boolean} 是否反选
     */
    isEnableReverseMask: function isEnableReverseMask(enable) {
      return Module._Globe_FragMaskEffectFilter_IsEnableReverseMask(this.handle);
    },
    /**
     * 设置第一个坐标点
     * @param {Number} x -坐标点x
     * @param {Number} y -坐标点y
     * @memberOf globeFragMaskEffectFilter#
     *
     */
    setFirstXY: function setFirstXY(x, y) {
      Module._Globe_FragMaskEffectFilter_SetFirstXY(this.handle, x, y);
    },
    /**
     * 获取第一个坐标点
     * @memberOf GlobeFragMaskEffectFilter#
     *
     * @returns {PIEVector2} 返回第一个坐标点
     */
    getFirstXY: function getFirstXY() {
      var posArray = new PIEArray(2, PIEArrayType.Int32);
      Module._Globe_FragMaskEffectFilter_GetFirstXY(this.handle, posArray.getHandle());
      posArray.updateData();
      var position = posArray.toArray();
      posArray.dispose();
      return new PIEVector2(position[0], position[1]);
    },
    /**
     * 设置第二个坐标点
     * @param {Number} x -坐标点x
     * @param {Number} y -坐标点y
     * @memberOf globeFragMaskEffectFilter#
     *
     */
    setSecondXY: function setSecondXY(x, y) {
      Module._Globe_FragMaskEffectFilter_SetSecondXY(this.handle, x, y);
    },
    /**
     * 获取第二个坐标点
     * @memberOf GlobeFragMaskEffectFilter#
     *
     * @returns {PIEVector2} 返回第二个坐标点
     */
    getSecondXY: function getSecondXY() {
      var posArray = new PIEArray(2, PIEArrayType.Int32);
      Module._Globe_FragMaskEffectFilter_GetSecondXY(this.handle, posArray.getHandle());
      posArray.updateData();
      var position = posArray.toArray();
      posArray.dispose();
      return new PIEVector2(position[0], position[1]);
    }
  });

  Object.assign(Object.create(PIEGlobeEffectFilter.prototype), {
    /**
     * 设置图层裁剪面
     * @param {(PIEVector3/Array)} swipeVector -图层裁剪面
     * @param {(PIEVector3/Array)} swipePoint -裁剪面的法向量
     * @memberOf GlobeSharderEffectFilter#
     *
     * @returns {Boolean} 返回是否设置成功
     */
    setClipPlane: function setClipPlane(swipeVector, swipePoint) {
      var arraySwipePoint = null;
      if (swipePoint instanceof PIEVector3) {
        arraySwipePoint = new PIEArray([swipePoint.x, swipePoint.y, swipePoint.z], PIEArrayType.Float64);
      } else {
        arraySwipePoint = new PIEArray(swipePoint, PIEArrayType.Float64);
      }
      var arraySwipeVector = null;
      if (swipeVector instanceof PIEVector3) {
        arraySwipeVector = new PIEArray([swipeVector.x, swipeVector.y, swipeVector.z], PIEArrayType.Float64);
      } else {
        arraySwipeVector = new PIEArray(swipeVector, PIEArrayType.Float64);
      }
      var res = Module._Globe_SharderEffect_SetClipPlane(this.handle, arraySwipeVector.getHandle(), arraySwipePoint.getHandle());
      arraySwipeVector.dispose();
      arraySwipePoint.dispose();
      return res;
    },
    /**
     * 删除图层裁剪面
     *
     * @memberOf GlobeSharderEffectFilter#
     * @returns {Boolean} 返回是否删除成功
     */
    removeClipPlane: function removeClipPlane() {
      return Module._Globe_SharderEffect_RemoveClipPlane(this.handle);
    },
    /**
     * 获取阴影部分夸张系数
     *
     * @memberOf GlobeSharderEffectFilter#
     * @return {Number} 返回阴影部分夸张系数
     */
    getShadingExaggeration: function getShadingExaggeration() {
      return Module._Globe_SharderEffect_GetShadingExaggeration(this.handle);
    },
    /**
     * 设置阴影部分夸张系数
     * @param {Number} value -阴影部分夸张系数
     * @memberOf GlobeSharderEffectFilter#
     */
    setShadingExaggeration: function setShadingExaggeration(value) {
      Module._Globe_SharderEffect_SetShadingExaggeration(this.handle, value);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 矢量瓦片渲染器操作函数
   * @name TileFeatureRenderer
   * @class TileFeatureRenderer
   *
   * @extends FeatureRenderer
   */
  function PIETileFeatureRenderer(handle, autoRelease) {
    PIEFeatureRenderer.call(this, handle, autoRelease);
  }
  PIETileFeatureRenderer.prototype = Object.assign(Object.create(PIEFeatureRenderer.prototype), {
    /**
     * 设置渲染器的风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格句柄内部是否克隆(如果是true，风格句柄需要外部释放，否则会出现内存泄露；如果是false，风格句柄由内部保存并释放，外部不能释放，否则会出现崩溃) 默认值（false）
     * @memberOf TileFeatureRenderer#
     */
    setStyle: function setStyle(style) {
      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      Module._TileFeatureRenderer_SetStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取渲染器风格
     * @memberOf TileFeatureRenderer#
     *
     * @returns {PIEStyle} 成功返回风格对象，失败返回NULL
     */
    getStyle: function getStyle() {
      var handle = Module._TileFeatureRenderer_GetStyle(this.handle);
      return PIEStyleFactory.CreateInstance(handle);
    }
  });

  Object.assign(Object.create(PIETileFeatureRenderer.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 三维瓦片图层基本操作函数
   * @name GlobeBaseTileLayer
   *
   * @extends GlobeLayer
   */
  function PIEGlobeBaseTileLayer(handle, autoRelease) {
    PIEGlobeLayer.call(this, handle, autoRelease);
  }
  PIEGlobeBaseTileLayer.prototype = Object.assign(Object.create(PIEGlobeLayer.prototype), {
    /**
     * 设置数据源名称
     * @param {String} strDsName -目标数据源名称
     * @memberOf GlobeBaseTileLayer#
     */
    setDataSourceName: function setDataSourceName(strDsName) {
      Module._Globe_BTileLayer_SetDataSourceName(this.handle, strDsName);
    },
    /**
     * 获取数据源名称
     *
     * @memberOf GlobeBaseTileLayer#
     * @returns {String} 返回数据源名称
     */
    getDataSourceName: function getDataSourceName() {
      var name = new PIEString(512);
      Module._Globe_BTileLayer_GetDataSourceName(this.handle, name.getHandle());
      var strName = name.toString();
      name.dispose();
      return strName;
    },
    // /**
    //  * 设置数据集名称
    //  * @param {String} strDsName -目标数据集名称
    //  * @memberOf GlobeBaseTileLayer#
    //  */
    setDatasetName: function setDatasetName(strDsName) {
      Module._Globe_BTileLayer_SetDatasetName(this.handle, strDsName);
    },
    // /**
    //  * 获取数据集名称
    //  *
    //  * @memberOf GlobeBaseTileLayer#
    //  * @returns {String} 返回数据集名称
    //  */
    getDatasetName: function getDatasetName() {
      var name = new PIEString(512);
      Module._Globe_BTileLayer_GetDatasetName(this.handle, name.getHandle());
      var strName = name.toString();
      name.dispose();
      return strName;
    },
    /**
     * 设置图层数据源
     * @param {PIEDataSource} datasource -数据源对象
     * @memberOf GlobeBaseTileLayer#
     *
     */
    setDataSource: function setDataSource(datasource) {
      Module._Globe_BTileLayer_SetDataset(this.handle, datasource.getDataset().getHandle());
    },
    /**
     * 获取数据源
     *
     * @memberOf GlobeBaseTileLayer#
     * @returns {PIEDataSource}  -返回数据源
     *
     */
    getDataSource: function getDataSource() {
      var hDataset = Module._Globe_BTileLayer_GetDataset(this.handle);
      var hDataSource = Module._Dataset_GetDataSource(hDataset);
      return PIEDataSourceFactory.CreateInstance(hDataSource);
    },
    /**
     * 设置图层数据集
     * @param {PIEDataset} hDataset -数据集对象
     * @memberOf GlobeBaseTileLayer#
     */
    setDataset: function setDataset(dataset) {
      Module._Globe_BTileLayer_SetDataset(this.handle, dataset.getHandle());
    },
    /**
     * 获取图层数据集
     * @param {PIEDataset} dataset -图层数据集
     * @memberOf GlobeBaseTileLayer#
     *
     * @returns {PIEDataset} 成功返回数据集对象，失败返回null
     */
    getDataset: function getDataset() {
      var handle = Module._Globe_BTileLayer_GetDataset(this.handle);
      return PIEDatasetFactory.CreateInstance(handle);
    },
    /**
     * 设置图层渲染器
     * @param {PIEFeatureRenderer} featureRenderer -要素渲染器对象
     * @memberOf GlobeBaseTileLayer#
     */
    setRenderer: function setRenderer(featureRenderer) {
      Module._Globe_BTileLayer_SetRenderer(this.handle, featureRenderer.getHandle());
    },
    /**
     * 获取图层渲染器
     * @memberOf GlobeBaseTileLayer#
     *
     * @returns {PIEFeatureRenderer} 成功返回要素渲染器对象，失败返回null
     */
    getRenderer: function getRenderer() {
      var handle = Module._Globe_BTileLayer_GetRenderer(this.handle);
      if (handle) {
        return PIEFeatureRenderFactory.CreateInstance(handle);
      }
      return null;
    },
    /**
     * 设置数据源最大层级
     * @param {Number} zoom -最大层级
     * @memberOf GlobeBaseTileLayer#
     */
    setSourceMaxZoom: function setSourceMaxZoom(zoom) {
      Module._Globe_BTileLayer_SetSourceMaxZoom(this.handle, zoom);
    },
    /**
     * 获取数据源最大层级
     * @memberOf GlobeBaseTileLayer#
     * @returns {Number} 返回数据源最大层级
     */
    getSourceMaxZoom: function getSourceMaxZoom() {
      return Module._Globe_BTileLayer_GetSourceMaxZoom(this.handle);
    }
  });

  Object.assign(Object.create(PIEGlobeBaseTileLayer.prototype), {});

  Object.assign(Object.create(PIEGlobeBaseTileLayer.prototype), {});

  Object.assign(Object.create(PIEGlobeBaseTileLayer.prototype), {});

  Object.assign(Object.create(PIEGlobeBaseTileLayer.prototype), {});

  Object.assign(Object.create(PIETileFeatureRenderer.prototype), {});

  Object.assign(Object.create(PIETileFeatureRenderer.prototype), {});

  Object.assign(Object.create(PIETileFeatureRenderer.prototype), {
    setColorProperty: function setColorProperty(colorProperty) {
      var strColorProperty = new PIEString$1(colorProperty);
      Module._CircleTileFeatureRenderer_SetColorProperty(this.handle, strColorProperty.getHandle());
      strColorProperty.dispose();
    },
    getColorProperty: function getColorProperty() {
      var strColorProperty = new PIEString$1(512);
      Module._CircleTileFeatureRenderer_SetColorProperty(this.handle, strColorProperty.getHandle());
      var colorProperty = strColorProperty.toString();
      strColorProperty.dispose();
      return colorProperty;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * Mapbox矢量瓦片图层操作函数
   * @name GlobeMVTLayer
   * @extends GlobeLayer
   */
  function PIEGlobeMVTLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._Globe_MVTLayer_Create();
      autoRelease = true;
    }
    PIEGlobeTileMapLayer.call(this, handle, autoRelease);
  }
  PIEGlobeMVTLayer.prototype = Object.assign(Object.create(PIEGlobeTileMapLayer.prototype), {
    /**
     * 打开Mapbox地图
     * @param {PIEDocument} hDocument -工作空间
     * @param {String} MapUrl -地图url
     * @param {String} SourceUrl -数据源url
     * @param {String} TileUrl -数据瓦片url
     * @returns {Boolean} 是否打开成功
     * @memberOf GlobeMVTLayer#
     */
    open: function open(hDocument, MapUrl, SourceUrl, TileUrl) {
      var strMapUrl = new PIEString$1(MapUrl);
      var strSourceUrl = new PIEString$1(SourceUrl);
      var strTileUrl = new PIEString$1(TileUrl);
      var reslut = Module._Globe_MVTLayer_Open(this.handle, hDocument.getHandle(), strMapUrl.getHandle(), strSourceUrl.getHandle(), strTileUrl.getHandle());
      strMapUrl.dispose();
      strSourceUrl.dispose();
      strTileUrl.dispose();
      return Boolean(reslut);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 分析模块
   * ---
   */

  /**
   * 创建三维场景工具相关操作函数
   * @name GlobeCreateTool
   * @extends GlobeTool
   *
   */
  function PIEGlobeCreateTool(handle, autoRelease) {
    PIEGlobeTool.call(this, handle, autoRelease);
  }
  PIEGlobeCreateTool.prototype = Object.assign(Object.create(PIEGlobeTool.prototype), {});

  Object.assign(Object.create(PIEGlobeCreateTool.prototype), {});

  Object.assign(Object.create(PIERenderGeometry.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 标绘模块
   * ---
   */

  /**
   * 符号尺寸模式
   * @readonly
   * @enum {number}
   */
  var PIESymbolSizeMode = {
    /**
     * 固定大小
     */
    Fixed: 1,
    /**
     * 按比例缩放
     */
    Rate: 2,
    /**
     * 随图缩放
     */
    Auto: 3
  };

  Object.assign(Object.create(PIERasterRenderer.prototype), {
    /**
     * 设置渲染波段索引
     * @param {Number} bandIndex -渲染波段索引
     * @memberOf ClassifyRasterRenderer#
     *
     */
    setBandIndex: function setBandIndex(bandIndex) {
      Module._ClassifyRasterRenderer_SetBandIndex(this.handle, bandIndex);
    },
    /**
     * 获取渲染波段索引
     * @returns {Number} 返回渲染波段索引
     * @memberOf ClassifyRasterRenderer#
     *
     */
    getBandIndex: function getBandIndex() {
      return Module._ClassifyRasterRenderer_GetBandIndex(this.handle);
    },
    /**
     * 设置无效值
     * @param {Number} value -无效值
     * @memberOf ClassifyRasterRenderer#
     *
     */
    setNoValue: function setNoValue(value) {
      Module._ClassifyRasterRenderer_SetNoValue(this.handle, value);
    },
    /**
     * 获取无效值
     *
     * @memberOf ClassifyRasterRenderer#
     * @returns {Number} 返回无效值
     *
     */
    getNoValue: function getNoValue() {
      return Module._ClassifyRasterRenderer_GetNoValue(this.handle);
    },
    /**
     * 获取分类方法
     *
     * @memberOf ClassifyRasterRenderer#
     * @returns {String} 分类方法
     *
     */
    getClassifyMethod: function getClassifyMethod() {
      return Module._ClassifyRasterRenderer_GetClassifyMethod(this.handle);
    },
    /**
     * 获取ClassBreaks数量
     *
     * @memberOf ClassifyRasterRenderer#
     * @returns {Number} 数量
     *
     */
    getClassBreakCount: function getClassBreakCount() {
      return Module._ClassifyRasterRenderer_GetClassBreakCount(this.handle);
    }
  });

  Object.assign(Object.create(PIERasterRenderer.prototype), {
    /**
     * 设置渲染波段索引
     * @param {Number} bandIndex 渲染波段索引
     * @memberOf ColormapRasterRenderer#
     *
     */
    setBandIndex: function setBandIndex(bandIndex) {
      Module._ColormapRasterRenderer_SetBandIndex(this.handle, bandIndex);
    },
    /**
     * 获取渲染波段索引
     *
     * @memberOf ColormapRasterRenderer#
     * @returns {Number} 返回渲染波段索引
     *
     */
    getBandIndex: function getBandIndex() {
      return Module._ColormapRasterRenderer_GetBandIndex(this.handle);
    },
    /**
     * 设置无效值
     * @param {Number} value 无效值
     * @memberOf ColormapRasterRenderer#
     *
     */
    setNoValue: function setNoValue(value) {
      Module._ColormapRasterRenderer_SetNoValue(this.handle, value);
    },
    /**
     * 获取无效值
     *
     * @memberOf ColormapRasterRenderer#
     * @returns {Number} 返回无效值
     *
     */
    getNoValue: function getNoValue() {
      return Module._ColormapRasterRenderer_GetNoValue(this.handle);
    },
    /**
     *  设置颜色表
     * @param {PIEColorTable} colorTable -颜色表对象
     * @memberOf ColormapRasterRenderer#
     *
     */
    setColorTable: function setColorTable(colorTable) {
      Module._ColormapRasterRenderer_SetColorTable(this.handle, colorTable.getHandle());
    },
    /**
     *  获取颜色表
     * @param {PIEColorTable} colorTable -颜色表对象
     * @memberOf ColormapRasterRenderer#
     *
     * @returns {Boolean} 是否获取成功
     */
    getColorTable: function getColorTable(colorTable) {
      return Module._ColormapRasterRenderer_GetColorTable(this.handle, colorTable.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 栅格渲染模块
   * ---
   */

  /**
   * 栅格过滤器操作函数
   * @name RasterFilter
   */
  function PIERasterFilter(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIERasterFilter.prototype, {
    /**
     * 释放栅格过滤器对象
     * @memberOf RasterFilter#
     *
     */
    "delete": function _delete() {
      Module._RasterFilter_Delete(this.handle);
    },
    /**
     * 判断是上层扩展的过滤器还是底层扩展的过滤器
     * @memberOf RasterFilter#
     * @returns {Boolean} 返回是上层扩展的过滤器还是底层扩展的过滤器
     *
     */
    isWrapper: function isWrapper() {
      return Module._RasterFilter_IsWrapper(this.handle);
    },
    /**
     * 获取连接栅格过滤器类型
     *
     * @memberOf RasterFilter#
     * @returns {PIERasterFilterType} 栅格过滤器类型
     *
     */
    getType: function getType() {
      return Module._RasterFilter_GetType(this.handle);
    },
    /**
     * 获取栅格过滤器类ID
     *
     * @memberOf RasterFilter#
     * @returns {String} 栅格过滤器类ID
     *
     */
    getClassID: function getClassID() {
      var strClassID = new PIEString$1(256);
      Module._RasterFilter_GetClassID(this.handle, strClassID.getHandle());
      var ClassID = strClassID.toString();
      strClassID.dispose();
      return ClassID;
    },
    /**
     * 判断栅格过滤器是否可用
     *
     * @memberOf RasterFilter#
     * @returns {Boolean} 返回栅格过滤器是否可用
     *
     */
    isEnable: function isEnable() {
      return Module._RasterFilter_IsEnable(this.handle);
    },
    /**
     * 设置栅格过滤器是否可用
     * @param {Boolean} enable -是否可用
     * @memberOf RasterFilter#
     *
     */
    setEnable: function setEnable(enable) {
      Module._RasterFilter_SetEnable(this.handle, enable);
    },
    /**
     * 设置属性信息
     * @param {String} name -属性名称
     * @param {String} value -属性值
     * @memberOf RasterFilter#
     *
     */
    setProperty: function setProperty(name, value) {
      var strName = new PIEString$1(name);
      var strValue = new PIEString$1(value);
      Module._RasterFilter_SetProperty(this.handle, strName.getHandle(), strValue.getHandle());
      strName.dispose();
      strValue.dispose();
      // return res;
    },

    /**
     * 设置栅格过滤器的栅格渲染器
     * @param {PIERasterRenderer} rasterRender -栅格渲染器对象
     * @memberOf RasterFilter#
     *
     */
    setRasterRenderer: function setRasterRenderer(rasterRender) {
      Module._RasterFilter_SetRasterRenderer(this.handle, rasterRender.getHandle());
    },
    /**
     * 获取栅格过滤器的栅格渲染器
     *
     * @memberOf RasterFilter#
     * @returns {PIERasterRenderer} 栅格渲染器对象
     *
     */
    getRasterRenderer: function getRasterRenderer() {
      var handle = Module._RasterFilter_GetRasterRenderer(this.handle);
      if (handle) {
        return new PIERasterRenderer(handle);
      }
    },
    /**
     * 获取xml中配置参数
     *
     * @memberOf RasterFilter#
     * @returns {String} 返回xml数据
     *
     */
    fromXML: function fromXML() {
      var strXML = new PIEString$1(256);
      Module._RasterFilter_FromXML(this.handle, strXML.getHandle());
      var xml = strXML.toString();
      strXML.dispose();
      return xml;
    },
    /**
     *栅格过滤器对象全局锁
     * @memberOf RasterFilter#
     *
     */
    lockObject: function lockObject() {
      Module._RasterFilter_LockObject(this.handle);
    },
    /**
     *打开栅格过滤器对象全局锁
     * @memberOf RasterFilter#
     *
     */
    unlockObject: function unlockObject() {
      Module._RasterFilter_UnlockObject(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 栅格渲染模块
   * ---
   */

  /**
   *
   * 创建栅格后置过滤器
   * @name AfterRasterFilter
   * @class AfterRasterFilter
   * 栅格后置过滤器操作函数
   *
   * @param {Object} options -
   * @param {String} options.classID -ID
   *
   * @extends RasterFilter
   * @example
   * let afterRasterFilter = new PIE.AfterRasterFilter({classID:"123"});
   *
   */
  function PIEAfterRasterFilter(options) {
    var handle = null;
    var autoRelease = false;
    if (options) {
      var classID = options.classID;
      if (classID) {
        var strClassID = new PIEString$1(classID);
        handle = Module._AfterRasterFilter_Create(strClassID.getHandle());
        strClassID.dispose();
        autoRelease = true;
      }
      if (options.handle) {
        handle = options.handle;
      }
    }
    PIERasterFilter.call(this, handle, autoRelease);
  }
  PIEAfterRasterFilter.prototype = Object.assign(Object.create(PIERasterFilter.prototype), {
    /**
     * 是否全波段显示
     *
     * @memberOf AfterRasterFilter#
     * @returns {Boolean} 是否设置成功
     *
     */
    isRequestAllBands: function isRequestAllBands() {
      return Module._AfterRasterFilter_IsRequestAllBands(this.handle);
    },
    /**
     * 创建栅格后置过滤器对象
     *
     * @memberOf AfterRasterFilter#
     * @returns {PIEAfterRasterFilter} 栅格后置过滤器对象
     *
     */
    createWrapper: function createWrapper() {
      var handle = Module._AfterRasterFilter_CreateWrapper();
      if (handle) {
        return new PIEAfterRasterFilter(handle);
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建水体渲染对象
   * @name RenderWater
   * @class RenderWater
   * 水体渲染操作函数
   * @extends RenderPolygon3D
   */
  function PIERenderWater(handle, autoRelease) {
    if (handle == null) {
      handle = Module._RenderWater_Create();
      autoRelease = true;
    }
    PIERenderPolygon3D.call(this, {
      handle: handle,
      autoRelease: autoRelease
    });
  }
  PIERenderWater.prototype = Object.assign(Object.create(PIERenderPolygon3D.prototype), {
    /**
     * 加载纹理数据
     * @param {Object} options -
     * @param {String} options.file -从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.url -纹理路径url(必填项)
     * @param {PIEFillEffect} options.fillEffect -填充效果
     *
     * @memberOf RenderWater#
     * @returns {Promise} 返回一个promise，在value中存放水体渲染对象
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var url = options.url;
        if (options.fillEffect != null) {
          that.setFillEffect(options.fillEffect);
        }
        if (url == null) {
          return null;
        }
        var name = PIEFile.getFileName(url);
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        var filesPicks = [];
        filesPicks.push(file);
        var urlsPicks = [];
        urlsPicks.push(url);
        function callBack(filelist, urllist, datalist) {
          var strPath = new PIEString$1(filelist[0]);
          Module._RenderWater_SetNormalPath(that.handle, strPath.getHandle());
          strPath.dispose();
          resolve(that);
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    setNormalPath: function setNormalPath(path) {
      var strPath = new PIE.String(path);
      Module._RenderWater_SetNormalPath(this.handle, strPath.getHandle());
      strPath.dispose();
    },
    /**
     * 获取填充效果
     *
     * @memberOf RenderWater#
     * @returns {PIEFillEffect} 返回填充效果
     */
    getFillEffect: function getFillEffect() {
      return Module._RenderWater_GetFillEffect(this.handle);
    },
    /**
     * 设置填充效果
     * @param {PIEFillEffect} effect 填充效果
     * @memberOf RenderWater#
     */
    setFillEffect: function setFillEffect(effect) {
      Module._RenderWater_SetFillEffect(this.handle, effect);
    },
    /**
     * 设置法向量纹理
     * @param {PIETexture} texture -法向量纹理
     * @memberOf RenderWater#
     */
    setNormalTexture: function setNormalTexture(texture) {
      Module._RenderWater_SetNormalTexture(this.handle, texture.getHandle());
    },
    /**
     * 获取法向量纹理
     *
     * @memberOf RenderWater#
     * @returns {PIETexture} 返回法向量纹理
     */
    getNormalTexture: function getNormalTexture() {
      var handle = Module._RenderWater_GetNormalTexture(this.handle);
      if (handle) {
        return new PIETexture(handle);
      }
    },
    /**
     * 获取水流速度
     *
     * @memberOf RenderWater#
     * @returns {Number} 返回水流速度
     */
    getWaterScale: function getWaterScale() {
      return Module._RenderWater_GetWaterScale(this.handle);
    },
    /**
     * 设置水流速度
     * @param {Number} scale 水流速度
     * @memberOf RenderWater#
     */
    setWaterScale: function setWaterScale(scale) {
      Module._RenderWater_SetWaterScale(this.handle, scale);
    },
    /**
     * 获取水流颜色
     *
     * @memberOf RenderWater#
     * @returns {PIEVector3} 返回水流颜色
     */
    getWaterColor: function getWaterColor() {
      var colorArray = new PIEArray(3, PIEArrayType.UInt8);
      Module._RenderWater_GetWaterColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var arrayColor = colorArray.toArray();
      colorArray.dispose();
      return new PIEVector3(arrayColor[0], arrayColor[1], arrayColor[2]);
    },
    /**
     * 设置水流颜色
     * @param {PIEVector3/Array} color 水流颜色
     * @memberOf RenderWater#
     */
    setWaterColor: function setWaterColor(color) {
      var colorArray = null;
      if (color instanceof PIEVector3) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray != null) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderWater_SetWaterColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建河流渲染对象
   * @name RenderRiver
   * @class RenderRiver
   * 河流渲染操作函数
   * @extends RenderPolygon3D
   */
  function PIERenderRiver(handle, autoRelease) {
    if (handle == null) {
      handle = Module._RenderRiver_Create();
      autoRelease = true;
    }
    PIERenderPolygon3D.call(this, {
      handle: handle,
      autoRelease: autoRelease
    });
  }
  PIERenderRiver.prototype = Object.assign(Object.create(PIERenderPolygon3D.prototype), {
    /**
     * 加载纹理数据
     * @param {Object} options -
     * @param {String} options.normal0Url -法向量垂直扰动纹理路径url(必填项)
     * @param {String} options.normal1Url -法向量水平扰动纹理路径url(必填项)
     * @param {String} options.flowUrl -流向纹理路径url(必填项)
     * @param {String} options.blendUrl -混合纹理路径url(可以为空)
     *
     * @memberOf RenderRiver#
     * @returns {Promise} 返回一个promise，在value中存放水体渲染对象
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var normal0File = options.normal0File;
        var normal1File = options.normal1File;
        var flowFile = options.flowFile;
        var blendFile = options.blendFile;
        var normal0Url = options.normal0Url;
        var normal1Url = options.normal1Url;
        var flowUrl = options.flowUrl;
        var blendUrl = options.blendUrl;
        if (!normal0Url || !normal1Url || !flowUrl) {
          return null;
        }
        if (!normal0File) {
          var name = PIEFile.getFileName(normal0Url);
          normal0File = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        if (!normal1File) {
          var name1 = PIEFile.getFileName(normal1Url);
          normal1File = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name1;
        }
        if (!flowFile) {
          var name2 = PIEFile.getFileName(flowUrl);
          flowFile = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name2;
        }
        if (!blendFile) {
          var name3 = PIEFile.getFileName(blendUrl);
          blendFile = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name3;
        }
        var filesPicks = [normal0File, normal1File, flowFile];
        var urlsPicks = [normal0Url, normal1Url, flowUrl];
        if (blendUrl) {
          urlsPicks.push(blendUrl);
          filesPicks.push(blendFile);
        }
        function callBack(filelist, urllist, datalist) {
          var strPath = new PIEString$1(filelist[0]);
          Module._RenderRiver_SetNormal0Path(that.handle, strPath.getHandle());
          strPath.dispose();
          var strPath1 = new PIEString$1(filelist[1]);
          Module._RenderRiver_SetNormal1Path(that.handle, strPath1.getHandle());
          strPath1.dispose();
          var strPath2 = new PIEString$1(filelist[2]);
          Module._RenderRiver_SetFlowPath(that.handle, strPath2.getHandle());
          strPath2.dispose();
          if (filesPicks.length == 4) {
            var strPath3 = new PIEString$1(filelist[3]);
            Module._RenderRiver_SetBlendPath(that.handle, strPath3.getHandle());
            strPath3.dispose();
          }
          resolve(that);
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    /**
     * 设置河流流速
     *
     * @memberOf RenderRiver#
     * @param {Number} speed -流速
     */
    setRiverSpeed: function setRiverSpeed(speed) {
      return Module._RenderRiver_SetRiverSpeed(this.handle, speed);
    },
    /**
     * 获取河流流速
     *
     * @memberOf RenderRiver#
     * @returns {Number} 返回河流流速
     */
    getRiverSpeed: function getRiverSpeed(speed) {
      return Module._RenderRiver_GetRiverSpeed(this.handle);
    },
    /**
     * 设置河流比例
     *
     * @memberOf RenderRiver#
     * @param {Number} speed -河流比例
     */
    setRiverScale: function setRiverScale(scale) {
      return Module._RenderRiver_SetRiverScale(this.handle, scale);
    },
    /**
     * 获取河流比例
     *
     * @memberOf RenderRiver#
     * @returns {Number} 返回河流比例
     */
    getRiverScale: function getRiverScale() {
      return Module._RenderRiver_GetRiverScale(this.handle);
    },
    /**
     * 设置河流反射比例
     *
     * @memberOf RenderRiver#
     * @param {Number} reflectivity -河流反射比例
     */
    setReflectivity: function setReflectivity(reflectivity) {
      return Module._RenderRiver_SetReflectivity(this.handle, reflectivity);
    },
    /**
     * 获取河流反射比例
     *
     * @memberOf RenderRiver#
     * @returns {Number} 返回河流反射比例
     */
    getReflectivity: function getReflectivity() {
      return Module._RenderRiver_GetReflectivity(this.handle);
    },
    /**
     * 设置河流混合比例
     *
     * @memberOf RenderRiver#
     * @param {Number} scale -河流混合比例
     */
    setBlendScale: function setBlendScale(scale) {
      return Module._RenderRiver_SetBlendScale(this.handle, scale);
    },
    /**
     * 获取河流混合比例
     *
     * @memberOf RenderRiver#
     * @returns {Number} 返回河流混合比例
     */
    getBlendScale: function getBlendScale() {
      return Module._RenderRiver_GetBlendScale(this.handle);
    },
    /**
     * 获取河流颜色
     *
     * @memberOf RenderRiver#
     * @returns {PIEVector3} 返回河流颜色
     */
    getWaterColor: function getWaterColor() {
      var colorArray = new PIEArray(3, PIEArrayType.UInt8);
      Module._RenderRiver_GetWaterColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var arrayColor = colorArray.toArray();
      colorArray.dispose();
      return new PIEVector3(arrayColor[0], arrayColor[1], arrayColor[2]);
    },
    /**
     * 设置河流颜色
     * @param {Array/PIEVector3} color -河流颜色
     * @memberOf RenderRiver#
     */
    setWaterColor: function setWaterColor(color) {
      var colorArray = null;
      if (color instanceof PIEVector3) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray != null) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderRiver_SetWaterColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    }
  });

  Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 加载雷达对象
     * @param {Object} options -
     * @param {PIERadarMsg} options.radarMsg -雷达对象
     * @param {Array} options.radarDisturbMsgs -雷达干扰机对象数组
     * @param {Array} options.imagefile -雷达贴图数据url
     * @param {Array} options.antennaImageUrl -雷达天线贴图url
     * @param {Array} options.position -雷达位置
     * @memberOf RenderRadar#
     * @returns {Promise} 返回一个promise，在value中存放创建好的RenderRadar对象
     */
    load: function load(options) {
      if (this.getHandle() == null) {
        this.handle = Module._RenderRadar_Create();
      }
      var that = this;
      return new Promise(function (resolve, reject) {
        var imageUrl = options.imageUrl;
        var antennaImageUrl = options.antennaImageUrl;
        var radarDisturbMsgs = options.radarDisturbMsgs;
        var radarMsg = options.radarMsg;
        if (radarMsg == null || radarDisturbMsgs == null) {
          resolve(null);
        }
        var filesPicks = [];
        if (imageUrl == null || antennaImageUrl == null) {
          resolve(null);
        }
        var imageName = PIEFile.getFileName(imageUrl);
        var imagefile = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + imageName;
        var antennaImageName = PIEFile.getFileName(antennaImageUrl);
        var antennaImageFile = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + antennaImageName;
        filesPicks.push(imagefile);
        filesPicks.push(antennaImageFile);
        var urlsPicks = [];
        urlsPicks.push(imageUrl);
        urlsPicks.push(antennaImageUrl);
        function callBack(filelist, urllist, datalist) {
          var strImage = new PIEString$1(filesPicks[0]);
          var strAntennaImage = new PIEString$1(filesPicks[1]);
          that.setRadarBoxMsg(radarMsg, radarDisturbMsgs);
          Module._RenderRadar_SetImagePath(that.handle, strImage.getHandle());
          Module._RenderRadar_ImageWaveForSectionPath(that.handle, strAntennaImage.getHandle());
          if (options.position != null) {
            that.setPosition(options.position);
          }
          strImage.dispose();
          strAntennaImage.dispose();
          resolve(that);
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    /**
     *
     *
     * @memberOf RenderRadar#
     */
    updateSectorDisMsg: function updateSectorDisMsg(imagePath) {
      var strImagePath = new PIEString$1(imagePath);
      Module._RenderRadar_UpdateSectorDisMsg(this.handle, strImagePath.getHandler());
      strImagePath.dispose();
    },
    setAlpha: function setAlpha(alpha) {
      Module._RenderRadar_SetAlpha(this.handle, alpha);
    },
    getMsg: function getMsg() {
      return Module._RenderRadar_GetMsg(this.handle);
    },
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof PIEVector3) {
        posArray = position.toArray();
      } else if (position instanceof Array) {
        posArray = position;
      }
      if (posArray != null) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._RenderRadar_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    setRadarAntennaType: function setRadarAntennaType(type) {
      Module._RenderRadar_SetRadarAntennaType(this.handle, type);
    },
    setRadarAntennaStyle: function setRadarAntennaStyle(style) {
      Module._RenderRadar_SetRadarAntennaStyle(this.handle, style);
    },
    setRadarAntennaSpeed: function setRadarAntennaSpeed(speed) {
      Module._RenderRadar_SetRadarAntennaSpeed(this.handle, speed);
    },
    setRadarBoxColor: function setRadarBoxColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray != null) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderRadar_SetRadarBoxColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    setRadarSectorColor: function setRadarSectorColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray != null) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderRadar_SetRadarSectorColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    setRadarAntennaColor: function setRadarAntennaColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray != null) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderRadar_SetRadarAntennaColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    setRadarBoxMsg: function setRadarBoxMsg(radarBoxMsg, arrDisturbMsg) {
      var disturbHandles = [];
      var distureSize = arrDisturbMsg.length;
      for (var i = 0; i < distureSize; i++) {
        disturbHandles.push(arrDisturbMsg[i].handle);
      }
      var disturbHandleArraty = new PIEArray(disturbHandles, PIEArrayType.Int32);
      Module._RenderRadar_SetRadarBoxMsg(this.handle, radarBoxMsg.handle, disturbHandleArraty.getHandle(), disturbHandles.length);
      for (var _i = 0; _i < disturbHandles.length; ++_i) {
        disturbHandles.pop();
      }
    },
    setRadarAntennaMsg: function setRadarAntennaMsg(radarBoxMsg) {
      Module._RenderRadar_SetRadarAntennaMsg(this.handle, radarBoxMsg.handle);
    },
    updateRadarBoxMsg: function updateRadarBoxMsg(radarBoxMsg) {
      Module._RenderRadar_UpdateRadarBoxMsg(this.handle, radarBoxMsg.handle);
    },
    updateRadarBoxDisturbMsg: function updateRadarBoxDisturbMsg(arrDisturbMsg) {
      var disturbHandles = [];
      var distureSize = arrDisturbMsg.length;
      for (var i = 0; i < distureSize; i++) {
        disturbHandles.push(arrDisturbMsg[i].handle);
      }
      var disturbHandleArraty = new PIEArray(disturbHandles, PIEArrayType.Int32);
      Module._RenderRadar_UpdateRadarBoxDisturbMsg(this.handle, disturbHandleArraty.getHandle(), disturbHandles.length);
      for (var _i2 = 0; _i2 < disturbHandles.length; ++_i2) {
        disturbHandles.pop();
      }
    },
    updateRadarBoxDisturbPos: function updateRadarBoxDisturbPos(index, pos) {
      var posArray = null;
      if (pos instanceof PIEVector3) {
        posArray = pos.toArray();
      } else if (pos instanceof Array) {
        posArray = pos;
      }
      if (pos != null) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._RenderRadar_UpdateRadarBoxDisturbPos(this.handle, index, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    updateRadarAntennaMsg: function updateRadarAntennaMsg(radarBoxMsg) {
      Module._RenderRadar_UpdateRadarAntennaMsg(this.handle, radarBoxMsg.handle);
    },
    setAntenaDirection: function setAntenaDirection(fyAngle, fwAngle) {
      Module._RenderRadar_SetAntenaDirection(this.handle, fyAngle, fwAngle);
    }
  });

  Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 设置雷达组网贴图
     *
     * @memberOf RenderRadar#
     */
    setImagePath: function setImagePath(imagePath) {
      var strImage = new PIE.String(imagePath);
      Module._RenderRadarGroup_SetImagePath(this.handle, strImage.getHandle());
      strImage.dispose();
    },
    setGroupConfig: function setGroupConfig(arrRenderRadar) {
      var surfValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;
      var arrRender = [];
      if (arrRenderRadar instanceof Array && arrRenderRadar.length > 0) {
        var length = arrRenderRadar.length;
        var i = 0;
        for (i; i < length; i++) {
          var renderRadar = arrRenderRadar.at(i);
          arrRender.push(renderRadar.getHandle());
        }
      }
      if (arrRender.length > 0) {
        var renderArr = new PIEArray(arrRender, PIEArrayType.Int32);
        Module._RenderRadarGroup_SetGroupConfig(this.handle, renderArr.getHandle(), arrRenderRadar.length, surfValue);
        renderArr.dispose();
      }
    },
    setGroupColor: function setGroupColor(color) {
      var colorArray = null;
      if (color instanceof PIEColor) {
        colorArray = color.toArray();
      } else if (color instanceof Array) {
        colorArray = color;
      }
      if (colorArray != null) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderRadarGroup_SetGroupColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    updateGroup: function updateGroup() {
      Module._RenderRadarGroup_UpdateGroup(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 雷达
   * @name RadarMsg
   * @class RadarMsg
   * 创建雷达对象
   */

  function PIERadarMsg(options) {
    if (options != null) {
      if (options.handle == null) {
        this.handle = Module._RadarMsg_Create();
        this.autoRelease = true;
      } else {
        this.handle = options.handle;
      }
    } else {
      this.handle = Module._RadarMsg_Create();
      this.autoRelease = true;
    }
  }
  Object.assign(PIERadarMsg.prototype, {
    SetPt: function SetPt(value) {
      Module._RadarMsg_SetPt(this.handle, value);
    },
    SetGt: function SetGt(value) {
      Module._RadarMsg_SetGt(this.handle, value);
    },
    // 信号波长m
    SetLanBuda: function SetLanBuda(value) {
      Module._RadarMsg_SetLanBuda(this.handle, value);
    },
    // 目标的雷达反射截面积 m2
    SetThegema: function SetThegema(value) {
      Module._RadarMsg_SetThegema(this.handle, value);
    },
    //脉冲积累数
    SetN: function SetN(value) {
      Module._RadarMsg_SetN(this.handle, value);
    },
    //玻尔兹曼常数
    SetK: function SetK(value) {
      Module._RadarMsg_SetK(this.handle, value);
    },
    //接收机通频带宽度 1.6* pow(10, 6)
    SetBn: function SetBn(value) {
      Module._RadarMsg_SetBn(this.handle, value);
    },
    //雷达接收机噪声系数
    SetFn: function SetFn(value) {
      Module._RadarMsg_SetFn(this.handle, value);
    },
    //雷达接收机最小可检测信噪比 2
    SetS_Delta_N: function SetS_Delta_N(value) {
      Module._RadarMsg_SetS_Delta_N(this.handle, value);
    },
    //以绝对温度表示的雷达接收机噪声温度
    SetT0: function SetT0(value) {
      Module._RadarMsg_SetT0(this.handle, value);
    },
    //方位角
    SetAz_SEnd_Angle: function SetAz_SEnd_Angle(startAngle, endAngle) {
      Module._RadarMsg_SetAz_SEnd_Angle(this.handle, startAngle, endAngle);
    },
    //俯仰角
    SetPitch_SEnd_Angle: function SetPitch_SEnd_Angle(startAngle, endAngle) {
      Module._RadarMsg_SetPitch_SEnd_Angle(this.handle, startAngle, endAngle);
    },
    //设置雷达参数缺失
    SetbParameterMiss: function SetbParameterMiss(value) {
      Module._RadarMsg_SetbParameterMiss(this.handle, value);
    },
    //设置雷达参数缺失情况下的雷达半径
    SetRadius: function SetRadius(value) {
      Module._RadarMsg_SetRadius(this.handle, value);
    },
    //天线图主瓣水平宽度，单位度
    SetLobeWidth_h: function SetLobeWidth_h(value) {
      Module._RadarMsg_SetLobeWidth_h(this.handle, value);
    },
    //天线图主瓣垂直宽度，单位度
    SetLobeWidth_v: function SetLobeWidth_v(value) {
      Module._RadarMsg_SetLobeWidth_v(this.handle, value);
    },
    //天线图主瓣半功率水平宽度，单位度
    SetLlobeWidth_halfPt_h: function SetLlobeWidth_halfPt_h(value) {
      Module._RadarMsg_SetLlobeWidth_halfPt_h(this.handle, value);
    },
    //天线图主瓣半功率垂直宽度，单位度
    SetLobeWidth_halfPt_v: function SetLobeWidth_halfPt_v(value) {
      Module._RadarMsg_SetLobeWidth_halfPt_v(this.handle, value);
    },
    //设置雷达的位置 墨卡托
    SetPos: function SetPos(x, y, z) {
      Module._RadarMsg_SetPos(this.handle, x, y, z);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 雷达干扰机
   * @name RadarDisturbMsg
   * @class RadarDisturbMsg
   * 创建雷达干扰机对象
   */
  function PIERadarDisturbMsg(options) {
    if (options != null) {
      if (options.handle == null) {
        this.handle = Module._RadarDisturbMsg_Create();
        this.autoRelease = true;
      } else {
        this.handle = options.handle;
      }
    } else {
      this.handle = Module._RadarDisturbMsg_Create();
      this.autoRelease = true;
    }
  }
  Object.assign(PIERadarDisturbMsg.prototype, {
    SetPJ: function SetPJ(value) {
      Module._RadarDisturbMsg_SetPj(this.handle, value);
    },
    SetGJ: function SetGJ(value) {
      Module._RadarDisturbMsg_SetGj(this.handle, value);
    },
    SetBJ: function SetBJ(value) {
      Module._RadarDisturbMsg_SetBj(this.handle, value);
    },
    SetKJ: function SetKJ(value) {
      Module._RadarDisturbMsg_SetKj(this.handle, value);
    },
    SetK: function SetK(value) {
      Module._RadarDisturbMsg_SetK(this.handle, value);
    },
    SetTheta_Half: function SetTheta_Half(value) {
      Module._RadarDisturbMsg_SetTheta_Half(this.handle, value);
    },
    //设置雷达的位置 墨卡托
    SetPos: function SetPos(x, y, z) {
      Module._RadarDisturbMsg_SetPos(this.handle, x, y, z);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 创建图标符号对象
   * @name IconSymbol
   * @class IconSymbol
   * 图标符号操作函数
   *
   * @extends Symbol
   * @example
   *
   * let iconSymbol = new PIE.IconSymbol();
   *
   */
  function PIEIconSymbol(handle, autoRelease) {
    if (handle == null) {
      handle = Module._IconSymbol_Create();
      autoRelease = true;
    }
    PIESymbol.call(this, handle, autoRelease);
  }
  PIEIconSymbol.prototype = Object.assign(Object.create(PIESymbol.prototype), {
    // /**
    //  * 获取符号的名称
    //  *
    //  * @memberOf IconSymbol#
    //  * @returns {String} 返回符号名称
    //  *
    //  */
    getPath: function getPath() {
      var strPath = new PIEString$1(256);
      Module._IconSymbol_GetPath(this.handle, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    // /**
    //  * 设置符号的路径
    //  * @param {String} path -符号路径
    //  *
    //  * @memberOf IconSymbol#
    //  *
    //  */
    setPath: function setPath(path) {
      var strPath = new PIEString$1(path);
      Module._IconSymbol_SetPath(this.handle, strPath.getHandle());
      strPath.dispose();
    },
    /**
     * 加载并设置符号
     * @param {Object} options -
     * @param {String} options.file -符号从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空)
     * @param {String} options.url  -符号图片的服务地址
     * @param {Boolean} options.base64  -符号图片格式是否是base64格式(默认为否)
     * @param {Int}    options.id       -用来设置符号的ID
     * @param {String} options.name     -用来设置符号的名字
     *
     * @memberOf IconSymbol#
     * @returns {Promise} 返回一个Promise，resolve了一个成功加载图片并设置了Name，ID和Path的IconSymbol对象
     * @example
     * let options = {
     *   file:'Resource/SymbolLib/System/location.png',
     *   url:'http://127.0.0.1:8080/Resource/SymbolLib/System/location.png',
     *   id: 11800,
     *   name:'star'
     * }
     * let iconSymbol = new PIE.IconSymbol();
     * let symbolLib = this.getGlobeControl().getGlobe().getDocument().getSymbolLib();
     * let symbolGroup = symbolLib.getGroup(PIE.SymbolGroupType.Icon)
     * iconSymbol.load(options).then((value)=>{
     * //value就是成功设置图片name，id的iconSymbol，可以对其加入到symbolGroup中，或者其他操作
     * symbolGroup.add(value)
     *
     * })
     *
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var filesPicks = [];
        var file = options.file;
        var url = options.url;
        if (!url || url == "") {
          reject(new Error('PIE.IconSymbol.load: input url is NULL'));
          return;
        }
        function callBack(filelist, urllist, datalist) {
          that.setID(options.id);
          that.setName(options.name);
          that.setPath(filesPicks[0]);
          resolve(that);
        }
        if (options.base64) {
          var _file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + "base64.png"; //设置生成json文件路径
          PIEFile.makeFolder(_file);
          var stream = Module.FS.open(_file, 'w+');
          var raw = window.atob(options.url); // 解码base64得到二进制字符串
          var rawLength = raw.length;
          var dataArray = new Uint8Array(rawLength); // 创建8位无符号整数值的类型化数组

          for (var i = 0; i < raw.length; i++) {
            dataArray[i] = raw.charCodeAt(i);
          }
          var blob = new Blob([dataArray], {
            type: "image/png"
          });
          blob.arrayBuffer().then(function (buffer) {
            var dataArray1 = new Uint8Array(buffer);
            Module.FS.write(stream, dataArray1, 0, dataArray1.length, 0);
            Module.FS.close(stream);
            that.setID(options.id);
            that.setName(options.name);
            that.setPath(_file);
            resolve(that);
          });
        } else {
          var name = PIEFile.getFileName(options.url);
          if (!file) {
            file = "data/" + PIEFile.uuid() + "/" + name;
          }
          filesPicks.push(file);
          var urlsPicks = [];
          urlsPicks.push(options.url);
          PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
        }
      });
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
  * 符号组类型枚举
  * @readonly
  * @enum {number}
  */
  var PIESymbolGroupType = {
    /**空类型*/
    Null: 0,
    // /**点符号组类型*/
    // Marker: 1,
    // /**线符号组类型*/
    // Line: 3,
    // /**填充符号组类型*/
    // Fill: 5,
    /**图标符号组类型*/
    Icon: 16
    // /**模型符号组类型*/
    // Model: 32
  };

  Object.assign(Object.create(PIESymbol.prototype), {
    // /**
    //  * 获取符号的名称
    //  * @memberOf FillSymbol#
    //  * @returns {String} 返回符号名称
    //  */
    getPath: function getPath() {
      var strPath = new PIEString$1(256);
      Module._FillSymbol_GetPath(this.handle, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    // /**
    //  * 设置符号的名称
    //  * @param {String} path -符号名称
    //  *
    //  * @memberOf FillSymbol#
    //  *
    //  */
    setPath: function setPath(path) {
      var strPath = new PIEString$1(path);
      Module._FillSymbol_SetPath(this.handle, strPath.getHandle());
      strPath.dispose();
    },
    // /**
    //  * 设置符号的是否可以修改颜色
    //  * @param {Boolean} enable -判断标示
    //  *
    //  * @memberOf FillSymbol#
    //  */
    enableCustomColor: function enableCustomColor(enable) {
      Module._FillSymbol_EnableCustomColor(this.handle, enable);
    },
    // /**
    //  * 获取符号的是否可以修改颜色
    //  * @memberOf FillSymbol#
    //  * @returns {Boolean} 返回是否可以修改颜色
    //  */
    isCustomColorEnabled: function isCustomColorEnabled() {
      return Module._FillSymbol_IsCustomColorEnabled(this.handle);
    }
  });

  Object.assign(Object.create(PIESymbol.prototype), {
    // /**
    //  * 获取符号的名称
    //  *
    //  * @memberOf MarkerSymbol#
    //  * @returns {String} 返回符号名称
    //  */
    getPath: function getPath() {
      var strPath = new PIEString$1(256);
      Module._MarkerSymbol_GetPath(this.handle, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    // /**
    //  * 设置符号的名称
    //  * @param {String} path -符号名称
    //  * @memberOf MarkerSymbol#
    //  */
    setPath: function setPath(path) {
      var strPath = new PIEString$1(path);
      var res = Module._MarkerSymbol_SetPath(this.handle, strPath.getHandle());
      strPath.dispose();
      return res;
    },
    //
    // /**
    //  * 启用自定义颜色
    //  * @param {Boolean} enable -是否成功启用
    //  * @memberOf MarkerSymbol#
    //  */
    enableCustomColor: function enableCustomColor(enable) {
      Module._MarkerSymbol_EnableCustomColor(this.handle, enable);
    },
    // /**
    //  * 判断自定义颜色是否成功启用
    //  * @memberOf MarkerSymbol#
    //  * @returns {Boolean} 返回是否成功启用
    //  */
    isCustomColorEnabled: function isCustomColorEnabled() {
      return Module._MarkerSymbol_IsCustomColorEnabled(this.handle);
    }
  });

  Object.assign(Object.create(PIESymbol.prototype), {
    // /**
    //  * 获取符号的名称
    //  *
    //  * @memberOf ModelSymbol#
    //  * @returns {String} 返回符号名称
    //  */
    getPath: function getPath() {
      var strPath = new PIEString$1(256);
      Module._ModelSymbol_GetPath(this.handle, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    // /**
    //  * 设置符号的名称
    //  * @param {String} path -符号名称
    //  * @memberOf ModelSymbol#
    //  */
    setPath: function setPath(path) {
      var strPath = new PIEString$1(path);
      var res = Module._ModelSymbol_SetPath(this.handle, strPath.getHandle());
      strPath.dispose();
      return res;
    },
    // /**
    //  * 获取符号的mesh
    //  *
    //  * @memberOf ModelSymbol#
    //  * @returns {PIEModelMesh} 返回符号mesh
    //  */
    getModelMesh: function getModelMesh() {
      var handle = Module._ModelSymbol_GetModelMesh(this.handle);
      if (handle) {
        return new PIEModelMesh(handle);
      }
    }
  });

  Object.assign(Object.create(PIESymbol.prototype), {
    // /**
    //  * 获取符号的名称
    //  *
    //  * @memberOf LineSymbol#
    //  * @returns {String} 返回符号名称
    //  */
    getPath: function getPath() {
      var strPath = new PIEString$1(256);
      Module._LineSymbol_GetPath(this.handle, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    // /**
    //  * 设置符号的名称
    //  * @param {String} path -符号名称
    //  *
    //  * @memberOf LineSymbol#
    //  */
    setPath: function setPath(path) {
      var strPath = new PIEString$1(path);
      var res = Module._LineSymbol_SetPath(this.handle, strPath.getHandle());
      strPath.dispose();
      return res;
    },
    // /**
    //  * 启用自定义宽度
    //  * @param {Boolean} enable -是否成功启用
    //  * @memberOf LineSymbol#
    //  */
    enableCustomWidth: function enableCustomWidth(enable) {
      Module._LineSymbol_EnableCustomWidth(this.handle, enable);
    },
    // /**
    //  * 判断是否启用自定义宽度
    //  * @memberOf LineSymbol#
    //  * @returns {Boolean}  返回自定义宽度是否启用
    //  */
    isCustomWidthEnabled: function isCustomWidthEnabled() {
      return Module._LineSymbol_IsCustomWidthEnabled(this.handle);
    },
    // /**
    //  * 启用自定义颜色
    //  * @param {Boolean} enable -是否成功启用
    //  * @memberOf LineSymbol#
    //  */
    enableCustomColor: function enableCustomColor(enable) {
      Module._LineSymbol_EnableCustomColor(this.handle, enable);
    },
    // /**
    //  * 判断自定义颜色是否启用
    //  * @memberOf LineSymbol#
    //  * @returns {Boolean} 返回自定义颜色是否启用
    //  */
    isCustomColorEnabled: function isCustomColorEnabled() {
      return Module._LineSymbol_IsCustomColorEnabled(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气渲染
   * @name WeatherRender
   *
   */
  function PIEWeatherRender(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEWeatherRender.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._PIEWeatherRender_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置高度
     * @param {Number} height -高度
     * @memberOf WeatherRender#
     *
     */
    setHeight: function setHeight(height) {
      Module._PIEWeatherRender_SetHeight(this.handle, height);
    },
    /**
     * 设置渲染优先级ID
     * @param {Number} id -渲染优先级ID
     * @memberOf WeatherRender#
     *
     */
    setRenderPriorityID: function setRenderPriorityID(id) {
      Module._PIEWeatherRender_SetRenderPriorityID(this.handle, id);
    },
    /**
     * 添加渲染数据
     * @param {PIEWeatherRenderData} hWeatherData -渲染数据
     * @memberOf WeatherRender#
     *
     */
    addRenderData: function addRenderData(hWeatherData) {
      Module._PIEWeatherRender_AddRenderData(this.handle, hWeatherData.getHandle());
    },
    /**
     * 设置跟踪图层
     * @param {PIEGlobeRenderableLayer} hTrackingLayer -跟踪图层
     * @memberOf WeatherRender#
     *
     */
    setTrackingLayer: function setTrackingLayer(hTrackingLayer) {
      Module._PIEWeatherRender_SetTrackingLayer(this.handle, hTrackingLayer.getHandle());
    },
    /**
     * 设置图层透明值
     * @param {Number} nTransparent -图层透明值
     * @memberOf WeatherRender#
     */
    setTransparent: function setTransparent(nTransparent) {
      Module._PIEWeatherRender_SetTransparent(this.handle, nTransparent);
    },
    /**
     * 设置地图对象
     * @param {PIEGlobe} hGlobe -地图对象
     * @memberOf WeatherRender#
     *
     */
    setGlobe: function setGlobe(hGlobe) {
      Module._PIEWeatherStreamLineRender_SetGlobe(this.handle, hGlobe.handle);
    },
    /**
     * 提交渲染
     * @memberOf WeatherRender#
     */
    initialize: function initialize() {
      Module._PIEWeatherRender_Initialize(this.handle);
    }
  });

  Object.assign(Object.create(PIEWeatherRender.prototype), {
    /**
     * 设置颜色表
     * @param {String} colorPath -颜色表文件路径
     *
     * @memberOf WeatherRasterRender#
     */
    setColorTable: function setColorTable(colorPath) {
      var strPath = new PIEString$1(colorPath);
      Module._PIEWeatherRasterRender_SetColorTable(this.handle, strPath.getHandle());
      strPath.dispose();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气Mesh渲染器
   * @name WeatherMeshRender
   * @class WeatherMeshRender
   *
   * @param {Object} options -
   * @param {String} options.name -Mesh数据名称
   *
   * @extends WeatherRender
   */
  function PIEWeatherMeshRender(options) {
    var handle = null;
    var autoRelease = false;
    if (options != null) {
      var strName = new PIEString$1(options.name);
      if (options.handle == null) {
        handle = Module._PIEWeatherMeshRender_Create(strName.getHandle());
      } else {
        handle = options.handle;
      }
      strName.dispose();
      autoRelease = true;
      PIEWeatherRender.call(this, handle, autoRelease);
    }
  }
  PIEWeatherMeshRender.prototype = Object.assign(Object.create(PIEWeatherRender.prototype), {
    /**
     * 设置纹理路径
     * @param {String} TextureFile -纹理路径
     *
     * @memberOf WeatherMeshRender#
     */
    setTextureFile: function setTextureFile(TextureFile) {
      var strfilePath = new PIE.String(TextureFile);
      Module._PIEWeatherMeshRender_SetTextureFile(this.handle, strfilePath.getHandle());
      strfilePath.dispose();
    }
  });

  Object.assign(Object.create(PIEWeatherRender.prototype), {
    /**
     * 设置动态对象计算出来的背景色的显隐
     * @param {Boolean} bVisible -背景色的显隐
     *
     * @memberOf WeatherDynamicStreamLineRender#
     */
    setBackGroundVisible: function setBackGroundVisible(bVisible) {
      Module._PIEWeatherDynamicStreamLineSetBackGroundVisible(this.handle, bVisible);
    },
    /**
     * 设置线宽
     * @param {Number} dLineWidth -线宽
     *
     * @memberOf WeatherDynamicStreamLineRender#
     */
    setLineWidth: function setLineWidth(dLineWidth) {
      Module._PIEWeatherStreamLineRender_SetLineWidth(this.handle, dLineWidth);
    },
    /**
     * 设置生存时间
     * @param {Number} nAge -生存时间
     *
     * @memberOf WeatherDynamicStreamLineRender#
     */
    setLiveAge: function setLiveAge(nAge) {
      Module._PIEWeatherDynamicStreamLineSetLiveAge(this.handle, nAge);
    },
    /**
     * 设置流速比例
     * @param {Number} dSpeedScale -流速比例
     *
     * @memberOf WeatherDynamicStreamLineRender#
     */
    setSpeedScale: function setSpeedScale(dSpeedScale) {
      Module._PIEWeatherDynamicStreamLineSetSpeedScale(this.handle, dSpeedScale);
    },
    /**
     * 设置粒子密度
     * @param {Number} dDensity -粒子密度
     *
     * @memberOf WeatherDynamicStreamLineRender#
     */
    setDensity: function setDensity(dDensity) {
      Module._PIEWeatherDynamicStreamLineSetDensity(this.handle, dDensity);
    },
    /**
     * 设置流线的长度比例
     * @param {Number} dLengthScale -流线的长度比例
     *
     * @memberOf WeatherDynamicStreamLineRender#
     */
    setLengthScale: function setLengthScale(dLengthScale) {
      Module._PIEWeatherDynamicStreamLineSetLengthScale(this.handle, dLengthScale);
    }
  });

  Object.assign(Object.create(PIEWeatherMeshRender.prototype), {
    /**
     * 设置所有要素可见
     *
     * @memberOf WeatherStationFillRender#
     */
    setAllVisible: function setAllVisible() {
      Module._PIEWeatherStationRender_SetAllVisible(this.handle, true);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气渲染数据
   * @name WeatherRenderData
   *
   */
  function PIEWeatherRenderData(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEWeatherRenderData.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._PIERenderData_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置文件格式
     * @param {Number} format -文件格式
     * @memberOf WeatherRenderData#
     *
     */
    setFileFormat: function setFileFormat(format) {
      Module._PIERenderData_SetFileFormat(this.handle, format);
    },
    /**
     * 设置文件路径
     * @param {String} pFilePath -文件路径
     * @memberOf WeatherRenderData#
     *
     */
    setFilePath: function setFilePath(pFilePath) {
      var strPath = new PIEString$1(pFilePath);
      Module._PIERenderData_SetFilePath(this.handle, strPath.getHandle());
      strPath.dispose();
    }
  });

  Object.assign(Object.create(PIEWeatherRenderData.prototype), {});

  Object.assign(Object.create(PIEWeatherRenderData.prototype), {
    /**
     * 渲染数据序列化到文件
     * @param {String} filePath -文件路径
     * @memberOf MeshRenderData#
     *
     */

    ReSerializeFromFile: function ReSerializeFromFile(filePath) {
      var strfilePath = new PIE.String(filePath);
      Module._PIERenderData_ReSerializeFromFile(this.handle, strfilePath.getHandle());
      strfilePath.dispose();
    }
  });

  Object.assign(Object.create(PIEWeatherRenderData.prototype), {
    load: function load(options) {
      var that = this;
      options.charset == null ? PIECharsetType.UTF8 : options.charset;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var url = options.url;
        var filesPicks = [];
        if (!url || url == "") {
          reject(new Error('PIE.DynamicStreamLineRenderData.load: input url is NULL'));
          return;
        }
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        filesPicks.push(file);
        var urlsPicks = [];
        urlsPicks.push(url);
        function callBack(filelist, urllist, datalist) {
          that.setFilePath(filesPicks[0]);
          resolve(that);
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气数据
   * @name WeatherData
   *
   */
  function PIEWeatherData(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEWeatherData.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._PIEWeatherData_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 获取数据解析之后的数据类型，默认站点散点路径数据
     * @return {PIE.WeatherDataType} 数据类型
     *
     * @memberOf WeatherMeshRender#
     */
    getType: function getType() {
      return Module._PIEWeatherData_GetType(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气数据
   * @name GridData
   *
   */
  function PIEGridData(handle, autoRelease) {
    if (handle == null) {
      handle = Module._PIEGridData_Create();
      autoRelease = true;
    }
    PIEWeatherData.call(this, handle, autoRelease);
  }
  PIEGridData.prototype = Object.assign(Object.create(PIEWeatherData.prototype), {
    /**设置值范围
     * @param {Number} dStartValue -开始值
     * @param {Number} dEndValue -结束值
     * @memberOf WeatherDataParser#
     *
     */
    setRange: function setRange(dStartValue, dEndValue) {
      Module._PIEGridData_SetRange(this.handle, dStartValue, dEndValue);
    },
    // /**设置值范围
    //  * @param {Number} dStartValue -开始值
    //  * @param {Number} dEndValue -结束值
    //  * @memberOf WeatherDataParser#
    //  *
    //  */
    // getRange: function () {
    //
    //     Module._PIEGridData_GetRange(this.handle,dStartValue,dEndValue);
    // },

    /**根据属性名获取某个属性
     * @param {PIEString} propertyName -属性名
     * @return {Number} -属性值
     * @memberOf WeatherDataParser#
     *
     */
    getProperty: function getProperty(propertyName) {
      var strName = new PIEString$1(propertyName);
      return Module._PIEGridData_GetProperty(this.handle, strName.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气数据
   * @name StationData
   *
   */
  function PIEStationData(handle, autoRelease) {
    if (handle == null) {
      handle = Module._PIEStationData_Create();
      autoRelease = true;
    }
    PIEWeatherData.call(this, handle, autoRelease);
  }
  PIEStationData.prototype = Object.assign(Object.create(PIEWeatherData.prototype), {
    /**
     * 将站点数据插值成格点数据
     * @param {Number} nFieldKey -采用站点数据中字段对应的数据进行插值
     * @param {Number} XNum -格点数据的宽度
     * @param {Number} YNum -格点数据的高度
     * @param {PIEBounds} bounds -格点数据的范围
     * @param {Number} _MinPointNum -插值算法所需要的最小离散点数目
     * @param {Number} _Radius -插值算法所需要的搜索半径
     * @param {PIEAlgorithmType} AlgorithmType -插值算法的类型
     * @memberOf WeatherDataParser#
     *
     */
    interFromStationData: function interFromStationData(nFieldKey, XNum, YNum, bounds, _MinPointNum, _Radius, AlgorithmType) {
      if (bounds != null && bounds instanceof PIEBounds) {
        var boundsArray = new PIEArray(bounds.toArray(), PIEArrayType.Float64);
        var hanle = Module._PIEGridDataOpera_interFromStationData(this.handle, nFieldKey, XNum, YNum, boundsArray.getHandle(), _MinPointNum, _Radius, AlgorithmType);
        boundsArray.dispose();
        return PIEWeatherDataFactory.CreateInstance(hanle);
      }
    }
  });

  function PIEWeatherDataFactory() {}
  Object.assign(PIEWeatherDataFactory.prototype, {});
  PIEWeatherDataFactory.CreateInstance = function (WeatherData) {
    var dataType = Module._PIEWeatherData_GetType(WeatherData);
    if (dataType == PIE.WeatherDataType.GridType) {
      return new PIEGridData(WeatherData);
    } else if (dataType == PIE.WeatherDataType.PathType) ; else if (dataType == PIE.WeatherDataType.StationType) {
      return new PIEStationData(WeatherData);
    }
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气数据分析器
   * @name WeatherDataParser
   *
   */
  function PIEWeatherDataParser(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEWeatherDataParser.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._PIEWDataParser_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置文件路径
     * @param {String} filePath -路径
     * @memberOf WeatherDataParser#
     *
     */
    setFilePath: function setFilePath(filePath) {
      var strfilePath = new PIE.String(filePath);
      Module._PIEWDataParser_SetFilePath(this.handle, strfilePath.getHandle());
      strfilePath.dispose();
    },
    /**
     * 获取文件路径
     * @return{String} -返回文件路径
     * @memberOf WeatherDataParser#
     *
     */
    getFilePath: function getFilePath() {
      var strfilePath = new PIE.String(512);
      Module._PIEWDataParser_SetFilePath(this.handle, strfilePath.getHandle());
      var filePath = strfilePath.toString();
      strfilePath.dispose();
      return filePath;
    },
    /**
     * @param {String} name -设置要素名称
     * @memberOf WeatherDataParser#
     *
     */
    setVarName: function setVarName(name) {
      Module._PIEWDataParser_SetVarName(this.handle, name);
    },
    /**
     * @param {Number} nTime -设置当前要读取的时次
     * @memberOf WeatherDataParser#
     *
     */
    setTimeIndex: function setTimeIndex(nTime) {
      Module._PIEWDataParser_SetTimeIndex(this.handle, nTime);
    },
    /**
     * @param {Number} nLevel -设置当前要读取的层次
     * @memberOf WeatherDataParser#
     *
     */
    setLevelIndex: function setLevelIndex(nLevel) {
      Module._PIEWDataParser_SetLevelIndex(this.handle, nLevel);
    },
    /**
     * @return{WeatherData} -获取气象数据
     * @memberOf WeatherDataParser#
     *
     */
    getWeatherData: function getWeatherData() {
      var handle = Module._PIEWDataParser_GetWeatherData(this.handle);
      if (handle != null) {
        return PIEWeatherDataFactory.CreateInstance(handle);
      }
    }
  });

  Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 设置体文件
     * @param {String} filePath -文件路径
     * @param {Number} xLenth -x长度
     * @param {Number} yLength -y长度
     * @param {Number} zLength -z长度
     *
     * @memberOf VolumeRayCast#
     */
    setVolumeFile: function setVolumeFile(filePath, xLenth, yLength, zLength) {
      var strPath = new PIEString$1(filePath);
      Module._VRC_SetVolumeFile(this.handle, strPath.getHandle(), xLenth, yLength, zLength);
      strPath.dispose();
    },
    /**
     * 设置裁剪范围
     * @param {Number} cbLeft -左值
     * @param {Number} cbTop -上值
     * @param {Number} cbRight -右值
     * @param {Number} cbBottom -下值
     *
     * @memberOf VolumeRayCast#
     */
    setClipBound: function setClipBound(cbLeft, cbTop, cbRight, cbBottom) {
      Module._VRC_SetClipBound(this.handle, cbLeft, cbTop, cbRight, cbBottom);
    },
    /**
     * 设置体范围
     * @param {Number} vbLeft -左值
     * @param {Number} vbTop -上值
     * @param {Number} vbRight -右值
     * @param {Number} vbBottom -下值
     *
     * @memberOf VolumeRayCast#
     */
    setVolumeBound: function setVolumeBound(vbLeft, vbTop, vbRight, vbBottom) {
      Module._VRC_SetVolumeBound(this.handle, vbLeft, vbTop, vbRight, vbBottom);
    },
    /**
     * 设置体高度
     * @param {Number} minHeight -最小高度
     * @param {Number} maxHeight -最大高度
     *
     * @memberOf VolumeRayCast#
     */
    setVolumeHeight: function setVolumeHeight(minHeight, maxHeight) {
      Module._VRC_SetVolumeHeight(this.handle, minHeight, maxHeight);
    },
    /**
     * 设置体颜色
     * @param {PIEVector4} rgbaColor -体颜色
     * @param {Number} count -体颜色数量
     *
     * @memberOf VolumeRayCast#
     */
    setVolumeColor: function setVolumeColor(rgbaColor, count) {
      var color = new PIEArray(rgbaColor, PIEArrayType.Float32);
      Module._VRC_SetVolumeColor(this.handle, color.getHandle(), count);
      color.dispose();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */
  Object.assign(Object.create(PIEWeatherDataParser.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */

  /**
   * 天气数据分析器
   * @name WeatherProcesser
   *
   */
  function PIEWeatherProcesser(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEWeatherProcesser.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._PIEWeatherProcesser_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 处理函数
     * @param {PIE.WeatherData} hWeatherData -天气数据
     * @memberOf WeatherProcesser#
     *
     */
    process: function process(hWeatherData) {
      Module._PIEWeatherProcesser_Process(this.handle, hWeatherData.getHandle());
    },
    /**
     * 获取处理后的结果（可渲染数据）
     * @return {PIE.WeatherRenderData} -可渲染数据
     * @memberOf WeatherProcesser#
     *
     */
    getWeatherRenderData: function getWeatherRenderData() {
      var handle = Module._PIEWeatherProcesser_GetWeatherRenderData(this.handle);
      return new PIEWeatherRenderData(handle);
    },
    /**
     * 设置精度
     * @param {Number} nPrecision -精度值
     * @memberOf WeatherProcesser#
     *
     */
    setPrecision: function setPrecision(nPrecision) {
      return Module._PIEWeatherProcesser_SetPrecision(this.handle, nPrecision);
    },
    /**
     * 设置是否坐标转换
     * @param {boolean} bIsTransform -是否
     * @memberOf WeatherProcesser#
     *
     */
    setIsTransform: function setIsTransform(bIsTransform) {
      Module._PIEWeatherProcesser_SetIsTransform(this.handle, bIsTransform);
    }
  });

  Object.assign(Object.create(PIEWeatherProcesser.prototype), {});

  Object.assign(Object.create(PIEWeatherRender.prototype), {
    /**
     * 设置颜色表
     * @param {Number} dLineWidth -设置线宽
     *
     * @memberOf WeatherIsoLineRender#
     */
    setLineWidth: function setLineWidth(dLineWidth) {
      Module._PIEWeatherIsoLineRender_SetLineWidth(this.handle, dLineWidth);
    },
    /**
     * 设置渲染优先级
     * @param {Number} id -ID
     * @memberOf WeatherIsoLineRender#
     */
    setRenderPriorityID: function setRenderPriorityID(id) {
      Module._PIEWeatherRender_SetRenderPriorityID(this.handle, id);
    },
    /**
     * 设置颜色值
     * @param {(PIEColor/Array)} color -颜色值
     * @memberOf WeatherIsoLineRender#
     */
    setLineColor: function setLineColor(color) {
      var arrayColor = [];
      if (color instanceof Array) {
        arrayColor = color;
      } else if (color instanceof PIEColor) {
        arrayColor = color.toArray();
      }
      if (arrayColor) {
        var colorArray = new PIEArray(arrayColor, PIEArrayType.UInt8);
        Module._PIEWeatherIsoLineRender_SetLineColor(this.handle, colorArray.getHandle());
        colorArray.dispose();
      }
    },
    /**
     * 设置Globe
     * @param {PIEGlobe} hGlobe -
     * @memberOf WeatherIsoLineRender#
     */
    setGlobe: function setGlobe(hGlobe) {
      Module._PIEWeatherIsoLineRender_SetGlobe(this.handle, hGlobe.handle);
    }
  });

  Object.assign(Object.create(PIEWeatherProcesser.prototype), {
    /**
     * 设置等值线的参数
     * @param {Number} dMinValue -起始值
     * @param {Number} dMaxValue -结束值
     * @param {Number} dInterval -间隔
     * @memberOf WeatherIsoLineProcesser#
     *
     */
    setParams: function setParams(dMinValue, dMaxValue, dInterval) {
      Module._PIEIsoLineProcesser_SetParams(this.handle, dMinValue, dMaxValue, dInterval);
    },
    /**
     * 设置等值线的参数
     * @param {Number} dMinValue -起始值
     * @param {Number} dMaxValue -结束值
     * @param {Number} dInterval -间隔
     * @memberOf WeatherIsoLineProcesser#
     *
     */
    setParamsEx: function setParamsEx(dValues) {
      var arrowValuesArray = null;
      if (dValues instanceof Array) {
        arrowValuesArray = dValues;
      }
      if (arrowValuesArray) {
        var arrayArrowValues = new PIEArray(arrowValuesArray, PIEArrayType.Float64);
        Module._PIEIsoLineProcesser_SetParamsEx(this.handle, arrayArrowValues.getHandle(), arrowValuesArray.length);
      }
    },
    /**
     * 设置使用的算法类型
     * @param {PIEWeatherIsoLineAlgorithmType} dMinValue -起始值
     * @memberOf WeatherIsoLineProcesser#
     *
     */
    setAlgorithmType: function setAlgorithmType(nAlgorithmType) {
      Module._PIEIsoLineProcesser_SetAlgorithmType(this.handle, nAlgorithmType);
    },
    /**
     * 设置创建等值面的类型
     * @param {PIEIsoSurfaceType} nCreateIsoSurfaceType -等值面类型
     * @memberOf WeatherIsoLineProcesser#
     *
     */
    setCreateIsoSurfaceType: function setCreateIsoSurfaceType(nCreateIsoSurfaceType) {
      Module._PIEIsoLineProcesser_SetCreateIsoSurfaceType(this.handle, nCreateIsoSurfaceType);
    },
    /**
     *  获取等值面渲染数据
     * @return {PIEWeatherRenderData} -渲染数据
     * @memberOf WeatherIsoLineProcesser#
     *
     */
    getIsoSurfaceRenderData: function getIsoSurfaceRenderData() {
      var handle = Module._PIEIsoLineProcesser_GetIsoSurfaceRenderData(this.handle);
      return new PIEWeatherRenderData(handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 气象模块
   * ---
   */
  Object.assign(Object.create(PIEWeatherDataParser.prototype), {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 四元数类
   * @name Quaternion4
   * @class Quaternion4
   *
   * @param {Number} x -x值
   * @param {Number} y -y值
   * @param {Number} z -z值
   * @param {Number} w -w值
   * @example
   * let quaternion4f = new PIE.Quaternion4(2,5,7,9)
   */
  function PIEQuaternion4(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  Object.assign(PIEQuaternion4.prototype, {
    /**
     * 从轴角转为四元数
     * @param {Number} radian -轴角
     * @param {PIEVector3} rkAxis -三维向量类
     * @memberOf Quaternion4#
     */
    fromAngleAxis: function fromAngleAxis(radian, rkAxis) {
      var fHalfAngle = 0.5 * radian;
      var fSin = Math.sin(fHalfAngle);
      this.w = Math.cos(fHalfAngle);
      this.x = fSin * rkAxis.x;
      this.y = fSin * rkAxis.y;
      this.z = fSin * rkAxis.z;
    },
    /**
     * 由四元数转为旋转矩阵
     * @memberOf Quaternion4#
     * @returns {PIEMatrix4} 返回旋转矩阵
     */
    toRotationMatrix4: function toRotationMatrix4() {
      var fTx = this.x + this.x;
      var fTy = this.y + this.y;
      var fTz = this.z + this.z;
      var fTwx = fTx * this.w;
      var fTwy = fTy * this.w;
      var fTwz = fTz * this.w;
      var fTxx = fTx * this.x;
      var fTxy = fTy * this.x;
      var fTxz = fTz * this.x;
      var fTyy = fTy * this.y;
      var fTyz = fTz * this.y;
      var fTzz = fTz * this.z;
      var kRot = new PIEMatrix4();
      kRot.m[0] = 1.0 - (fTyy + fTzz);
      kRot.m[4] = fTxy - fTwz;
      kRot.m[8] = fTxz + fTwy;
      kRot.m[12] = 0;
      kRot.m[1] = fTxy + fTwz;
      kRot.m[5] = 1.0 - (fTxx + fTzz);
      kRot.m[9] = fTyz - fTwx;
      kRot.m[13] = 0;
      kRot.m[2] = fTxz - fTwy;
      kRot.m[6] = fTyz + fTwx;
      kRot.m[10] = 1.0 - (fTxx + fTyy);
      kRot.m[14] = 0;
      kRot.m[3] = 0;
      kRot.m[7] = 0;
      kRot.m[11] = 0;
      kRot.m[15] = 1;
      return kRot;
    },
    /**
     * 由旋转矩阵转为四元数
     * @param {PIEMatrix3} rot -旋转矩阵
     * @memberOf Quaternion4#
     */
    fromRotationMatrix3: function fromRotationMatrix3(rot) {
      var fTrace = rot.m[0] + rot.m[4] + rot.m[8];
      var fRoot = 0.0;
      if (fTrace > 0.0) {
        fRoot = Math.sqrt(fTrace + 1.0);
        this.w = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        this.x = (rot.m[5] - rot.m[7]) * fRoot;
        this.y = (rot.m[6] - rot.m[2]) * fRoot;
        this.z = (rot.m[1] - rot.m[3]) * fRoot;
      } else {
        var s_iNext = [1, 2, 0];
        var i = 0;
        if (rot.m[4] > rot.m[0]) i = 1;
        if (rot.m[8] > rot.m[4 * i]) i = 2;
        var j = s_iNext[i];
        var k = s_iNext[j];
        fRoot = Math.sqrt(rot.m[4 * i] - rot.m[4 * j] - rot.m[4 * k] + 1.0);
        var apkQuat = [this.x, this.y, this.z];
        apkQuat[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        this.w = (rot.m[3 * j + k] - rot.m[3 * k + j]) * fRoot;
        apkQuat[j] = (rot.m[3 * i + j] + rot.m[3 * j + i]) * fRoot;
        apkQuat[k] = (rot.m[3 * i + k] + rot.m[3 * k + i]) * fRoot;
        this.x = apkQuat[0];
        this.y = apkQuat[1];
        this.z = apkQuat[2];
      }
    },
    /**
     * 由四元数转为旋转矩阵
     *
     * @memberOf Quaternion4#
     * @returns {PIEMatrix3} 返回旋转矩阵
     */
    toRotationMatrix3: function toRotationMatrix3() {
      var fTx = this.x + this.x;
      var fTy = this.y + this.y;
      var fTz = this.z + this.z;
      var fTwx = fTx * this.w;
      var fTwy = fTy * this.w;
      var fTwz = fTz * this.w;
      var fTxx = fTx * this.x;
      var fTxy = fTy * this.x;
      var fTxz = fTz * this.x;
      var fTyy = fTy * this.y;
      var fTyz = fTz * this.y;
      var fTzz = fTz * this.z;
      var kRot = new PIEMatrix3();
      kRot.m[0] = 1.0 - (fTyy + fTzz);
      kRot.m[3] = fTxy - fTwz;
      kRot.m[6] = fTxz + fTwy;
      kRot.m[1] = fTxy + fTwz;
      kRot.m[4] = 1.0 - (fTxx + fTzz);
      kRot.m[7] = fTyz - fTwx;
      kRot.m[2] = fTxz - fTwy;
      kRot.m[5] = fTyz + fTwx;
      kRot.m[8] = 1.0 - (fTxx + fTyy);
      return kRot;
    }
  });

  /**
   * 把矩阵拆分成位置，缩放比例和四元数
   * @param {PIEMatrix3} kRot -矩阵
   * @param {PIEVector3} position -位置
   * @param {Number} scale -缩放比例
   * @param {PIEQuaternion4} orientation -四元数
   *
   * @memberOf Quaternion4#
   */
  PIEQuaternion4.prototype.decomposition = function (kRot, position, scale, orientation) {
    var m3x3 = kRot.toRotationMatrix();
    var matQ = new PIEMatrix3();
    var vecU = new PIEVector3();
    m3x3.decomposition(matQ, scale, vecU);
    orientation.fromRotationMatrix3(matQ);
    position.x = kRot.m[12];
    position.y = kRot.m[13];
    position.z = kRot.m[14];
  };

  /**
   * 通过位置，缩放比例和四元数组合成矩阵
   * @param {PIEVector3} position -位置
   * @param {Number} scale -缩放比例
   * @param {PIEQuaternion4} orientation -四元数
   *
   * @memberOf Quaternion4#
   * @returns {PIEMatrix4} 返回矩阵
   */
  PIEQuaternion4.prototype.composition = function (position, scale, orientation) {
    var rot = new PIEMatrix3();
    orientation.toRotationMatrix3(rot);

    // Make the translation relative to new axes
    var rotT = rot.transpose();
    var trans = PIEMatrix3.prototype.multiplyMV(position, rotT);
    trans.x = -trans.x;
    trans.y = -trans.y;
    trans.z = -trans.z;

    // Make final matrix
    var viewMatrix = new PIEMatrix4();
    viewMatrix.identity();
    viewMatrix.m[0] = rotT.m[0];
    viewMatrix.m[1] = rotT.m[1];
    viewMatrix.m[2] = rotT.m[2];
    viewMatrix.m[4] = rotT.m[3];
    viewMatrix.m[5] = rotT.m[4];
    viewMatrix.m[6] = rotT.m[5];
    viewMatrix.m[8] = rotT.m[6];
    viewMatrix.m[9] = rotT.m[7];
    viewMatrix.m[10] = rotT.m[8];
    viewMatrix.m[12] = trans.x;
    viewMatrix.m[13] = trans.y;
    viewMatrix.m[14] = trans.z;
    return viewMatrix;
  };

  /**
   * 欧拉角转四元数
   * @param {Number} yaw -欧拉角向量的y轴
   * @param {Number} pitch -欧拉角向量的x轴
   * @param {Number} roll -欧拉角向量的z轴
   *
   * @memberOf Quaternion4#
   * @returns {PIEQuaternion4} 返回四元数
   */
  PIEQuaternion4.prototype.eulerToQuaternion = function (yaw, pitch, roll) {
    var cy = Math.cos(yaw * 0.5);
    var cp = Math.cos(pitch * 0.5);
    var cr = Math.cos(roll * 0.5);
    var sy = Math.sin(yaw * 0.5);
    var sp = Math.sin(pitch * 0.5);
    var sr = Math.sin(roll * 0.5);
    var qw = cy * cp * cr + sy * sp * sr;
    var qx = sy * cp * cr - cy * sp * sr;
    var qy = cy * sp * cr + sy * cp * sr;
    var qz = cy * cp * sr - sy * sp * cr;
    return new PIEQuaternion4(qx, qy, qz, qw);
  };

  Object.assign(Object.create(PIERenderable.prototype), {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放夜光背景渲染对象
     * @memberOf NightLight#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._NightLight_Delete(this.handle);
        this.handle = null;
      }
    },
    /**
     * 通过图片url加载夜光背景渲染对象
     * @param {Object} options -
     * @param {String} options.file -从服务上获取的数据后存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.url -图片地址(必填项)
     * @param {PIEBounds/Array} options.bounds -图片范围(非必填项)
     * @memberOf NightLight#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     */
    load: function load(options) {
      var that = this;
      var bounds = options.bounds;
      return new Promise(function (resolve, reject) {
        var file = options.file;
        var url = options.url;
        var filesPicks = [];
        if (!url || url == "") {
          reject(new Error('PIE.NightLight.load: input url is NULL'));
          return;
        }
        var name = PIEFile.getFileName(url);
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        filesPicks.push(file);
        var urlsPicks = [];
        urlsPicks.push(options.url);
        function callBack(filelist, urllist, datalist) {
          var strFilePath = new PIEString$1(filelist[0]);
          Module._NightLight_SetImagePath(that.handle, strFilePath.getHandle());
          strFilePath.dispose();
          if (bounds) {
            that.setImageBounds(bounds);
          }
          resolve(that);
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    /**
     *
     * 设置背景图片范围
     * @memberOf NightLight#
     * @param {PIEBounds/Array} options.bounds -图片范围
     */
    setImageBounds: function setImageBounds(bounds) {
      var boundsArray = null;
      if (bounds instanceof Array) {
        boundsArray = new PIEArray(bounds, PIEArrayType.Float64);
      } else if (bounds instanceof PIEBounds) {
        boundsArray = new PIEArray([bounds.left, bounds.top, bounds.right, bounds.bottom], PIEArrayType.Float64);
      }
      if (!boundsArray) {
        return;
      }
      Module._NightLight_SetImageBound(this.handle, boundsArray.getHandle());
      boundsArray.dispose();
    },
    /**
     * 获取背景图片范围
     * @memberOf NightLight#
     * @returns {PIEBounds} 返回背景图片范围
     */
    getImageBound: function getImageBound() {
      var boundsArray = new PIEArray(4, PIEArrayType.Float64);
      Module._NightLight_GetImageBound(this.handle, boundsArray.getHandle());
      boundsArray.updateData();
      var bounds = boundsArray.toArray();
      boundsArray.dispose();
      return PIEBounds.fromArray(bounds);
    }
  });

  Object.assign(Object.create(PIERenderable.prototype), {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放光晕渲染对象
     * @memberOf GlobeHalo#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._GlobeHalo_Delete(this.handle);
        this.handle = null;
      }
    },
    /**
     *
     * 设置光晕颜色
     * @memberOf GlobeHalo#
     * @param {PIEColor/Array} options.color -颜色
     */
    setColor: function setColor(color) {
      var colorArray = null;
      if (color instanceof Array) {
        colorArray = new PIEArray(color, PIEArrayType.UInt8);
      } else if (color instanceof PIEColor) {
        colorArray = new PIEArray(color.toArray(), PIEArrayType.UInt8);
      }
      if (!colorArray) {
        return;
      }
      Module._GlobeHalo_SetColor(this.handle, colorArray.getHandle());
      colorArray.dispose();
    },
    /**
     * 获取光晕颜色
     * @memberOf GlobeHalo#
     * @returns {PIEColor} 返回光晕颜色
     */
    getColor: function getColor() {
      var colorArray = new PIEArray(4, PIEArrayType.UInt8);
      Module._GlobeHalo_GetColor(this.handle, colorArray.getHandle());
      colorArray.updateData();
      var color = colorArray.toArray();
      colorArray.dispose();
      return color;
    }
  });

  function PIEProjection(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEProjection.prototype, {});

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 空间参考系模块
   * ---
   */

  /**
   * 创建空间参考转换器
   * @name ReferenceTranslator
   * @class ReferenceTranslator
   *空间参考转换器操作函数
   *
   *@example
   * let referenceTranslator = new PIE.ReferenceTranslator()
   */
  function PIEReferenceTranslator(handle, autoRelease) {
    if (handle == null) {
      this.handle = Module._RefTranslator_Create();
      this.autoRelease = true;
    } else {
      this.handle = handle;
      this.autoRelease = false;
    }
  }
  Object.assign(PIEReferenceTranslator.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 删除空间参考转换器
     * @memberOf ReferenceTranslator#kong
     */
    dispose: function dispose() {
      Module._RefTranslator_Delete(this.handle);
    },
    /**
     * 设置源空间参考系
     * @param {SpatialReference} spatialReference -空间参考系对象
     * @memberOf ReferenceTranslator#
     *
     * @returns {boolean} 返回是否设置成功
     *
     */
    setCoordSysSrc: function setCoordSysSrc(spatialReference) {
      var result = Module._RefTranslator_SetCoordSysSrc(this.handle, spatialReference.getHandle());
      return Boolean(result);
    },
    /**
     * 设置目标坐标系
     * @param {SpatialReference} spatialReference -空间参考系对象
     * @memberOf ReferenceTranslator#
     *
     * @returns {boolean} 返回是否设置成功
     */
    setCoordSysDes: function setCoordSysDes(spatialReference) {
      var result = Module._RefTranslator_SetCoordSysDes(this.handle, spatialReference.getHandle());
      return Boolean(result);
    },
    /**
     * 点坐标转换
     * @param {PIEVector2/Array} point -坐标点
     * @param {boolean} forward - 标识正算或反算(true-正算：即源参考系转换为目标参考系；false-反算：即目标参考系转换为源参考系)
     * @memberOf ReferenceTranslator#
     *
     * @returns {PIEVector2} 转换成功返回PIEVector2点对象，失败返回null
     */
    translatePoint: function translatePoint(point, forward) {
      if (forward == undefined) {
        forward = true;
      }
      var pointArray = null;
      if (point instanceof PIEVector2) {
        pointArray = [point.x, point.y];
      } else if (point instanceof Array && point.length == 2) {
        pointArray = point;
      }
      if (pointArray) {
        var arrayPoint = new PIEArray(point, PIEArrayType.Float64);
        var res = Module._RefTranslator_TranslatePoint(this.handle, arrayPoint.getHandle(), forward);
        arrayPoint.updateData();
        var destPoint = arrayPoint.toArray();
        arrayPoint.dispose();
        if (res) {
          return new PIEVector2(destPoint[0], destPoint[1]);
        }
      }
      return null;
    },
    /**
     * 范围坐标转换
     * 超出转换范围时，搜索并截取最大有效范围
     * @param {PIEBounds/Array} rcBounds -范围
     * @param {boolean} forward - 标识正算或反算，默认正算(true-正算：即源参考系转换为目标参考系；false-反算：即目标参考系转换为源参考系)
     * @memberOf ReferenceTranslator#
     *
     * @returns {PIEBounds} 转换成功返回PIEBounds对象，失败返回null
     */
    translateBounds: function translateBounds(rcBounds, forward) {
      if (forward == undefined) {
        forward = true;
      }
      var arrayBounds = null;
      if (rcBounds instanceof PIEBounds) {
        arrayBounds = rcBounds.toArray();
      } else if (rcBounds instanceof Array && rcBounds.length == 4) {
        arrayBounds = rcBounds;
      }
      if (arrayBounds) {
        var arrayRcBounds = new PIEArray(arrayBounds, PIEArrayType.Float64);
        var res = Module._RefTranslator_TranslateBounds(this.handle, arrayRcBounds.getHandle(), forward);
        arrayRcBounds.updateData();
        var boundsArray = arrayRcBounds.toArray();
        arrayRcBounds.dispose();
        if (res) {
          return PIEBounds.fromArray(boundsArray);
        }
      }
      return null;
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 创建画布渲染对象
   * @name RenderCanvas
   * @class RenderCanvas
   * 画布渲染对象
   *
   * @extends Renderable
   *@example
   *let renderCanvas = new PIE.RenderCanvas();
   */
  function PIERenderCanvas(handle, autoRelease) {
    handle = Module._RenderCanvas_Create();
    PIERenderable.call(this, handle, autoRelease);
  }
  PIERenderCanvas.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 添加密度集列表渲染
     * @param {PIERenderListDensitySet} renderListDensitySet -密度集列表渲染
     * @memberOf RenderCanvas#
     *
     */
    add: function add(renderListDensitySet) {
      Module._RenderCanvas_Add(this.handle, renderListDensitySet.getHandle());
    },
    /**
     * 设置颜色范围
     * @param {PIEColorRange} colorRange -颜色范围
     * @memberOf RenderCanvas#
     *
     */
    setColorRange: function setColorRange(colorRange) {
      Module._RenderCanvas_SetColorRange(this.handle, colorRange.getHandle());
    },
    /**
     * 获取颜色范围
     * @memberOf RenderCanvas#
     * @returns {PIEColorRange} colorRange -颜色范围
     */
    getColorRange: function getColorRange() {
      return Module._RenderCanvas_GetColorRange(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   *  点符号类型
   * @readonly
   * @enum {number}
   */
  var PIEPointType = {
    /** 空类型*/
    Null: 0,
    // /**符号库类型*/
    // Marker: 1,
    /**图标类型*/
    Icon: 16
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 周期集渲染相关操作函数
   * @name RenderCycleSet
   * @extends Renderable
   */
  function PIERenderCycleSet(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIERenderCycleSet.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 获取空间参考系类型
     *
     * @memberOf RenderCycleSet#
     * @returns {Number} 空间参考系类型
     */
    getSpatialRefType: function getSpatialRefType() {
      return Module._RenderCycleSet_GetSpatialRefType(this.handle);
    },
    /**
     * 设置空间参考系类型
     * @param {Number} type -空间参考系类型
     * @memberOf RenderCycleSet#
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._RenderCycleSet_SetSpatialRefType(this.handle, type);
    },
    /**
     * 获取位置
     *
     * @memberOf RenderCycleSet#
     * @returns {PIEVector3} 返回位置
     */
    getPosition: function getPosition() {
      var arrayPos = new PIEArray(3, PIEArrayType.Float64);
      Module._RenderCycleSet_GetPosition(this.handle, arrayPos);
      arrayPos.updateData();
      var posArray = arrayPos.toArray();
      arrayPos.dispose();
      return new PIEVector3(posArray[0], posArray[1], posArray[2]);
    },
    /**
     * 设置位置
     * @param {(Array/PIEVector3)} position -位置
     * @memberOf RenderCycleSet#
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = position.toArray();
      }
      if (posArray && posArray.length > 0) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._RenderCycleSet_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取帧速
     *
     * @memberOf RenderCycleSet#
     * @returns {Number} 返回帧速
     */
    getSpeedPerFrame: function getSpeedPerFrame() {
      return Module._RenderCycleSet_GetSpeedPerFrame(this.handle);
    },
    /**
     * 设置帧速
     * @param {Number} speed -速度值
     * @memberOf RenderCycleSet#
     */
    setSpeedPerFrame: function setSpeedPerFrame(speed) {
      Module._RenderCycleSet_SetSpeedPerFrame(this.handle, speed);
    },
    /**
     * 设置当前时间
     * @param {Number} time -当前时间
     * @memberOf RenderCycleSet#
     *
     */
    setCurTime: function setCurTime(time) {
      Module._RenderCycleSet_SetCurTime(this.handle, time);
    },
    /**
     * 获取当前时间
     *
     * @memberOf RenderCycleSet#
     * @returns {Number} 返回当前时间
     */
    getCurTime: function getCurTime() {
      return Module._RenderCycleSet_GetCurTime(this.handle);
    },
    /**
     * 设置开始时间
     * @param {Number} time -开始时间
     * @memberOf RenderCycleSet#
     */
    setStartTime: function setStartTime(time) {
      Module._RenderCycleSet_SetStartTime(this.handle, time);
    },
    /**
     * 获取开始时间
     *
     * @memberOf RenderCycleSet#
     * @returns {Number} -返回开始时间
     */
    getStartTime: function getStartTime() {
      return Module._RenderCycleSet_GetStartTime(this.handle);
    },
    /**
     * 设置结束时间
     * @param {Number} time -结束时间
     * @memberOf RenderCycleSet#
     */
    setEndTime: function setEndTime(time) {
      Module._RenderCycleSet_SetEndTime(this.handle, time);
    },
    /**
     * 获取结束时间
     *
     * @memberOf RenderCycleSet#
     * @returns {Number} -返回结束时间
     */
    getEndTime: function getEndTime() {
      return Module._RenderCycleSet_GetEndTime(this.handle);
    },
    /**
     *设置跟踪时间
     * @param {Number} time -跟踪时间
     * @memberOf RenderCycleSet#
     */
    setTraceTime: function setTraceTime(time) {
      Module._RenderCycleSet_SetTraceTime(this.handle, time);
    },
    /**
     * 获取跟踪时间
     *
     * @memberOf RenderCycleSet#
     * @returns {Number} 返回跟踪时间
     */
    getTraceTime: function getTraceTime() {
      return Module._RenderCycleSet_GetTraceTime(this.handle);
    },
    /**
     *设置启用深度测试
     * @param {Boolean} enable -是否启用深度测试
     * @memberOf RenderCycleSet#
     */
    setEnableDepthTest: function setEnableDepthTest(enable) {
      Module._RenderCycleSet_SetEnableDepthTest(this.handle, enable);
    },
    /**
     * 获取是否启用深度测试
     *
     * @memberOf RenderCycleSet#
     * @returns {Boolean} 启用返回true 否则返回false
     */
    isEnableDepthTest: function isEnableDepthTest() {
      return Module._RenderCycleSet_IsEnableDepthTest(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 线周期集渲染相关操作函数
   * @name RenderLineCycleSet
   *
   * @extends RenderCycleSet
   */
  function PIERenderLineCycleSet(handle, autoRelease) {
    PIERenderCycleSet.call(this, handle, autoRelease);
  }
  PIERenderLineCycleSet.prototype = Object.assign(Object.create(PIERenderCycleSet.prototype), {
    /**
     * 设置循环前进路径
     * @param {String} path -前进路径
     * @memberOf RenderLineCycleSet#
     */
    setForePath: function setForePath(path) {
      if (path != null) {
        var strPath = new PIEString$1(path);
        Module._RenderLineCycleSet_SetForePath(this.handle, strPath.getHandle());
        strPath.dispose();
      }
    },
    /**
     * 获取循环前进路径
     *
     * @memberOf RenderLineCycleSet#
     * @returns {String} 返回前进路径
     * @example
     * let renderLineCycleSet = new PIE.RenderLineCycleSet();
     * var path = renderLineCycleSet.getForePath();
     */
    getForePath: function getForePath() {
      var strPath = new PIEString$1(256);
      Module._RenderLineCycleSet_GetForePath(this.handle, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    /**
     * 设置循环返回路径
     * @param {String} path -返回路径
     * @memberOf RenderLineCycleSet#
     *
     */
    setBackPath: function setBackPath(path) {
      if (path != null) {
        var strPath = new PIEString$1(path);
        Module._RenderLineCycleSet_SetBackPath(this.handle, strPath.getHandle());
        strPath.dispose();
      }
    },
    /**
     * 获取循环返回路径
     *
     * @memberOf RenderLineCycleSet#
     * @returns {String} 返回循环返回路径
     * @example
     * let renderLineCycleSet = new PIE.RenderLineCycleSet();
     * var path = renderLineCycleSet.getBackPath();
     */
    getBackPath: function getBackPath() {
      var strPath = new PIEString$1(256);
      Module._RenderLineCycleSet_GetBackPath(this.handle, strPath.getHandle());
      var path = strPath.toString();
      strPath.dispose();
      return path;
    },
    /**
     * 设置循环颜色
     * @param {(Array/PIEColor)} color -循环颜色
     * @memberOf RenderLineCycleSet#
     *
     */
    setForeColor: function setForeColor(color) {
      var colorArray = null;
      if (color instanceof Array) {
        colorArray = color;
      } else if (color instanceof PIEColor) {
        colorArray = color.toArray();
      }
      if (colorArray && colorArray.length > 0) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderLineCycleSet_SetForeColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    /**
     * 获取循环颜色
     *
     * @memberOf RenderLineCycleSet#
     * @returns {PIEColor} 返回循环颜色
     * @example
     * let renderLineCycleSet = new PIE.RenderLineCycleSet();
     * var PIEColor = renderLineCycleSet.getForeColor();
     */
    getForeColor: function getForeColor() {
      var arrayColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._RenderLineCycleSet_GetForeColor(this.handle, arrayColor.getHandle());
      arrayColor.updateData();
      var color = arrayColor.toArray();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置循环返回颜色
     * @param {(Array/PIEColor)} color -返回颜色
     * @memberOf RenderLineCycleSet#
     *
     */
    setBackColor: function setBackColor(color) {
      var colorArray = null;
      if (color instanceof Array) {
        colorArray = color;
      } else if (color instanceof PIEColor) {
        colorArray = color.toArray();
      }
      if (colorArray && colorArray.length > 0) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._RenderLineCycleSet_SetBackColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    /**
     * 获取循环返回颜色
     *
     * @memberOf RenderLineCycleSet#
     * @returns {PIEColor} 循环返回颜色
     * @example
     * let renderLineCycleSet = new PIE.RenderLineCycleSet();
     * var PIEColor = renderLineCycleSet.getBackColor();
     */
    getBackColor: function getBackColor() {
      var arrayColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._RenderLineCycleSet_GetBackColor(this.handle, arrayColor.getHandle());
      arrayColor.updateData();
      var color = arrayColor.toArray();
      return new PIEColor(color[0], color[1], color[2], color[3]);
    },
    /**
     * 设置循环前进启用线
     * @param {Boolean} enable -是否成功设置
     * @memberOf RenderLineCycleSet#
     *
     */
    setEnableForeLine: function setEnableForeLine(enable) {
      Module._RenderLineCycleSet_SetEnableForeLine(this.handle, enable);
    },
    /**
     * 判断循环前进启用线是否成功设置
     *
     * @memberOf RenderLineCycleSet#
     * @returns {Boolean} 返回是否成功设置
     */
    isEnableForeLine: function isEnableForeLine() {
      return Module._RenderLineCycleSet_IsEnableForeLine(this.handle);
    },
    /**
     * 设置循环返回启用线
     * @param {Boolean} enable -是否成功启动
     * @memberOf RenderLineCycleSet#
     *
     */
    setEnableBackLine: function setEnableBackLine(enable) {
      Module._RenderLineCycleSet_SetEnableBackLine(this.handle, enable);
    },
    /**
     * 判断循环返回启用线是否成功设置
     *
     * @memberOf RenderLineCycleSet#
     * @returns {Boolean} 返回启用线是否成功设置
     */
    isEnableBackLine: function isEnableBackLine() {
      return Module._RenderLineCycleSet_IsEnableBackLine(this.handle);
    },
    /**
     * 设置循环前进线宽度
     * @param {Number} width -前进线宽度
     * @memberOf RenderLineCycleSet#
     *
     */
    setForeLineWidth: function setForeLineWidth(width) {
      Module._RenderLineCycleSet_SetForeLineWidth(this.handle, width);
    },
    /**
     * 获取循环前进线宽度
     *
     * @memberOf RenderLineCycleSet#
     * @returns {Number} 返回前进线宽度
     */
    getForeLineWidth: function getForeLineWidth() {
      return Module._RenderLineCycleSet_GetForeLineWidth(this.handle);
    },
    /**
     * 设置循环返回线宽度
     * @param {Number} width -返回线宽度
     * @memberOf RenderLineCycleSet#
     *
     */
    setBackLineWidth: function setBackLineWidth(width) {
      Module._RenderLineCycleSet_SetBackLineWidth(this.handle, width);
    },
    /**
     * 获取循环返回线宽度
     *
     * @memberOf RenderLineCycleSet#
     * @returns {Number} 返回线宽度
     */
    getBackLineWidth: function getBackLineWidth() {
      return Module._RenderLineCycleSet_GetBackLineWidth(this.handle);
    },
    /**
     * 设置光滑线
     * @param {Boolean} smooth 是否设置成功
     * @memberOf RenderLineCycleSet#
     *
     */
    setLineSmooth: function setLineSmooth(smooth) {
      Module._RenderLineCycleSet_SetLineSmooth(this.handle, smooth);
    },
    /**
     * 判断光滑线是否设置成功
     *
     * @memberOf RenderLineCycleSet#
     * @returns {Boolean} 返回光滑线是否设置成功
     */
    isLineSmooth: function isLineSmooth() {
      return Module._RenderLineCycleSet_IsLineSmooth(this.handle);
    },
    /**
     * 设置跟踪启用时间
     * @param {Boolean} enable 是否成功启用
     * @memberOf RenderLineCycleSet#
     *
     */
    setEnableBackTraceTime: function setEnableBackTraceTime(enable) {
      Module._RenderLineCycleSet_SetEnableBackTraceTime(this.handle, enable);
    },
    /**
     * 判断跟踪启用时间是否成功启动
     *
     * @memberOf RenderLineCycleSet#
     * @returns {Boolean} 返回是否成功启动
     */
    isEnableBackTraceTime: function isEnableBackTraceTime() {
      return Module._RenderLineCycleSet_IsEnableBackTraceTime(this.handle);
    },
    /**
     * 设置跟踪返回时间
     * @param {Number} time -跟踪返回时间
     * @memberOf RenderLineCycleSet#
     *
     */
    setBackTraceTime: function setBackTraceTime(time) {
      Module._RenderLineCycleSet_SetBackTraceTime(this.handle, time);
    },
    /**
     * 获取跟踪返回时间
     *
     * @memberOf RenderLineCycleSet#
     * @returns {Number} 返回跟踪返回时间
     */
    getBackTraceTime: function getBackTraceTime() {
      return Module._RenderLineCycleSet_GetBackTraceTime(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 系统线周期渲染相关操作函数
   * @name RenderSysLineCycleSet
   * @class RenderSysLineCycleSet
   *
   * @extends RenderLineCycleSet
   */
  function PIERenderSysLineCycleSet(handle, autoRelease) {
    if (handle == null) {
      handle = Module._RenderSysLineCycleSet_Create();
      autoRelease = true;
    }
    PIERenderLineCycleSet.call(this, handle, autoRelease);
  }
  PIERenderSysLineCycleSet.prototype = Object.assign(Object.create(PIERenderLineCycleSet.prototype), {
    /**
     * 添加跟踪列表
     * @param {PIETraceList} tracelist -跟踪列表
     * @memberOf RenderLineCycleSet#
     *
     * @returns {Boolean} 返回是否添加成功
     */
    addTraceList: function addTraceList(tracelist) {
      return Module._RenderSysLineCycleSet_AddTraceList(this.handle, tracelist.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建跟踪列表
   * @name TraceList
   * @class TraceList
   * 跟踪列表操作函数
   *
   * @example
   * let traceList = new PIE.TraceList();
   */
  function PIETraceList(handle, autoRelease) {
    if (handle == null) {
      handle = Module._TraceList_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIETraceList.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    dispose: function dispose() {
      if (this.autoRelease) ;
      this.handle = null;
    },
    /**
     * 获取空间参考系类型
     *
     * @memberOf TraceList#
     * @returns {Number} 返回空间参考系类型
     */
    getSpatialRefType: function getSpatialRefType() {
      return Module._TraceList_GetSpatialRefType(this.handle);
    },
    /**
     * 设置空间参考系类型
     * @param {Number} type -空间参考系类型
     * @memberOf TraceList#
     *
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._TraceList_SetSpatialRefType(this.handle, type);
    },
    /**
     * 获取元素个数
     *
     * @memberOf TraceList#
     * @returns {Number} 返回元素个数
     */
    getCount: function getCount() {
      return Module._TraceList_GetCount(this.handle);
    },
    /**
     * 设置位置
     * @param {(Array/PIEVector4)} positions -位置
     * @memberOf TraceList#
     *
     */
    setPositions: function setPositions(positions) {
      var posArray = null;
      if (positions instanceof Array) {
        posArray = positions;
      } else if (positions instanceof PIEVector4) {
        posArray = positions.toArray();
      }
      if (posArray && posArray.length >= 4) {
        var arrayPositions = new PIEArray(posArray, PIEArrayType.Float64);
        var length = posArray.length / 4;
        Module._TraceList_SetPositions(this.handle, arrayPositions.getHandle(), length);
        arrayPositions.dispose();
      }
    },
    /**
     * 获取位置
     *
     * @memberOf TraceList#
     * @returns {PIEVector4} 返回位置
     */
    getPositions: function getPositions() {
      var count = this.getCount();
      if (count) {
        var arrayPostions = new PIEArray(count * 4, PIEArrayType.Float64);
        Module._TraceList_GetPositions(this.handle, arrayPostions.getHandle());
        arrayPostions.updateData();
        var positionsArray = arrayPostions.toArray();
        arrayPostions.dispose();
        return positionsArray;
      }
      return null;
    },
    /**
     * 添加位置
     * @param {(Array/PIEVector4)} positions -位置
     * @memberOf TraceList#
     *
     */
    addPositions: function addPositions(positions) {
      var posArray = null;
      if (positions instanceof Array) {
        posArray = positions;
      } else if (positions instanceof PIEVector4) {
        posArray = positions.toArray();
      }
      if (posArray && posArray.length >= 4) {
        var arrayPositions = new PIEArray(posArray, PIEArrayType.Float64);
        var length = posArray.length / 4;
        Module._TraceList_AddPositions(this.handle, arrayPositions.getHandle(), length);
        arrayPositions.dispose();
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 密度图渲染对象
   *
   * @name RenderDensitySet
   * @extends Renderable
   *
   */
  function PIERenderDensitySet(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIERenderDensitySet.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     *是否设置几何着色器
     *
     * @param {Boolean} enable -是否设置
     * @memberOf RenderDensitySet#
     */
    setGeometryShader: function setGeometryShader(enable) {
      Module._RenderDensity_SetGeometryShader(this.handle, enable);
    },
    /**
     *判断是否设置几何着色器
     *
     * @memberOf RenderDensitySet#
     * @returns {Boolean} 是否设置
     */
    isGeometryShader: function isGeometryShader() {
      return Module._RenderDensity_IsGeometryShader(this.handle);
    },
    /**
     * 获取空间参考系类型
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 返回空间参考系类型
     */
    getSpatialRefType: function getSpatialRefType() {
      return Module._RenderDensity_GetSpatialRefType(this.handle);
    },
    /**
     * 设置空间参考系类型
     * @param {Number} type -空间参考系类型
     * @memberOf RenderDensitySet#
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._RenderDensity_SetSpatialRefType(this.handle, type);
    },
    /**
     *设置是否在画布上呈现
     * @param {Boolean} enable -是否设置
     * @memberOf RenderDensitySet#
     */
    setCanvasRender: function setCanvasRender(enable) {
      Module._RenderDensity_SetCanvasRender(this.handle, enable);
    },
    /**
     * 判断是否设置在画布上呈现
     *
     * @memberOf RenderDensitySet#
     * @returns {Boolean} 返回是否设置画布
     */
    isCanvasRender: function isCanvasRender() {
      return Module._RenderDensity_IsCanvasRender(this.handle);
    },
    /**
     * 获取透明度
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 返回透明度
     */
    getTransparent: function getTransparent() {
      return Module._RenderDensity_GetTransparent(this.handle);
    },
    /**
     * 设置透明度
     * @param {Number} transparent -透明度
     * @memberOf RenderDensitySet#
     */
    setTransparent: function setTransparent(transparent) {
      Module._RenderDensity_SetTransparent(this.handle, transparent);
    },
    /**
     * 设置位置
     * @param {(PIEVector3/Array)} position
     * @memberOf RenderDensitySet#
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._RenderDensity_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 设置帧速
     * @param {Number} speed -速度
     * @memberOf RenderDensitySet#
     */
    setSpeedPerFrame: function setSpeedPerFrame(speed) {
      Module._RenderDensity_SetSpeedPerFrame(this.handle, speed);
    },
    /**
     * 获取帧速
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 返回帧速
     */
    getSpeedPerFrame: function getSpeedPerFrame() {
      return Module._RenderDensity_GetSpeedPerFrame(this.handle);
    },
    /**
     * 设置当前时间值
     * @param {Number} time -时间值
     * @memberOf RenderDensitySet#
     */
    setCurTime: function setCurTime(time) {
      Module._RenderDensity_SetCurTime(this.handle, time);
    },
    /**
     * 获取当前时间值
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 返回当前时间值
     */
    getCurTime: function getCurTime() {
      return Module._RenderDensity_GetCurTime(this.handle);
    },
    /**
     * 设置开始时间
     * @param {Number} time -开始时间
     * @memberOf RenderDensitySet#
     */
    setStartTime: function setStartTime(time) {
      Module._RenderDensity_SetStartTime(this.handle, time);
    },
    /**
     * 获取开始时间
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 返回时间
     */
    getStartTime: function getStartTime() {
      return Module._RenderDensity_GetStartTime(this.handle);
    },
    /**
     * 设置结束时间
     * @param {Number} time -结束时间
     * @memberOf RenderDensitySet#
     */
    setEndTime: function setEndTime(time) {
      Module._RenderDensity_SetEndTime(this.handle, time);
    },
    /**
     * 获取结束时间
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 返回结束时间
     */
    getEndTime: function getEndTime() {
      return Module._RenderDensity_GetEndTime(this.handle);
    },
    /**
     *设置跟踪时间
     * @param {Number} time -跟踪时间
     * @memberOf RenderDensitySet#
     */
    setTraceTime: function setTraceTime(time) {
      Module._RenderDensity_SetTraceTime(this.handle, time);
    },
    /**
     *获取跟踪时间
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 返回跟踪时间
     */
    getTraceTime: function getTraceTime() {
      return Module._RenderDensity_GetTraceTime(this.handle);
    },
    /**
     * 获取当前密度数量
     *
     * @memberOf RenderDensitySet#
     * @returns {Number} 密度数量
     */
    getCurDensityCount: function getCurDensityCount() {
      return Module._RenderDensity_GetCurDensityCount(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建密度点对象
   * @name DensityPoint
   * @class DensityPoint
   * 密度点操作函数
   *
   * @example
   * let densityPoint = new PIE.DensityPoint();
   */
  function PIEDensityPoint(handle, autoRelease) {
    if (handle == null) {
      handle = Module._DensityPoint_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEDensityPoint.prototype, {
    setAutoRelease: function setAutoRelease(autoRelease) {
      this.autoRelease = autoRelease;
    },
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放密度点对象
     * @memberOf DensityPoint#
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._DensityPoint_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置颜色
     * @param {(Array/PIEVector4/PIEColor)} color -颜色值
     * @memberOf DensityPoint#
     */
    setColor: function setColor(color) {
      var colorArray = null;
      if (color instanceof Array) {
        colorArray = color;
      } else if (color instanceof PIEVector4) {
        colorArray = color.toArray();
      } else if (color instanceof PIEColor) {
        colorArray = color.toArray();
      }
      if (colorArray) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._DensityPoint_SetColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    /**
     * 设置位置
     * @param {(PIEVector4/Array)} position -位置
     * @memberOf DensityPoint#
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector4) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._DensityPoint_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 设置半径
     * @param {Number} radius -半径
     * @memberOf DensityPoint#
     */
    setRadius: function setRadius(radius) {
      Module._DensityPoint_SetRadius(this.handle, radius);
    },
    /**
     * 设置风格
     * @param {Number} style -风格
     * @memberOf DensityPoint#
     */
    setStyle: function setStyle(style) {
      Module._DensityPoint_SetStyle(this.handle, style);
    },
    /**
     * 设置空间参考系类型
     * @param {Number} type -空间参考系类型
     * @memberOf DensityPoint#
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._DensityPoint_SetSpatialRefType(this.handle, type);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建列表密度集渲染对象
   * @name RenderListDensitySet
   * @class RenderListDensitySet
   * 列表密度集渲染函数
   *
   * @extends RenderDensitySet
   * @example
   * let renderListDensitySet = new PIE.RenderListDensitySet();
   */
  function PIERenderListDensitySet(handle, autoRelease) {
    if (handle == null) {
      handle = Module._RenderListDensitySet_Create();
      autoRelease = true;
    }
    PIERenderDensitySet.call(this, handle, autoRelease);
  }
  PIERenderListDensitySet.prototype = Object.assign(Object.create(PIERenderDensitySet.prototype), {
    /**
     * 设置缓存池大小
     * @param {Number} size -缓存池大小
     * @memberOf RenderListDensitySet#
     *
     */
    setPoolSize: function setPoolSize(size) {
      Module._RenderListDensitySet_SetPoolSize(this.handle, size);
    },
    /**
     * 获取缓存池大小
     *
     * @memberOf RenderListDensitySet#
     * @returns {Number} 返回缓存池大小
     */
    getPoolSize: function getPoolSize() {
      return Module._RenderListDensitySet_GetPoolSize(this.handle);
    },
    /**
     * 获取密度点数量
     *
     * @memberOf RenderListDensitySet#
     * @returns {Number} 返回密度点数量
     */
    getDensityPointCount: function getDensityPointCount() {
      return Module._RenderListDensitySet_GetDensityPointCount(this.handle);
    },
    /**
     * 移除所有密度点
     * @memberOf RenderListDensitySet#
     */
    removeAllDensityPoint: function removeAllDensityPoint() {
      Module._RenderListDensitySet_RemoveAllDensityPoint(this.handle);
    },
    /**
     * 添加密度点
     * @param {PIEDensityPoint} densityPoint -密度点
     *
     * @memberOf RenderListDensitySet#
     * @returns {Boolean} 返回是否添加成功
     */
    addDensityPoint: function addDensityPoint(densityPoint) {
      return Module._RenderListDensitySet_AddDensityPoint(this.handle, densityPoint.getHandle());
    },
    /**
     * 更新密度点
     * @param {Number} index -密度点索引
     * @param {PIEDensityPoint} densityPoint -密度点
     * @memberOf RenderListDensitySet#
     *
     * @returns {Boolean} 返回是否更新成功
     */
    updateDensityPoint: function updateDensityPoint(index, densityPoint) {
      return Module._RenderListDensitySet_UpdateDensityPoint(this.handle, index, densityPoint.getHandle());
    },
    /**
     * 获取密度点
     * @param {Number} index -密度点索引
     * @memberOf RenderListDensitySet#
     *
     * @returns {PIEDensityPoint} 返回密度点
     */
    getDensityPoint: function getDensityPoint(index) {
      var handle = Module._RenderListDensitySet_GetDensityPoint(this.handle, index);
      return new PIEDensityPoint(handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建世界列表密度集渲染函数
   * @name RenderWorldListDensitySet
   * @class RenderWorldListDensitySet
   * 世界列表密度集渲染函数
   *
   * @extends RenderListDensitySet
   * @example
   * let renderWorldListDensitySet = new PIE.RenderWorldListDensitySet();
   */
  function PIERenderWorldListDensitySet(handle, autoRelease) {
    if (handle == null) {
      handle = Module._RenderWorldListDensitySet_Create();
      autoRelease = true;
    }
    PIERenderListDensitySet.call(this, handle, autoRelease);
  }
  PIERenderWorldListDensitySet.prototype = Object.assign(Object.create(PIERenderListDensitySet.prototype), {
    /**
     * 设置几何着色器
     * @param {Boolean} enable -是否设置成功
     * @memberOf RenderWorldListDensitySet#
     *
     */
    setGeometryShader: function setGeometryShader(enable) {
      Module._RenderWorldListDensitySet_SetGeometryShader(this.handle, enable);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 组密度图对象相关函数
   * @name GroupDensitySet
   * @class GroupDensitySet
   */
  function PIEGroupDensity(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIEGroupDensity.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放组密度图对象
     * @memberOf GroupDensitySet#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._GroupDensity_Delete(this.handle);
        this.handle = null;
      }
    },
    /**
     *  添加密度点
     * @param {PIEDensityPoint} densityPoint -密度点
     * @memberOf GroupaDensitySet#
     * @returns {Boolean} 返回是否添加成功
     */
    addDensityPoint: function addDensityPoint(densityPoint) {
      return Module._GroupDensity_AddDensityPoint(this.handle, densityPoint.getHandle());
    }
  });

  Object.assign(Object.create(PIERenderDensitySet.prototype), {
    /**
     * 释放组密度图渲染对象
     * @memberOf RenderGroupDensitySet#
     */
    dispose: function dispose() {
      if (this.autoRelease && this.handle) {
        Module._RenderGroupDensitySet_Delete(this.handle);
        this.handle = null;
      }
    },
    /**
     *  创建组密度图对象
     * @memberOf RenderGroupDensitySet#
     * @returns {PIEGroupDensity} 创建成功返回PIEGroupDensitySet对象，否则返回NULL
     */
    createGroup: function createGroup() {
      var handle = Module._RenderGroupDensitySet_CreateGroup(this.handle);
      if (handle) {
        return new PIEGroupDensity(handle);
      }
      return null;
    },
    /**
     * 添加组密度图
     * @param {PIEGroupDensity} type -组密度图对象
     * @memberOf RenderGroupDensitySet#
     * @returns {Boolean} 添加成功返回true，否则返回false
     */
    addGroup: function addGroup(groupDensity) {
      return Module._RenderGroupDensitySet_AddGroup(this.handle, groupDensity.getHandle());
    },
    /**
     * 获取组密度图对象个数
     * @memberOf RenderGroupDensitySet#
     * @returns {Number} 返回组对象个数
     */
    getGroupCount: function getGroupCount() {
      return Module._RenderGroupDensitySet_GetGroupCount(this.handle);
    },
    /**
     * 移除所有组密度图对象
     * @memberOf RenderGroupDensitySet#
     */
    removeAllGroup: function removeAllGroup() {
      Module._RenderGroupDensitySet_RemoveAllGroup(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建点周期集渲染函数
   * @name RenderPointGridSet
   * 点周期集渲染函数
   *
   * @extends PIERenderCycleSet
   */
  function PIERenderPointCycleSet(handle, autoRelease) {
    PIERenderCycleSet.call(this, handle, autoRelease);
  }
  PIERenderPointCycleSet.prototype = Object.assign(Object.create(PIERenderCycleSet.prototype), {});

  Object.assign(Object.create(PIERenderPointCycleSet.prototype), {
    /**
     * 添加周期点
     * @param {PIECyclePoint} cyclePoint -周期点
     * @memberOf RenderWorldPointCycleSet#
     *
     * @returns {Boolean} 返回是否添加成功
     */
    addCyclePoint: function addCyclePoint(cyclePoint) {
      return Module._RenderWorldPointCycleSet_AddCyclePoint(this.handle, cyclePoint.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建多维数据集渲染操作相关函数
   * @name RenderCubeSet
   * @extends Renderable
   */
  function PIERenderCubeSet(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIERenderCubeSet.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 删除多维数据集
     * @memberOf RenderCubeSet#
     */
    "delete": function _delete() {
      Module._RenderCubeSet_Delete(this.handle);
    },
    /**
     * 获取空间参考系类型
     *
     * @memberOf RenderCubeSet#
     * @returns {Number} 返回空间参考系类型
     */
    getSpatialRefType: function getSpatialRefType() {
      return Module._RenderCubeSet_GetSpatialRefType(this.handle);
    },
    /**
     * 设置空间参考系类型
     * @param {Number} type -空间参考系类型
     * @memberOf RenderCubeSet#
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._RenderCubeSet_SetSpatialRefType(this.handle, type);
    },
    /**
     * 设置位置
     * @param {(Array/PIEVector3)} position -位置
     * @memberOf RenderCubeSet#
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._RenderCubeSet_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 获取位置
     *
     * @memberOf RenderCubeSet#
     * @returns {PIEVector3} 返回位置
     */
    getPosition: function getPosition() {
      var arrayPosition = new PIEArray(3, PIEArrayType.Float64);
      Module._RenderCubeSet_GetPosition(this.handle, arrayPosition.getHandle());
      arrayPosition.updateData();
      var positionArray = arrayPosition.toArray();
      arrayPosition.dispose();
      return new PIEVector3(positionArray[0], positionArray[1], positionArray[2]);
    }
  });

  Object.assign(Object.create(PIERenderCubeSet.prototype), {
    /**
     * 删除多维数据集列表
     * @memberOf RenderListCubeSet#
     */
    "delete": function _delete() {
      Module._RenderListCubeSet_Delete(this.handle);
    },
    /**
     * 设置缓存池大小
     * @param {Number} size -缓存池大小
     * @memberOf RenderListCubeSet#
     *
     */
    SetPoolSize: function SetPoolSize(size) {
      Module._RenderListCubeSet_SetPoolSize(this.handle, size);
    },
    /**
     * 获取缓存池大小
     *
     * @memberOf RenderListCubeSet#
     * @returns {Number} 返回缓存池大小
     */
    getPoolSize: function getPoolSize() {
      return Module._RenderListCubeSet_GetPoolSize(this.handle);
    },
    /**
     * 移除所有多维数据点
     * @memberOf RenderListCubeSet#
     */
    removeAllCubePoint: function removeAllCubePoint() {
      Module._RenderListCubeSet_RemoveAllCubePoint(this.handle);
    },
    /**
     * 设置增长效果
     * @param {Boolean} enable -是否设置成功
     * @memberOf RenderListCubeSet#
     */
    setEnableGrow: function setEnableGrow(enable) {
      Module._RenderListCubeSet_SetEnableGrow(this.handle, enable);
    },
    /**
     * 获取增长效果
     *
     * @memberOf RenderListCubeSet#
     * @returns {Boolean} 返回是否获取成功
     */
    isEnableGrow: function isEnableGrow() {
      return Module._RenderListCubeSet_IsEnableGrow(this.handle);
    },
    /**
     * 设置当前增长比例
     * @param {Number} growRatio -增长比例
     * @memberOf RenderListCubeSet#
     *
     */
    setCurGrowRatio: function setCurGrowRatio(growRatio) {
      Module._RenderListCubeSet_SetCurGrowRatio(this.handle, growRatio);
    },
    /**
     * 获取当前增长比例
     *
     * @memberOf RenderListCubeSet#
     * @returns {Number} 返回增长比例
     */
    getCurGrowRatio: function getCurGrowRatio() {
      return Module._RenderListCubeSet_GetCurGrowRatio(this.handle);
    },
    /**
     * 设置每一帧的增长比例
     * @param {Number} growRatioPerFrame -每一帧的增长比例
     * @memberOf RenderListCubeSet#
     *
     */
    setGrowRatioPerFrame: function setGrowRatioPerFrame(growRatioPerFrame) {
      Module._RenderListCubeSet_SetGrowRatioPerFrame(this.handle, growRatioPerFrame);
    },
    /**
     * 获取每一帧的增长比例
     *
     * @memberOf RenderListCubeSet#
     * @returns {Number} 返回增长比例
     */
    getGrowRatioPerFrame: function getGrowRatioPerFrame() {
      return Module._RenderListCubeSet_GetGrowRatioPerFrame(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 网格渲染对象
   * @name RenderGridSet
   * @extends Renderable
   */
  function PIERenderGridSet(handle, autoRelease) {
    PIERenderable.call(this, handle, autoRelease);
  }
  PIERenderGridSet.prototype = Object.assign(Object.create(PIERenderable.prototype), {
    /**
     * 获取空间索引类型
     *
     * @memberOf RenderGridSet#
     * @returns {Number} 空间索引类型
     */
    getSpatialRefType: function getSpatialRefType() {
      return Module._RenderGridSet_GetSpatialRefType(this.handle);
    },
    /**
     * 设置空间索引类型
     * @param {Number} type -空间索引类型
     * @memberOf RenderGridSet#
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._RenderGridSet_SetSpatialRefType(this.handle, type);
    },
    /**
     * 设置位置
     * @param {(Array/PIEVector3)} position -网格位置
     * @memberOf RenderGridSet#
     *
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector3) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._RenderGridSet_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     *设置网格大小
     * @param {Number} gridSize -网格大小
     * @memberOf RenderGridSet#
     */
    setGridSize: function setGridSize(gridSize) {
      Module._RenderGridSet_SetGridSize(this.handle, gridSize);
    },
    /**
     * 获取网格大小
     *
     * @memberOf RenderGridSet#
     * @returns {Number} 返回网格大小
     */
    getGridSize: function getGridSize() {
      return Module._RenderGridSet_GetGridSize(this.handle);
    },
    /**
     * 设置文本大小
     * @param {Number} textSize -文本大小
     * @memberOf RenderGridSet#
     */
    setTextSize: function setTextSize(textSize) {
      Module._RenderGridSet_SetTextSize(this.handle, textSize);
    },
    /**
     * 获取文本大小
     * @memberOf RenderGridSet#
     * @returns {Number} 返回文本大小
     */
    getTextSize: function getTextSize() {
      return Module._RenderGridSet_GetTextSize(this.handle);
    },
    /**
     * 设置文本颜色
     * @param {(Array/PIEColor)} textColor -文本颜色
     * @memberOf RenderGridSet#
     *
     */
    setTextColor: function setTextColor(textColor) {
      var textcolorArray = [];
      if (textColor instanceof Array) {
        textcolorArray = textColor;
      } else if (textColor instanceof PIEColor) {
        textcolorArray = textColor.toArray();
      }
      if (textcolorArray && textcolorArray.length > 0) {
        var arrayTextColor = new PIEArray(textcolorArray, PIEArrayType.UInt8);
        Module._RenderGridSet_SetTextColor(this.handle, arrayTextColor.getHandle());
        arrayTextColor.dispose();
      }
    },
    /**
     *获取位置
     *
     * @memberOf RenderGridSet#
     * @returns {PIEVector3} 返回位置
     */
    getPosition: function getPosition() {
      var arrayPosition = new PIEArray(3, PIEArrayType.UInt8);
      Module._RenderGridSet_GetPosition(this.handle, arrayPosition.getHandle());
      arrayPosition.updateData();
      var position = arrayPosition.toArray();
      arrayPosition.dispose();
      return new PIEVector3(position[0], position[1], position[2]);
    },
    /**
     * 获取文本颜色
     *
     * @memberOf RenderGridSet#
     * @returns {PIEVector4} 返回文本颜色
     */
    getTextColor: function getTextColor() {
      var arrayTextColor = new PIEArray(4, PIEArrayType.UInt8);
      Module._RenderGridSet_GetTextColor(this.handle, arrayTextColor.getHandle());
      arrayTextColor.updateData();
      var textColor = arrayTextColor.toArray();
      arrayTextColor.dispose();
      return new PIEVector4(textColor[0], textColor[1], textColor[2], textColor[3]);
    }
  });

  Object.assign(Object.create(PIERenderGridSet.prototype), {
    /**
     * 清除所有网格点集
     * @memberOf RenderPointGridSet#
     */
    removeAll: function removeAll() {
      Module._RenderPointGridSet_RemoveAll(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建周期点对象
   * @name CyclePoint
   * @class CyclePoint
   * 周期点操作函数
   *
   * @example
   * let cyclePoint = new PIE.CyclePoint();
   */
  function PIECyclePoint(handle, autoRelease) {
    if (handle == null) {
      handle = Module._CyclePoint_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIECyclePoint.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放周期点对象
     * @memberOf CyclePoint#
     */
    dispose: function dispose() {
      if (this.autoRelease) {
        Module._CyclePoint_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置颜色
     * @param {(Array/PIEVector4/PIEColor)} color -颜色值
     * @memberOf CyclePoint#
     */
    setColor: function setColor(color) {
      var colorArray = null;
      if (color instanceof Array) {
        colorArray = color;
      } else if (color instanceof PIEVector4) {
        colorArray = color.toArray();
      } else if (color instanceof PIEColor) {
        colorArray = color.toArray();
      }
      if (colorArray) {
        var arrayColor = new PIEArray(colorArray, PIEArrayType.UInt8);
        Module._CyclePoint_SetColor(this.handle, arrayColor.getHandle());
        arrayColor.dispose();
      }
    },
    /**
     * 设置位置
     * @param {(Array/PIEVector4)} position -位置
     * @memberOf CyclePoint#
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector4) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._CyclePoint_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     * 设置半径
     * @param {Number} radius -半径
     * @memberOf CyclePoint#
     */
    setRadius: function setRadius(radius) {
      Module._CyclePoint_SetRadius(this.handle, radius);
    },
    /**
     * 设置空间参考系类型
     * @param {Number} type -空间参考系类型
     * @memberOf CyclePoint#
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._CyclePoint_SetSpatialRefType(this.handle, type);
    },
    /**
     * 设置风格
     * @param {Number} style -风格
     * @memberOf CyclePoint#
     */
    setStyle: function setStyle(style) {
      Module._CyclePoint_SetStyle(this.handle, style);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 大数据模块
   * ---
   */

  /**
   * 创建多维数据点对象
   * @name CubePoint
   * @class CubePoint
   * 多维数据点操作函数
   *
   *
   * @example
   * let cubePoint = new PIE.CubePoint();
   *
   */
  function PIECubePoint(handle, autoRelease) {
    if (handle == null) {
      handle = Module._CubePoint_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIECubePoint.prototype, {
    getHandle: function getHandle() {
      return this.handle;
    },
    /**
     * 释放多维数据点对象
     * @memberOf CubePoint#
     */
    "delete": function _delete() {
      if (this.autoRelease) {
        Module._CubePoint_Delete(this.handle);
      }
      this.handle = null;
    },
    /**
     * 设置位置
     * @param {(Array/PIEVector4)} position -位置
     * @memberOf CubePoint#
     *
     */
    setPosition: function setPosition(position) {
      var posArray = null;
      if (position instanceof Array) {
        posArray = position;
      } else if (position instanceof PIEVector4) {
        posArray = position.toArray();
      }
      if (posArray) {
        var arrayPos = new PIEArray(posArray, PIEArrayType.Float64);
        Module._CubePoint_SetPosition(this.handle, arrayPos.getHandle());
        arrayPos.dispose();
      }
    },
    /**
     *设置半径
     * @param {Number} radius -半径
     * @memberOf CubePoint#
     */
    setRadius: function setRadius(radius) {
      Module._CubePoint_SetRadius(this.handle, radius);
    },
    /**
     * 设置空间参考系类型
     * @param {Number} type -空间参考系类型
     * @memberOf CubePoint#
     */
    setSpatialRefType: function setSpatialRefType(type) {
      Module._CubePoint_SetSpatialRefType(this.handle, type);
    },
    /**
     *设置顶部颜色
     * @param {Array} topColor -顶部颜色值
     * @memberOf CubePoint#
     */
    setTopColor: function setTopColor(topColor) {
      var arrayTopColor = new PIEArray(topColor, PIEArrayType.Float64);
      Module._CubePoint_SetTopColor(this.handle, arrayTopColor.getHandle());
      arrayTopColor.dispose();
    },
    /**
     *设置底部颜色
     * @param {Array} bottomColor -底部颜色值
     * @memberOf CubePoint#
     */
    setBottomColor: function setBottomColor(bottomColor) {
      var arrayBottomColor = new PIEArray(bottomColor, PIEArrayType.Float64);
      Module._CubePoint_SetBottomColor(this.handle, arrayBottomColor.getHandle());
      arrayBottomColor.dispose();
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 布告板的显示模式
   * @readonly
   * @enum {number}
   */
  var PIEBillBoardModeType = {
    /**屏幕对齐模式*/
    ScreenAlignMode: 0,
    /**轴旋转模式*/
    AxialRotateMode: 1,
    /**角度固定模式*/
    AngleFixedMode: 2
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建纹理对象
   * @name GeoTexture
   * @class GeoTexture
   * 纹理对象操作函数
   *
   * @param {Object} options
   * @param {Number} options.texture -纹理编号
   * @param {(Array/PIEVector2)}  options.point -纹理对象的定位点
   * @param {(Array/PIESize)} options.size -纹理的尺寸，宽和高
   * @param {Number} options.color -纹理的尺寸，宽和高
   * @param {Number} options.angle -纹理旋转角度
   *
   * @extends Geometry3D
   * @example
   * var lons = [73.33, 135.05];
   var lats = [3.51, 53.33];
   var x = Math.random() * (lons[1] - lons[0] + 1) + lons[0];
   var y = Math.random() * (lats[1] - lats[0] + 1) + lats[0];

   var point = patialReference.forward([x, y]);
   var geoTexture = new PIE.GeoTexture({
                          texture: 11800,
                          point: point,
                          size: [32, 32],
                          color: [255, 0, 0, 255],
                          angle: 60});
   *
   */
  function PIEGeoTexture(options) {
    var handle = null;
    var autoRelease = false;
    if (options) {
      var texture = options.texture;
      var point = options.point;
      var size = options.size;
      var color = options.color;
      var angle = options.angle;
      if (texture != null && point && size && color && angle != null) {
        var arrayPoint;
        var arraySize;
        var arrayColor;
        if (point instanceof Array) {
          arrayPoint = new PIEArray(point, PIEArrayType.Float64);
        } else if (point instanceof PIEVector2) {
          arrayPoint = new PIEArray([point.x, point.y], PIEArrayType.Float64);
        }
        if (size instanceof Array) {
          arraySize = new PIEArray(size, PIEArrayType.Float64);
        } else if (size instanceof PIESize) {
          arraySize = new PIEArray([size.cx, size.cy], PIEArrayType.Float64);
        }
        if (color instanceof Array) {
          arrayColor = new PIEArray(color, PIEArrayType.UInt8);
        } else if (color instanceof PIEColor) {
          arrayColor = new PIEArray([color.r, color.g, color.b, color.a], PIEArrayType.UInt8);
        }
        if (arrayPoint && arraySize && arrayColor) {
          handle = Module._GeoTexture_Make(texture, arrayPoint.getHandle(), arraySize.getHandle(), arrayColor.getHandle(), angle);
          arrayPoint.dispose();
          arraySize.dispose();
          arrayColor.dispose();
          autoRelease = true;
        }
      }
      if (options.handle) {
        handle = options.handle;
      }
    }
    PIEGeometry3D.call(this, handle, autoRelease);
  }
  PIEGeoTexture.prototype = Object.assign(Object.create(PIEGeometry3D.prototype), {
    /**
     * 获取点纹理对象的定位点坐标
     * @memberOf GeoTexture#
     * @returns {PIEVector2} 返回纹理对象的定位点
     */
    getPoint: function getPoint() {
      var arrayPoint = new PIEArray(2, PIEArrayType.Float64);
      Module._GeoTexture_GetPoint(this.handle, arrayPoint.getHandle());
      arrayPoint.updateData();
      var point = arrayPoint.toArray();
      return new PIEVector2(point[0], point[1]);
    },
    /**
     * 设置点纹理对象的定位点坐标
     * @param {(Array/PIEVector2)} point -纹理对象的定位点坐标
     * @memberOf GeoTexture#
     */
    setPoint: function setPoint(point) {
      var pointArray = null;
      if (point instanceof Array) {
        pointArray = point;
      } else if (point instanceof PIEVector2) {
        pointArray = point.toArray();
      }
      if (pointArray) {
        var arrayPoint = new PIEArray(pointArray, PIEArrayType.Float64);
        Module._GeoTexture_SetPoint(this.handle, arrayPoint.getHandle());
        arrayPoint.dispose();
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建栅格数据块对象
   * @name RasterBlock
   * @class RasterBlock
   * 创建栅格数据块对象
   *
   * @extends Geometry
   */

  function PIERasterBlock(handle, autoRelease) {
    PIEGeometry.call(this, handle, autoRelease);
  }
  PIERasterBlock.prototype = Object.assign(Object.create(PIEGeometry.prototype), {
    /**
     * 通过图片路径加载栅格数据块对象
     * @param {Object} options -
     * @param {String} options.file -从服务上获取的数据存储到浏览器某个空间下的地址(可以为空，系统默认创建路径)
     * @param {String} options.url -图片路径
     * @param {PIEBounds} options.bounds -栅格数据块地理范围
     * @param {Number} options.ID -对象ID
     * @memberOf RasterBlock
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     * @example
     *  let options = {
     *      bounds:bounds,
     *       file: 'data/pngTest/world.png',
     *       url: 'http://localhost:8080/data/pngTest/world.png',
     *   };
     *
     *  var RasterBlock = new PIE.RasterBlock();
     *   RasterBlock.load(options).then((value) => {
     *   //vaule就是load之后创建的RasterBlock, 可以用来添加到渲染对象中
     *      var FeatureElement = new PIE.GlobeFeatureElement({geometry:value});
     *       GraphicsLayer.add(FeatureElement);
     *   });
     *
     */
    load: function load(options) {
      var _this = this;
      return new Promise(function (resolve, reject) {
        var that = _this;
        var bounds = options.bounds;
        var file = options.file;
        var url = options.url;
        if (url == null) {
          return null;
        }
        var name = PIEFile.getFileName(url);
        if (name.indexOf('.') < 0) {
          name += ".png";
        }
        if (!file) {
          file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        var filesPicks = [];
        filesPicks.push(file);
        var urlsPicks = [];
        urlsPicks.push(url);
        function callBack(filelist, urllist, datalist) {
          var handle = null;
          var strpath = new PIEString$1(filesPicks[0]);
          if (bounds != null && bounds instanceof PIEBounds) {
            handle = Module._RasterBlock_FromFileEx(strpath.getHandle(), bounds.left, bounds.top, bounds.right, bounds.bottom);
          } else {
            handle = Module._RasterBlock_FromFile(strpath.getHandle());
          }
          strpath.dispose();
          that.handle = handle;
          that.autoRelease = true;
          if (options != null && that.handle != null && options.ID != null) {
            that.setID(options.ID);
          }
          if (that) {
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    },
    /**
     * 通过base64图片加载栅格数据块对象
     * @param {Object} options -
     * @param {String} options.data -base64图片数据
     * @param {String} options.bounds -栅格数据块地理范围
     * @param {Number} options.ID -对象ID
     * @memberOf GeoJsonDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     *
     */
    loadBase64: function loadBase64(options) {
      var that = this;
      var data = options.data;
      var bounds = options.bounds;
      return new Promise(function (resolve, reject) {
        if (options != null && options.data != null) {
          var file = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + "base64.png"; //设置生成json文件路径
          PIEFile.makeFolder(file);
          var stream = Module.FS.open(file, 'w+');
          var raw = window.atob(data); // 解码base64得到二进制字符串
          var rawLength = raw.length;
          var dataArray = new Uint8Array(rawLength); // 创建8位无符号整数值的类型化数组

          for (var i = 0; i < raw.length; i++) {
            dataArray[i] = raw.charCodeAt(i);
          }
          var blob = new Blob([dataArray], {
            type: "image/png"
          });
          blob.arrayBuffer().then(function (buffer) {
            var handle = null;
            var dataArray1 = new Uint8Array(buffer);
            Module.FS.write(stream, dataArray1, 0, dataArray1.length, 0);
            Module.FS.close(stream);
            var strpath = new PIEString$1(file);
            if (bounds != null && bounds instanceof PIEBounds) {
              handle = Module._RasterBlock_FromFileEx(strpath.getHandle(), bounds.left, bounds.top, bounds.right, bounds.bottom);
            } else {
              handle = Module._RasterBlock_FromFile(strpath.getHandle());
            }
            that.handle = handle;
            that.autoRelease = true;
            if (that.handle != null && options.ID != null) {
              that.setID(options.ID);
            }
            resolve(that);
          });
        } else {
          resolve(null);
        }
      });
    },
    /**
     * 获取栅格数据块地理范围
     *
     * @memberOf RasterBlock#
     * @returns {PIEBounds} 返回地理范围
     *
     */
    getBounds: function getBounds() {
      var boundsArr = new PIEArray(4, PIEArrayType.Float64);
      Module._RasterBlock_GetBounds(this.handle, boundsArr.getHandle());
      boundsArr.updateData();
      var array = boundsArr.toArray();
      var bounds = new PIEBounds(array[0], array[1], arrayS[2], array[3]);
      boundsArr.dispose();
      return bounds;
    },
    /**
     * 设置栅格数据块地理范围
     *
     * @memberOf RasterBlock#
     * @param {PIEBounds} bounds -地理范围
     *
     */
    setBounds: function setBounds(bounds) {
      if (bounds != null && bounds instanceof PIEBounds) {
        var boundsArray = new PIEArray(bounds.toArray(), PIEArrayType.Float64);
        Module._RasterBlock_SetBounds(this.handle, boundsArray.getHandle());
        boundsArray.dispose();
      }
    },
    /**
     * 栅格数据块坐标点串数组
     *
     * @memberOf RasterBlock#
     * @returns {Array} 返回栅格数据块坐标点串数组
     *
     */
    getPoints: function getPoints() {
      var pointsArr = new PIEArray(8, PIEArrayType.Float64);
      Module._RasterBlock_GetPoints(this.handle, pointsArr.getHandle());
      pointsArr.updateData();
      var arrayPoints = pointsArr.toArray();
      pointsArr.dispose();
      return arrayPoints;
    },
    /**
     * 设置栅格数据块坐标点串数组
     *
     * @memberOf RasterBlock#
     * @param {Array} points -栅格数据块坐标点串数组(四组坐标点，所以大小应该为8)
     * @returns {Boolean} 设置成功返回true,否则返回false
     */
    setPoints: function setPoints(points) {
      if (points != null && points instanceof Array && points.length == 8) {
        var pointsArr = new PIEArray(points, PIEArrayType.Float64);
        var res = Module._RasterBlock_SetPoints(this.handle, pointsArr.getHandle());
        pointsArr.dispose();
        return res;
      } else {
        return false;
      }
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 创建SMS数据源
   * @name SMSDataSource
   * @class SMSDataSource
   * GeoJson数据源操作函数
   * @extends FeatureDataSource
   */
  function PIESMSDataSource(handle, autoRelease) {
    PIEFeatureDataSource.call(this, handle, autoRelease);
  }
  PIESMSDataSource.prototype = Object.assign(Object.create(PIEFeatureDataSource.prototype), {
    /**
     * 通过数据源路径加载并打开数据源
     * @param {Object} options -
     * @param {String} options.SMSUrl -sms数据服务地址
     * @param {Array} options.filters -需要加载的要素类型
     * @memberOf SMSDataSource#
     * @returns {Promise} 返回一个promise，在value中存放数据源数据
     * @example
     *
     let options = {
            SMSUrl: "http://localhost:8080/data/DN08511111/DN08511111.SMS",
            filters: ["A", "B", "C", "D", "E", "F", "G"],
        };
     let workspace = viewer.getGlobe().getDocument();
     let dataSource = new PIE.SMSDataSource();
     dataSource.load(options).then((value)=>{
           //vaule就是load之后的被成功打开的dataSource 可以用来添加到工作空间中，然后与layer绑定
            workspace.getDataSourceManager().addDataSource(value);
       })
    types : A-测量控制点
            B-工农业社会文化设施
            C-居民地及附属设施
            D-陆地交通
            E-管线
            F-水域陆地
            G-海底地貌及底质
            H-礁石沉船障碍物
            I-水文
            J-陆地地貌及土质
            K-境界与政区
            L-植被
            M-地磁要素
            N-助航设备及航道
            O-海上区域界线
            P-航空要素
            Q-J事区域
            R-注记
            W-J事目标
            T-区域
     */
    load: function load(options) {
      var that = this;
      return new Promise(function (resolve, reject) {
        var SMSFile = "";
        var SMSUrl = options.SMSUrl;
        if (SMSUrl == null) {
          return null;
        }
        var name = PIEFile.getFileName(SMSUrl);
        if (!SMSFile) {
          SMSFile = "data/" + PIEFile.uuid() + "/" + PIEFile.uuid() + name;
        }
        var filesPicks = [];
        var urlsPicks = [];
        filesPicks.push(SMSFile);
        urlsPicks.push(SMSUrl);
        var filters = [];
        if (options.filters != null) {
          filters = options.filters;
        }
        var types = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "W", "T"];
        var suffixs = ["MS", "SX", "TP", "ZB"];
        for (var _i = 0, _types = types; _i < _types.length; _i++) {
          var type = _types[_i];
          if (filters.length > 0 && !filters.includes(type)) {
            continue;
          }
          var _iterator = _createForOfIteratorHelper(suffixs),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var suf = _step.value;
              var suffixValue = '.' + type + suf;
              var url = SMSUrl.replace(/.SMS/, suffixValue);
              urlsPicks.push(url);
              var file = SMSFile.replace(/.SMS/, suffixValue);
              filesPicks.push(file);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        function callBack(filelist, urllist, datalist) {
          if (that.open({
            database: filesPicks[0],
            alias: options.alias
          })) {
            resolve(that);
          }
        }
        PIEFile.loadFiles(filesPicks, urlsPicks, callBack);
      });
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * SMS搭配条件操作函数
   * @name SMSMatchCondition
   */
  function PIESMSMatchCondition(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESMSMatchCondition.prototype, {
    /**
     * 删除SMS搭配条件对象
     * @memberOf SMSMatchCondition#
     */
    "delete": function _delete() {
      Module._SMSMatchCondition_Delete(this.handle);
    },
    /**
     * 获取SMS搭配条件类型
     *
     * @memberOf SMSMatchCondition#
     * @returns {Number} 返回SMS搭配条件类型
     */
    getConditionType: function getConditionType() {
      return Module._SMSMatchCondition_GetConditionType(this.handle);
    },
    /**
     * 获取SMS搭配条件的值类型
     *
     * @memberOf SMSMatchCondition#
     * @returns {PIEVarType} 返回SMS搭配条件的值类型
     */
    getValueType: function getValueType() {
      return Module._SMSMatchCondition_GetValueType(this.handle);
    },
    /**
     * 获取是否和SMS搭配条件匹配
     * @param {Number} value -与SMS搭配条件匹配的值
     *
     * @memberOf SMSMatchCondition#
     * @returns {Boolean} 返回是否和SMS搭配条件匹配
     */
    isMatch: function isMatch(value) {
      return Module._SMSMatchCondition_IsMatch(this.handle, value);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * SMS规则项操作函数
   * @name SMSRule
   */
  function PIESMSRule(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESMSRule.prototype, {
    /**
     * 删除SMS规则项对象
     * @memberOf SMSRule#
     */
    "delete": function _delete() {
      Module._SMSRule_Delete(this.handle);
    },
    /**
     * 设置SMS规则项搭配条件
     * @param {PIESMSMatchCondition} matchCondition -SMS规则项搭配条件
     * @memberOf SMSRule#
     */
    setMatchCondition: function setMatchCondition(matchCondition) {
      Module._SMSRule_SetMatchCondition(this.handle, matchCondition);
    },
    /**
     * 获取SMS规则项搭配条件
     *
     * @memberOf SMSRule#
     * @returns {PIESMSMatchCondition} 返回SMS规则项搭配条件
     */
    getMatchCondition: function getMatchCondition() {
      var handle = Module._SMSRule_GetMatchCondition(this.handle);
      if (handle) {
        return new PIESMSMatchCondition(handle);
      }
    },
    /**
     * 设置SMS规则项名称
     * @param {String} name -SMS规则项名称
     * @memberOf SMSRule#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._SMSRule_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取SMS规则项名称
     *
     * @memberOf SMSRule#
     * @returns {String} 返回SMS规则项名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._SMSRule_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置SMS规则项几何类型
     * @param {PIESMSGeometryType} geometryType -SMS规则项几何类型
     * @memberOf SMSRule#
     */
    setGeometryType: function setGeometryType(geometryType) {
      Module._SMSRule_SetGeometryType(this.handle, geometryType.getHandle());
    },
    /**
     * 获取SMS规则项几何类型
     *
     * @memberOf SMSRule#
     * @returns {PIESMSGeometryType} 返回SMS规则项几何类型
     */
    getGeometryType: function getGeometryType() {
      return Module._SMSRule_GetGeometryType(this.handle);
    },
    /**
     * 设置SMS规则项是否可见
     * @param {Boolean} visible -SMS规则项是否可见
     * @memberOf SMSRule#
     */
    setVisible: function setVisible(visible) {
      Module._SMSRule_SetVisible(this.handle, visible);
    },
    /**
     * 获取SMS规则项是否可见
     *
     * @memberOf SMSRule#
     * @returns {Boolean} 返回SMS规则项是否可见
     */
    isVisible: function isVisible() {
      return Module._SMSRule_IsVisible(this.handle);
    },
    /**
     * 设置SMS规则项最大可见比例尺
     * @param {Number} maxVisibleScale -SMS规则项最大可见比例尺
     * @memberOf SMSRule#
     */
    setMaxVisibleScale: function setMaxVisibleScale(maxVisibleScale) {
      Module._SMSRule_SetMaxVisibleScale(this.handle, maxVisibleScale);
    },
    /**
     * 获取SMS规则项最大可见比例尺
     *
     * @memberOf SMSRule#
     * @returns {Number} 返回SMS规则项最大可见比例尺
     */
    getMaxVisibleScale: function getMaxVisibleScale() {
      return Module._SMSRule_GetMaxVisibleScale(this.handle);
    },
    /**
     * 设置SMS规则项最小可见比例尺
     * @param {Number} minVisibleScale -SMS规则项最小可见比例尺
     * @memberOf SMSRule#
     */
    setMinVisibleScale: function setMinVisibleScale(minVisibleScale) {
      Module._SMSRule_SetMinVisibleScale(this.handle, minVisibleScale);
    },
    /**
     * 获取SMS规则项最小可见比例尺
     *
     * @memberOf SMSRule#
     * @returns {Number} 返回SMS规则项最小可见比例尺
     */
    getMinVisibleScale: function getMinVisibleScale() {
      return Module._SMSRule_GetMinVisibleScale(this.handle);
    },
    /**
     * 设置SMS规则项点风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格对象内部是否克隆
     * @memberOf SMSRule#
     */
    setPointStyle: function setPointStyle(style, clone) {
      Module._SMSRule_SetPointStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取SMS规则项点风格
     *
     * @memberOf SMSRule#
     * @returns {PIEStyle} 返回SMS规则项对象，失败返回NULL
     */
    getPointStyle: function getPointStyle() {
      var handle = Module._SMSRule_GetPointStyle(this.handle);
      return PIEStyleFactory.CreateInstance(handle);
    },
    /**
     * 设置SMS规则项线风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格对象内部是否克隆
     * @memberOf SMSRule#
     */
    setLineStyle: function setLineStyle(style, clone) {
      Module._SMSRule_SetLineStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取SMS规则项线风格
     *
     * @memberOf SMSRule#
     * @returns {PIEStyle} 返回SMS规则项对象，失败返回NULL
     */
    getLineStyle: function getLineStyle() {
      var handle = Module._SMSRule_GetLineStyle(this.handle);
      return PIEStyleFactory.CreateInstance(handle);
    },
    /**
     * 设置SMS规则项面风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格对象内部是否克隆
     * @memberOf SMSRule#
     */
    setFillStyle: function setFillStyle(style, clone) {
      Module._SMSRule_SetFillStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取SMS规则项面风格
     *
     * @memberOf SMSRule#
     * @returns {PIEStyle} 返回SMS规则项对象，失败返回NULL
     */
    getFillStyle: function getFillStyle() {
      var handle = Module._SMSRule_GetFillStyle(this.handle);
      return PIEStyleFactory.CreateInstance(handle);
    },
    /**
     * 设置SMS规则项文字风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格对象内部是否克隆
     * @memberOf SMSRule#
     */
    setTextStyle: function setTextStyle(style, clone) {
      Module._SMSRule_SetTextStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取SMS规则项文字风格
     *
     * @memberOf SMSRule#
     * @returns {PIEStyle} 返回SMS规则项对象，失败返回NULL
     */
    getTextStyle: function getTextStyle() {
      var handle = Module._SMSRule_GetTextStyle(this.handle);
      return PIEStyleFactory.CreateInstance(handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 设置SMS子图层搭配条件
   * @name SMSSubLayer
   * @class SMSSubLayer
   * SMS子图层操作函数
   */
  function PIESMSSubLayer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._SMSSubLayer_Create();
      autoRelease = true;
    }
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESMSSubLayer.prototype, {
    /**
     * 删除图层
     * @memberOf SMSSubLayer#
     */
    "delete": function _delete() {
      Module._SMSSubLayer_Delete(this.handle);
    },
    /**
     * 设置SMS子图层搭配条件
     * @param {PIESMSMatchCondition} matchCondition -SMS子图层搭配条件
     * @memberOf SMSSubLayer#
     */
    setMatchCondition: function setMatchCondition(matchCondition) {
      Module._SMSSubLayer_SetMatchCondition(this.handle, matchCondition.getHandle());
    },
    /**
     * 获取SMS子图层搭配条件
     *
     * @memberOf SMSSubLayer#
     * @returns {PIESMSMatchCondition} 返回SMS子图层搭配条件
     */
    getMatchCondition: function getMatchCondition() {
      var handle = Module._SMSSubLayer_GetMatchCondition(this.handle);
      if (handle) {
        return new PIESMSMatchCondition(handle);
      }
    },
    /**
     * 设置SMS子图层名称
     * @param {String} name -SMS子图层名称
     * @memberOf SMSSubLayer#
     */
    setName: function setName(name) {
      var strName = new PIEString$1(name);
      Module._SMSSubLayer_SetName(this.handle, strName.getHandle());
      strName.dispose();
    },
    /**
     * 获取SMS子图层名称
     *
     * @memberOf SMSSubLayer#
     * @returns {String} 返回SMS子图层名称
     */
    getName: function getName() {
      var strName = new PIEString$1(256);
      Module._SMSSubLayer_GetName(this.handle, strName.getHandle());
      var name = strName.toString();
      strName.dispose();
      return name;
    },
    /**
     * 设置SMS子图层是否可见
     * @param {Boolean} visible -SMS子图层是否可见
     * @memberOf SMSSubLayer#
     */
    setVisible: function setVisible(visible) {
      Module._SMSSubLayer_SetVisible(this.handle, visible);
    },
    /**
     * 获取SMS子图层是否可见
     *
     * @memberOf SMSSubLayer#
     * @returns {Boolean} 返回SMS子图层是否可见
     */
    isVisible: function isVisible() {
      return Module._SMSSubLayer_IsVisible(this.handle);
    },
    /**
     * 设置SMS子图层符号最大可见比例尺
     * @param {Number} maxVisibleScale -SMS子图层符号最大可见比例尺
     * @memberOf SMSSubLayer#
     */
    setSymbolMaxVisibleScale: function setSymbolMaxVisibleScale(maxVisibleScale) {
      Module._SMSSubLayer_SetSymbolMaxVisibleScale(this.handle, maxVisibleScale);
    },
    /**
     * 获取SMS子图层符号最大可见比例尺
     *
     * @memberOf SMSSubLayer#
     * @returns {Number} 返回SMS子图层符号最大可见比例尺
     */
    getSymbolMaxVisibleScale: function getSymbolMaxVisibleScale() {
      return Module._SMSSubLayer_GetSymbolMaxVisibleScale(this.handle);
    },
    /**
     * 设置SMS子图层符号最小可见比例尺
     * @param {Number} minVisibleScale -SMS子图层符号最小可见比例尺
     * @memberOf SMSSubLayer#
     */
    setSymbolMinVisibleScale: function setSymbolMinVisibleScale(minVisibleScale) {
      Module._SMSSubLayer_SetSymbolMinVisibleScale(this.handle, minVisibleScale);
    },
    /**
     * 获取SMS子图层符号最小可见比例尺
     *
     * @memberOf SMSSubLayer#
     * @return {Number} 返回SMS子图层符号最小可见比例尺
     */
    getSymbolMinVisibleScale: function getSymbolMinVisibleScale() {
      return Module._SMSSubLayer_GetSymbolMinVisibleScale(this.handle);
    },
    /**
     * 设置SMS子图层注记最大可见比例尺
     * @param {Number} maxVisibleScale -SMS子图层注记最大可见比例尺
     * @memberOf SMSSubLayer#
     */
    setAnnoMaxVisibleScale: function setAnnoMaxVisibleScale(maxVisibleScale) {
      Module._SMSSubLayer_SetAnnoMaxVisibleScale(this.handle, maxVisibleScale);
    },
    /**
     * 获取SMS子图层注记最大可见比例尺
     *
     * @memberOf SMSSubLayer#
     * @return {Number} 返回SMS子图层注记最大可见比例尺
     */
    getAnnoMaxVisibleScale: function getAnnoMaxVisibleScale() {
      return Module._SMSSubLayer_GetAnnoMaxVisibleScale(this.handle);
    },
    /**
     * 设置SMS子图层符号最小可见比例尺
     * @param {Number} minVisibleScale -SMS子图层符号最小可见比例尺
     * @memberOf SMSSubLayer#
     */
    setAnnoMinVisibleScale: function setAnnoMinVisibleScale(minVisibleScale) {
      Module._SMSSubLayer_SetAnnoMinVisibleScale(this.handle, minVisibleScale);
    },
    /**
     * 获取SMS子图层符号最小可见比例尺
     *
     * @memberOf SMSSubLayer#
     * @return {Number} 返回SMS子图层符号最小可见比例尺
     */
    getAnnoMinVisibleScale: function getAnnoMinVisibleScale() {
      return Module._SMSSubLayer_GetAnnoMinVisibleScale(this.handle);
    },
    /**
     * 设置SMS子图层注记字段
     * @param {String} fieldName -SMS子图层注记字段
     * @memberOf SMSSubLayer#
     */
    setAnnoFieldName: function setAnnoFieldName(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      Module._SMSSubLayer_SetAnnoFieldName(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
    },
    /**
     * 获取SMS子图层注记字段
     *
     * @memberOf SMSSubLayer#
     * @return {String} 返回SMS子图层注记字段
     */
    getAnnoFieldName: function getAnnoFieldName() {
      var strFieldName = new PIEString$1(256);
      Module._SMSSubLayer_GetAnnoFieldName(this.handle, strFieldName.getHandle());
      var fieldName = strFieldName.toString();
      strFieldName.dispose();
      return fieldName;
    },
    /**
     * 设置SMS子图层注记风格
     * @param {PIEStyle} style -风格对象
     * @param {Boolean} clone -风格对象内部是否克隆
     * @memberOf SMSSubLayer#
     */
    setAnnoTextStyle: function setAnnoTextStyle(style, clone) {
      Module._SMSSubLayer_SetAnnoTextStyle(this.handle, style.getHandle(), clone);
    },
    /**
     * 获取SMS子图层注记风格
     *
     * @memberOf SMSSubLayer#
     * @return {PIEStyle} 返回SMS子图层对象，失败返回NULL:
     */
    getAnnoTextStyle: function getAnnoTextStyle() {
      return Module._SMSSubLayer_GetAnnoTextStyle(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * SMS子图层管理类操作函数
   * @name SMSSubLayerManager
   */
  function PIESMSSubLayerManager(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESMSSubLayerManager.prototype, {
    /**
     * 通过字段值查找子图层
     * @param {Number} value -字段值
     *
     * @memberOf SMSSubLayerManager#
     * @return {PIESMSSubLayer} 返回指定字段值的子图层
     */
    findSubLayer: function findSubLayer(value) {
      var handle = Module._SMSSubLayerManager_FindSubLayer(this.handle, value);
      if (handle) {
        return new PIESMSSubLayer(handle);
      }
    },
    /**
     * 获取子图层数组个数
     *
     * @memberOf SMSSubLayerManager#
     * @return {Number} 返回子图层数组个数
     */
    getSubLayerCount: function getSubLayerCount() {
      return Module._SMSSubLayerManager_GetSubLayerCount(this.handle);
    },
    /**
     * 获取指定索引子图层
     * @param {Number} index -子图层数组索引
     *
     * @memberOf SMSSubLayerManager#
     * @return {PIESMSSubLayer} 返回指定索引的子图层
     */
    getSubLayerAt: function getSubLayerAt(index) {
      var handle = Module._SMSSubLayerManager_GetSubLayerAt(this.handle, index);
      if (handle) {
        return new PIESMSSubLayer(handle);
      }
    },
    /**
     * 设置指定索引子图层
     * @param {Number} index -子图层数组索引
     * @param {PIESMSSubLayer} subLayer -子图层
     * @memberOf SMSSubLayerManager#
     */
    setSubLayerAt: function setSubLayerAt(index, subLayer) {
      Module._SMSSubLayerManager_SetSubLayerAt(this.handle, index, subLayer.getHandle());
    },
    /**
     * 添加子图层
     * @param {PIESMSSubLayer} subLayer -子图层
     * @memberOf SMSSubLayerManager#
     */
    addSubLayer: function addSubLayer(subLayer) {
      Module._SMSSubLayerManager_AddSubLayer(this.handle, subLayer.getHandle());
    },
    /**
     * 移除子图层
     * @param {PIESMSSubLayer} subLayer -子图层
     * @memberOf SMSSubLayerManager#
     */
    removeSubLayer: function removeSubLayer(subLayer) {
      Module._SMSSubLayerManager_RemoveSubLayer(this.handle, subLayer.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * SMS规则管理类操作函数
   * @name SMSRuleManager
   */
  function PIESMSRuleManager(handle, autoRelease) {
    this.handle = handle;
    this.autoRelease = autoRelease;
  }
  Object.assign(PIESMSRuleManager.prototype, {
    /**
     * 设置SMS规则管理类字段
     * @param {String} fieldName -SMS规则管理类字段
     * @memberOf SMSRuleManager#
     */
    setFieldName: function setFieldName(fieldName) {
      var strFieldName = new PIEString$1(fieldName);
      Module._SMSRuleManager_SetFieldName(this.handle, strFieldName.getHandle());
      strFieldName.dispose();
    },
    /**
     * 获取SMS规则管理类字段
     *
     * @memberOf SMSRuleManager#
     * @returns {String} 返回SMS规则管理类字段
     */
    getFieldName: function getFieldName() {
      var strFieldName = new PIEString$1(256);
      Module._SMSRuleManager_GetFieldName(this.handle);
      var fieldName = strFieldName.toString();
      strFieldName.dispose();
      return fieldName;
    },
    /**
     * 通过字段值查找项
     * @param {Number} value -字段值
     * @param {PIESMSGeometryType} geometryType -几何对象类型
     *
     * @memberOf SMSRuleManager#
     * @returns {PIESMSRule} 返回指定字段值的规则项
     */
    findRule: function findRule(value, geometryType) {
      var handle = Module._SMSRuleManager_FindRule(this.handle, value, geometryType.getHandle());
      if (handle) {
        return new PIESMSRule(handle);
      }
    },
    /**
     * 获取规则项数组个数
     *
     * @memberOf SMSRuleManager#
     * @returns {Number} 返回规则项数组个数
     */
    getRuleCount: function getRuleCount() {
      return Module._SMSRuleManager_GetRuleCount(this.handle);
    },
    /**
     * 获取指定索引规则项
     * @param {Number} index -规则项数组索引
     *
     * @memberOf SMSRuleManager#
     * @returns {PIESMSRule} 返回指定索引的规则项
     */
    getRuleAt: function getRuleAt(index) {
      var handle = Module._SMSRuleManager_GetRuleAt(this.handle, index);
      if (handle) {
        return new PIESMSRule(handle);
      }
    },
    /**
     * 设置指定索引规则项
     * @param {Number} index -规则项数组索引
     * @param {PIESMSRule} rule -规则项
     * @memberOf SMSRuleManager#
     */
    setRuleAt: function setRuleAt(index, rule) {
      Module._SMSRuleManager_SetRuleAt(this.handle, index, rule.getHandle());
    },
    /**
     * 添加规则项
     * @param {PIESMSRule} rule -规则项
     * @memberOf SMSRuleManager#
     */
    addRule: function addRule(rule) {
      Module._SMSRuleManager_AddRule(this.handle, rule.getHandle());
    },
    /**
     * 移除规则项
     * @param {PIESMSRule} rule -规则项
     * @memberOf SMSRuleManager#
     */
    removeRule: function removeRule(rule) {
      Module._SMSRuleManager_RemoveRule(this.handle, rule.getHandle());
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 创建渲染器对象
   * @name SMSFeatureRenderer
   * @class SMSFeatureRenderer
   * SMS专题图渲染器操作函数
   * @extends FeatureRenderer
   */
  function PIESMSFeatureRenderer(handle, autoRelease) {
    if (handle == null) {
      handle = Module._SMSFeatureRenderer_Create();
      autoRelease = true;
    }
    PIEFeatureRenderer.call(this, handle, autoRelease);
  }
  PIESMSFeatureRenderer.prototype = Object.assign(Object.create(PIEFeatureRenderer.prototype), {
    /**
     * 制作SMS专题图
     * @param {PIEDataset} dataset -数据集对象
     * @param {Number} mapScale -数据比例尺,默认-1
     *
     * @memberOf SMSFeatureRenderer#
     * @return {Boolean} 成功返回true，否则返回false
     */
    makeDefault: function makeDefault(dataset, mapScale) {
      return Boolean(Module._SMSFeatureRenderer_MakeDefault(this.handle, dataset.getHandle(), mapScale));
    },
    /**
     * 获取子图层管理器
     *
     * @memberOf SMSFeatureRenderer#
     * @return {PIESMSSubLayerManager} 返回子图层管理器
     */
    getSubLayerManager: function getSubLayerManager() {
      var handle = Module._SMSFeatureRenderer_GetSubLayerManager(this.handle);
      if (handle) {
        return new PIESMSSubLayerManager(handle);
      }
    },
    // getSymbolRuleManager: function (){
    //     var handle = Module._SMSFeatureRenderer_GetSymbolRuleManager(this.handle);
    //     if(handle){
    //         return new PIESMSSymbolRuleManager(handle);
    //     }
    // },

    /**
     * 获取符号的最大可见比例尺
     * @memberOf SMSFeatureRenderer#
     * @return {Number} 最大可见比例尺
     */
    getMaxVisibleScale: function getMaxVisibleScale() {
      return Module._SMSFeatureRenderer_GetMaxVisibleScale(this.handle);
    },
    /**
     * 获取符号的最小可见比例尺
     * @memberOf SMSFeatureRenderer#
     * @return {Number} 最小可见比例尺
     */
    getMinVisibleScale: function getMinVisibleScale() {
      return Module._SMSFeatureRenderer_GetMinVisibleScale(this.handle);
    }
  });

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 
   * @class Math
   * Math函数
   */
  var CesiumMath = {};

  /*
   * 地球半径
   *
   * @memberOf Math
   */
  CesiumMath.EARTH_RADIUS = 6378137;

  /*
   * 0.1
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON1 = 0.1;

  /*
   * 0.01
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON2 = 0.01;

  /*
   * 0.001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON3 = 0.001;

  /*
   * 0.0001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON4 = 0.0001;

  /*
   * 0.00001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON5 = 0.00001;

  /*
   * 0.000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON6 = 0.000001;

  /*
   * 0.0000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON7 = 0.0000001;

  /*
   * 0.00000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON8 = 0.00000001;

  /*
   * 0.000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON9 = 0.000000001;

  /*
   * 0.0000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON10 = 0.0000000001;

  /*
   * 0.00000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON11 = 0.00000000001;

  /*
   * 0.000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON12 = 0.000000000001;

  /*
   * 0.0000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON13 = 0.0000000000001;

  /*
   * 0.00000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON14 = 0.00000000000001;

  /*
   * 0.000000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON15 = 0.000000000000001;

  /*
   * 0.0000000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON16 = 0.0000000000000001;

  /*
   * 0.00000000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON17 = 0.00000000000000001;

  /*
   * 0.000000000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON18 = 0.000000000000000001;

  /*
   * 0.0000000000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON19 = 0.0000000000000000001;

  /*
   * 0.00000000000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON20 = 0.00000000000000000001;

  /*
   * 0.000000000000000000001
   * @type {Number}
   * @constant
   */
  CesiumMath.EPSILON21 = 0.000000000000000000001;

  /*
   * The gravitational parameter of the Earth in meters cubed
   * per second squared as defined by the WGS84 model: 3.986004418e14
   * @type {Number}
   * @constant
   */
  CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;

  /*
   * Radius of the sun in meters: 6.955e8
   * @type {Number}
   * @constant
   */
  CesiumMath.SOLAR_RADIUS = 6.955e8;

  /*
   * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
   * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
   * Celestial Mechanics 82: 83-110, 2002.
   * @type {Number}
   * @constant
   */
  CesiumMath.LUNAR_RADIUS = 1737400.0;

  /*
   * 64 * 1024
   * @type {Number}
   * @constant
   */
  CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;

  /*
   * 4 * 1024 * 1024 * 1024
   * @type {Number}
   * @constant
   */
  CesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;

  /**
   * 弧度转角度
   *
   * @memberOf Math
   */
  CesiumMath.RTOD = 57.295779513082320876798154814;
  /**
   * 角度转弧度
   *
   * @memberOf Math
   */
  CesiumMath.DTOR = 0.0174532925199432957692369077;

  /**
   * 返回一个数的符号；如果这个数是正数，返回 1；如果这个数是负数，返回 -1；如果这个数是 0，返回 0。
   * @function
   * @param {Number} value 要返回符号的数值。
   * @returns {Number} 数值的符号。
   */
  // eslint-disable-next-line es/no-math-sign
  CesiumMath.sign = defaultValue$1(Math.sign, function sign(value) {
    value = +value; // coerce to number
    if (value === 0 || value !== value) {
      // zero or NaN
      return value;
    }
    return value > 0 ? 1 : -1;
  });

  /**
   * 如果给定的数值是正数或零，则返回 1.0；如果是负数，则返回 -1.0。这与 {@link CesiumMath.sign} 类似，但是当输入值为 0.0 时，返回的是 1.0 而不是 0.0。
   * @param {Number} value 要返回符号的数值。
   * @returns {Number} 数值的符号。
   */
  CesiumMath.signNotZero = function (value) {
    return value < 0.0 ? -1.0 : 1.0;
  };

  /**
   * 将范围在 [-1.0, 1.0] 的标量值转换为范围在 [0, rangeMaximum] 的 SNORM 值。
   * @param {Number} value 范围在 [-1.0, 1.0] 的标量值。
   * @param {Number} rangeMaximum=255 <code>optional</code> 映射范围中的最大值，默认为 255。
   * @returns {Number} 一个 SNORM 值，其中 0 映射到 -1.0，rangeMaximum 映射到 1.0。
   *
   * @see CesiumMath.fromSNorm
   */
  CesiumMath.toSNorm = function (value, rangeMaximum) {
    rangeMaximum = defaultValue$1(rangeMaximum, 255);
    return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);
  };

  /**
   * 将范围在 [0, rangeMaximum] 的 SNORM 值转换为范围在 [-1.0, 1.0] 的标量。
   * @param {Number} value 范围在 [0, rangeMaximum] 的 SNORM 值。
   * @param {Number} rangeMaximum=255 <code>optional</code> SNORM 范围中的最大值，默认为 255。
   * @returns {Number} 范围在 [-1.0, 1.0] 的标量。
   *
   * @see CesiumMath.toSNorm
   */
  CesiumMath.fromSNorm = function (value, rangeMaximum) {
    rangeMaximum = defaultValue$1(rangeMaximum, 255);
    return CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum * 2.0 - 1.0;
  };

  /**
   * 将范围在 [rangeMinimum, rangeMaximum] 的标量值转换为范围在 [0.0, 1.0] 的标量。
   * @param {Number} value 范围在 [rangeMinimum, rangeMaximum] 的标量值。
   * @param {Number} rangeMinimum 映射范围中的最小值。
   * @param {Number} rangeMaximum 映射范围中的最大值。
   * @returns {Number} 一个标量值，其中 rangeMinimum 映射到 0.0，rangeMaximum 映射到 1.0。
   */
  CesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {
    rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);
    return rangeMaximum === 0.0 ? 0.0 : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);
  };

  /**
   * 返回一个数的双曲正弦值。
   * 
   * @function
   * @param {Number} value 欲返回其双曲正弦值的数字。
   * @returns {Number} value的双曲正弦值。
   */
  // eslint-disable-next-line es/no-math-sinh
  CesiumMath.sinh = defaultValue$1(Math.sinh, function sinh(value) {
    return (Math.exp(value) - Math.exp(-value)) / 2.0;
  });

  /**
   * 返回一个数的双曲余弦值。
   *
   * @function
   * @param {Number} value 要计算双曲余弦值的数值。
   * @returns {Number} value的双曲余弦值。
   */
  // eslint-disable-next-line es/no-math-cosh
  CesiumMath.cosh = defaultValue$1(Math.cosh, function cosh(value) {
    return (Math.exp(value) + Math.exp(-value)) / 2.0;
  });

  /**
   * 计算两个值的线性插值。
   * @param {Number} p 开始插值的值。
   * @param {Number} q 结束插值的值。
   * @param {Number} time 插值时间，通常在 [0.0, 1.0] 范围内。
   * @returns {Number} 线性插值的值。
   *
   * @example
   * const n = Earth.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
   */
  CesiumMath.lerp = function (p, q, time) {
    return (1.0 - time) * p + time * q;
  };

  /*
   * pi
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.PI = Math.PI;

  /*
   * 1/pi
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;

  /*
   * pi/2
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.PI_OVER_TWO = Math.PI / 2.0;

  /*
   * pi/3
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.PI_OVER_THREE = Math.PI / 3.0;

  /*
   * pi/4
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;

  /*
   * pi/6
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.PI_OVER_SIX = Math.PI / 6.0;

  /*
   * 3pi/2
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.THREE_PI_OVER_TWO = 3.0 * Math.PI / 2.0;

  /*
   * 2pi
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.TWO_PI = 2.0 * Math.PI;

  /*
   * 1/2pi
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);

  /*
   * The number of radians in a degree.
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;

  /*
   * The number of degrees in a radian.
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;

  /*
   * The number of radians in an arc second.
   *
   * @type {Number}
   * @constant
   */
  CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;

  /**
   * 将角度值转换为弧度值。
   * @param {Number} degrees 要转换的角度值。
   * @returns {Number} 相应的弧度值。
   */
  CesiumMath.toRadians = function (degrees) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(degrees)) {
      throw new DeveloperError$1("degrees is required.");
    }
    //>>includeEnd('debug');
    return degrees * CesiumMath.RADIANS_PER_DEGREE;
  };

  /**
   * 将弧度转换为角度。
   * @param {Number} radians 要转换的弧度。
   * @returns {Number} 对应的角度值。
   */
  CesiumMath.toDegrees = function (radians) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(radians)) {
      throw new DeveloperError$1("radians is required.");
    }
    //>>includeEnd('debug');
    return radians * CesiumMath.DEGREES_PER_RADIAN;
  };

  /**
   * 将以弧度为单位的经度值转换为范围为[-Math.PI, Math.PI)的值。
   * @param {Number} angle 要转换为范围[-Math.PI, Math.PI)的经度值（以弧度为单位）。
   * @returns {Number} 在范围[-Math.PI, Math.PI)内相应的经度值。
   *
   * @example
   * // Convert 270 degrees to -90 degrees longitude
   * const longitude = Earth.Math.convertLongitudeRange(Earth.Math.toRadians(270.0));
   */
  CesiumMath.convertLongitudeRange = function (angle) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(angle)) {
      throw new DeveloperError$1("angle is required.");
    }
    //>>includeEnd('debug');
    var twoPi = CesiumMath.TWO_PI;
    var simplified = angle - Math.floor(angle / twoPi) * twoPi;
    if (simplified < -Math.PI) {
      return simplified + twoPi;
    }
    if (simplified >= Math.PI) {
      return simplified - twoPi;
    }
    return simplified;
  };

  /**
   * 将一个以弧度为单位的纬度值夹紧在区间 [-Math.PI/2, Math.PI/2) 内，有助于在使用需要正确范围的对象之前对数据进行清理。
   *
   * @param {Number} angle 给定的纬度值，以弧度表示，需要被限制在范围[-Math.PI/2, Math.PI/2)内。
   * @returns {Number} 被限制在范围[-Math.PI/2, Math.PI/2)内的纬度值。
   *
   * @example
   * // Clamp 108 degrees latitude to 90 degrees latitude
   * const latitude = Earth.Math.clampToLatitudeRange(Earth.Math.toRadians(108.0));
   */
  CesiumMath.clampToLatitudeRange = function (angle) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(angle)) {
      throw new DeveloperError$1("angle is required.");
    }
    //>>includeEnd('debug');

    return CesiumMath.clamp(angle, -1 * CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);
  };

  /**
   * 将给定的角度转换为等效于 -Pi <= angle <= Pi 范围内的角度。
   * @param {Number} angle 给定的角度，以弧度表示。
   * @returns {Number} 转换后的角度，范围在[-CesiumMath.PI, CesiumMath.PI]之间。
   */
  CesiumMath.negativePiToPi = function (angle) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(angle)) {
      throw new DeveloperError$1("angle is required.");
    }
    //>>includeEnd('debug');
    if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {
      // Early exit if the input is already inside the range. This avoids
      // unnecessary math which could introduce floating point error.
      return angle;
    }
    return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;
  };

  /**
   * 将给定的角度转换为等效于 0 <= angle <= 2Pi 范围内的角度。
   * @param {Number} angle 给定的角度，以弧度表示。
   * @returns {Number} 转换后的角度，范围在[0, CesiumMath.TWO_PI]之间。
   */
  CesiumMath.zeroToTwoPi = function (angle) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(angle)) {
      throw new DeveloperError$1("angle is required.");
    }
    //>>includeEnd('debug');
    if (angle >= 0 && angle <= CesiumMath.TWO_PI) {
      // Early exit if the input is already inside the range. This avoids
      // unnecessary math which could introduce floating point error.
      return angle;
    }
    var mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);
    if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(angle) > CesiumMath.EPSILON14) {
      return CesiumMath.TWO_PI;
    }
    return mod;
  };

  /**
   * 对负数也适用的取模运算。
   * @param {Number} m 被除数。
   * @param {Number} n 除数。
   * @returns {Number} 余数。
   */
  CesiumMath.mod = function (m, n) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(m)) {
      throw new DeveloperError$1("m is required.");
    }
    if (!defined$1(n)) {
      throw new DeveloperError$1("n is required.");
    }
    if (n === 0.0) {
      throw new DeveloperError$1("divisor cannot be 0.");
    }
    //>>includeEnd('debug');
    if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {
      // Early exit if the input does not need to be modded. This avoids
      // unnecessary math which could introduce floating point error.
      return m;
    }
    return (m % n + n) % n;
  };

  /**
   * 使用绝对或相对容差测试确定两个值是否相等。当直接比较浮点数值时，由于舍入误差，使用此方法可以避免问题。首先使用绝对容差测试比较这两个值。如果失败，则执行相对容差测试。如果不确定左右两个值的大小，请使用此测试。
   * @param {Number} left 要比较的第一个值。
   * @param {Number} right 要比较的另一个值。
   * @param {Number} relativeEpsilon=0 <code>optional</code> 相对容差测试中左右两个值之间的最大可包含增量。
   * @param {Number} absoluteEpsilon=relativeEpsilon <code>optional</code> 绝对容差测试中左右两个值之间的最大可包含增量。
   * @returns {Boolean} 如果两个值在容差范围内相等，则返回 true；否则返回 false。
   *
   * @example
   * const a = Earth.Math.equalsEpsilon(0.0, 0.01, Earth.Math.EPSILON2); // true
   * const b = Earth.Math.equalsEpsilon(0.0, 0.1, Earth.Math.EPSILON2);  // false
   * const c = Earth.Math.equalsEpsilon(3699175.1634344, 3699175.2, Earth.Math.EPSILON7); // true
   * const d = Earth.Math.equalsEpsilon(3699175.1634344, 3699175.2, Earth.Math.EPSILON9); // false
   */
  CesiumMath.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(left)) {
      throw new DeveloperError$1("left is required.");
    }
    if (!defined$1(right)) {
      throw new DeveloperError$1("right is required.");
    }
    //>>includeEnd('debug');

    relativeEpsilon = defaultValue$1(relativeEpsilon, 0.0);
    absoluteEpsilon = defaultValue$1(absoluteEpsilon, relativeEpsilon);
    var absDiff = Math.abs(left - right);
    return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));
  };

  /**
   * 判断左边的值是否小于右边的值。如果两个值之间的差小于 absoluteEpsilon，则认为它们相等，此函数返回 false。
   * @param {Number} left 要比较的第一个数字。
   * @param {Number} right 要比较的第二个数字。
   * @param {Number} absoluteEpsilon 用于比较的绝对误差。
   * @returns {Boolean} 如果 left 比 right 小超过 absoluteEpsilon，则返回 true；
   */
  CesiumMath.lessThan = function (left, right, absoluteEpsilon) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(left)) {
      throw new DeveloperError$1("first is required.");
    }
    if (!defined$1(right)) {
      throw new DeveloperError$1("second is required.");
    }
    if (!defined$1(absoluteEpsilon)) {
      throw new DeveloperError$1("absoluteEpsilon is required.");
    }
    //>>includeEnd('debug');
    return left - right < -absoluteEpsilon;
  };

  /**
   * 判断左侧值是否小于等于右侧值。如果两个值相差不超过absoluteEpsilon，则认为它们相等，此函数将返回true。
   * @param {Number} left 要比较的第一个数字。
   * @param {Number} right 要比较的第二个数字。
   * @param {Number} absoluteEpsilon 在比较中使用的绝对误差。
   * @returns {Boolean} 如果left小于right或者这两个值几乎相等，则返回true。
   */
  CesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(left)) {
      throw new DeveloperError$1("first is required.");
    }
    if (!defined$1(right)) {
      throw new DeveloperError$1("second is required.");
    }
    if (!defined$1(absoluteEpsilon)) {
      throw new DeveloperError$1("absoluteEpsilon is required.");
    }
    //>>includeEnd('debug');
    return left - right < absoluteEpsilon;
  };

  /**
   * 判断左值是否大于右值。如果两个值在 absoluteEpsilon 范围内，则认为它们相等，此函数返回 false。
  @param {Number} left 要比较的第一个数。
  @param {Number} right 要比较的第二个数。
  @param {Number} absoluteEpsilon 用于比较的绝对误差。
  @returns {Boolean} 如果 left> 大于 right 超过 absoluteEpsilon，则返回 true。
   */
  CesiumMath.greaterThan = function (left, right, absoluteEpsilon) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(left)) {
      throw new DeveloperError$1("first is required.");
    }
    if (!defined$1(right)) {
      throw new DeveloperError$1("second is required.");
    }
    if (!defined$1(absoluteEpsilon)) {
      throw new DeveloperError$1("absoluteEpsilon is required.");
    }
    //>>includeEnd('debug');
    return left - right > absoluteEpsilon;
  };

  /**
   * 判断左值是否大于或等于右值。如果两个值在 absoluteEpsilon 范围内，则认为它们相等，此函数返回 true。
   * @param {Number} left 要比较的第一个数。
   * @param {Number} right 要比较的第二个数。
   * @param {Number} absoluteEpsilon 用于比较的绝对误差。
   * @returns {Boolean} 如果 left大于 right 或两个值几乎相等，则返回 true。
   */
  CesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(left)) {
      throw new DeveloperError$1("first is required.");
    }
    if (!defined$1(right)) {
      throw new DeveloperError$1("second is required.");
    }
    if (!defined$1(absoluteEpsilon)) {
      throw new DeveloperError$1("absoluteEpsilon is required.");
    }
    //>>includeEnd('debug');
    return left - right > -absoluteEpsilon;
  };
  var factorials = [1];

  /**
   * 计算给定数字的阶乘。
   * @param {Number} n 要计算阶乘的数字。
   * @returns {Number} 给定数字的阶乘，如果数字小于0，则返回 undefined。
   * @exception {DeveloperError} 必须提供大于或等于0的数字。
   *
   *
   * @example
   * //Compute 7!, which is equal to 5040
   * const computedFactorial = Earth.Math.factorial(7);
   */
  CesiumMath.factorial = function (n) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof n !== "number" || n < 0) {
      throw new DeveloperError$1("A number greater than or equal to 0 is required.");
    }
    //>>includeEnd('debug');

    var length = factorials.length;
    if (n >= length) {
      var sum = factorials[length - 1];
      for (var i = length; i <= n; i++) {
        var next = sum * i;
        factorials.push(next);
        sum = next;
      }
    }
    return factorials[n];
  };

  /**
   * 对一个数字进行递增，如果数字超过最大值则将其回绕到最小值。
   * @param {Number} n <code>optional</code> 要递增的数字。
   * @param {Number} maximumValue <code>optional</code> 在回绕到最小值之前递增的最大值。
   * @param {Number} minimumValue=0.0 <code>optional</code> 超过最大值后重置为的数字。
   * @returns {Number} 递增后的数字。
   * @exception {DeveloperError} 最大值必须大于最小值。
   *
   * @example
   * const n = Earth.Math.incrementWrap(5, 10, 0); // returns 6
   * const m = Earth.Math.incrementWrap(10, 10, 0); // returns 0
   */
  CesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {
    minimumValue = defaultValue$1(minimumValue, 0.0);

    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(n)) {
      throw new DeveloperError$1("n is required.");
    }
    if (maximumValue <= minimumValue) {
      throw new DeveloperError$1("maximumValue must be greater than minimumValue.");
    }
    //>>includeEnd('debug');

    ++n;
    if (n > maximumValue) {
      n = minimumValue;
    }
    return n;
  };

  /**
   * 确定非负整数是否是2的幂。最大允许的输入是(2^32)-1，由于 Javascript 中32位位运算符的限制。
   * @param {Number} n 在范围 [0, (2^32)-1] 中测试的整数。
   * @returns {Boolean} 如果数字是2的幂，则返回true；否则返回false。
   * @exception {DeveloperError} 必须提供介于0和(2^32)-1之间的数字。
   *
   * @example
   * const t = Earth.Math.isPowerOfTwo(16); // true
   * const f = Earth.Math.isPowerOfTwo(20); // false
   */
  CesiumMath.isPowerOfTwo = function (n) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof n !== "number" || n < 0 || n > 4294967295) {
      throw new DeveloperError$1("A number between 0 and (2^32)-1 is required.");
    }
    //>>includeEnd('debug');

    return n !== 0 && (n & n - 1) === 0;
  };

  /**
   * 计算大于或等于提供的非负整数的下一个2的幂。最大允许的输入是2^31，由于 Javascript 中32位位运算符的限制。
   * @param {Number} n 在范围 [0, 2^31] 中测试的整数。
   * @returns {Number} 下一个2的幂的整数。
   * @exception {DeveloperError} 必须提供介于0和2^31之间的数字。
   *
   * @example
   * const n = Earth.Math.nextPowerOfTwo(29); // 32
   * const m = Earth.Math.nextPowerOfTwo(32); // 32
   */
  CesiumMath.nextPowerOfTwo = function (n) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof n !== "number" || n < 0 || n > 2147483648) {
      throw new DeveloperError$1("A number between 0 and 2^31 is required.");
    }
    //>>includeEnd('debug');

    // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
    --n;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    ++n;
    return n;
  };

  /**
   * 计算小于或等于提供的非负整数的上一个2的幂。最大允许的输入是2^32-1，由于 Javascript 中32位位运算符的限制。
   * @param {Number} n 在范围 [0, 2^32-1] 中测试的整数。
   * @returns {Number} 上一个2的幂的整数。
   * @exception {DeveloperError} 必须提供介于0和2^32-1之间的数字。
   *
   * @example
   * const n = Earth.Math.previousPowerOfTwo(29); // 16
   * const m = Earth.Math.previousPowerOfTwo(32); // 32
   */
  CesiumMath.previousPowerOfTwo = function (n) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof n !== "number" || n < 0 || n > 4294967295) {
      throw new DeveloperError$1("A number between 0 and (2^32)-1 is required.");
    }
    //>>includeEnd('debug');

    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n |= n >> 32;

    // The previous bitwise operations implicitly convert to signed 32-bit. Use `>>>` to convert to unsigned
    n = (n >>> 0) - (n >>> 1);
    return n;
  };

  /**
   * 将一个值限制在两个值之间。
   * @param {Number} value 要限制的值。
   * @param {Number} min 最小值。
   * @param {Number} max 最大值。
   * @returns {Number} 限制后的值，满足min <= result <= max。
   */
  CesiumMath.clamp = function (value, min, max) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("value", value);
    Check.typeOf.number("min", min);
    Check.typeOf.number("max", max);
    //>>includeEnd('debug');

    return value < min ? min : value > max ? max : value;
  };
  var randomNumberGenerator = new mersenneTwister();

  /**
   * 设置 {@link CesiumMath.nextRandomNumber} 随机数生成器使用的种子。
   * @param {Number} seed 用作种子的整数。
   */
  CesiumMath.setRandomNumberSeed = function (seed) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(seed)) {
      throw new DeveloperError$1("seed is required.");
    }
    //>>includeEnd('debug');

    randomNumberGenerator = new mersenneTwister(seed);
  };

  /**
   * 使用Mersenne twister生成一个位于区间[0.0, 1.0)的随机浮点数。
   * @returns {Number} 位于区间[0.0, 1.0)的随机数
   *
   * @see CesiumMath.setRandomNumberSeed
   */
  CesiumMath.nextRandomNumber = function () {
    return randomNumberGenerator.random();
  };

  /**
   * 生成两个数之间的随机数。
   * @param {Number} min 最小值。
   * @param {Number} max 最大值。
   * @returns {Number} 介于最小值和最大值之间的随机数
   */
  CesiumMath.randomBetween = function (min, max) {
    return CesiumMath.nextRandomNumber() * (max - min) + min;
  };

  /**
   * 计算 Math.acos(value)，但先将 value 夹在 [-1.0, 1.0] 范围内，以确保该函数永远不会返回 NaN。
   * @param {Number} value 要计算 acos 的值。
   * @returns {Number} 如果 value 在 [-1.0, 1.0] 范围内，则返回 value 的 acos 值；如果 value 超出该范围，则返回 -1.0 或 1.0 的 acos 值，取决于哪个更接近。
   */
  CesiumMath.acosClamped = function (value) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(value)) {
      throw new DeveloperError$1("value is required.");
    }
    //>>includeEnd('debug');
    return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));
  };

  /**
   * 计算 Math.asin(value)，但先将 value夹在 [-1.0, 1.0] 范围内，以确保该函数永远不会返回 NaN。
   * @param {Number} value 要计算 asin 的值。
   * @returns {Number} 如果 value 在 [-1.0, 1.0] 范围内，则返回 value 的 asin 值；如果 value 超出该范围，则返回 -1.0 或 1.0 的 asin 值，取决于哪个更接近。
   */
  CesiumMath.asinClamped = function (value) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(value)) {
      throw new DeveloperError$1("value is required.");
    }
    //>>includeEnd('debug');
    return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));
  };

  /**
   * 找到两点之间弦长，给定圆的半径和两点之间的角度。
   * @param {Number} angle 两点之间的角度。
   * @param {Number} radius 圆的半径。
   * @returns {Number} 弦长
   */
  CesiumMath.chordLength = function (angle, radius) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(angle)) {
      throw new DeveloperError$1("angle is required.");
    }
    if (!defined$1(radius)) {
      throw new DeveloperError$1("radius is required.");
    }
    //>>includeEnd('debug');
    return 2.0 * radius * Math.sin(angle * 0.5);
  };

  /**
   * 找到一个数的对数，给定底数。
   * @param {Number} number 数字。
   * @param {Number} base 底数。
   * @returns {Number} 结果。
   */
  CesiumMath.logBase = function (number, base) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(number)) {
      throw new DeveloperError$1("number is required.");
    }
    if (!defined$1(base)) {
      throw new DeveloperError$1("base is required.");
    }
    //>>includeEnd('debug');
    return Math.log(number) / Math.log(base);
  };

  /**
   * 找到一个数的立方根。如果没有提供 number，则返回 NaN。
   * @function
   * @param {Number} number <code>optional</code> 数字。
   * @returns {Number} 结果。
   */
  // eslint-disable-next-line es/no-math-cbrt
  CesiumMath.cbrt = defaultValue$1(Math.cbrt, function cbrt(number) {
    var result = Math.pow(Math.abs(number), 1.0 / 3.0);
    return number < 0.0 ? -result : result;
  });

  /**
   * 找出一个数的以2为底的对数。
   * @function
   * @param {Number} number 数字。
   * @returns {Number} 结果。
   */
  // eslint-disable-next-line es/no-math-log2
  CesiumMath.log2 = defaultValue$1(Math.log2, function log2(number) {
    return Math.log(number) * Math.LOG2E;
  });

  /**
   * @private
   */
  CesiumMath.fog = function (distanceToCamera, density) {
    var scalar = distanceToCamera * density;
    return 1.0 - Math.exp(-(scalar * scalar));
  };

  /**
   * 计算在范围[-1,1]内的输入值的快速atan近似。基于Michal Drobot在ShaderFastLibs中的近似计算，它又基于“Efficient approximations for the arctangent function”，Rajan, S. Sichun Wang Inkol, R. Joyal, A.，2006年5月。从ShaderFastLibs中改编而来，使用MIT许可证。
   * @param {Number} x 位于范围[-1,1]内的输入数字。
   * @returns {Number} atan(x)的近似值。
   */
  CesiumMath.fastApproximateAtan = function (x) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("x", x);
    //>>includeEnd('debug');

    return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);
  };

  /**
   * 计算任意输入标量的快速atan2(x, y)近似。
   * @param {Number} x 如果y为零，则为非零输入数字。
   * @param {Number} y 如果x为零，则为非零输入数字。
   * @returns {Number} atan2(x, y)的近似值。
   */
  CesiumMath.fastApproximateAtan2 = function (x, y) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("x", x);
    Check.typeOf.number("y", y);
    //>>includeEnd('debug');

    // atan approximations are usually only reliable over [-1, 1]
    // So reduce the range by flipping whether x or y is on top based on which is bigger.
    var opposite;
    var t = Math.abs(x); // t used as swap and atan result.
    opposite = Math.abs(y);
    var adjacent = Math.max(t, opposite);
    opposite = Math.min(t, opposite);
    var oppositeOverAdjacent = opposite / adjacent;
    //>>includeStart('debug', pragmas.debug);
    if (isNaN(oppositeOverAdjacent)) {
      throw new DeveloperError$1("either x or y must be nonzero");
    }
    //>>includeEnd('debug');
    t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);

    // Undo range reduction
    t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;
    t = x < 0.0 ? CesiumMath.PI - t : t;
    t = y < 0.0 ? -t : t;
    return t;
  };
  /**
   * 球面两点间的距离
   * @param {Vector2|Array} pntFrom -经纬坐标
   * @param {Vector2|Array} pntTo -经纬坐标
   *
   * @memberOf Math
   */
  CesiumMath.sphereDistance = function (pntFrom, pntTo) {
    if (pntFrom instanceof Array) {
      pntFrom = new PIEVector2(pntFrom[0], pntFrom[1]);
    }
    if (pntTo instanceof Array) {
      pntTo = new PIEVector2(pntTo[0], pntTo[1]);
    }
    if (pntFrom.x > 180 || pntFrom.x < -180 || pntTo.x > 180 || pntTo.x < -180 || pntFrom.y > 180 / 2 || pntFrom.y < -180 / 2 || pntTo.y > 180 / 2 || pntTo.y < -180 / 2) {
      return 0;
    }
    var dLongDist = pntFrom.x - pntTo.x;
    if (dLongDist < -180) {
      dLongDist += 2 * 180;
    } else if (dLongDist > 180) {
      dLongDist = 2 * 180 - dLongDist;
    }
    var dPnt1Latitude = pntFrom.y;
    var dPnt2Latitude = pntTo.y;
    var dCospnt1 = Math.cos(dPnt1Latitude * (Math.PI / 180));
    var dCospnt2 = Math.cos(dPnt2Latitude * (Math.PI / 180));
    var dSinpnt1 = Math.sin(dPnt1Latitude * (Math.PI / 180));
    var dSinpnt2 = Math.sin(dPnt2Latitude * (Math.PI / 180));
    var dSinDist = dSinpnt1 - dSinpnt2;
    var dValue = dSinDist * dSinDist + dCospnt1 * dCospnt1 + dCospnt2 * dCospnt2 - 2 * dCospnt1 * dCospnt2 * Math.cos(dLongDist * (Math.PI / 180));
    if (dValue < 0) {
      dValue = 0;
    }
    //这是以pnt1和pnt2所在大圆最短圆弧长
    var dLength = 2 * Math.asin(Math.sqrt(dValue) / 2) * 6371118;
    return dLength;
  };
  /**
   * 求解两个值之间的样条插值
   * @param {Number} edge0 -样条插值函数的下界
   * @param {Number} edge1 -样条插值函数的上界
   * @param {Number} x -插值的源输入
   */
  CesiumMath.smoothstep = function (edge0, edge1, x) {
    x = CesiumMath.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * x * (x * (x * 6 - 15) + 10);
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 
   * @class Cartesian2
   * 2维笛卡尔点
   * @constructor
   * 
   * @param {Number} x=0.0 <code>optional</code>  X值。
   * @param {Number} y=0.0 <code>optional</code>  Y值。
   *
   * @see Cartesian3
   */
  function Cartesian2(x, y) {
    /*
     * The X component.
     * @type {Number}
     * @default 0.0
     */
    this.x = defaultValue$1(x, 0.0);

    /*
     * The Y component.
     * @type {Number}
     * @default 0.0
     */
    this.y = defaultValue$1(y, 0.0);
  }

  /**
   * 根据x和y坐标创建Cartesian2实例
   *
   * @param {Number} x x坐标。
   * @param {Number} y y坐标。
   * @param {Cartesian2} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian2} 如果没有提供一个新的 Cartesian2 实例，则返回修改后的结果参数或创建一个新的 Cartesian2 实例。
   */
  Cartesian2.fromElements = function (x, y, result) {
    if (!defined$1(result)) {
      return new Cartesian2(x, y);
    }
    result.x = x;
    result.y = y;
    return result;
  };

  /**
   * 将一个Cartesian2实例复制一份。
   *
   * @param {Cartesian2} cartesian 要复制的Cartesian2实例。
   * @param {Cartesian2} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数，如果没有提供参数则返回新的Cartesian2实例。（如果cartesian为undefined，则返回undefined）
   */
  Cartesian2.clone = function (cartesian, result) {
    if (!defined$1(cartesian)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Cartesian2(cartesian.x, cartesian.y);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    return result;
  };

  /**
   * 从现有的Cartesian3实例创建一个Cartesian2实例。这只是简单地取Cartesian3的x和y属性，丢弃z属性。
   * @function
   *
   * @param {Cartesian3} cartesian 用来创建Cartesian2实例的Cartesian3实例。
   * @param {Cartesian2} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数，如果没有提供参数则返回新的Cartesian2实例。
   */
  Cartesian2.fromCartesian3 = Cartesian2.clone;

  /**
   * 从现有的Cartesian4实例创建一个Cartesian2实例。这只是简单地取Cartesian4的x和y属性，丢弃z和w属性。
   * @function
   *
   * @param {Cartesian4} cartesian 用来创建Cartesian2实例的Cartesian4实例。
   * @param {Cartesian2} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数，如果没有提供参数则返回新的Cartesian2实例。
   */
  Cartesian2.fromCartesian4 = Cartesian2.clone;

  /*
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Cartesian2.packedLength = 2;

  /**
   * 将提供的实例存储到提供的数组中。
   *
   * @param {Cartesian2} value 要打包的值。
   * @param {Number[]} array 要打包到的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 开始打包元素的数组索引。
   *
   * @returns {Number[]} 已经打包的数组
   */
  Cartesian2.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("value", value);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex] = value.y;
    return array;
  };

  /**
   * 从打包的数组中获取一个实例。
   *
   * @param {Number[]} array 打包的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 要解包的元素的起始索引。
   * @param {Cartesian2} result <code>optional</code> 储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数或者如果没有提供则返回一个新的Cartesian2实例。
   */
  Cartesian2.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new Cartesian2();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex];
    return result;
  };

  /**
   * 将一个Cartesian2数组扁平化为一个组件数组。
   *
   * @param {Cartesian2[]} array 要打包的Cartesian数组。
   * @param {Number[]} result <code>optional</code> 存储结果的数组。
   * @returns {Number[]} 打包后的数组。
   */
  Cartesian2.packArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    var length = array.length;
    var resultLength = length * 2;
    if (!defined$1(result)) {
      result = new Array(resultLength);
    } else if (!Array.isArray(result) && result.length !== resultLength) {
      //>>includeStart('debug', pragmas.debug);
      throw new DeveloperError$1("If result is a typed array, it must have exactly array.length * 2 elements");
      //>>includeEnd('debug');
    } else if (result.length !== resultLength) {
      result.length = resultLength;
    }
    for (var i = 0; i < length; ++i) {
      Cartesian2.pack(array[i], result, i * 2);
    }
    return result;
  };

  /**
   * 将一个包含Cartesian2组件的数组展开为一个Cartesian2对象数组。
   * 
   * @param {Number[]} array 要展开的组件数组。
   * @param {Cartesian2[]} result <code>optional</code> 存储结果的数组。
   * @returns {Cartesian2[]} 展开后的数组。
   */
  Cartesian2.unpackArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 2);
    if (array.length % 2 !== 0) {
      throw new DeveloperError$1("array length must be a multiple of 2.");
    }
    //>>includeEnd('debug');

    var length = array.length;
    if (!defined$1(result)) {
      result = new Array(length / 2);
    } else {
      result.length = length / 2;
    }
    for (var i = 0; i < length; i += 2) {
      var index = i / 2;
      result[index] = Cartesian2.unpack(array, i, result[index]);
    }
    return result;
  };

  /**
   * 从数组中的两个相邻元素创建一个Cartesian2。
   * @function
   *
   * @param {Number[]} array 两个相邻元素对应于x和y分量的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 第一个元素的偏移量，对应于x分量。
   * @param {Cartesian2} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian2} 修改后的result参数或者如果未提供result，则返回一个新的Cartesian2实例。
   *
   * @example
   * // Create a Cartesian2 with (1.0, 2.0)
   * const v = [1.0, 2.0];
   * const p = Earth.Cartesian2.fromArray(v);
   *
   * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 2.0];
   * const p2 = Earth.Cartesian2.fromArray(v2, 2);
   */
  Cartesian2.fromArray = Cartesian2.unpack;

  /**
   * 计算提供的Cartesian的最大分量值。
   * @param {Cartesian2} cartesian 要使用的Cartesian。
   * @returns {Number} 最大分量的值。
   */
  Cartesian2.maximumComponent = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    //>>includeEnd('debug');

    return Math.max(cartesian.x, cartesian.y);
  };

  /**
   * 计算提供的Cartesian的最小分量值。
   * @param {Cartesian2} cartesian 要使用的Cartesian。
   * @returns {Number} 最小分量的值。
   */
  Cartesian2.minimumComponent = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    //>>includeEnd('debug');

    return Math.min(cartesian.x, cartesian.y);
  };

  /**
   * 比较两个Cartesian并计算一个Cartesian，其中包含提供的Cartesian的最小分量。
   * @param {Cartesian2} first 要比较的Cartesian。
   * @param {Cartesian2} second 要比较的Cartesian。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 具有最小分量的Cartesian。
   */
  Cartesian2.minimumByComponent = function (first, second, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("first", first);
    Check.typeOf.object("second", second);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    return result;
  };

  /**
   * 比较两个Cartesian并计算一个Cartesian，其中包含提供的Cartesian的最大分量。
   * @param {Cartesian2} first 要比较的Cartesian。
   * @param {Cartesian2} second 要比较的Cartesian。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 具有最大分量的Cartesian
   */
  Cartesian2.maximumByComponent = function (first, second, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("first", first);
    Check.typeOf.object("second", second);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    return result;
  };

  /**
   * 将一个值限制在两个值之间。
   * @param {Cartesian2} value 要夹紧的值。
   * @param {Cartesian2} min 最小边界。
   * @param {Cartesian2} max 最大边界。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 被夹紧的值，满足 min <= result <= max。
   */
  Cartesian2.clamp = function (value, min, max, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("value", value);
    Check.typeOf.object("min", min);
    Check.typeOf.object("max", max);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var x = CesiumMath.clamp(value.x, min.x, max.x);
    var y = CesiumMath.clamp(value.y, min.y, max.y);
    result.x = x;
    result.y = y;
    return result;
  };

  /**
   * 计算提供的Cartesian的平方幅值。
   * @param {Cartesian2} cartesian 要计算平方幅值的Cartesian实例。
   * @returns {Number} 平方幅值
   */
  Cartesian2.magnitudeSquared = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    //>>includeEnd('debug');

    return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
  };

  /**
   * Computes the Cartesian's magnitude (length).
   *
   * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.
   * @returns {Number} The magnitude.
   */
  Cartesian2.magnitude = function (cartesian) {
    return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
  };
  var distanceScratch$2 = new Cartesian2();

  /**
   * 计算Cartesian的幅值（长度）。
   * @param {Cartesian2} cartesian 要计算幅值的Cartesian实例。
   * @returns {Number} 幅值
   *
   * @example
   * // Returns 1.0
   * const d = Earth.Cartesian2.distance(new Earth.Cartesian2(1.0, 0.0), new Earth.Cartesian2(2.0, 0.0));
   */
  Cartesian2.distance = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    Cartesian2.subtract(left, right, distanceScratch$2);
    return Cartesian2.magnitude(distanceScratch$2);
  };

  /**
   * 计算两个点之间的平方距离。使用此函数比使用{@link Cartesian2.distance}比较距离更有效率。
   * @param {Cartesian2} left 要计算距离的第一个点。
   * @param {Cartesian2} right 要计算距离的第二个点。
   * @returns {Number} 两点之间的距离。
   *
   * @example
   * // Returns 4.0, not 2.0
   * const d = Earth.Cartesian2.distance(new Earth.Cartesian2(1.0, 0.0), new Earth.Cartesian2(3.0, 0.0));
   */
  Cartesian2.distanceSquared = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    Cartesian2.subtract(left, right, distanceScratch$2);
    return Cartesian2.magnitudeSquared(distanceScratch$2);
  };

  /**
   * 计算所提供笛卡尔坐标的标准化形式。
   * @param {Cartesian2} cartesian 要标准化的笛卡尔坐标。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.normalize = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var magnitude = Cartesian2.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;

    //>>includeStart('debug', pragmas.debug);
    if (isNaN(result.x) || isNaN(result.y)) {
      throw new DeveloperError$1("normalized result is not a number");
    }
    //>>includeEnd('debug');

    return result;
  };

  /**
   * 计算两个笛卡尔坐标的点积（数量积）。
   * @param {Cartesian2} left 第一个笛卡尔坐标。
   * @param {Cartesian2} right 第二个笛卡尔坐标。
   * @returns {Number} 点积。
   */
  Cartesian2.dot = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    return left.x * right.x + left.y * right.y;
  };

  /**
   * 计算在将输入向量的 Z 坐标隐式设置为 0 的情况下，将产生的叉积的大小。
   * @param {Cartesian2} left 第一个笛卡尔坐标。
   * @param {Cartesian2} right 第二个笛卡尔坐标。
   * @returns {Number} 叉积大小。
   */
  Cartesian2.cross = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    return left.x * right.y - left.y * right.x;
  };

  /**
   * 计算两个Cartesian的分量积。
   * @param {Cartesian2} left 第一个Cartesian。
   * @param {Cartesian2} right 第二个Cartesian。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.multiplyComponents = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x * right.x;
    result.y = left.y * right.y;
    return result;
  };

  /**
   * 计算两个笛卡尔点的分量商。
   * @param {Cartesian2} left 第一个笛卡尔点。
   * @param {Cartesian2} right 第二个笛卡尔点。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.divideComponents = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x / right.x;
    result.y = left.y / right.y;
    return result;
  };

  /**
   * 计算两个笛卡尔点的分量和。
   * @param {Cartesian2} left 第一个笛卡尔点。
   * @param {Cartesian2} right 第二个笛卡尔点。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.add = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x + right.x;
    result.y = left.y + right.y;
    return result;
  };

  /**
   * 计算两个笛卡尔坐标之间的逐分量差。
   * @param {Cartesian2} left 第一个笛卡尔坐标。
   * @param {Cartesian2} right 第二个笛卡尔坐标。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.subtract = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x - right.x;
    result.y = left.y - right.y;
    return result;
  };

  /**
   * 将提供的笛卡尔坐标逐分量乘以提供的标量。
   * @param {Cartesian2} cartesian 需要进行缩放的笛卡尔坐标。
   * @param {Number} scalar 用于乘法的标量。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.multiplyByScalar = function (cartesian, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.number("scalar", scalar);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    return result;
  };

  /**
   * 将提供的笛卡尔坐标逐分量除以提供的标量。
   * @param {Cartesian2} cartesian 需要进行除法的笛卡尔坐标。
   * @param {Number} scalar 用于除法的标量。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.divideByScalar = function (cartesian, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.number("scalar", scalar);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    return result;
  };

  /**
   * 对提供的笛卡尔坐标进行取反。
   * @param {Cartesian2} cartesian 需要被取反的笛卡尔坐标。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.negate = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = -cartesian.x;
    result.y = -cartesian.y;
    return result;
  };

  /**
   * 计算提供的笛卡尔坐标的绝对值。
   * @param {Cartesian2} cartesian 需要计算绝对值的笛卡尔坐标。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.abs = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    return result;
  };
  var lerpScratch$2 = new Cartesian2();
  /**
   * 使用提供的笛卡尔坐标，在 t 处进行线性插值或外推。
   * @param {Cartesian2} start 对应于 t=0.0 的值。
   * @param {Cartesian2} end 对应于 t=1.0 的值。
   * @param {Number} t 插值的点 t。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 修改后的结果参数。
   */
  Cartesian2.lerp = function (start, end, t, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("start", start);
    Check.typeOf.object("end", end);
    Check.typeOf.number("t", t);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    Cartesian2.multiplyByScalar(end, t, lerpScratch$2);
    result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
    return Cartesian2.add(lerpScratch$2, result, result);
  };
  var angleBetweenScratch$1 = new Cartesian2();
  var angleBetweenScratch2$1 = new Cartesian2();
  /**
   * 返回提供的两个笛卡尔坐标之间的夹角，以弧度表示。
   * @param {Cartesian2} left 第一个笛卡尔坐标。
   * @param {Cartesian2} right 第二个笛卡尔坐标。
   * @returns {Number} 两个笛卡尔坐标之间的夹角。
   */
  Cartesian2.angleBetween = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    Cartesian2.normalize(left, angleBetweenScratch$1);
    Cartesian2.normalize(right, angleBetweenScratch2$1);
    return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch$1, angleBetweenScratch2$1));
  };
  var mostOrthogonalAxisScratch$2 = new Cartesian2();
  /**
   * 返回与提供的笛卡尔坐标最正交的轴。
   * @param {Cartesian2} cartesian 需要查找最正交轴的笛卡尔坐标。
   * @param {Cartesian2} result 存储结果的对象。
   * @returns {Cartesian2} 最正交轴。
   */
  Cartesian2.mostOrthogonalAxis = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch$2);
    Cartesian2.abs(f, f);
    if (f.x <= f.y) {
      result = Cartesian2.clone(Cartesian2.UNIT_X, result);
    } else {
      result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
    }
    return result;
  };

  /**
   * 按分量逐个比较提供的笛卡尔坐标，如果它们相等则返回 true，否则返回 false。
   * @param {Cartesian2} left <code>optional</code> 第一个笛卡尔坐标。
   * @param {Cartesian2} right <code>optional</code> 第二个笛卡尔坐标。
   * @returns {Boolean} 如果 left 和 right 相等，则返回 true，否则返回 false。
   */
  Cartesian2.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left.x === right.x && left.y === right.y;
  };

  /**
   * @private
   */
  Cartesian2.equalsArray = function (cartesian, array, offset) {
    return cartesian.x === array[offset] && cartesian.y === array[offset + 1];
  };

  /**
   * 按分量逐个比较提供的笛卡尔坐标，如果它们通过绝对或相对容差测试，则返回 true，否则返回 false。
   * @param {Cartesian2} left <code>optional</code> 第一个笛卡尔坐标。
   * @param {Cartesian2} right <code>optional</code> 第二个笛卡尔坐标。
   * @param {Number} relativeEpsilon=0 <code>optional</code> 相对容差，用于相等性测试。
   * @param {Number} absoluteEpsilon=relativeEpsilon <code>optional</code> 绝对容差，用于相等性测试。
   * @returns {Boolean} 如果 left 和 right 在提供的容差范围内，则返回 true，否则返回 false。
   */
  Cartesian2.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    return left === right || defined$1(left) && defined$1(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon);
  };

  /*
   * An immutable Cartesian2 instance initialized to (0.0, 0.0).
   *
   * @type {Cartesian2}
   * @constant
   */
  Cartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));

  /*
   * An immutable Cartesian2 instance initialized to (1.0, 1.0).
   *
   * @type {Cartesian2}
   * @constant
   */
  Cartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));

  /*
   * An immutable Cartesian2 instance initialized to (1.0, 0.0).
   *
   * @type {Cartesian2}
   * @constant
   */
  Cartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));

  /*
   * An immutable Cartesian2 instance initialized to (0.0, 1.0).
   *
   * @type {Cartesian2}
   * @constant
   */
  Cartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));

  /**
   * 复制此Cartesian2实例。
   * @param {Cartesian2} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian2} 修改后的result参数或如果没有提供则为新的Cartesian2实例。
   */
  Cartesian2.prototype.clone = function (result) {
    return Cartesian2.clone(this, result);
  };

  /**
   * 逐个分量比较此Cartesian与提供的Cartesian，如果它们相等返回true，否则返回false。
  @param {Cartesian2} right <code>optional</code> 右边的Cartesian。
  @returns {Boolean} 如果它们相等则返回true，否则返回false。
   */
  Cartesian2.prototype.equals = function (right) {
    return Cartesian2.equals(this, right);
  };

  /**
   * 将该二维笛卡尔坐标与另一个二维笛卡尔坐标逐分量进行比较，并返回如果它们在绝对误差或相对误差容差测试中通过，则返回true，否则返回false。
   * @param {Cartesian2} right <code>optional</code> 右侧的二维笛卡尔坐标。
   * @param {Number} relativeEpsilon=0 <code>optional</code> 用于相等测试的相对 epsilon 容差。
   * @param {Number} absoluteEpsilon=relativeEpsilon <code>optional</code> 用于相等测试的绝对 epsilon 容差。
   * @returns {Boolean} 如果它们在提供的误差范围内，则为true，否则为false。
   */
  Cartesian2.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {
    return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };

  /**
   * 创建一个字符串，以“(x，y)”的格式表示此Cartesian。
   * @returns {String} 以“(x，y)”的格式表示提供的Cartesian的字符串。
   */
  Cartesian2.prototype.toString = function () {
    return "(".concat(this.x, ", ").concat(this.y, ")");
  };

  var scaleToGeodeticSurfaceIntersection = new Cartesian3();
  var scaleToGeodeticSurfaceGradient = new Cartesian3();

  /**
   * Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined.
   *
   * @param {Cartesian3} cartesian The Cartesian position to scale.
   * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.
   * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.
   * @param {Number} centerToleranceSquared Tolerance for closeness to the center.
   * @param {Cartesian3} [result] The object onto which to store the result.
   * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
   *
   * @function scaleToGeodeticSurface
   *
   * @private
   */
  function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(cartesian)) {
      throw new DeveloperError$1("cartesian is required.");
    }
    if (!defined$1(oneOverRadii)) {
      throw new DeveloperError$1("oneOverRadii is required.");
    }
    if (!defined$1(oneOverRadiiSquared)) {
      throw new DeveloperError$1("oneOverRadiiSquared is required.");
    }
    if (!defined$1(centerToleranceSquared)) {
      throw new DeveloperError$1("centerToleranceSquared is required.");
    }
    //>>includeEnd('debug');

    var positionX = cartesian.x;
    var positionY = cartesian.y;
    var positionZ = cartesian.z;
    var oneOverRadiiX = oneOverRadii.x;
    var oneOverRadiiY = oneOverRadii.y;
    var oneOverRadiiZ = oneOverRadii.z;
    var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
    var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
    var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;

    // Compute the squared ellipsoid norm.
    var squaredNorm = x2 + y2 + z2;
    var ratio = Math.sqrt(1.0 / squaredNorm);

    // As an initial approximation, assume that the radial intersection is the projection point.
    var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);

    // If the position is near the center, the iteration will not converge.
    if (squaredNorm < centerToleranceSquared) {
      return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);
    }
    var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
    var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
    var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;

    // Use the gradient at the intersection point in place of the true unit normal.
    // The difference in magnitude will be absorbed in the multiplier.
    var gradient = scaleToGeodeticSurfaceGradient;
    gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;
    gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;
    gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;

    // Compute the initial guess at the normal vector multiplier, lambda.
    var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));
    var correction = 0.0;
    var func;
    var denominator;
    var xMultiplier;
    var yMultiplier;
    var zMultiplier;
    var xMultiplier2;
    var yMultiplier2;
    var zMultiplier2;
    var xMultiplier3;
    var yMultiplier3;
    var zMultiplier3;
    do {
      lambda -= correction;
      xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
      yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
      zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);
      xMultiplier2 = xMultiplier * xMultiplier;
      yMultiplier2 = yMultiplier * yMultiplier;
      zMultiplier2 = zMultiplier * zMultiplier;
      xMultiplier3 = xMultiplier2 * xMultiplier;
      yMultiplier3 = yMultiplier2 * yMultiplier;
      zMultiplier3 = zMultiplier2 * zMultiplier;
      func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;

      // "denominator" here refers to the use of this expression in the velocity and acceleration
      // computations in the sections to follow.
      denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
      var derivative = -2.0 * denominator;
      correction = func / derivative;
    } while (Math.abs(func) > CesiumMath.EPSILON12);
    if (!defined$1(result)) {
      return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);
    }
    result.x = positionX * xMultiplier;
    result.y = positionY * yMultiplier;
    result.z = positionZ * zMultiplier;
    return result;
  }

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * @class Cartographic
   * 一个由经度、纬度和高度定义的位置。
   * @constructor
   *
   * @param {Number} longitude=0.0 <code>optional</code> 经度，以弧度为单位。
   * @param {Number} latitude=0.0 <code>optional</code> 纬度，以弧度为单位。
   * @param {Number} height=0.0 <code>optional</code> 相对于椭球体而言的高度（以米为单位）。
   * @see Ellipsoid
   */
  function Cartographic(longitude, latitude, height) {
    /*
     * The longitude, in radians.
     * @type {Number}
     * @default 0.0
     */
    this.longitude = defaultValue$1(longitude, 0.0);

    /*
     * The latitude, in radians.
     * @type {Number}
     * @default 0.0
     */
    this.latitude = defaultValue$1(latitude, 0.0);

    /*
     * The height, in meters, above the ellipsoid.
     * @type {Number}
     * @default 0.0
     */
    this.height = defaultValue$1(height, 0.0);
  }

  /**
   * 根据以弧度为单位指定的经度和纬度创建一个新的地理坐标对象。
   * @param {Number} longitude 经度，以弧度为单位。
   * @param {Number} latitude 纬度，以弧度为单位。
   * @param {Number} height=0.0 <code>optional</code> 相对于椭球体的高度，以米为单位。
   * @param {Cartographic} result <code>optional</code> 存储结果的对象。
   * @returns {Cartographic} 修改后的结果参数,如果未提供则为新的 Cartographic 实例。
   */
  Cartographic.fromRadians = function (longitude, latitude, height, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number('longitude', longitude);
    Check.typeOf.number('latitude', latitude);
    //>>includeEnd('debug');

    height = defaultValue$1(height, 0.0);
    if (!defined$1(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
  };

  /**
   * 根据以度为单位指定的经度和纬度创建一个新的地理坐标对象。返回的对象中的值将以弧度为单位。
   * @param {Number} longitude 经度，以度为单位。
   * @param {Number} latitude 纬度，以度为单位。
   * @param {Number} height=0.0 <code>optional</code> 相对于椭球体的高度，以米为单位。
   * @param {Cartographic} result <code>optional</code> 存储结果的对象。
   * @returns {Cartographic} 修改后的结果参数,如果未提供则为新的 Cartographic 实例。
   */
  Cartographic.fromDegrees = function (longitude, latitude, height, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number('longitude', longitude);
    Check.typeOf.number('latitude', latitude);
    //>>includeEnd('debug');
    longitude = CesiumMath.toRadians(longitude);
    latitude = CesiumMath.toRadians(latitude);
    return Cartographic.fromRadians(longitude, latitude, height, result);
  };
  new Cartesian3();
  new Cartesian3();
  new Cartesian3();
  new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);
  new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));
  CesiumMath.EPSILON1;

  /**
   * 根据一个笛卡尔坐标创建一个新的地理坐标对象。返回的对象中的值将以弧度为单位。
   * @param {Cartesian3} cartesian 要转换为地理坐标表示的笛卡尔坐标位置。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 位置所在的椭球体。
   * @param {Cartographic} result <code>optional</code> 存储结果的对象。
   * @returns {Cartographic} 修改后的结果参数，如果未提供则为新的 Cartographic 实例，如果笛卡尔坐标位于椭球体的中心，则返回未定义。
   */
  Cartographic.fromCartesian = function (cartesian, ellipsoid, result) {
    var vector3 = PIEVector3.cartesianToSpherical(cartesian.x, cartesian.y, cartesian.z);
    var radius = defined$1(ellipsoid) ? ellipsoid._radii.x : Ellipsoid$1.WGS84._radii.x;
    var longitude = vector3.x;
    var latitude = vector3.y;
    var height = vector3.z - radius;
    if (!defined$1(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;

    // const oneOverRadii = defined(ellipsoid)
    //   ? ellipsoid.oneOverRadii
    //   : wgs84OneOverRadii;
    // const oneOverRadiiSquared = defined(ellipsoid)
    //   ? ellipsoid.oneOverRadiiSquared
    //   : wgs84OneOverRadiiSquared;
    // const centerToleranceSquared = defined(ellipsoid)
    //   ? ellipsoid._centerToleranceSquared
    //   : wgs84CenterToleranceSquared;

    // //`cartesian is required.` is thrown from scaleToGeodeticSurface
    // const p = scaleToGeodeticSurface(
    //   cartesian,
    //   oneOverRadii,
    //   oneOverRadiiSquared,
    //   centerToleranceSquared,
    //   cartesianToCartographicP
    // );

    // if (!defined(p)) {
    //   return undefined;
    // }

    // let n = Cartesian3.multiplyComponents(
    //   p,
    //   oneOverRadiiSquared,
    //   cartesianToCartographicN
    // );
    // n = Cartesian3.normalize(n, n);

    // const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);

    // const longitude = Math.atan2(n.y, n.x);
    // const latitude = Math.asin(n.z);
    // const height =
    //   CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);

    // if (!defined(result)) {
    //   return new Cartographic(longitude, latitude, height);
    // }
    // result.longitude = longitude;
    // result.latitude = latitude;
    // result.height = height;
    // return result;
  };

  /**
   * 根据地理坐标对象创建一个新的 Cartesian3 坐标对象。传入的地理坐标对象中的值应该是以弧度为单位的。
   * @param {Cartographic} cartographic 待转换为 Cartesian3 对象的输入对象。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 位置所在的椭球体。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} Cartesian3 坐标对象。
   */
  Cartographic.toCartesian = function (cartographic, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('cartographic', cartographic);
    //>>includeEnd('debug');

    return Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic.height, ellipsoid, result);
  };

  /**
   * 复制一个地理坐标对象。
   * @param {Cartographic} cartographic 要复制的地理坐标对象。
   * @param {Cartographic} result <code>optional</code> 存储结果的对象。
   * @returns {Cartographic} 修改后的结果参数或如果未提供则为新的 Cartographic 实例。如果 cartographic 为 undefined，则返回 undefined。
   */
  Cartographic.clone = function (cartographic, result) {
    if (!defined$1(cartographic)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
    }
    result.longitude = cartographic.longitude;
    result.latitude = cartographic.latitude;
    result.height = cartographic.height;
    return result;
  };

  /**
   * 逐个比较提供的地理坐标对象，如果它们相等则返回 true，否则返回 false。
   * @param {Cartographic} left <code>optional</code> 第一个地理坐标对象。
   * @param {Cartographic} right <code>optional</code> 第二个地理坐标对象。
   * @returns {Boolean} 如果 left 和 right 相等则返回 true，否则返回 false。
   */
  Cartographic.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left.longitude === right.longitude && left.latitude === right.latitude && left.height === right.height;
  };

  /**
   * 逐个比较提供的地理坐标对象，如果它们在提供的 epsilon 范围内相等则返回 true，否则返回 false。
   * @param {Cartographic} left <code>optional</code> 第一个地理坐标对象。
   * @param {Cartographic} right <code>optional</code> 第二个地理坐标对象。
   * @param {Number} epsilon=0 <code>optional</code> 用于测试相等性的 epsilon。
   * @returns {Boolean} 如果 left 和 right 在提供的 epsilon 范围内相等则返回 true，否则返回 false。
   */
  Cartographic.equalsEpsilon = function (left, right, epsilon) {
    epsilon = defaultValue$1(epsilon, 0);
    return left === right || defined$1(left) && defined$1(right) && Math.abs(left.longitude - right.longitude) <= epsilon && Math.abs(left.latitude - right.latitude) <= epsilon && Math.abs(left.height - right.height) <= epsilon;
  };

  /*
   * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
   *
   * @type {Cartographic}
   * @constant
   */
  Cartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));

  /**
   * 复制此实例。
   * @param {Cartographic} result <code>optional</code> 用于存储结果的对象。
   * @returns {Cartographic} 如果提供了 result 参数，则返回修改后的 result 参数；否则返回新的 Cartographic 实例。
   */
  Cartographic.prototype.clone = function (result) {
    return Cartographic.clone(this, result);
  };

  /**
   * 逐个比较提供的 cartographic 和该 cartographic，如果它们相等，则返回 true；否则返回 false。
   * @param {Cartographic} right <code>optional</code> 第二个 cartographic。
   * @returns {Boolean} 如果左侧和右侧相等，则返回 true；否则返回 false。
   */
  Cartographic.prototype.equals = function (right) {
    return Cartographic.equals(this, right);
  };

  /**
   * 将提供的参数与当前 Cartographic 实例逐个比较，如果它们相等则返回 true，否则返回 false。
   * @param {Cartographic} right <code>optional</code> 第二个 Cartographic 实例。
   * @param {Number} epsilon=0 <code>optional</code> 用于相等性测试的 epsilon。
   * @returns {Boolean} 如果左右两个 Cartographic 实例的每个对应属性差值都在 epsilon 范围内，则返回 true，否则返回 false。
   */
  Cartographic.prototype.equalsEpsilon = function (right, epsilon) {
    return Cartographic.equalsEpsilon(this, right, epsilon);
  };

  /**
   * 以'(经度, 纬度, 高度)'格式创建表示此地理坐标的字符串。
   * @returns {String} 以'(经度, 纬度, 高度)'格式表示的此地理坐标的字符串。
   */
  Cartographic.prototype.toString = function () {
    return "(".concat(this.longitude, ", ").concat(this.latitude, ", ").concat(this.height, ")");
  };

  function initialize(ellipsoid, x, y, z) {
    x = defaultValue$1(x, 0.0);
    y = defaultValue$1(y, 0.0);
    z = defaultValue$1(z, 0.0);

    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number.greaterThanOrEquals('x', x, 0.0);
    Check.typeOf.number.greaterThanOrEquals('y', y, 0.0);
    Check.typeOf.number.greaterThanOrEquals('z', z, 0.0);
    //>>includeEnd('debug');

    ellipsoid._radii = new Cartesian3(x, y, z);
    ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);
    ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);
    ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);
    ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));
    ellipsoid._minimumRadius = Math.min(x, y, z);
    ellipsoid._maximumRadius = Math.max(x, y, z);
    ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;
    if (ellipsoid._radiiSquared.z !== 0) {
      ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;
    }
  }
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Ellipsoid
   * 椭球类
   * @constructor
   *
   * @param {Number} x=0 <code>optional</code> x方向半径
   * @param {Number} y=0 <code>optional</code> y方向半径
   * @param {Number} z=0 <code>optional</code> z方向半径
   *
   * @exception {DeveloperError} 所有半径必须大于或等于零。
   *
   * @see Ellipsoid.fromCartesian3
   * @see Ellipsoid.WGS84
   * @see Ellipsoid.UNIT_SPHERE
   */
  function Ellipsoid$1(x, y, z) {
    this._radii = undefined;
    this._radiiSquared = undefined;
    this._radiiToTheFourth = undefined;
    this._oneOverRadii = undefined;
    this._oneOverRadiiSquared = undefined;
    this._minimumRadius = undefined;
    this._maximumRadius = undefined;
    this._centerToleranceSquared = undefined;
    this._squaredXOverSquaredZ = undefined;
    initialize(this, x, y, z);
  }
  Object.defineProperties(Ellipsoid$1.prototype, {
    /** 
     * 获取椭球半径
     * @memberof Ellipsoid.prototype
     * @type {Cartesian3}
     * @readonly
     */
    radii: {
      get: function get() {
        return this._radii;
      }
    },
    /*
     * 获取椭球体的半轴长度的平方。
     * @memberof Ellipsoid.prototype
     * @type {Cartesian3}
     * @readonly
     */
    radiiSquared: {
      get: function get() {
        return this._radiiSquared;
      }
    },
    /*
     * 获取椭球体的半轴长度的四次方。
     * @memberof Ellipsoid.prototype
     * @type {Cartesian3}
     * @readonly
     */
    radiiToTheFourth: {
      get: function get() {
        return this._radiiToTheFourth;
      }
    },
    /*
     * 获取椭球体的半轴长度的倒数。
     * @memberof Ellipsoid.prototype
     * @type {Cartesian3}
     * @readonly
     */
    oneOverRadii: {
      get: function get() {
        return this._oneOverRadii;
      }
    },
    /*
     * 获取椭球体的半轴长度的平方的倒数。
     * @memberof Ellipsoid.prototype
     * @type {Cartesian3}
     * @readonly
     */
    oneOverRadiiSquared: {
      get: function get() {
        return this._oneOverRadiiSquared;
      }
    },
    /*
     * 获取椭球体的最小半径。
     * @memberof Ellipsoid.prototype
     * @type {Number}
     * @readonly
     */
    minimumRadius: {
      get: function get() {
        return this._minimumRadius;
      }
    },
    /*
     * Gets the maximum radius of the ellipsoid.
     * @memberof Ellipsoid.prototype
     * @type {Number}
     * @readonly
     */
    maximumRadius: {
      get: function get() {
        return this._maximumRadius;
      }
    }
  });

  /**
   * 复制Ellipsoid实例。
   * @param {Ellipsoid} ellipsoid 要复制的椭球体。
   * @param {Ellipsoid} result <code>optional</code> 用于存储结果的对象，如果需要创建新实例则为undefined。
   * @returns {Ellipsoid} 克隆的Ellipsoid。（如果ellipsoid为undefined，则返回undefined）
   */
  Ellipsoid$1.clone = function (ellipsoid, result) {
    if (!defined$1(ellipsoid)) {
      return undefined;
    }
    var radii = ellipsoid._radii;
    if (!defined$1(result)) {
      return new Ellipsoid$1(radii.x, radii.y, radii.z);
    }
    Cartesian3.clone(radii, result._radii);
    Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);
    Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
    Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
    Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
    result._minimumRadius = ellipsoid._minimumRadius;
    result._maximumRadius = ellipsoid._maximumRadius;
    result._centerToleranceSquared = ellipsoid._centerToleranceSquared;
    return result;
  };

  /**
   * 根据在x，y和z方向上指定的半径，从Cartesian3计算Ellipsoid。
   * @param {Cartesian3} cartesian = Cartesian3.ZERO <code>optional</code> x，y和z方向上的椭球体半径。
   * @param {Ellipsoid} result <code>optional</code> 用于存储结果的对象，如果需要创建新实例则为undefined。
   * @returns {Ellipsoid} 新的Ellipsoid实例
   *
   * @exception {DeveloperError} 所有半径必须大于或等于零。
   *
   * @see Ellipsoid.WGS84
   * @see Ellipsoid.UNIT_SPHERE
   */
  Ellipsoid$1.fromCartesian3 = function (cartesian, result) {
    if (!defined$1(result)) {
      result = new Ellipsoid$1();
    }
    if (!defined$1(cartesian)) {
      return result;
    }
    initialize(result, cartesian.x, cartesian.y, cartesian.z);
    return result;
  };

  /*
   * An Ellipsoid instance initialized to the WGS84 standard.
   *
   * @type {Ellipsoid}
   * @constant
   */
  Ellipsoid$1.WGS84 = Object.freeze(
  // new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)
  new Ellipsoid$1(6378137.0, 6378137.0, 6378137.0));

  /*
   * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
   *
   * @type {Ellipsoid}
   * @constant
   */
  Ellipsoid$1.UNIT_SPHERE = Object.freeze(new Ellipsoid$1(1.0, 1.0, 1.0));

  /*
   * An Ellipsoid instance initialized to a sphere with the lunar radius.
   *
   * @type {Ellipsoid}
   * @constant
   */
  Ellipsoid$1.MOON = Object.freeze(new Ellipsoid$1(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));

  /**
   * 复制一个Ellipsoid实例。
   *
   * @param {Ellipsoid} result <code>optional</code> 用于存储结果的对象。
   * @returns {Ellipsoid} 复制后的椭球。
   */
  Ellipsoid$1.prototype.clone = function (result) {
    return Ellipsoid$1.clone(this, result);
  };

  /*
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Ellipsoid$1.packedLength = Cartesian3.packedLength;

  /**
   * 将提供的实例存储到提供的数组中。
   *
   * @param {Ellipsoid} value 要打包的值。
   * @param {Number[]} array 要打包到其中的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 开始打包元素的数组索引。
   * @returns {Number[]} 打包的数组。
   */
  Ellipsoid$1.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    Cartesian3.pack(value._radii, array, startingIndex);
    return array;
  };

  /**
   * 从打包数组中检索实例。
   * @param {Number[]} array 打包的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 要解包的元素的起始索引。
   * @param {Ellipsoid} result <code>optional</code> 存储结果的对象。
   * @returns {Ellipsoid} 修改后的结果参数，如果没有提供新的Ellipsoid实例，则返回一个新的Ellipsoid实例。
   */
  Ellipsoid$1.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    var radii = Cartesian3.unpack(array, startingIndex);
    return Ellipsoid$1.fromCartesian3(radii, result);
  };

  /**
   * 计算从该椭球体中心指向提供的笛卡尔坐标位置的单位向量。
   * @function
   * @param {Cartesian3} cartesian 要确定地心法线的笛卡尔坐标。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数，如果没有提供则返回新的Cartesian3实例。
   */
  Ellipsoid$1.prototype.geocentricSurfaceNormal = Cartesian3.normalize;

  /**
   * 计算在提供的位置处，椭球体表面切平面的法线。
   * @param {Cartographic} cartographic 要确定测地法线的地图投影坐标。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数，如果没有提供则返回新的Cartesian3实例。
   */
  Ellipsoid$1.prototype.geodeticSurfaceNormalCartographic = function (cartographic, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartographic', cartographic);
    //>>includeEnd('debug');

    var longitude = cartographic.longitude;
    var latitude = cartographic.latitude;
    var cosLatitude = Math.cos(latitude);
    var x = cosLatitude * Math.cos(longitude);
    var y = cosLatitude * Math.sin(longitude);
    var z = Math.sin(latitude);
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return Cartesian3.normalize(result, result);
  };

  /**
   * 计算在提供的位置处，椭球体表面切平面的法线。
   * @param {Cartesian3} cartesian 要确定表面法线的笛卡尔坐标。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数，如果没有提供则返回新的Cartesian3实例，如果无法找到法线则返回undefined。
   */
  Ellipsoid$1.prototype.geodeticSurfaceNormal = function (cartesian, result) {
    if (Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)) {
      return undefined;
    }
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);
    return Cartesian3.normalize(result, result);
  };
  var cartographicToCartesianNormal = new Cartesian3();
  var cartographicToCartesianK = new Cartesian3();

  /**
   * 将提供的地理坐标系转换为笛卡尔坐标系表示。
   * @param {Cartographic} cartographic 地理坐标位置。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或者如果没有提供则为新的Cartesian3实例。
   *
   * @example
   * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
   * const position = new Earth.Cartographic(Earth.Math.toRadians(21), Earth.Math.toRadians(78), 5000);
   * const cartesianPosition = Earth.Ellipsoid.WGS84.cartographicToCartesian(position);
   */
  Ellipsoid$1.prototype.cartographicToCartesian = function (cartographic, result) {
    //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.
    var n = cartographicToCartesianNormal;
    var k = cartographicToCartesianK;
    this.geodeticSurfaceNormalCartographic(cartographic, n);
    Cartesian3.multiplyComponents(this._radiiSquared, n, k);
    var gamma = Math.sqrt(Cartesian3.dot(n, k));
    Cartesian3.divideByScalar(k, gamma, k);
    Cartesian3.multiplyByScalar(n, cartographic.height, n);
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    return Cartesian3.add(k, n, result);
  };

  /**
   * 将提供的地理坐标系数组转换为笛卡尔坐标系数组表示。
   * @param {Cartographic[]} cartographics 地理坐标位置的数组。
   * @param {Cartesian3[]} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3[]} 修改后的结果参数或者如果没有提供则为新的数组实例。
   *
   * @example
   * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
   * const positions = [new Earth.Cartographic(Earth.Math.toRadians(21), Earth.Math.toRadians(78), 0),
   *                  new Earth.Cartographic(Earth.Math.toRadians(21.321), Earth.Math.toRadians(78.123), 100),
   *                  new Earth.Cartographic(Earth.Math.toRadians(21.645), Earth.Math.toRadians(78.456), 250)];
   * const cartesianPositions = Earth.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
   */
  Ellipsoid$1.prototype.cartographicArrayToCartesianArray = function (cartographics, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('cartographics', cartographics);
    //>>includeEnd('debug')

    var length = cartographics.length;
    if (!defined$1(result)) {
      result = new Array(length);
    } else {
      result.length = length;
    }
    for (var i = 0; i < length; i++) {
      result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
    }
    return result;
  };
  var cartesianToCartographicN = new Cartesian3();
  var cartesianToCartographicP = new Cartesian3();
  var cartesianToCartographicH = new Cartesian3();

  /**
   * 将提供的地理坐标系转换为笛卡尔坐标系表示。
   * 
   *
   * @param {Cartesian3} cartesian 要转换为地理坐标系表示的笛卡尔坐标位置。
   * @param {Cartographic} result <code>optional</code> 存储结果的对象。
   * @returns {Cartographic} 修改后的结果参数，如果没有提供则为新的Cartographic实例，如果笛卡尔坐标在椭球体中心则返回undefined。
   *
   * @example
   * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
   * const position = new Earth.Cartesian3(17832.12, 83234.52, 952313.73);
   * const cartographicPosition = Earth.Ellipsoid.WGS84.cartesianToCartographic(position);
   */
  Ellipsoid$1.prototype.cartesianToCartographic = function (cartesian, result) {
    //`cartesian is required.` is thrown from scaleToGeodeticSurface
    var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);
    if (!defined$1(p)) {
      return undefined;
    }
    var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
    var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);
    var longitude = Math.atan2(n.y, n.x);
    var latitude = Math.asin(n.z);
    var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);
    if (!defined$1(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
  };

  /**
   * 将提供的笛卡尔坐标系数组转换为地理坐标系数组表示。
   * @param {Cartesian3[]} cartesians 笛卡尔坐标位置的数组。
   * @param {Cartographic[]} result <code>optional</code> 存储结果的对象。
   * @returns {Cartographic[]} 修改后的结果参数或者如果没有提供则为新的数组实例。
   *
   * @example
   * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
   * const positions = [new Earth.Cartesian3(17832.12, 83234.52, 952313.73),
   *                  new Earth.Cartesian3(17832.13, 83234.53, 952313.73),
   *                  new Earth.Cartesian3(17832.14, 83234.54, 952313.73)]
   * const cartographicPositions = Earth.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
   */
  Ellipsoid$1.prototype.cartesianArrayToCartographicArray = function (cartesians, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('cartesians', cartesians);
    //>>includeEnd('debug');

    var length = cartesians.length;
    if (!defined$1(result)) {
      result = new Array(length);
    } else {
      result.length = length;
    }
    for (var i = 0; i < length; ++i) {
      result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
    }
    return result;
  };

  /**
   * 沿着地理表面法向量缩放提供的笛卡尔坐标位置，使其位于该椭球体的表面上。如果位置位于椭球体中心，则该函数返回undefined。
   * @param {Cartesian3} cartesian 要缩放的笛卡尔坐标位置。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数，如果没有提供则为新的Cartesian3实例，如果该位置位于椭球体中心，则返回undefined。
   */
  Ellipsoid$1.prototype.scaleToGeodeticSurface = function (cartesian, result) {
    return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);
  };

  /**
   * 沿着地心表面法向量缩放提供的笛卡尔坐标位置，使其位于该椭球体的表面上。
   * @param {Cartesian3} cartesian 要缩放的笛卡尔坐标位置。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或者如果没有提供则为新的Cartesian3实例。
   */
  Ellipsoid$1.prototype.scaleToGeocentricSurface = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    var positionX = cartesian.x;
    var positionY = cartesian.y;
    var positionZ = cartesian.z;
    var oneOverRadiiSquared = this._oneOverRadiiSquared;
    var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
    return Cartesian3.multiplyByScalar(cartesian, beta, result);
  };

  /**
   * 通过将笛卡尔坐标X、Y、Z的各个分量乘以{@link Ellipsoid.oneOverRadii}的结果，将笛卡尔坐标位置转换为椭球体缩放空间。
   * @param {Cartesian3} position 要转换的位置。
   * @param {Cartesian3} result <code>optional</code> 存储结果的位置，如果未定义则创建并返回一个新实例。
   * @returns {Cartesian3} 以缩放空间表示的位置。如果result参数不为undefined，则返回传递的result参数实例，否则返回一个新实例。
   */
  Ellipsoid$1.prototype.transformPositionToScaledSpace = function (position, result) {
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
  };

  /**
   * 通过将笛卡尔坐标X、Y、Z的各个分量乘以{@link Ellipsoid.radii}的结果，将笛卡尔坐标位置从椭球体缩放空间转换为未缩放空间。
   * @param {Cartesian3} position 要转换的位置。
   * @param {Cartesian3} result <code>optional</code> 存储结果的位置，如果未定义则创建并返回一个新实例。
   * @returns {Cartesian3} 以未缩放空间表示的位置。如果result参数不为undefined，则返回传递的result参数实例，否则返回一个新实例。
   */
  Ellipsoid$1.prototype.transformPositionFromScaledSpace = function (position, result) {
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    return Cartesian3.multiplyComponents(position, this._radii, result);
  };

  /**
   * 对比此椭球体和提供的椭球体，逐个分量进行比较，如果它们相等则返回true，否则返回false。
   * @param {Ellipsoid} right <code>optional</code> 另一个椭球体。
   * @returns {Boolean} 如果它们相等则返回true，否则返回false。
   */
  Ellipsoid$1.prototype.equals = function (right) {
    return this === right || defined$1(right) && Cartesian3.equals(this._radii, right._radii);
  };

  /**
   * 以'(radii.x, radii.y, radii.z)'的格式创建一个表示此椭球体的字符串。
   * @returns {String} 一个以'(radii.x, radii.y, radii.z)'的格式表示此椭球体的字符串。
   */
  Ellipsoid$1.prototype.toString = function () {
    return this._radii.toString();
  };

  /**
   * 计算一个点，该点是表面法线与z轴的交点。
   * @param {Cartesian3} position 位置，必须在椭球体表面上。
   * @param {Number} buffer = 0.0 <code>optional</code> 检查点是否在椭球体内时要从椭球体大小中减去的缓冲区。
   *                              
   * @param {Cartesian3} result <code>optional</code> 存储结果的Cartesian对象，如果未提供，则为undefined。
   * @returns {Cartesian3 | undefined} 如果在椭球体内，则为交点，否则为undefined。
   * @exception {DeveloperError} 必须提供位置参数。
   * @exception {DeveloperError} 椭球体必须是旋转椭球体（radii.x == radii.y）。
   * @exception {DeveloperError} Ellipsoid.radii.z 必须大于0。
   */
  Ellipsoid$1.prototype.getSurfaceNormalIntersectionWithZAxis = function (position, buffer, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('position', position);
    if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {
      throw new DeveloperError$1('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');
    }
    Check.typeOf.number.greaterThan('Ellipsoid.radii.z', this._radii.z, 0);
    //>>includeEnd('debug');

    buffer = defaultValue$1(buffer, 0.0);
    var squaredXOverSquaredZ = this._squaredXOverSquaredZ;
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    result.x = 0.0;
    result.y = 0.0;
    result.z = position.z * (1 - squaredXOverSquaredZ);
    if (Math.abs(result.z) >= this._radii.z - buffer) {
      return undefined;
    }
    return result;
  };
  var abscissas = [0.14887433898163, 0.43339539412925, 0.67940956829902, 0.86506336668898, 0.97390652851717, 0.0];
  var weights = [0.29552422471475, 0.26926671930999, 0.21908636251598, 0.14945134915058, 0.066671344308684, 0.0];

  /**
   * 计算给定定积分的10阶 Gauss-Legendre 积分值。
   * @param {Number} a 积分下限。
   * @param {Number} b 积分上限。
   * @param {Ellipsoid~RealValuedScalarFunction} func 要积分的函数。
   * @returns {Number} 在给定区间内给定函数的积分值。
   * @private
   */
  function gaussLegendreQuadrature(a, b, func) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number('a', a);
    Check.typeOf.number('b', b);
    Check.typeOf.func('func', func);
    //>>includeEnd('debug');

    // The range is half of the normal range since the five weights add to one (ten weights add to two).
    // The values of the abscissas are multiplied by two to account for this.
    var xMean = 0.5 * (b + a);
    var xRange = 0.5 * (b - a);
    var sum = 0.0;
    for (var i = 0; i < 5; i++) {
      var dx = xRange * abscissas[i];
      sum += weights[i] * (func(xMean + dx) + func(xMean - dx));
    }

    // Scale the sum to the range of x.
    sum *= xRange;
    return sum;
  }

  /*
   * A real valued scalar function.
   * @callback Ellipsoid~RealValuedScalarFunction
   *
   * @param {Number} x The value used to evaluate the function.
   * @returns {Number} The value of the function at x.
   *
   * @private
   */

  /**
   * 使用高斯-勒让德10阶积分法计算椭球面上矩形的表面积的近似值。
   * @param {Rectangle} rectangle 用于计算表面积的矩形。
   * @returns {Number} 此椭球体表面上矩形的近似面积。
   */
  Ellipsoid$1.prototype.surfaceArea = function (rectangle) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('rectangle', rectangle);
    //>>includeEnd('debug');
    var minLongitude = rectangle.west;
    var maxLongitude = rectangle.east;
    var minLatitude = rectangle.south;
    var maxLatitude = rectangle.north;
    while (maxLongitude < minLongitude) {
      maxLongitude += CesiumMath.TWO_PI;
    }
    var radiiSquared = this._radiiSquared;
    var a2 = radiiSquared.x;
    var b2 = radiiSquared.y;
    var c2 = radiiSquared.z;
    var a2b2 = a2 * b2;
    return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {
      // phi represents the angle measured from the north pole
      // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar
      var sinPhi = Math.cos(lat);
      var cosPhi = Math.sin(lat);
      return Math.cos(lat) * gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {
        var cosTheta = Math.cos(lon);
        var sinTheta = Math.sin(lon);
        return Math.sqrt(a2b2 * cosPhi * cosPhi + c2 * (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) * sinPhi * sinPhi);
      });
    });
  };

  var _ENCODINGS;/**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   */var REVISION='133';var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var PCFShadowMap=1;var PCFSoftShadowMap=2;var VSMShadowMap=3;var FrontSide=0;var BackSide=1;var DoubleSide$1=2;var FlatShading=1;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var CineonToneMapping=3;var ACESFilmicToneMapping=4;var CustomToneMapping=5;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var CubeUVReflectionMapping=306;var CubeUVRefractionMapping=307;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipmapNearestFilter=1004;var NearestMipmapLinearFilter=1005;var LinearFilter=1006;var LinearMipmapNearestFilter=1007;var LinearMipmapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedShort565Type=1019;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var RGBEFormat=RGBAFormat;var DepthFormat=1026;var DepthStencilFormat=1027;var RedFormat=1028;var RedIntegerFormat=1029;var RGFormat=1030;var RGIntegerFormat=1031;var RGBIntegerFormat=1032;var RGBAIntegerFormat=1033;var RGB_S3TC_DXT1_Format=33776;var RGBA_S3TC_DXT1_Format=33777;var RGBA_S3TC_DXT3_Format=33778;var RGBA_S3TC_DXT5_Format=33779;var RGB_PVRTC_4BPPV1_Format=35840;var RGB_PVRTC_2BPPV1_Format=35841;var RGBA_PVRTC_4BPPV1_Format=35842;var RGBA_PVRTC_2BPPV1_Format=35843;var RGB_ETC1_Format=36196;var RGB_ETC2_Format=37492;var RGBA_ETC2_EAC_Format=37496;var RGBA_ASTC_4x4_Format=37808;var RGBA_ASTC_5x4_Format=37809;var RGBA_ASTC_5x5_Format=37810;var RGBA_ASTC_6x5_Format=37811;var RGBA_ASTC_6x6_Format=37812;var RGBA_ASTC_8x5_Format=37813;var RGBA_ASTC_8x6_Format=37814;var RGBA_ASTC_8x8_Format=37815;var RGBA_ASTC_10x5_Format=37816;var RGBA_ASTC_10x6_Format=37817;var RGBA_ASTC_10x8_Format=37818;var RGBA_ASTC_10x10_Format=37819;var RGBA_ASTC_12x10_Format=37820;var RGBA_ASTC_12x12_Format=37821;var RGBA_BPTC_Format=36492;var SRGB8_ALPHA8_ASTC_4x4_Format=37840;var SRGB8_ALPHA8_ASTC_5x4_Format=37841;var SRGB8_ALPHA8_ASTC_5x5_Format=37842;var SRGB8_ALPHA8_ASTC_6x5_Format=37843;var SRGB8_ALPHA8_ASTC_6x6_Format=37844;var SRGB8_ALPHA8_ASTC_8x5_Format=37845;var SRGB8_ALPHA8_ASTC_8x6_Format=37846;var SRGB8_ALPHA8_ASTC_8x8_Format=37847;var SRGB8_ALPHA8_ASTC_10x5_Format=37848;var SRGB8_ALPHA8_ASTC_10x6_Format=37849;var SRGB8_ALPHA8_ASTC_10x8_Format=37850;var SRGB8_ALPHA8_ASTC_10x10_Format=37851;var SRGB8_ALPHA8_ASTC_12x10_Format=37852;var SRGB8_ALPHA8_ASTC_12x12_Format=37853;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var NormalAnimationBlendMode=2500;var AdditiveAnimationBlendMode=2501;var TrianglesDrawMode=0;var TriangleStripDrawMode=1;var TriangleFanDrawMode=2;var LinearEncoding=3000;var sRGBEncoding=3001;var GammaEncoding=3007;var RGBEEncoding=3002;var LogLuvEncoding=3003;var RGBM7Encoding=3004;var RGBM16Encoding=3005;var RGBDEncoding=3006;var BasicDepthPacking=3200;var RGBADepthPacking=3201;var TangentSpaceNormalMap=0;var ObjectSpaceNormalMap=1;var KeepStencilOp=7680;var AlwaysStencilFunc=519;var StaticDrawUsage=35044;var DynamicDrawUsage=35048;var GLSL3='300 es';/**
   * https://github.com/mrdoob/eventdispatcher.js/
   */var EventDispatcher=/*#__PURE__*/function(){function EventDispatcher(){_classCallCheck(this,EventDispatcher);}_createClass(EventDispatcher,[{key:"addEventListener",value:function addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}}},{key:"hasEventListener",value:function hasEventListener(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;}},{key:"removeEventListener",value:function removeEventListener(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}}},{key:"dispatchEvent",value:function dispatchEvent(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;// Make a copy, in case listeners are removed while iterating.
  var array=listenerArray.slice(0);for(var i=0,l=array.length;i<l;i++){array[i].call(this,event);}event.target=null;}}}]);return EventDispatcher;}();var _seed=1234567;var DEG2RAD=Math.PI/180;var RAD2DEG=180/Math.PI;//
  var _lut=[];for(var i$2=0;i$2<256;i$2++){_lut[i$2]=(i$2<16?'0':'')+i$2.toString(16);}var hasRandomUUID=typeof crypto!=='undefined'&&'randomUUID'in crypto;function generateUUID(){if(hasRandomUUID){return crypto.randomUUID().toUpperCase();}// TODO Remove this code when crypto.randomUUID() is available everywhere
  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  var d0=Math.random()*0xffffffff|0;var d1=Math.random()*0xffffffff|0;var d2=Math.random()*0xffffffff|0;var d3=Math.random()*0xffffffff|0;var uuid=_lut[d0&0xff]+_lut[d0>>8&0xff]+_lut[d0>>16&0xff]+_lut[d0>>24&0xff]+'-'+_lut[d1&0xff]+_lut[d1>>8&0xff]+'-'+_lut[d1>>16&0x0f|0x40]+_lut[d1>>24&0xff]+'-'+_lut[d2&0x3f|0x80]+_lut[d2>>8&0xff]+'-'+_lut[d2>>16&0xff]+_lut[d2>>24&0xff]+_lut[d3&0xff]+_lut[d3>>8&0xff]+_lut[d3>>16&0xff]+_lut[d3>>24&0xff];// .toUpperCase() here flattens concatenated strings to save heap memory space.
  return uuid.toUpperCase();}function clamp(value,min,max){return Math.max(min,Math.min(max,value));}// compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  function euclideanModulo(n,m){return (n%m+m)%m;}// Linear mapping from range <a1, a2> to range <b1, b2>
  function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);}// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
  function inverseLerp(x,y,value){if(x!==y){return (value-x)/(y-x);}else {return 0;}}// https://en.wikipedia.org/wiki/Linear_interpolation
  function lerp$1(x,y,t){return (1-t)*x+t*y;}// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
  function damp(x,y,lambda,dt){return lerp$1(x,y,1-Math.exp(-lambda*dt));}// https://www.desmos.com/calculator/vcsjnyz7x4
  function pingpong(x){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;return length-Math.abs(euclideanModulo(x,length*2)-length);}// http://en.wikipedia.org/wiki/Smoothstep
  function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);}function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);}// Random integer from <low, high> interval
  function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));}// Random float from <low, high> interval
  function randFloat(low,high){return low+Math.random()*(high-low);}// Random float from <-range/2, range/2> interval
  function randFloatSpread(range){return range*(0.5-Math.random());}// Deterministic pseudo-random float in the interval [ 0, 1 ]
  function seededRandom(s){if(s!==undefined)_seed=s%2147483647;// Park-Miller algorithm
  _seed=_seed*16807%2147483647;return (_seed-1)/2147483646;}function degToRad$1(degrees){return degrees*DEG2RAD;}function radToDeg$1(radians){return radians*RAD2DEG;}function isPowerOfTwo(value){return (value&value-1)===0&&value!==0;}function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));}function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));}function setQuaternionFromProperEuler(q,a,b,c,order){// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  var cos=Math.cos;var sin=Math.sin;var c2=cos(b/2);var s2=sin(b/2);var c13=cos((a+c)/2);var s13=sin((a+c)/2);var c1_3=cos((a-c)/2);var s1_3=sin((a-c)/2);var c3_1=cos((c-a)/2);var s3_1=sin((c-a)/2);switch(order){case'XYX':q.set(c2*s13,s2*c1_3,s2*s1_3,c2*c13);break;case'YZY':q.set(s2*s1_3,c2*s13,s2*c1_3,c2*c13);break;case'ZXZ':q.set(s2*c1_3,s2*s1_3,c2*s13,c2*c13);break;case'XZX':q.set(c2*s13,s2*s3_1,s2*c3_1,c2*c13);break;case'YXY':q.set(s2*c3_1,c2*s13,s2*s3_1,c2*c13);break;case'ZYZ':q.set(s2*s3_1,s2*c3_1,c2*s13,c2*c13);break;default:console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: '+order);}}var MathUtils=/*#__PURE__*/Object.freeze({__proto__:null,DEG2RAD:DEG2RAD,RAD2DEG:RAD2DEG,generateUUID:generateUUID,clamp:clamp,euclideanModulo:euclideanModulo,mapLinear:mapLinear,inverseLerp:inverseLerp,lerp:lerp$1,damp:damp,pingpong:pingpong,smoothstep:smoothstep,smootherstep:smootherstep,randInt:randInt,randFloat:randFloat,randFloatSpread:randFloatSpread,seededRandom:seededRandom,degToRad:degToRad$1,radToDeg:radToDeg$1,isPowerOfTwo:isPowerOfTwo,ceilPowerOfTwo:ceilPowerOfTwo,floorPowerOfTwo:floorPowerOfTwo,setQuaternionFromProperEuler:setQuaternionFromProperEuler});var Vector2=/*#__PURE__*/function(_Symbol$iterator){function Vector2(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;_classCallCheck(this,Vector2);this.x=x;this.y=y;}_createClass(Vector2,[{key:"width",get:function get(){return this.x;},set:function set(value){this.x=value;}},{key:"height",get:function get(){return this.y;},set:function set(value){this.y=value;}},{key:"set",value:function set(x,y){this.x=x;this.y=y;return this;}},{key:"setScalar",value:function setScalar(scalar){this.x=scalar;this.y=scalar;return this;}},{key:"setX",value:function setX(x){this.x=x;return this;}},{key:"setY",value:function setY(y){this.y=y;return this;}},{key:"setComponent",value:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;}},{key:"getComponent",value:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}}},{key:"clone",value:function clone(){return new this.constructor(this.x,this.y);}},{key:"copy",value:function copy(v){this.x=v.x;this.y=v.y;return this;}},{key:"add",value:function add(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;}},{key:"addScalar",value:function addScalar(s){this.x+=s;this.y+=s;return this;}},{key:"addVectors",value:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;}},{key:"addScaledVector",value:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;}},{key:"sub",value:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;}},{key:"subScalar",value:function subScalar(s){this.x-=s;this.y-=s;return this;}},{key:"subVectors",value:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;}},{key:"multiply",value:function multiply(v){this.x*=v.x;this.y*=v.y;return this;}},{key:"multiplyScalar",value:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;}},{key:"divide",value:function divide(v){this.x/=v.x;this.y/=v.y;return this;}},{key:"divideScalar",value:function divideScalar(scalar){return this.multiplyScalar(1/scalar);}},{key:"applyMatrix3",value:function applyMatrix3(m){var x=this.x,y=this.y;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;}},{key:"min",value:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;}},{key:"max",value:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;}},{key:"clamp",value:function clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;}},{key:"clampScalar",value:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));return this;}},{key:"clampLength",value:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}},{key:"floor",value:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;}},{key:"ceil",value:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;}},{key:"round",value:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;}},{key:"roundToZero",value:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;}},{key:"negate",value:function negate(){this.x=-this.x;this.y=-this.y;return this;}},{key:"dot",value:function dot(v){return this.x*v.x+this.y*v.y;}},{key:"cross",value:function cross(v){return this.x*v.y-this.y*v.x;}},{key:"lengthSq",value:function lengthSq(){return this.x*this.x+this.y*this.y;}},{key:"length",value:function length(){return Math.sqrt(this.x*this.x+this.y*this.y);}},{key:"manhattanLength",value:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);}},{key:"normalize",value:function normalize(){return this.divideScalar(this.length()||1);}},{key:"angle",value:function angle(){// computes the angle in radians with respect to the positive x-axis
  var angle=Math.atan2(-this.y,-this.x)+Math.PI;return angle;}},{key:"distanceTo",value:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}},{key:"distanceToSquared",value:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;}},{key:"manhattanDistanceTo",value:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);}},{key:"setLength",value:function setLength(length){return this.normalize().multiplyScalar(length);}},{key:"lerp",value:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;}},{key:"lerpVectors",value:function lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;return this;}},{key:"equals",value:function equals(v){return v.x===this.x&&v.y===this.y;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;}},{key:"rotateAround",value:function rotateAround(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}},{key:"random",value:function random(){this.x=Math.random();this.y=Math.random();return this;}},{key:_Symbol$iterator,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:_context2.next=2;return this.x;case 2:_context2.next=4;return this.y;case 4:case"end":return _context2.stop();}},value,this);})}]);return Vector2;}(Symbol.iterator);Vector2.prototype.isVector2=true;var Matrix3$1=/*#__PURE__*/function(){function Matrix3(){_classCallCheck(this,Matrix3);this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}_createClass(Matrix3,[{key:"set",value:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;}},{key:"identity",value:function identity(){this.set(1,0,0,0,1,0,0,0,1);return this;}},{key:"copy",value:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;}},{key:"extractBasis",value:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,1);zAxis.setFromMatrix3Column(this,2);return this;}},{key:"setFromMatrix4",value:function setFromMatrix4(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;}},{key:"multiply",value:function multiply(m){return this.multiplyMatrices(this,m);}},{key:"premultiply",value:function premultiply(m){return this.multiplyMatrices(m,this);}},{key:"multiplyMatrices",value:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;}},{key:"multiplyScalar",value:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;}},{key:"determinant",value:function determinant(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;}},{key:"invert",value:function invert(){var te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;}},{key:"transpose",value:function transpose(){var tmp;var m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;}},{key:"getNormalMatrix",value:function getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose();}},{key:"transposeIntoArray",value:function transposeIntoArray(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;}},{key:"setUvTransform",value:function setUvTransform(tx,ty,sx,sy,rotation,cx,cy){var c=Math.cos(rotation);var s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);return this;}},{key:"scale",value:function scale(sx,sy){var te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this;}},{key:"rotate",value:function rotate(theta){var c=Math.cos(theta);var s=Math.sin(theta);var te=this.elements;var a11=te[0],a12=te[3],a13=te[6];var a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+s*a21;te[3]=c*a12+s*a22;te[6]=c*a13+s*a23;te[1]=-s*a11+c*a21;te[4]=-s*a12+c*a22;te[7]=-s*a13+c*a23;return this;}},{key:"translate",value:function translate(tx,ty){var te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this;}},{key:"equals",value:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var _i=0;_i<9;_i++){if(te[_i]!==me[_i])return false;}return true;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;for(var _i2=0;_i2<9;_i2++){this.elements[_i2]=array[_i2+offset];}return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}},{key:"clone",value:function clone(){return new this.constructor().fromArray(this.elements);}}]);return Matrix3;}();Matrix3$1.prototype.isMatrix3=true;function arrayMax(array){if(array.length===0)return -Infinity;var max=array[0];for(var _i3=1,l=array.length;_i3<l;++_i3){if(array[_i3]>max)max=array[_i3];}return max;}function createElementNS(name){return document.createElementNS('http://www.w3.org/1999/xhtml',name);}var _canvas;var ImageUtils=/*#__PURE__*/function(){function ImageUtils(){_classCallCheck(this,ImageUtils);}_createClass(ImageUtils,null,[{key:"getDataURL",value:function getDataURL(image){if(/^data:/i.test(image.src)){return image.src;}if(typeof HTMLCanvasElement=='undefined'){return image.src;}var canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else {if(_canvas===undefined)_canvas=createElementNS('canvas');_canvas.width=image.width;_canvas.height=image.height;var context=_canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else {context.drawImage(image,0,0,image.width,image.height);}canvas=_canvas;}if(canvas.width>2048||canvas.height>2048){console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',image);return canvas.toDataURL('image/jpeg',0.6);}else {return canvas.toDataURL('image/png');}}}]);return ImageUtils;}();var textureId=0;var Texture=/*#__PURE__*/function(_EventDispatcher){_inherits(Texture,_EventDispatcher);var _super=_createSuper(Texture);function Texture(){var _this2;var image=arguments.length>0&&arguments[0]!==undefined?arguments[0]:Texture.DEFAULT_IMAGE;var mapping=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Texture.DEFAULT_MAPPING;var wrapS=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ClampToEdgeWrapping;var wrapT=arguments.length>3&&arguments[3]!==undefined?arguments[3]:ClampToEdgeWrapping;var magFilter=arguments.length>4&&arguments[4]!==undefined?arguments[4]:LinearFilter;var minFilter=arguments.length>5&&arguments[5]!==undefined?arguments[5]:LinearMipmapLinearFilter;var format=arguments.length>6&&arguments[6]!==undefined?arguments[6]:RGBAFormat;var type=arguments.length>7&&arguments[7]!==undefined?arguments[7]:UnsignedByteType;var anisotropy=arguments.length>8&&arguments[8]!==undefined?arguments[8]:1;var encoding=arguments.length>9&&arguments[9]!==undefined?arguments[9]:LinearEncoding;_classCallCheck(this,Texture);_this2=_super.call(this);Object.defineProperty(_assertThisInitialized(_this2),'id',{value:textureId++});_this2.uuid=generateUUID();_this2.name='';_this2.image=image;_this2.mipmaps=[];_this2.mapping=mapping;_this2.wrapS=wrapS;_this2.wrapT=wrapT;_this2.magFilter=magFilter;_this2.minFilter=minFilter;_this2.anisotropy=anisotropy;_this2.format=format;_this2.internalFormat=null;_this2.type=type;_this2.offset=new Vector2(0,0);_this2.repeat=new Vector2(1,1);_this2.center=new Vector2(0,0);_this2.rotation=0;_this2.matrixAutoUpdate=true;_this2.matrix=new Matrix3$1();_this2.generateMipmaps=true;_this2.premultiplyAlpha=false;_this2.flipY=true;_this2.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
  _this2.encoding=encoding;_this2.version=0;_this2.onUpdate=null;_this2.isRenderTargetTexture=false;return _this2;}_createClass(Texture,[{key:"updateMatrix",value:function updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;}},{key:"toJSON",value:function toJSON(meta){var isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==undefined){// TODO: Move to THREE.Image
  var image=this.image;if(image.uuid===undefined){image.uuid=generateUUID();// UGH
  }if(!isRootObject&&meta.images[image.uuid]===undefined){var url;if(Array.isArray(image)){// process array of images e.g. CubeTexture
  url=[];for(var _i4=0,l=image.length;_i4<l;_i4++){// check cube texture with data textures
  if(image[_i4].isDataTexture){url.push(serializeImage(image[_i4].image));}else {url.push(serializeImage(image[_i4]));}}}else {// process single image
  url=serializeImage(image);}meta.images[image.uuid]={uuid:image.uuid,url:url};}output.image=image.uuid;}if(!isRootObject){meta.textures[this.uuid]=output;}return output;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}},{key:"transformUv",value:function transformUv(uv){if(this.mapping!==UVMapping)return uv;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else {uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else {uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}return uv;}},{key:"needsUpdate",set:function set(value){if(value===true)this.version++;}}]);return Texture;}(EventDispatcher);Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Texture.prototype.isTexture=true;function serializeImage(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){// default images
  return ImageUtils.getDataURL(image);}else {if(image.data){// images of DataTexture
  return {data:Array.prototype.slice.call(image.data),width:image.width,height:image.height,type:image.data.constructor.name};}else {console.warn('THREE.Texture: Unable to serialize Texture.');return {};}}}var Vector4=/*#__PURE__*/function(_Symbol$iterator2){function Vector4(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,Vector4);this.x=x;this.y=y;this.z=z;this.w=w;}_createClass(Vector4,[{key:"width",get:function get(){return this.z;},set:function set(value){this.z=value;}},{key:"height",get:function get(){return this.w;},set:function set(value){this.w=value;}},{key:"set",value:function set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;}},{key:"setScalar",value:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;}},{key:"setX",value:function setX(x){this.x=x;return this;}},{key:"setY",value:function setY(y){this.y=y;return this;}},{key:"setZ",value:function setZ(z){this.z=z;return this;}},{key:"setW",value:function setW(w){this.w=w;return this;}},{key:"setComponent",value:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;}},{key:"getComponent",value:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}}},{key:"clone",value:function clone(){return new this.constructor(this.x,this.y,this.z,this.w);}},{key:"copy",value:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;}},{key:"add",value:function add(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;}},{key:"addScalar",value:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;}},{key:"addVectors",value:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;}},{key:"addScaledVector",value:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;}},{key:"sub",value:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;}},{key:"subScalar",value:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;}},{key:"subVectors",value:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;}},{key:"multiply",value:function multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;this.w*=v.w;return this;}},{key:"multiplyScalar",value:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;}},{key:"applyMatrix4",value:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;}},{key:"divideScalar",value:function divideScalar(scalar){return this.multiplyScalar(1/scalar);}},{key:"setAxisAngleFromQuaternion",value:function setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
  // q is assumed to be normalized
  this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else {this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;}},{key:"setAxisAngleFromRotationMatrix",value:function setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var angle,x,y,z;// variables for result
  var epsilon=0.01,// margin to allow for rounding errors
  epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
  te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
  // first check for identity matrix which must have +1 for all terms
  // in leading diagonal and zero in other terms
  if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
  this.set(1,0,0,0);return this;// zero angle, arbitrary axis
  }// otherwise this singularity is angle = 180
  angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
  if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else {x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
  if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else {y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else {// m33 is the largest diagonal term so base result on this
  if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else {z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
  }// as we have reached here there are no singularities so we can handle normally
  var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
  if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
  // caught by singularity test above, but I've left it in just in case
  this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;}},{key:"min",value:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;}},{key:"max",value:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;}},{key:"clamp",value:function clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;}},{key:"clampScalar",value:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));this.w=Math.max(minVal,Math.min(maxVal,this.w));return this;}},{key:"clampLength",value:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}},{key:"floor",value:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;}},{key:"ceil",value:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;}},{key:"round",value:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;}},{key:"roundToZero",value:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;}},{key:"negate",value:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;}},{key:"dot",value:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;}},{key:"lengthSq",value:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;}},{key:"length",value:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);}},{key:"manhattanLength",value:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);}},{key:"normalize",value:function normalize(){return this.divideScalar(this.length()||1);}},{key:"setLength",value:function setLength(length){return this.normalize().multiplyScalar(length);}},{key:"lerp",value:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;}},{key:"lerpVectors",value:function lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;this.w=v1.w+(v2.w-v1.w)*alpha;return this;}},{key:"equals",value:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}},{key:"random",value:function random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();this.w=Math.random();return this;}},{key:_Symbol$iterator2,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:_context3.next=2;return this.x;case 2:_context3.next=4;return this.y;case 4:_context3.next=6;return this.z;case 6:_context3.next=8;return this.w;case 8:case"end":return _context3.stop();}},value,this);})}]);return Vector4;}(Symbol.iterator);Vector4.prototype.isVector4=true;/*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */var WebGLRenderTarget=/*#__PURE__*/function(_EventDispatcher2){_inherits(WebGLRenderTarget,_EventDispatcher2);var _super2=_createSuper(WebGLRenderTarget);function WebGLRenderTarget(width,height){var _this3;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,WebGLRenderTarget);_this3=_super2.call(this);_this3.width=width;_this3.height=height;_this3.depth=1;_this3.scissor=new Vector4(0,0,width,height);_this3.scissorTest=false;_this3.viewport=new Vector4(0,0,width,height);_this3.texture=new Texture(undefined,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);_this3.texture.isRenderTargetTexture=true;_this3.texture.image={width:width,height:height,depth:1};_this3.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;_this3.texture.internalFormat=options.internalFormat!==undefined?options.internalFormat:null;_this3.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;_this3.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;_this3.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:false;_this3.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;return _this3;}_createClass(WebGLRenderTarget,[{key:"setTexture",value:function setTexture(texture){texture.image={width:this.width,height:this.height,depth:this.depth};this.texture=texture;}},{key:"setSize",value:function setSize(width,height){var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;this.texture.image.width=width;this.texture.image.height=height;this.texture.image.depth=depth;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){this.width=source.width;this.height=source.height;this.depth=source.depth;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.texture.image=_objectSpread2({},this.texture.image);// See #20328.
  this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}}]);return WebGLRenderTarget;}(EventDispatcher);WebGLRenderTarget.prototype.isWebGLRenderTarget=true;var WebGLMultisampleRenderTarget=/*#__PURE__*/function(_WebGLRenderTarget2){_inherits(WebGLMultisampleRenderTarget,_WebGLRenderTarget2);var _super4=_createSuper(WebGLMultisampleRenderTarget);function WebGLMultisampleRenderTarget(width,height,options){var _this5;_classCallCheck(this,WebGLMultisampleRenderTarget);_this5=_super4.call(this,width,height,options);_this5.samples=4;return _this5;}_createClass(WebGLMultisampleRenderTarget,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(WebGLMultisampleRenderTarget.prototype),"copy",this).call(this,source);this.samples=source.samples;return this;}}]);return WebGLMultisampleRenderTarget;}(WebGLRenderTarget);WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget=true;var Quaternion=/*#__PURE__*/function(){function Quaternion(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,Quaternion);this._x=x;this._y=y;this._z=z;this._w=w;}_createClass(Quaternion,[{key:"x",get:function get(){return this._x;},set:function set(value){this._x=value;this._onChangeCallback();}},{key:"y",get:function get(){return this._y;},set:function set(value){this._y=value;this._onChangeCallback();}},{key:"z",get:function get(){return this._z;},set:function set(value){this._z=value;this._onChangeCallback();}},{key:"w",get:function get(){return this._w;},set:function set(value){this._w=value;this._onChangeCallback();}},{key:"set",value:function set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this;}},{key:"clone",value:function clone(){return new this.constructor(this._x,this._y,this._z,this._w);}},{key:"copy",value:function copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this;}},{key:"setFromEuler",value:function setFromEuler(euler,update){if(!(euler&&euler.isEuler)){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}var x=euler._x,y=euler._y,z=euler._z,order=euler._order;// http://www.mathworks.com/matlabcentral/fileexchange/
  // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  //	content/SpinCalc.m
  var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);switch(order){case'XYZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'YXZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'ZXY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'ZYX':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'YZX':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'XZY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;default:console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: '+order);}if(update!==false)this._onChangeCallback();return this;}},{key:"setFromAxisAngle",value:function setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
  // assumes axis is normalized
  var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this._onChangeCallback();return this;}},{key:"setFromRotationMatrix",value:function setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){var s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){var _s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/_s;this._x=0.25*_s;this._y=(m12+m21)/_s;this._z=(m13+m31)/_s;}else if(m22>m33){var _s2=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/_s2;this._x=(m12+m21)/_s2;this._y=0.25*_s2;this._z=(m23+m32)/_s2;}else {var _s3=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/_s3;this._x=(m13+m31)/_s3;this._y=(m23+m32)/_s3;this._z=0.25*_s3;}this._onChangeCallback();return this;}},{key:"setFromUnitVectors",value:function setFromUnitVectors(vFrom,vTo){// assumes direction vectors vFrom and vTo are normalized
  var r=vFrom.dot(vTo)+1;if(r<Number.EPSILON){// vFrom and vTo point in opposite directions
  r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){this._x=-vFrom.y;this._y=vFrom.x;this._z=0;this._w=r;}else {this._x=0;this._y=-vFrom.z;this._z=vFrom.y;this._w=r;}}else {// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
  this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;this._w=r;}return this.normalize();}},{key:"angleTo",value:function angleTo(q){return 2*Math.acos(Math.abs(clamp(this.dot(q),-1,1)));}},{key:"rotateTowards",value:function rotateTowards(q,step){var angle=this.angleTo(q);if(angle===0)return this;var t=Math.min(1,step/angle);this.slerp(q,t);return this;}},{key:"identity",value:function identity(){return this.set(0,0,0,1);}},{key:"invert",value:function invert(){// quaternion is assumed to have unit length
  return this.conjugate();}},{key:"conjugate",value:function conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this;}},{key:"dot",value:function dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;}},{key:"lengthSq",value:function lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;}},{key:"length",value:function length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);}},{key:"normalize",value:function normalize(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else {l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this._onChangeCallback();return this;}},{key:"multiply",value:function multiply(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);}},{key:"premultiply",value:function premultiply(q){return this.multiplyQuaternions(q,this);}},{key:"multiplyQuaternions",value:function multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
  var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this;}},{key:"slerp",value:function slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
  var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else {this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sqrSinHalfTheta=1.0-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=Number.EPSILON){var s=1-t;this._w=s*w+t*this._w;this._x=s*x+t*this._x;this._y=s*y+t*this._y;this._z=s*z+t*this._z;this.normalize();this._onChangeCallback();return this;}var sinHalfTheta=Math.sqrt(sqrSinHalfTheta);var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this._onChangeCallback();return this;}},{key:"slerpQuaternions",value:function slerpQuaternions(qa,qb,t){this.copy(qa).slerp(qb,t);}},{key:"random",value:function random(){// Derived from http://planning.cs.uiuc.edu/node198.html
  // Note, this source uses w, x, y, z ordering,
  // so we swap the order below.
  var u1=Math.random();var sqrt1u1=Math.sqrt(1-u1);var sqrtu1=Math.sqrt(u1);var u2=2*Math.PI*Math.random();var u3=2*Math.PI*Math.random();return this.set(sqrt1u1*Math.cos(u2),sqrtu1*Math.sin(u3),sqrtu1*Math.cos(u3),sqrt1u1*Math.sin(u2));}},{key:"equals",value:function equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);return this;}},{key:"_onChange",value:function _onChange(callback){this._onChangeCallback=callback;return this;}},{key:"_onChangeCallback",value:function _onChangeCallback(){}}],[{key:"slerp",value:function slerp(qa,qb,qm,t){console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');return qm.slerpQuaternions(qa,qb,t);}},{key:"slerpFlat",value:function slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
  var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3];var x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(t===0){dst[dstOffset+0]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;return;}if(t===1){dst[dstOffset+0]=x1;dst[dstOffset+1]=y1;dst[dstOffset+2]=z1;dst[dstOffset+3]=w1;return;}if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t;var cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
  if(sqrSin>Number.EPSILON){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
  if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}},{key:"multiplyQuaternionsFlat",value:function multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){var x0=src0[srcOffset0];var y0=src0[srcOffset0+1];var z0=src0[srcOffset0+2];var w0=src0[srcOffset0+3];var x1=src1[srcOffset1];var y1=src1[srcOffset1+1];var z1=src1[srcOffset1+2];var w1=src1[srcOffset1+3];dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1;dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1;dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1;dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1;return dst;}}]);return Quaternion;}();Quaternion.prototype.isQuaternion=true;var Vector3=/*#__PURE__*/function(_Symbol$iterator3){function Vector3(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;_classCallCheck(this,Vector3);this.x=x;this.y=y;this.z=z;}_createClass(Vector3,[{key:"set",value:function set(x,y,z){if(z===undefined)z=this.z;// sprite.scale.set(x,y)
  this.x=x;this.y=y;this.z=z;return this;}},{key:"setScalar",value:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;}},{key:"setX",value:function setX(x){this.x=x;return this;}},{key:"setY",value:function setY(y){this.y=y;return this;}},{key:"setZ",value:function setZ(z){this.z=z;return this;}},{key:"setComponent",value:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;}},{key:"getComponent",value:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}}},{key:"clone",value:function clone(){return new this.constructor(this.x,this.y,this.z);}},{key:"copy",value:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;}},{key:"add",value:function add(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}},{key:"addScalar",value:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;}},{key:"addVectors",value:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;}},{key:"addScaledVector",value:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;}},{key:"sub",value:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}},{key:"subScalar",value:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;}},{key:"subVectors",value:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;}},{key:"multiply",value:function multiply(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;}},{key:"multiplyScalar",value:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;}},{key:"multiplyVectors",value:function multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;}},{key:"applyEuler",value:function applyEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(_quaternion$4.setFromEuler(euler));}},{key:"applyAxisAngle",value:function applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle));}},{key:"applyMatrix3",value:function applyMatrix3(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;}},{key:"applyNormalMatrix",value:function applyNormalMatrix(m){return this.applyMatrix3(m).normalize();}},{key:"applyMatrix4",value:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;var w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;}},{key:"applyQuaternion",value:function applyQuaternion(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
  var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
  this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;}},{key:"project",value:function project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);}},{key:"unproject",value:function unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);}},{key:"transformDirection",value:function transformDirection(m){// input: THREE.Matrix4 affine matrix
  // vector interpreted as a direction
  var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();}},{key:"divide",value:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;}},{key:"divideScalar",value:function divideScalar(scalar){return this.multiplyScalar(1/scalar);}},{key:"min",value:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;}},{key:"max",value:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;}},{key:"clamp",value:function clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;}},{key:"clampScalar",value:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));return this;}},{key:"clampLength",value:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}},{key:"floor",value:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;}},{key:"ceil",value:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;}},{key:"round",value:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;}},{key:"roundToZero",value:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;}},{key:"negate",value:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;}},{key:"dot",value:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}// TODO lengthSquared?
  },{key:"lengthSq",value:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;}},{key:"length",value:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);}},{key:"manhattanLength",value:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);}},{key:"normalize",value:function normalize(){return this.divideScalar(this.length()||1);}},{key:"setLength",value:function setLength(length){return this.normalize().multiplyScalar(length);}},{key:"lerp",value:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;}},{key:"lerpVectors",value:function lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;return this;}},{key:"cross",value:function cross(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}return this.crossVectors(this,v);}},{key:"crossVectors",value:function crossVectors(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;}},{key:"projectOnVector",value:function projectOnVector(v){var denominator=v.lengthSq();if(denominator===0)return this.set(0,0,0);var scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar);}},{key:"projectOnPlane",value:function projectOnPlane(planeNormal){_vector$c.copy(this).projectOnVector(planeNormal);return this.sub(_vector$c);}},{key:"reflect",value:function reflect(normal){// reflect incident vector off plane orthogonal to normal
  // normal is assumed to have unit length
  return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)));}},{key:"angleTo",value:function angleTo(v){var denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;var theta=this.dot(v)/denominator;// clamp, to handle numerical problems
  return Math.acos(clamp(theta,-1,1));}},{key:"distanceTo",value:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}},{key:"distanceToSquared",value:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;}},{key:"manhattanDistanceTo",value:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);}},{key:"setFromSpherical",value:function setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta);}},{key:"setFromSphericalCoords",value:function setFromSphericalCoords(radius,phi,theta){var sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this;}},{key:"setFromCylindrical",value:function setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y);}},{key:"setFromCylindricalCoords",value:function setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this;}},{key:"setFromMatrixPosition",value:function setFromMatrixPosition(m){var e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;}},{key:"setFromMatrixScale",value:function setFromMatrixScale(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;}},{key:"setFromMatrixColumn",value:function setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);}},{key:"setFromMatrix3Column",value:function setFromMatrix3Column(m,index){return this.fromArray(m.elements,index*3);}},{key:"equals",value:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}},{key:"random",value:function random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this;}},{key:"randomDirection",value:function randomDirection(){// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
  var u=(Math.random()-0.5)*2;var t=Math.random()*Math.PI*2;var f=Math.sqrt(1-Math.pow(u,2));this.x=f*Math.cos(t);this.y=f*Math.sin(t);this.z=u;return this;}},{key:_Symbol$iterator3,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context4){while(1)switch(_context4.prev=_context4.next){case 0:_context4.next=2;return this.x;case 2:_context4.next=4;return this.y;case 4:_context4.next=6;return this.z;case 6:case"end":return _context4.stop();}},value,this);})}]);return Vector3;}(Symbol.iterator);Vector3.prototype.isVector3=true;var _vector$c=/*@__PURE__*/new Vector3();var _quaternion$4=/*@__PURE__*/new Quaternion();var Box3=/*#__PURE__*/function(){function Box3(){var min=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3(+Infinity,+Infinity,+Infinity);var max=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3(-Infinity,-Infinity,-Infinity);_classCallCheck(this,Box3);this.min=min;this.max=max;}_createClass(Box3,[{key:"set",value:function set(min,max){this.min.copy(min);this.max.copy(max);return this;}},{key:"setFromArray",value:function setFromArray(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var _i8=0,l=array.length;_i8<l;_i8+=3){var x=array[_i8];var y=array[_i8+1];var z=array[_i8+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}},{key:"setFromBufferAttribute",value:function setFromBufferAttribute(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var _i9=0,l=attribute.count;_i9<l;_i9++){var x=attribute.getX(_i9);var y=attribute.getY(_i9);var z=attribute.getZ(_i9);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}},{key:"setFromPoints",value:function setFromPoints(points){this.makeEmpty();for(var _i10=0,il=points.length;_i10<il;_i10++){this.expandByPoint(points[_i10]);}return this;}},{key:"setFromCenterAndSize",value:function setFromCenterAndSize(center,size){var halfSize=_vector$b.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}},{key:"setFromObject",value:function setFromObject(object){this.makeEmpty();return this.expandByObject(object);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}},{key:"makeEmpty",value:function makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;}},{key:"isEmpty",value:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
  return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;}},{key:"getCenter",value:function getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}},{key:"getSize",value:function getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);}},{key:"expandByPoint",value:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;}},{key:"expandByVector",value:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}},{key:"expandByScalar",value:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}},{key:"expandByObject",value:function expandByObject(object){// Computes the world-axis-aligned bounding box of an object (including its children),
  // accounting for both the object's, and children's, world transforms
  object.updateWorldMatrix(false,false);var geometry=object.geometry;if(geometry!==undefined){if(geometry.boundingBox===null){geometry.computeBoundingBox();}_box$3.copy(geometry.boundingBox);_box$3.applyMatrix4(object.matrixWorld);this.union(_box$3);}var children=object.children;for(var _i11=0,l=children.length;_i11<l;_i11++){this.expandByObject(children[_i11]);}return this;}},{key:"containsPoint",value:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;}},{key:"containsBox",value:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;}},{key:"getParameter",value:function getParameter(point,target){// This can potentially have a divide by zero if the box
  // has a size dimension of 0.
  return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));}},{key:"intersectsBox",value:function intersectsBox(box){// using 6 splitting planes to rule out intersections.
  return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;}},{key:"intersectsSphere",value:function intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
  this.clampPoint(sphere.center,_vector$b);// If that point is inside the sphere, the AABB and sphere intersect.
  return _vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;}},{key:"intersectsPlane",value:function intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
  // are on the same side (back or front) of the plane, then there is no intersection.
  var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else {min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else {min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else {min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;}},{key:"intersectsTriangle",value:function intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
  this.getCenter(_center);_extents.subVectors(this.max,_center);// translate triangle to aabb origin
  _v0$2.subVectors(triangle.a,_center);_v1$7.subVectors(triangle.b,_center);_v2$3.subVectors(triangle.c,_center);// compute edge vectors for triangle
  _f0.subVectors(_v1$7,_v0$2);_f1.subVectors(_v2$3,_v1$7);_f2.subVectors(_v0$2,_v2$3);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  var axes=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// test 3 face normals from the aabb
  axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// finally testing the face normal of the triangle
  // use already existing triangle edge vectors here
  _triangleNormal.crossVectors(_f0,_f1);axes=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z];return satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents);}},{key:"clampPoint",value:function clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}},{key:"distanceToPoint",value:function distanceToPoint(point){var clampedPoint=_vector$b.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();}},{key:"getBoundingSphere",value:function getBoundingSphere(target){this.getCenter(target.center);target.radius=this.getSize(_vector$b).length()*0.5;return target;}},{key:"intersect",value:function intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  if(this.isEmpty())this.makeEmpty();return this;}},{key:"union",value:function union(box){this.min.min(box.min);this.max.max(box.max);return this;}},{key:"applyMatrix4",value:function applyMatrix4(matrix){// transform of empty box is an empty box.
  if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  _points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
  _points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
  _points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
  _points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
  _points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
  _points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
  _points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
  _points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
  this.setFromPoints(_points);return this;}},{key:"translate",value:function translate(offset){this.min.add(offset);this.max.add(offset);return this;}},{key:"equals",value:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}}]);return Box3;}();Box3.prototype.isBox3=true;var _points=[/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3()];var _vector$b=/*@__PURE__*/new Vector3();var _box$3=/*@__PURE__*/new Box3();// triangle centered vertices
  var _v0$2=/*@__PURE__*/new Vector3();var _v1$7=/*@__PURE__*/new Vector3();var _v2$3=/*@__PURE__*/new Vector3();// triangle edge vectors
  var _f0=/*@__PURE__*/new Vector3();var _f1=/*@__PURE__*/new Vector3();var _f2=/*@__PURE__*/new Vector3();var _center=/*@__PURE__*/new Vector3();var _extents=/*@__PURE__*/new Vector3();var _triangleNormal=/*@__PURE__*/new Vector3();var _testAxis=/*@__PURE__*/new Vector3();function satForAxes(axes,v0,v1,v2,extents){for(var _i12=0,j=axes.length-3;_i12<=j;_i12+=3){_testAxis.fromArray(axes,_i12);// project the aabb onto the seperating axis
  var r=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z);// project all 3 vertices of the triangle onto the seperating axis
  var p0=v0.dot(_testAxis);var p1=v1.dot(_testAxis);var p2=v2.dot(_testAxis);// actual test, basically see if either of the most extreme of the triangle points intersects r
  if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
  // the axis is seperating and we can exit
  return false;}}return true;}var _box$2=/*@__PURE__*/new Box3();var _v1$6=/*@__PURE__*/new Vector3();var _toFarthestPoint=/*@__PURE__*/new Vector3();var _toPoint=/*@__PURE__*/new Vector3();var Sphere=/*#__PURE__*/function(){function Sphere(){var center=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var radius=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-1;_classCallCheck(this,Sphere);this.center=center;this.radius=radius;}_createClass(Sphere,[{key:"set",value:function set(center,radius){this.center.copy(center);this.radius=radius;return this;}},{key:"setFromPoints",value:function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else {_box$2.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var _i13=0,il=points.length;_i13<il;_i13++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[_i13]));}this.radius=Math.sqrt(maxRadiusSq);return this;}},{key:"copy",value:function copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;}},{key:"isEmpty",value:function isEmpty(){return this.radius<0;}},{key:"makeEmpty",value:function makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this;}},{key:"containsPoint",value:function containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;}},{key:"distanceToPoint",value:function distanceToPoint(point){return point.distanceTo(this.center)-this.radius;}},{key:"intersectsSphere",value:function intersectsSphere(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;}},{key:"intersectsBox",value:function intersectsBox(box){return box.intersectsSphere(this);}},{key:"intersectsPlane",value:function intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;}},{key:"clampPoint",value:function clampPoint(point,target){var deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;}},{key:"getBoundingBox",value:function getBoundingBox(target){if(this.isEmpty()){// Empty sphere produces empty bounding box
  target.makeEmpty();return target;}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;}},{key:"applyMatrix4",value:function applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;}},{key:"translate",value:function translate(offset){this.center.add(offset);return this;}},{key:"expandByPoint",value:function expandByPoint(point){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
  _toPoint.subVectors(point,this.center);var lengthSq=_toPoint.lengthSq();if(lengthSq>this.radius*this.radius){var length=Math.sqrt(lengthSq);var missingRadiusHalf=(length-this.radius)*0.5;// Nudge this sphere towards the target point. Add half the missing distance to radius,
  // and the other half to position. This gives a tighter enclosure, instead of if
  // the whole missing distance were just added to radius.
  this.center.add(_toPoint.multiplyScalar(missingRadiusHalf/length));this.radius+=missingRadiusHalf;}return this;}},{key:"union",value:function union(sphere){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
  // To enclose another sphere into this sphere, we only need to enclose two points:
  // 1) Enclose the farthest point on the other sphere into this sphere.
  // 2) Enclose the opposite point of the farthest point into this sphere.
  _toFarthestPoint.subVectors(sphere.center,this.center).normalize().multiplyScalar(sphere.radius);this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));return this;}},{key:"equals",value:function equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Sphere;}();var _vector$a=/*@__PURE__*/new Vector3();var _segCenter=/*@__PURE__*/new Vector3();var _segDir=/*@__PURE__*/new Vector3();var _diff=/*@__PURE__*/new Vector3();var _edge1=/*@__PURE__*/new Vector3();var _edge2=/*@__PURE__*/new Vector3();var _normal$1=/*@__PURE__*/new Vector3();var Ray=/*#__PURE__*/function(){function Ray(){var origin=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var direction=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3(0,0,-1);_classCallCheck(this,Ray);this.origin=origin;this.direction=direction;}_createClass(Ray,[{key:"set",value:function set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;}},{key:"copy",value:function copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;}},{key:"at",value:function at(t,target){return target.copy(this.direction).multiplyScalar(t).add(this.origin);}},{key:"lookAt",value:function lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;}},{key:"recast",value:function recast(t){this.origin.copy(this.at(t,_vector$a));return this;}},{key:"closestPointToPoint",value:function closestPointToPoint(point,target){target.subVectors(point,this.origin);var directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);}},{key:"distanceToPoint",value:function distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));}},{key:"distanceSqToPoint",value:function distanceSqToPoint(point){var directionDistance=_vector$a.subVectors(point,this.origin).dot(this.direction);// point behind the ray
  if(directionDistance<0){return this.origin.distanceToSquared(point);}_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return _vector$a.distanceToSquared(point);}},{key:"distanceSqToSegment",value:function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  // It returns the min distance between the ray and the segment
  // defined by v0 and v1
  // It can also set two optional targets :
  // - The closest point on the ray
  // - The closest point on the segment
  _segCenter.copy(v0).add(v1).multiplyScalar(0.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(_segDir);var b0=_diff.dot(this.direction);var b1=-_diff.dot(_segDir);var c=_diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
  s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
  // Minimum at interior points of ray and segment.
  var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else {// region 1
  s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {// region 5
  s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {if(s1<=-extDet){// region 4
  s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
  s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else {// region 2
  s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else {// Ray and segment are parallel.
  s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);}return sqrDist;}},{key:"intersectSphere",value:function intersectSphere(sphere,target){_vector$a.subVectors(sphere.center,this.origin);var tca=_vector$a.dot(this.direction);var d2=_vector$a.dot(_vector$a)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
  var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
  var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
  if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
  // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  // in order to always return an intersect point that is in front of the ray.
  if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
  return this.at(t0,target);}},{key:"intersectsSphere",value:function intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;}},{key:"distanceToPlane",value:function distanceToPlane(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
  if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
  return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
  return t>=0?t:null;}},{key:"intersectPlane",value:function intersectPlane(plane,target){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);}},{key:"intersectsPlane",value:function intersectsPlane(plane){// check if the ray lies on the plane first
  var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
  return false;}},{key:"intersectBox",value:function intersectBox(box,target){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else {tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else {tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
  // (result of 0 * Infinity). x !== x returns true if x is NaN
  if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else {tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
  if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);}},{key:"intersectsBox",value:function intersectsBox(box){return this.intersectBox(box,_vector$a)!==null;}},{key:"intersectTriangle",value:function intersectTriangle(a,b,c,backfaceCulling,target){// Compute the offset origin, edges, and normal.
  // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
  _edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal$1.crossVectors(_edge1,_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  var DdN=this.direction.dot(_normal$1);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else {return null;}_diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));// b1 < 0, no intersection
  if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));// b2 < 0, no intersection
  if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
  if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
  var QdN=-sign*_diff.dot(_normal$1);// t < 0, no intersection
  if(QdN<0){return null;}// Ray intersects triangle.
  return this.at(QdN/DdN,target);}},{key:"applyMatrix4",value:function applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;}},{key:"equals",value:function equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Ray;}();var Matrix4$1=/*#__PURE__*/function(){function Matrix4(){_classCallCheck(this,Matrix4);this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}_createClass(Matrix4,[{key:"set",value:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;}},{key:"identity",value:function identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;}},{key:"clone",value:function clone(){return new Matrix4().fromArray(this.elements);}},{key:"copy",value:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;}},{key:"copyPosition",value:function copyPosition(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;}},{key:"setFromMatrix3",value:function setFromMatrix3(m){var me=m.elements;this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1);return this;}},{key:"extractBasis",value:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;}},{key:"makeBasis",value:function makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;}},{key:"extractRotation",value:function extractRotation(m){// this method does not support reflection matrices
  var te=this.elements;var me=m.elements;var scaleX=1/_v1$5.setFromMatrixColumn(m,0).length();var scaleY=1/_v1$5.setFromMatrixColumn(m,1).length();var scaleZ=1/_v1$5.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}},{key:"makeRotationFromEuler",value:function makeRotationFromEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var _ce=c*e,_cf=c*f,_de=d*e,_df=d*f;te[0]=_ce-_df*b;te[4]=-a*f;te[8]=_de+_cf*b;te[1]=_cf+_de*b;te[5]=a*e;te[9]=_df-_ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var _ae=a*e,_af=a*f,_be=b*e,_bf=b*f;te[0]=c*e;te[4]=_be*d-_af;te[8]=_ae*d+_bf;te[1]=c*f;te[5]=_bf*d+_ae;te[9]=_af*d-_be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var _ac=a*c,_ad=a*d,_bc=b*c,_bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=_ac*f+_bd;te[5]=a*e;te[9]=_ad*f-_bc;te[2]=_bc*f-_ad;te[6]=b*e;te[10]=_bd*f+_ac;}// bottom row
  te[3]=0;te[7]=0;te[11]=0;// last column
  te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}},{key:"makeRotationFromQuaternion",value:function makeRotationFromQuaternion(q){return this.compose(_zero,q,_one);}},{key:"lookAt",value:function lookAt(eye,target,up){var te=this.elements;_z.subVectors(eye,target);if(_z.lengthSq()===0){// eye and target are in the same position
  _z.z=1;}_z.normalize();_x.crossVectors(up,_z);if(_x.lengthSq()===0){// up and z are parallel
  if(Math.abs(up.z)===1){_z.x+=0.0001;}else {_z.z+=0.0001;}_z.normalize();_x.crossVectors(up,_z);}_x.normalize();_y.crossVectors(_z,_x);te[0]=_x.x;te[4]=_y.x;te[8]=_z.x;te[1]=_x.y;te[5]=_y.y;te[9]=_z.y;te[2]=_x.z;te[6]=_y.z;te[10]=_z.z;return this;}},{key:"multiply",value:function multiply(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);}},{key:"premultiply",value:function premultiply(m){return this.multiplyMatrices(m,this);}},{key:"multiplyMatrices",value:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;}},{key:"multiplyScalar",value:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;}},{key:"determinant",value:function determinant(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
  //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
  return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);}},{key:"transpose",value:function transpose(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;}},{key:"setPosition",value:function setPosition(x,y,z){var te=this.elements;if(x.isVector3){te[12]=x.x;te[13]=x.y;te[14]=x.z;}else {te[12]=x;te[13]=y;te[14]=z;}return this;}},{key:"invert",value:function invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  var te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;}},{key:"scale",value:function scale(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;}},{key:"getMaxScaleOnAxis",value:function getMaxScaleOnAxis(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));}},{key:"makeTranslation",value:function makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;}},{key:"makeRotationX",value:function makeRotationX(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;}},{key:"makeRotationY",value:function makeRotationY(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;}},{key:"makeRotationZ",value:function makeRotationZ(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;}},{key:"makeRotationAxis",value:function makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
  var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;}},{key:"makeScale",value:function makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;}},{key:"makeShear",value:function makeShear(xy,xz,yx,yz,zx,zy){this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1);return this;}},{key:"compose",value:function compose(position,quaternion,scale){var te=this.elements;var x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;var sx=scale.x,sy=scale.y,sz=scale.z;te[0]=(1-(yy+zz))*sx;te[1]=(xy+wz)*sx;te[2]=(xz-wy)*sx;te[3]=0;te[4]=(xy-wz)*sy;te[5]=(1-(xx+zz))*sy;te[6]=(yz+wx)*sy;te[7]=0;te[8]=(xz+wy)*sz;te[9]=(yz-wx)*sz;te[10]=(1-(xx+yy))*sz;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;te[15]=1;return this;}},{key:"decompose",value:function decompose(position,quaternion,scale){var te=this.elements;var sx=_v1$5.set(te[0],te[1],te[2]).length();var sy=_v1$5.set(te[4],te[5],te[6]).length();var sz=_v1$5.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
  var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
  _m1$2.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;_m1$2.elements[0]*=invSX;_m1$2.elements[1]*=invSX;_m1$2.elements[2]*=invSX;_m1$2.elements[4]*=invSY;_m1$2.elements[5]*=invSY;_m1$2.elements[6]*=invSY;_m1$2.elements[8]*=invSZ;_m1$2.elements[9]*=invSZ;_m1$2.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1$2);scale.x=sx;scale.y=sy;scale.z=sz;return this;}},{key:"makePerspective",value:function makePerspective(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;}},{key:"makeOrthographic",value:function makeOrthographic(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;}},{key:"equals",value:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var _i14=0;_i14<16;_i14++){if(te[_i14]!==me[_i14])return false;}return true;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;for(var _i15=0;_i15<16;_i15++){this.elements[_i15]=array[_i15+offset];}return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}}]);return Matrix4;}();Matrix4$1.prototype.isMatrix4=true;var _v1$5=/*@__PURE__*/new Vector3();var _m1$2=/*@__PURE__*/new Matrix4$1();var _zero=/*@__PURE__*/new Vector3(0,0,0);var _one=/*@__PURE__*/new Vector3(1,1,1);var _x=/*@__PURE__*/new Vector3();var _y=/*@__PURE__*/new Vector3();var _z=/*@__PURE__*/new Vector3();var _matrix$1=/*@__PURE__*/new Matrix4$1();var _quaternion$3=/*@__PURE__*/new Quaternion();var Euler=/*#__PURE__*/function(){function Euler(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var order=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Euler.DefaultOrder;_classCallCheck(this,Euler);this._x=x;this._y=y;this._z=z;this._order=order;}_createClass(Euler,[{key:"x",get:function get(){return this._x;},set:function set(value){this._x=value;this._onChangeCallback();}},{key:"y",get:function get(){return this._y;},set:function set(value){this._y=value;this._onChangeCallback();}},{key:"z",get:function get(){return this._z;},set:function set(value){this._z=value;this._onChangeCallback();}},{key:"order",get:function get(){return this._order;},set:function set(value){this._order=value;this._onChangeCallback();}},{key:"set",value:function set(x,y,z){var order=arguments.length>3&&arguments[3]!==undefined?arguments[3]:this._order;this._x=x;this._y=y;this._z=z;this._order=order;this._onChangeCallback();return this;}},{key:"clone",value:function clone(){return new this.constructor(this._x,this._y,this._z,this._order);}},{key:"copy",value:function copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this;}},{key:"setFromRotationMatrix",value:function setFromRotationMatrix(m){var order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._order;var update=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];switch(order){case'XYZ':this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.9999999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else {this._x=Math.atan2(m32,m22);this._z=0;}break;case'YXZ':this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.9999999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else {this._y=Math.atan2(-m31,m11);this._z=0;}break;case'ZXY':this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.9999999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else {this._y=0;this._z=Math.atan2(m21,m11);}break;case'ZYX':this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.9999999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else {this._x=0;this._z=Math.atan2(-m12,m22);}break;case'YZX':this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.9999999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else {this._x=0;this._y=Math.atan2(m13,m33);}break;case'XZY':this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.9999999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else {this._x=Math.atan2(-m23,m33);this._y=0;}break;default:console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: '+order);}this._order=order;if(update===true)this._onChangeCallback();return this;}},{key:"setFromQuaternion",value:function setFromQuaternion(q,order,update){_matrix$1.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix$1,order,update);}},{key:"setFromVector3",value:function setFromVector3(v){var order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._order;return this.set(v.x,v.y,v.z,order);}},{key:"reorder",value:function reorder(newOrder){// WARNING: this discards revolution information -bhouston
  _quaternion$3.setFromEuler(this);return this.setFromQuaternion(_quaternion$3,newOrder);}},{key:"equals",value:function equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;}},{key:"fromArray",value:function fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this._onChangeCallback();return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;}},{key:"toVector3",value:function toVector3(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else {return new Vector3(this._x,this._y,this._z);}}},{key:"_onChange",value:function _onChange(callback){this._onChangeCallback=callback;return this;}},{key:"_onChangeCallback",value:function _onChangeCallback(){}}]);return Euler;}();Euler.prototype.isEuler=true;Euler.DefaultOrder='XYZ';Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];var Layers=/*#__PURE__*/function(){function Layers(){_classCallCheck(this,Layers);this.mask=1|0;}_createClass(Layers,[{key:"set",value:function set(channel){this.mask=1<<channel|0;}},{key:"enable",value:function enable(channel){this.mask|=1<<channel|0;}},{key:"enableAll",value:function enableAll(){this.mask=0xffffffff|0;}},{key:"toggle",value:function toggle(channel){this.mask^=1<<channel|0;}},{key:"disable",value:function disable(channel){this.mask&=~(1<<channel|0);}},{key:"disableAll",value:function disableAll(){this.mask=0;}},{key:"test",value:function test(layers){return (this.mask&layers.mask)!==0;}}]);return Layers;}();var _object3DId=0;var _v1$4=/*@__PURE__*/new Vector3();var _q1=/*@__PURE__*/new Quaternion();var _m1$1=/*@__PURE__*/new Matrix4$1();var _target=/*@__PURE__*/new Vector3();var _position$3=/*@__PURE__*/new Vector3();var _scale$2=/*@__PURE__*/new Vector3();var _quaternion$2=/*@__PURE__*/new Quaternion();var _xAxis=/*@__PURE__*/new Vector3(1,0,0);var _yAxis=/*@__PURE__*/new Vector3(0,1,0);var _zAxis=/*@__PURE__*/new Vector3(0,0,1);var _addedEvent={type:'added'};var _removedEvent={type:'removed'};var Object3D$1=/*#__PURE__*/function(_EventDispatcher3){_inherits(Object3D,_EventDispatcher3);var _super5=_createSuper(Object3D);function Object3D(){var _this6;_classCallCheck(this,Object3D);_this6=_super5.call(this);Object.defineProperty(_assertThisInitialized(_this6),'id',{value:_object3DId++});_this6.uuid=generateUUID();_this6.name='';_this6.type='Object3D';_this6.parent=null;_this6.children=[];_this6.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation._onChange(onRotationChange);quaternion._onChange(onQuaternionChange);Object.defineProperties(_assertThisInitialized(_this6),{position:{configurable:true,enumerable:true,value:position},rotation:{configurable:true,enumerable:true,value:rotation},quaternion:{configurable:true,enumerable:true,value:quaternion},scale:{configurable:true,enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4$1()},normalMatrix:{value:new Matrix3$1()}});_this6.matrix=new Matrix4$1();_this6.matrixWorld=new Matrix4$1();_this6.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;_this6.matrixWorldNeedsUpdate=false;_this6.layers=new Layers();_this6.visible=true;_this6.castShadow=false;_this6.receiveShadow=false;_this6.frustumCulled=true;_this6.renderOrder=0;_this6.animations=[];_this6.userData={};return _this6;}_createClass(Object3D,[{key:"onBeforeRender",value:function onBeforeRender(/* renderer, scene, camera, geometry, material, group */){}},{key:"onAfterRender",value:function onAfterRender(/* renderer, scene, camera, geometry, material, group */){}},{key:"applyMatrix4",value:function applyMatrix4(matrix){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);}},{key:"applyQuaternion",value:function applyQuaternion(q){this.quaternion.premultiply(q);return this;}},{key:"setRotationFromAxisAngle",value:function setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
  this.quaternion.setFromAxisAngle(axis,angle);}},{key:"setRotationFromEuler",value:function setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);}},{key:"setRotationFromMatrix",value:function setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  this.quaternion.setFromRotationMatrix(m);}},{key:"setRotationFromQuaternion",value:function setRotationFromQuaternion(q){// assumes q is normalized
  this.quaternion.copy(q);}},{key:"rotateOnAxis",value:function rotateOnAxis(axis,angle){// rotate object on axis in object space
  // axis is assumed to be normalized
  _q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1);return this;}},{key:"rotateOnWorldAxis",value:function rotateOnWorldAxis(axis,angle){// rotate object on axis in world space
  // axis is assumed to be normalized
  // method assumes no rotated parent
  _q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1);return this;}},{key:"rotateX",value:function rotateX(angle){return this.rotateOnAxis(_xAxis,angle);}},{key:"rotateY",value:function rotateY(angle){return this.rotateOnAxis(_yAxis,angle);}},{key:"rotateZ",value:function rotateZ(angle){return this.rotateOnAxis(_zAxis,angle);}},{key:"translateOnAxis",value:function translateOnAxis(axis,distance){// translate object by distance along axis in object space
  // axis is assumed to be normalized
  _v1$4.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$4.multiplyScalar(distance));return this;}},{key:"translateX",value:function translateX(distance){return this.translateOnAxis(_xAxis,distance);}},{key:"translateY",value:function translateY(distance){return this.translateOnAxis(_yAxis,distance);}},{key:"translateZ",value:function translateZ(distance){return this.translateOnAxis(_zAxis,distance);}},{key:"localToWorld",value:function localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);}},{key:"worldToLocal",value:function worldToLocal(vector){return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());}},{key:"lookAt",value:function lookAt(x,y,z){// This method does not support objects having non-uniformly-scaled parent(s)
  if(x.isVector3){_target.copy(x);}else {_target.set(x,y,z);}var parent=this.parent;this.updateWorldMatrix(true,false);_position$3.setFromMatrixPosition(this.matrixWorld);if(this.isCamera||this.isLight){_m1$1.lookAt(_position$3,_target,this.up);}else {_m1$1.lookAt(_target,_position$3,this.up);}this.quaternion.setFromRotationMatrix(_m1$1);if(parent){_m1$1.extractRotation(parent.matrixWorld);_q1.setFromRotationMatrix(_m1$1);this.quaternion.premultiply(_q1.invert());}}},{key:"add",value:function add(object){if(arguments.length>1){for(var _i16=0;_i16<arguments.length;_i16++){this.add(arguments[_i16]);}return this;}if(object===this){console.error('THREE.Object3D.add: object can\'t be added as a child of itself.',object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;this.children.push(object);object.dispatchEvent(_addedEvent);}else {console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.',object);}return this;}},{key:"remove",value:function remove(object){if(arguments.length>1){for(var _i17=0;_i17<arguments.length;_i17++){this.remove(arguments[_i17]);}return this;}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;this.children.splice(index,1);object.dispatchEvent(_removedEvent);}return this;}},{key:"removeFromParent",value:function removeFromParent(){var parent=this.parent;if(parent!==null){parent.remove(this);}return this;}},{key:"clear",value:function clear(){for(var _i18=0;_i18<this.children.length;_i18++){var object=this.children[_i18];object.parent=null;object.dispatchEvent(_removedEvent);}this.children.length=0;return this;}},{key:"attach",value:function attach(object){// adds object as a child of this, while maintaining the object's world transform
  this.updateWorldMatrix(true,false);_m1$1.copy(this.matrixWorld).invert();if(object.parent!==null){object.parent.updateWorldMatrix(true,false);_m1$1.multiply(object.parent.matrixWorld);}object.applyMatrix4(_m1$1);this.add(object);object.updateWorldMatrix(false,true);return this;}},{key:"getObjectById",value:function getObjectById(id){return this.getObjectByProperty('id',id);}},{key:"getObjectByName",value:function getObjectByName(name){return this.getObjectByProperty('name',name);}},{key:"getObjectByProperty",value:function getObjectByProperty(name,value){if(this[name]===value)return this;for(var _i19=0,l=this.children.length;_i19<l;_i19++){var child=this.children[_i19];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;}},{key:"getWorldPosition",value:function getWorldPosition(target){this.updateWorldMatrix(true,false);return target.setFromMatrixPosition(this.matrixWorld);}},{key:"getWorldQuaternion",value:function getWorldQuaternion(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,target,_scale$2);return target;}},{key:"getWorldScale",value:function getWorldScale(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,_quaternion$2,target);return target;}},{key:"getWorldDirection",value:function getWorldDirection(target){this.updateWorldMatrix(true,false);var e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize();}},{key:"raycast",value:function raycast(){}},{key:"traverse",value:function traverse(callback){callback(this);var children=this.children;for(var _i20=0,l=children.length;_i20<l;_i20++){children[_i20].traverse(callback);}}},{key:"traverseVisible",value:function traverseVisible(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var _i21=0,l=children.length;_i21<l;_i21++){children[_i21].traverseVisible(callback);}}},{key:"traverseAncestors",value:function traverseAncestors(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}}},{key:"updateMatrix",value:function updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;}},{key:"updateMatrixWorld",value:function updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
  var children=this.children;for(var _i22=0,l=children.length;_i22<l;_i22++){children[_i22].updateMatrixWorld(force);}}},{key:"updateWorldMatrix",value:function updateWorldMatrix(updateParents,updateChildren){var parent=this.parent;if(updateParents===true&&parent!==null){parent.updateWorldMatrix(true,false);}if(this.matrixAutoUpdate)this.updateMatrix();if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}// update children
  if(updateChildren===true){var children=this.children;for(var _i23=0,l=children.length;_i23<l;_i23++){children[_i23].updateWorldMatrix(false,true);}}}},{key:"toJSON",value:function toJSON(meta){// meta is a string when called from JSON.stringify
  var isRootObject=meta===undefined||typeof meta==='string';var output={};// meta is a hash used to collect geometries, materials.
  // not providing it implies that this is the root object
  // being serialized.
  if(isRootObject){// initialize meta obj
  meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
  var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;object.layers=this.layers.mask;object.matrix=this.matrix.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;// object specific properties
  if(this.isInstancedMesh){object.type='InstancedMesh';object.count=this.count;object.instanceMatrix=this.instanceMatrix.toJSON();if(this.instanceColor!==null)object.instanceColor=this.instanceColor.toJSON();}//
  function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.isScene){if(this.background){if(this.background.isColor){object.background=this.background.toJSON();}else if(this.background.isTexture){object.background=this.background.toJSON(meta).uuid;}}if(this.environment&&this.environment.isTexture){object.environment=this.environment.toJSON(meta).uuid;}}else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);var parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){var shapes=parameters.shapes;if(Array.isArray(shapes)){for(var _i24=0,l=shapes.length;_i24<l;_i24++){var shape=shapes[_i24];serialize(meta.shapes,shape);}}else {serialize(meta.shapes,shapes);}}}if(this.isSkinnedMesh){object.bindMode=this.bindMode;object.bindMatrix=this.bindMatrix.toArray();if(this.skeleton!==undefined){serialize(meta.skeletons,this.skeleton);object.skeleton=this.skeleton.uuid;}}if(this.material!==undefined){if(Array.isArray(this.material)){var uuids=[];for(var _i25=0,_l=this.material.length;_i25<_l;_i25++){uuids.push(serialize(meta.materials,this.material[_i25]));}object.material=uuids;}else {object.material=serialize(meta.materials,this.material);}}//
  if(this.children.length>0){object.children=[];for(var _i26=0;_i26<this.children.length;_i26++){object.children.push(this.children[_i26].toJSON(meta).object);}}//
  if(this.animations.length>0){object.animations=[];for(var _i27=0;_i27<this.animations.length;_i27++){var animation=this.animations[_i27];object.animations.push(serialize(meta.animations,animation));}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);var _shapes=extractFromCache(meta.shapes);var skeletons=extractFromCache(meta.skeletons);var animations=extractFromCache(meta.animations);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(_shapes.length>0)output.shapes=_shapes;if(skeletons.length>0)output.skeletons=skeletons;if(animations.length>0)output.animations=animations;}output.object=object;return output;// extract data from the cache hash
  // remove metadata on each item
  // and return as array
  function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}}},{key:"clone",value:function clone(recursive){return new this.constructor().copy(this,recursive);}},{key:"copy",value:function copy(source){var recursive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.rotation.order=source.rotation.order;this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(var _i28=0;_i28<source.children.length;_i28++){var child=source.children[_i28];this.add(child.clone());}}return this;}}]);return Object3D;}(EventDispatcher);Object3D$1.DefaultUp=new Vector3(0,1,0);Object3D$1.DefaultMatrixAutoUpdate=true;Object3D$1.prototype.isObject3D=true;var _v0$1=/*@__PURE__*/new Vector3();var _v1$3=/*@__PURE__*/new Vector3();var _v2$2=/*@__PURE__*/new Vector3();var _v3$1=/*@__PURE__*/new Vector3();var _vab=/*@__PURE__*/new Vector3();var _vac=/*@__PURE__*/new Vector3();var _vbc=/*@__PURE__*/new Vector3();var _vap=/*@__PURE__*/new Vector3();var _vbp=/*@__PURE__*/new Vector3();var _vcp=/*@__PURE__*/new Vector3();var Triangle$1=/*#__PURE__*/function(){function Triangle(){var a=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var b=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var c=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector3();_classCallCheck(this,Triangle);this.a=a;this.b=b;this.c=c;}_createClass(Triangle,[{key:"set",value:function set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;}},{key:"setFromPointsAndIndices",value:function setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;}},{key:"setFromAttributeAndIndices",value:function setFromAttributeAndIndices(attribute,i0,i1,i2){this.a.fromBufferAttribute(attribute,i0);this.b.fromBufferAttribute(attribute,i1);this.c.fromBufferAttribute(attribute,i2);return this;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;}},{key:"getArea",value:function getArea(){_v0$1.subVectors(this.c,this.b);_v1$3.subVectors(this.a,this.b);return _v0$1.cross(_v1$3).length()*0.5;}},{key:"getMidpoint",value:function getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);}},{key:"getNormal",value:function getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target);}},{key:"getPlane",value:function getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c);}},{key:"getBarycoord",value:function getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);}},{key:"getUV",value:function getUV(point,uv1,uv2,uv3,target){return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target);}},{key:"containsPoint",value:function containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);}},{key:"isFrontFacing",value:function isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction);}},{key:"intersectsBox",value:function intersectsBox(box){return box.intersectsTriangle(this);}},{key:"closestPointToPoint",value:function closestPointToPoint(p,target){var a=this.a,b=this.b,c=this.c;var v,w;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  // under the accompanying license; see chapter 5.1.5 for detailed explanation.
  // basically, we're distinguishing which of the voronoi regions of the triangle
  // the point lies in with the minimum amount of redundant computation.
  _vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);var d1=_vab.dot(_vap);var d2=_vac.dot(_vap);if(d1<=0&&d2<=0){// vertex region of A; barycentric coords (1, 0, 0)
  return target.copy(a);}_vbp.subVectors(p,b);var d3=_vab.dot(_vbp);var d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3){// vertex region of B; barycentric coords (0, 1, 0)
  return target.copy(b);}var vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0){v=d1/(d1-d3);// edge region of AB; barycentric coords (1-v, v, 0)
  return target.copy(a).addScaledVector(_vab,v);}_vcp.subVectors(p,c);var d5=_vab.dot(_vcp);var d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6){// vertex region of C; barycentric coords (0, 0, 1)
  return target.copy(c);}var vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0){w=d2/(d2-d6);// edge region of AC; barycentric coords (1-w, 0, w)
  return target.copy(a).addScaledVector(_vac,w);}var va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0){_vbc.subVectors(c,b);w=(d4-d3)/(d4-d3+(d5-d6));// edge region of BC; barycentric coords (0, 1-w, w)
  return target.copy(b).addScaledVector(_vbc,w);// edge region of BC
  }// face region
  var denom=1/(va+vb+vc);// u = va * denom
  v=vb*denom;w=vc*denom;return target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w);}},{key:"equals",value:function equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}}],[{key:"getNormal",value:function getNormal(a,b,c,target){target.subVectors(c,b);_v0$1.subVectors(a,b);target.cross(_v0$1);var targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);}// static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  },{key:"getBarycoord",value:function getBarycoord(point,a,b,c,target){_v0$1.subVectors(c,a);_v1$3.subVectors(b,a);_v2$2.subVectors(point,a);var dot00=_v0$1.dot(_v0$1);var dot01=_v0$1.dot(_v1$3);var dot02=_v0$1.dot(_v2$2);var dot11=_v1$3.dot(_v1$3);var dot12=_v1$3.dot(_v2$2);var denom=dot00*dot11-dot01*dot01;// collinear or singular triangle
  if(denom===0){// arbitrary location outside of triangle?
  // not sure if this is the best idea, maybe should be returning undefined
  return target.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
  return target.set(1-u-v,v,u);}},{key:"containsPoint",value:function containsPoint(point,a,b,c){this.getBarycoord(point,a,b,c,_v3$1);return _v3$1.x>=0&&_v3$1.y>=0&&_v3$1.x+_v3$1.y<=1;}},{key:"getUV",value:function getUV(point,p1,p2,p3,uv1,uv2,uv3,target){this.getBarycoord(point,p1,p2,p3,_v3$1);target.set(0,0);target.addScaledVector(uv1,_v3$1.x);target.addScaledVector(uv2,_v3$1.y);target.addScaledVector(uv3,_v3$1.z);return target;}},{key:"isFrontFacing",value:function isFrontFacing(a,b,c,direction){_v0$1.subVectors(c,b);_v1$3.subVectors(a,b);// strictly front facing
  return _v0$1.cross(_v1$3).dot(direction)<0?true:false;}}]);return Triangle;}();var materialId=0;var Material$1=/*#__PURE__*/function(_EventDispatcher4){_inherits(Material,_EventDispatcher4);var _super6=_createSuper(Material);function Material(){var _this7;_classCallCheck(this,Material);_this7=_super6.call(this);Object.defineProperty(_assertThisInitialized(_this7),'id',{value:materialId++});_this7.uuid=generateUUID();_this7.name='';_this7.type='Material';_this7.fog=true;_this7.blending=NormalBlending;_this7.side=FrontSide;_this7.vertexColors=false;_this7.opacity=1;_this7.format=RGBAFormat;_this7.transparent=false;_this7.blendSrc=SrcAlphaFactor;_this7.blendDst=OneMinusSrcAlphaFactor;_this7.blendEquation=AddEquation;_this7.blendSrcAlpha=null;_this7.blendDstAlpha=null;_this7.blendEquationAlpha=null;_this7.depthFunc=LessEqualDepth;_this7.depthTest=true;_this7.depthWrite=true;_this7.stencilWriteMask=0xff;_this7.stencilFunc=AlwaysStencilFunc;_this7.stencilRef=0;_this7.stencilFuncMask=0xff;_this7.stencilFail=KeepStencilOp;_this7.stencilZFail=KeepStencilOp;_this7.stencilZPass=KeepStencilOp;_this7.stencilWrite=false;_this7.clippingPlanes=null;_this7.clipIntersection=false;_this7.clipShadows=false;_this7.shadowSide=null;_this7.colorWrite=true;_this7.precision=null;// override the renderer's default precision for this material
  _this7.polygonOffset=false;_this7.polygonOffsetFactor=0;_this7.polygonOffsetUnits=0;_this7.dithering=false;_this7.alphaToCoverage=false;_this7.premultipliedAlpha=false;_this7.visible=true;_this7.toneMapped=true;_this7.userData={};_this7.version=0;_this7._alphaTest=0;return _this7;}_createClass(Material,[{key:"alphaTest",get:function get(){return this._alphaTest;},set:function set(value){if(this._alphaTest>0!==value>0){this.version++;}this._alphaTest=value;}},{key:"onBuild",value:function onBuild(/* shaderobject, renderer */){}},{key:"onBeforeRender",value:function onBeforeRender(/* renderer, scene, camera, geometry, object, group */){}},{key:"onBeforeCompile",value:function onBeforeCompile(/* shaderobject, renderer */){}},{key:"customProgramCacheKey",value:function customProgramCacheKey(){return this.onBeforeCompile.toString();}},{key:"setValues",value:function setValues(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn('THREE.Material: \''+key+'\' parameter is undefined.');continue;}// for backward compatability if shading is set in the constructor
  if(key==='shading'){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=newValue===FlatShading?true:false;continue;}var currentValue=this[key];if(currentValue===undefined){console.warn('THREE.'+this.type+': \''+key+'\' is not a property of this material.');continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else {this[key]=newValue;}}}},{key:"toJSON",value:function toJSON(meta){var isRoot=meta===undefined||typeof meta==='string';if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.sheen!==undefined)data.sheen=this.sheen;if(this.sheenTint&&this.sheenTint.isColor)data.sheenTint=this.sheenTint.getHex();if(this.sheenRoughness!==undefined)data.sheenRoughness=this.sheenRoughness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity&&this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.specularIntensity!==undefined)data.specularIntensity=this.specularIntensity;if(this.specularTint&&this.specularTint.isColor)data.specularTint=this.specularTint.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearcoat!==undefined)data.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==undefined)data.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture){data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid;}if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture){data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid;}if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid;data.clearcoatNormalScale=this.clearcoatNormalScale.toArray();}if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture){data.lightMap=this.lightMap.toJSON(meta).uuid;data.lightMapIntensity=this.lightMapIntensity;}if(this.aoMap&&this.aoMap.isTexture){data.aoMap=this.aoMap.toJSON(meta).uuid;data.aoMapIntensity=this.aoMapIntensity;}if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalMapType=this.normalMapType;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.specularIntensityMap&&this.specularIntensityMap.isTexture)data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid;if(this.specularTintMap&&this.specularTintMap.isTexture)data.specularTintMap=this.specularTintMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;if(this.combine!==undefined)data.combine=this.combine;}if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;if(this.reflectivity!==undefined)data.reflectivity=this.reflectivity;if(this.refractionRatio!==undefined)data.refractionRatio=this.refractionRatio;if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.transmission!==undefined)data.transmission=this.transmission;if(this.transmissionMap&&this.transmissionMap.isTexture)data.transmissionMap=this.transmissionMap.toJSON(meta).uuid;if(this.thickness!==undefined)data.thickness=this.thickness;if(this.thicknessMap&&this.thicknessMap.isTexture)data.thicknessMap=this.thicknessMap.toJSON(meta).uuid;if(this.attenuationDistance!==undefined)data.attenuationDistance=this.attenuationDistance;if(this.attenuationTint!==undefined)data.attenuationTint=this.attenuationTint.getHex();if(this.size!==undefined)data.size=this.size;if(this.shadowSide!==null)data.shadowSide=this.shadowSide;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors)data.vertexColors=true;if(this.opacity<1)data.opacity=this.opacity;if(this.format!==RGBAFormat)data.format=this.format;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;data.colorWrite=this.colorWrite;data.stencilWrite=this.stencilWrite;data.stencilWriteMask=this.stencilWriteMask;data.stencilFunc=this.stencilFunc;data.stencilRef=this.stencilRef;data.stencilFuncMask=this.stencilFuncMask;data.stencilFail=this.stencilFail;data.stencilZFail=this.stencilZFail;data.stencilZPass=this.stencilZPass;// rotation (SpriteMaterial)
  if(this.rotation&&this.rotation!==0)data.rotation=this.rotation;if(this.polygonOffset===true)data.polygonOffset=true;if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth&&this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.alphaToCoverage===true)data.alphaToCoverage=this.alphaToCoverage;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.flatShading===true)data.flatShading=this.flatShading;if(this.visible===false)data.visible=false;if(this.toneMapped===false)data.toneMapped=false;if(JSON.stringify(this.userData)!=='{}')data.userData=this.userData;// TODO: Copied from Object3D.toJSON
  function extractFromCache(cache){var values=[];for(var key in cache){var _data=cache[key];delete _data.metadata;values.push(_data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){this.name=source.name;this.fog=source.fog;this.blending=source.blending;this.side=source.side;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.format=source.format;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;var srcPlanes=source.clippingPlanes;var dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var _i29=0;_i29!==n;++_i29){dstPlanes[_i29]=srcPlanes[_i29].clone();}}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.alphaToCoverage=source.alphaToCoverage;this.premultipliedAlpha=source.premultipliedAlpha;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse(JSON.stringify(source.userData));return this;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}},{key:"needsUpdate",set:function set(value){if(value===true)this.version++;}}]);return Material;}(EventDispatcher);Material$1.prototype.isMaterial=true;var _colorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};var _hslA={h:0,s:0,l:0};var _hslB={h:0,s:0,l:0};function hue2rgb$1(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}function SRGBToLinear(c){return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);}function LinearToSRGB(c){return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;}var Color$2=/*#__PURE__*/function(){function Color(r,g,b){_classCallCheck(this,Color);if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
  return this.set(r);}return this.setRGB(r,g,b);}_createClass(Color,[{key:"set",value:function set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;}},{key:"setScalar",value:function setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;}},{key:"setHex",value:function setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;}},{key:"setRGB",value:function setRGB(r,g,b){this.r=r;this.g=g;this.b=b;return this;}},{key:"setHSL",value:function setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
  h=euclideanModulo(h,1);s=clamp(s,0,1);l=clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else {var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb$1(q,p,h+1/3);this.g=hue2rgb$1(q,p,h);this.b=hue2rgb$1(q,p,h-1/3);}return this;}},{key:"setStyle",value:function setStyle(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)){// rgb / hsl
  var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
  this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[4]);return this;}if(color=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[4]);return this;}break;case'hsl':case'hsla':if(color=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  var h=parseFloat(color[1])/360;var s=parseInt(color[2],10)/100;var l=parseInt(color[3],10)/100;handleAlpha(color[4]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f\d]+)$/.exec(style)){// hex color
  var hex=m[1];var size=hex.length;if(size===3){// #ff0
  this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
  this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){return this.setColorName(style);}return this;}},{key:"setColorName",value:function setColorName(style){// color keywords
  var hex=_colorKeywords[style.toLowerCase()];if(hex!==undefined){// red
  this.setHex(hex);}else {// unknown color
  console.warn('THREE.Color: Unknown color '+style);}return this;}},{key:"clone",value:function clone(){return new this.constructor(this.r,this.g,this.b);}},{key:"copy",value:function copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;}},{key:"copyGammaToLinear",value:function copyGammaToLinear(color){var gammaFactor=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;}},{key:"copyLinearToGamma",value:function copyLinearToGamma(color){var gammaFactor=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;}},{key:"convertGammaToLinear",value:function convertGammaToLinear(gammaFactor){this.copyGammaToLinear(this,gammaFactor);return this;}},{key:"convertLinearToGamma",value:function convertLinearToGamma(gammaFactor){this.copyLinearToGamma(this,gammaFactor);return this;}},{key:"copySRGBToLinear",value:function copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this;}},{key:"copyLinearToSRGB",value:function copyLinearToSRGB(color){this.r=LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this;}},{key:"convertSRGBToLinear",value:function convertSRGBToLinear(){this.copySRGBToLinear(this);return this;}},{key:"convertLinearToSRGB",value:function convertLinearToSRGB(){this.copyLinearToSRGB(this);return this;}},{key:"getHex",value:function getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;}},{key:"getHexString",value:function getHexString(){return ('000000'+this.getHex().toString(16)).slice(-6);}},{key:"getHSL",value:function getHSL(target){// h,s,l ranges are in 0.0 - 1.0
  var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else {var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;}},{key:"getStyle",value:function getStyle(){return 'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';}},{key:"offsetHSL",value:function offsetHSL(h,s,l){this.getHSL(_hslA);_hslA.h+=h;_hslA.s+=s;_hslA.l+=l;this.setHSL(_hslA.h,_hslA.s,_hslA.l);return this;}},{key:"add",value:function add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;}},{key:"addColors",value:function addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;}},{key:"addScalar",value:function addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;}},{key:"sub",value:function sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;}},{key:"multiply",value:function multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;}},{key:"multiplyScalar",value:function multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;}},{key:"lerp",value:function lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;}},{key:"lerpColors",value:function lerpColors(color1,color2,alpha){this.r=color1.r+(color2.r-color1.r)*alpha;this.g=color1.g+(color2.g-color1.g)*alpha;this.b=color1.b+(color2.b-color1.b)*alpha;return this;}},{key:"lerpHSL",value:function lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);var h=lerp$1(_hslA.h,_hslB.h,alpha);var s=lerp$1(_hslA.s,_hslB.s,alpha);var l=lerp$1(_hslA.l,_hslB.l,alpha);this.setHSL(h,s,l);return this;}},{key:"equals",value:function equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index){this.r=attribute.getX(index);this.g=attribute.getY(index);this.b=attribute.getZ(index);if(attribute.normalized===true){// assuming Uint8Array
  this.r/=255;this.g/=255;this.b/=255;}return this;}},{key:"toJSON",value:function toJSON(){return this.getHex();}}]);return Color;}();Color$2.NAMES=_colorKeywords;Color$2.prototype.isColor=true;Color$2.prototype.r=1;Color$2.prototype.g=1;Color$2.prototype.b=1;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   * }
   */var MeshBasicMaterial$1=/*#__PURE__*/function(_Material){_inherits(MeshBasicMaterial,_Material);var _super7=_createSuper(MeshBasicMaterial);function MeshBasicMaterial(parameters){var _this8;_classCallCheck(this,MeshBasicMaterial);_this8=_super7.call(this);_this8.type='MeshBasicMaterial';_this8.color=new Color$2(0xffffff);// emissive
  _this8.map=null;_this8.lightMap=null;_this8.lightMapIntensity=1.0;_this8.aoMap=null;_this8.aoMapIntensity=1.0;_this8.specularMap=null;_this8.alphaMap=null;_this8.envMap=null;_this8.combine=MultiplyOperation;_this8.reflectivity=1;_this8.refractionRatio=0.98;_this8.wireframe=false;_this8.wireframeLinewidth=1;_this8.wireframeLinecap='round';_this8.wireframeLinejoin='round';_this8.setValues(parameters);return _this8;}_createClass(MeshBasicMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshBasicMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}]);return MeshBasicMaterial;}(Material$1);MeshBasicMaterial$1.prototype.isMeshBasicMaterial=true;var _vector$9=/*@__PURE__*/new Vector3();var _vector2$1=/*@__PURE__*/new Vector2();var BufferAttribute=/*#__PURE__*/function(){function BufferAttribute(array,itemSize,normalized){_classCallCheck(this,BufferAttribute);if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;}_createClass(BufferAttribute,[{key:"onUploadCallback",value:function onUploadCallback(){}},{key:"needsUpdate",set:function set(value){if(value===true)this.version++;}},{key:"setUsage",value:function setUsage(value){this.usage=value;return this;}},{key:"copy",value:function copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;return this;}},{key:"copyAt",value:function copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var _i30=0,l=this.itemSize;_i30<l;_i30++){this.array[index1+_i30]=attribute.array[index2+_i30];}return this;}},{key:"copyArray",value:function copyArray(array){this.array.set(array);return this;}},{key:"copyColorsArray",value:function copyColorsArray(colors){var array=this.array;var offset=0;for(var _i31=0,l=colors.length;_i31<l;_i31++){var color=colors[_i31];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',_i31);color=new Color$2();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;}},{key:"copyVector2sArray",value:function copyVector2sArray(vectors){var array=this.array;var offset=0;for(var _i32=0,l=vectors.length;_i32<l;_i32++){var vector=vectors[_i32];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',_i32);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;}},{key:"copyVector3sArray",value:function copyVector3sArray(vectors){var array=this.array;var offset=0;for(var _i33=0,l=vectors.length;_i33<l;_i33++){var vector=vectors[_i33];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',_i33);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;}},{key:"copyVector4sArray",value:function copyVector4sArray(vectors){var array=this.array;var offset=0;for(var _i34=0,l=vectors.length;_i34<l;_i34++){var vector=vectors[_i34];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',_i34);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;}},{key:"applyMatrix3",value:function applyMatrix3(m){if(this.itemSize===2){for(var _i35=0,l=this.count;_i35<l;_i35++){_vector2$1.fromBufferAttribute(this,_i35);_vector2$1.applyMatrix3(m);this.setXY(_i35,_vector2$1.x,_vector2$1.y);}}else if(this.itemSize===3){for(var _i36=0,_l2=this.count;_i36<_l2;_i36++){_vector$9.fromBufferAttribute(this,_i36);_vector$9.applyMatrix3(m);this.setXYZ(_i36,_vector$9.x,_vector$9.y,_vector$9.z);}}return this;}},{key:"applyMatrix4",value:function applyMatrix4(m){for(var _i37=0,l=this.count;_i37<l;_i37++){_vector$9.x=this.getX(_i37);_vector$9.y=this.getY(_i37);_vector$9.z=this.getZ(_i37);_vector$9.applyMatrix4(m);this.setXYZ(_i37,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}},{key:"applyNormalMatrix",value:function applyNormalMatrix(m){for(var _i38=0,l=this.count;_i38<l;_i38++){_vector$9.x=this.getX(_i38);_vector$9.y=this.getY(_i38);_vector$9.z=this.getZ(_i38);_vector$9.applyNormalMatrix(m);this.setXYZ(_i38,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}},{key:"transformDirection",value:function transformDirection(m){for(var _i39=0,l=this.count;_i39<l;_i39++){_vector$9.x=this.getX(_i39);_vector$9.y=this.getY(_i39);_vector$9.z=this.getZ(_i39);_vector$9.transformDirection(m);this.setXYZ(_i39,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}},{key:"set",value:function set(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.array.set(value,offset);return this;}},{key:"getX",value:function getX(index){return this.array[index*this.itemSize];}},{key:"setX",value:function setX(index,x){this.array[index*this.itemSize]=x;return this;}},{key:"getY",value:function getY(index){return this.array[index*this.itemSize+1];}},{key:"setY",value:function setY(index,y){this.array[index*this.itemSize+1]=y;return this;}},{key:"getZ",value:function getZ(index){return this.array[index*this.itemSize+2];}},{key:"setZ",value:function setZ(index,z){this.array[index*this.itemSize+2]=z;return this;}},{key:"getW",value:function getW(index){return this.array[index*this.itemSize+3];}},{key:"setW",value:function setW(index,w){this.array[index*this.itemSize+3]=w;return this;}},{key:"setXY",value:function setXY(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;}},{key:"setXYZ",value:function setXYZ(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;}},{key:"setXYZW",value:function setXYZW(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;}},{key:"onUpload",value:function onUpload(callback){this.onUploadCallback=callback;return this;}},{key:"clone",value:function clone(){return new this.constructor(this.array,this.itemSize).copy(this);}},{key:"toJSON",value:function toJSON(){var data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};if(this.name!=='')data.name=this.name;if(this.usage!==StaticDrawUsage)data.usage=this.usage;if(this.updateRange.offset!==0||this.updateRange.count!==-1)data.updateRange=this.updateRange;return data;}}]);return BufferAttribute;}();BufferAttribute.prototype.isBufferAttribute=true;//
  var Uint16BufferAttribute=/*#__PURE__*/function(_BufferAttribute5){_inherits(Uint16BufferAttribute,_BufferAttribute5);var _super12=_createSuper(Uint16BufferAttribute);function Uint16BufferAttribute(array,itemSize,normalized){_classCallCheck(this,Uint16BufferAttribute);return _super12.call(this,new Uint16Array(array),itemSize,normalized);}return _createClass(Uint16BufferAttribute);}(BufferAttribute);var Uint32BufferAttribute=/*#__PURE__*/function(_BufferAttribute7){_inherits(Uint32BufferAttribute,_BufferAttribute7);var _super14=_createSuper(Uint32BufferAttribute);function Uint32BufferAttribute(array,itemSize,normalized){_classCallCheck(this,Uint32BufferAttribute);return _super14.call(this,new Uint32Array(array),itemSize,normalized);}return _createClass(Uint32BufferAttribute);}(BufferAttribute);var Float16BufferAttribute=/*#__PURE__*/function(_BufferAttribute8){_inherits(Float16BufferAttribute,_BufferAttribute8);var _super15=_createSuper(Float16BufferAttribute);function Float16BufferAttribute(array,itemSize,normalized){_classCallCheck(this,Float16BufferAttribute);return _super15.call(this,new Uint16Array(array),itemSize,normalized);}return _createClass(Float16BufferAttribute);}(BufferAttribute);Float16BufferAttribute.prototype.isFloat16BufferAttribute=true;var Float32BufferAttribute=/*#__PURE__*/function(_BufferAttribute9){_inherits(Float32BufferAttribute,_BufferAttribute9);var _super16=_createSuper(Float32BufferAttribute);function Float32BufferAttribute(array,itemSize,normalized){_classCallCheck(this,Float32BufferAttribute);return _super16.call(this,new Float32Array(array),itemSize,normalized);}return _createClass(Float32BufferAttribute);}(BufferAttribute);var _id=0;var _m1=/*@__PURE__*/new Matrix4$1();var _obj=/*@__PURE__*/new Object3D$1();var _offset=/*@__PURE__*/new Vector3();var _box$1=/*@__PURE__*/new Box3();var _boxMorphTargets=/*@__PURE__*/new Box3();var _vector$8=/*@__PURE__*/new Vector3();var BufferGeometry=/*#__PURE__*/function(_EventDispatcher5){_inherits(BufferGeometry,_EventDispatcher5);var _super18=_createSuper(BufferGeometry);function BufferGeometry(){var _this9;_classCallCheck(this,BufferGeometry);_this9=_super18.call(this);Object.defineProperty(_assertThisInitialized(_this9),'id',{value:_id++});_this9.uuid=generateUUID();_this9.name='';_this9.type='BufferGeometry';_this9.index=null;_this9.attributes={};_this9.morphAttributes={};_this9.morphTargetsRelative=false;_this9.groups=[];_this9.boundingBox=null;_this9.boundingSphere=null;_this9.drawRange={start:0,count:Infinity};_this9.userData={};return _this9;}_createClass(BufferGeometry,[{key:"getIndex",value:function getIndex(){return this.index;}},{key:"setIndex",value:function setIndex(index){if(Array.isArray(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else {this.index=index;}return this;}},{key:"getAttribute",value:function getAttribute(name){return this.attributes[name];}},{key:"setAttribute",value:function setAttribute(name,attribute){this.attributes[name]=attribute;return this;}},{key:"deleteAttribute",value:function deleteAttribute(name){delete this.attributes[name];return this;}},{key:"hasAttribute",value:function hasAttribute(name){return this.attributes[name]!==undefined;}},{key:"addGroup",value:function addGroup(start,count){var materialIndex=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;this.groups.push({start:start,count:count,materialIndex:materialIndex});}},{key:"clearGroups",value:function clearGroups(){this.groups=[];}},{key:"setDrawRange",value:function setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;}},{key:"applyMatrix4",value:function applyMatrix4(matrix){var position=this.attributes.position;if(position!==undefined){position.applyMatrix4(matrix);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3$1().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix);normal.needsUpdate=true;}var tangent=this.attributes.tangent;if(tangent!==undefined){tangent.transformDirection(matrix);tangent.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;}},{key:"applyQuaternion",value:function applyQuaternion(q){_m1.makeRotationFromQuaternion(q);this.applyMatrix4(_m1);return this;}},{key:"rotateX",value:function rotateX(angle){// rotate geometry around world x-axis
  _m1.makeRotationX(angle);this.applyMatrix4(_m1);return this;}},{key:"rotateY",value:function rotateY(angle){// rotate geometry around world y-axis
  _m1.makeRotationY(angle);this.applyMatrix4(_m1);return this;}},{key:"rotateZ",value:function rotateZ(angle){// rotate geometry around world z-axis
  _m1.makeRotationZ(angle);this.applyMatrix4(_m1);return this;}},{key:"translate",value:function translate(x,y,z){// translate geometry
  _m1.makeTranslation(x,y,z);this.applyMatrix4(_m1);return this;}},{key:"scale",value:function scale(x,y,z){// scale geometry
  _m1.makeScale(x,y,z);this.applyMatrix4(_m1);return this;}},{key:"lookAt",value:function lookAt(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this;}},{key:"center",value:function center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset).negate();this.translate(_offset.x,_offset.y,_offset.z);return this;}},{key:"setFromPoints",value:function setFromPoints(points){var position=[];for(var _i40=0,l=points.length;_i40<l;_i40++){var point=points[_i40];position.push(point.x,point.y,point.z||0);}this.setAttribute('position',new Float32BufferAttribute(position,3));return this;}},{key:"computeBoundingBox",value:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingBox.set(new Vector3(-Infinity,-Infinity,-Infinity),new Vector3(+Infinity,+Infinity,+Infinity));return;}if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);// process morph attributes if present
  if(morphAttributesPosition){for(var _i41=0,il=morphAttributesPosition.length;_i41<il;_i41++){var morphAttribute=morphAttributesPosition[_i41];_box$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(this.boundingBox.min,_box$1.min);this.boundingBox.expandByPoint(_vector$8);_vector$8.addVectors(this.boundingBox.max,_box$1.max);this.boundingBox.expandByPoint(_vector$8);}else {this.boundingBox.expandByPoint(_box$1.min);this.boundingBox.expandByPoint(_box$1.max);}}}}else {this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}}},{key:"computeBoundingSphere",value:function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingSphere.set(new Vector3(),Infinity);return;}if(position){// first, find the center of the bounding sphere
  var center=this.boundingSphere.center;_box$1.setFromBufferAttribute(position);// process morph attributes if present
  if(morphAttributesPosition){for(var _i42=0,il=morphAttributesPosition.length;_i42<il;_i42++){var morphAttribute=morphAttributesPosition[_i42];_boxMorphTargets.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(_box$1.min,_boxMorphTargets.min);_box$1.expandByPoint(_vector$8);_vector$8.addVectors(_box$1.max,_boxMorphTargets.max);_box$1.expandByPoint(_vector$8);}else {_box$1.expandByPoint(_boxMorphTargets.min);_box$1.expandByPoint(_boxMorphTargets.max);}}}_box$1.getCenter(center);// second, try to find a boundingSphere with a radius smaller than the
  // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
  var maxRadiusSq=0;for(var _i43=0,_il=position.count;_i43<_il;_i43++){_vector$8.fromBufferAttribute(position,_i43);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}// process morph attributes if present
  if(morphAttributesPosition){for(var _i44=0,_il2=morphAttributesPosition.length;_i44<_il2;_i44++){var _morphAttribute=morphAttributesPosition[_i44];var morphTargetsRelative=this.morphTargetsRelative;for(var j=0,jl=_morphAttribute.count;j<jl;j++){_vector$8.fromBufferAttribute(_morphAttribute,j);if(morphTargetsRelative){_offset.fromBufferAttribute(position,j);_vector$8.add(_offset);}maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}}}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}}},{key:"computeTangents",value:function computeTangents(){var index=this.index;var attributes=this.attributes;// based on http://www.terathon.com/code/tangent.html
  // (per vertex tangents)
  if(index===null||attributes.position===undefined||attributes.normal===undefined||attributes.uv===undefined){console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');return;}var indices=index.array;var positions=attributes.position.array;var normals=attributes.normal.array;var uvs=attributes.uv.array;var nVertices=positions.length/3;if(attributes.tangent===undefined){this.setAttribute('tangent',new BufferAttribute(new Float32Array(4*nVertices),4));}var tangents=attributes.tangent.array;var tan1=[],tan2=[];for(var _i45=0;_i45<nVertices;_i45++){tan1[_i45]=new Vector3();tan2[_i45]=new Vector3();}var vA=new Vector3(),vB=new Vector3(),vC=new Vector3(),uvA=new Vector2(),uvB=new Vector2(),uvC=new Vector2(),sdir=new Vector3(),tdir=new Vector3();function handleTriangle(a,b,c){vA.fromArray(positions,a*3);vB.fromArray(positions,b*3);vC.fromArray(positions,c*3);uvA.fromArray(uvs,a*2);uvB.fromArray(uvs,b*2);uvC.fromArray(uvs,c*2);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);var r=1.0/(uvB.x*uvC.y-uvC.x*uvB.y);// silently ignore degenerate uv triangles having coincident or colinear vertices
  if(!isFinite(r))return;sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r);tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r);tan1[a].add(sdir);tan1[b].add(sdir);tan1[c].add(sdir);tan2[a].add(tdir);tan2[b].add(tdir);tan2[c].add(tdir);}var groups=this.groups;if(groups.length===0){groups=[{start:0,count:indices.length}];}for(var _i46=0,il=groups.length;_i46<il;++_i46){var group=groups[_i46];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){handleTriangle(indices[j+0],indices[j+1],indices[j+2]);}}var tmp=new Vector3(),tmp2=new Vector3();var n=new Vector3(),n2=new Vector3();function handleVertex(v){n.fromArray(normals,v*3);n2.copy(n);var t=tan1[v];// Gram-Schmidt orthogonalize
  tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();// Calculate handedness
  tmp2.crossVectors(n2,t);var test=tmp2.dot(tan2[v]);var w=test<0.0?-1.0:1.0;tangents[v*4]=tmp.x;tangents[v*4+1]=tmp.y;tangents[v*4+2]=tmp.z;tangents[v*4+3]=w;}for(var _i47=0,_il3=groups.length;_i47<_il3;++_i47){var _group=groups[_i47];var _start2=_group.start;var _count=_group.count;for(var _j=_start2,_jl=_start2+_count;_j<_jl;_j+=3){handleVertex(indices[_j+0]);handleVertex(indices[_j+1]);handleVertex(indices[_j+2]);}}}},{key:"computeVertexNormals",value:function computeVertexNormals(){var index=this.index;var positionAttribute=this.getAttribute('position');if(positionAttribute!==undefined){var normalAttribute=this.getAttribute('normal');if(normalAttribute===undefined){normalAttribute=new BufferAttribute(new Float32Array(positionAttribute.count*3),3);this.setAttribute('normal',normalAttribute);}else {// reset existing normals to zero
  for(var _i48=0,il=normalAttribute.count;_i48<il;_i48++){normalAttribute.setXYZ(_i48,0,0,0);}}var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var nA=new Vector3(),nB=new Vector3(),nC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
  if(index){for(var _i49=0,_il4=index.count;_i49<_il4;_i49+=3){var vA=index.getX(_i49+0);var vB=index.getX(_i49+1);var vC=index.getX(_i49+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z);}}else {// non-indexed elements (unconnected triangle soup)
  for(var _i50=0,_il5=positionAttribute.count;_i50<_il5;_i50+=3){pA.fromBufferAttribute(positionAttribute,_i50+0);pB.fromBufferAttribute(positionAttribute,_i50+1);pC.fromBufferAttribute(positionAttribute,_i50+2);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normalAttribute.setXYZ(_i50+0,cb.x,cb.y,cb.z);normalAttribute.setXYZ(_i50+1,cb.x,cb.y,cb.z);normalAttribute.setXYZ(_i50+2,cb.x,cb.y,cb.z);}}this.normalizeNormals();normalAttribute.needsUpdate=true;}}},{key:"merge",value:function merge(geometry,offset){if(!(geometry&&geometry.isBufferGeometry)){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined){offset=0;console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '+'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');}var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeOffset=attribute2.itemSize*offset;var length=Math.min(attributeArray2.length,attributeArray1.length-attributeOffset);for(var _i51=0,j=attributeOffset;_i51<length;_i51++,j++){attributeArray1[j]=attributeArray2[_i51];}}return this;}},{key:"normalizeNormals",value:function normalizeNormals(){var normals=this.attributes.normal;for(var _i52=0,il=normals.count;_i52<il;_i52++){_vector$8.fromBufferAttribute(normals,_i52);_vector$8.normalize();normals.setXYZ(_i52,_vector$8.x,_vector$8.y,_vector$8.z);}}},{key:"toNonIndexed",value:function toNonIndexed(){function convertBufferAttribute(attribute,indices){var array=attribute.array;var itemSize=attribute.itemSize;var normalized=attribute.normalized;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var _i53=0,l=indices.length;_i53<l;_i53++){if(attribute.isInterleavedBufferAttribute){index=indices[_i53]*attribute.data.stride+attribute.offset;}else {index=indices[_i53]*itemSize;}for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}return new BufferAttribute(array2,itemSize,normalized);}//
  if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;// attributes
  for(var name in attributes){var attribute=attributes[name];var newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute);}// morph attributes
  var morphAttributes=this.morphAttributes;for(var _name in morphAttributes){var morphArray=[];var morphAttribute=morphAttributes[_name];// morphAttribute: array of Float32BufferAttributes
  for(var _i54=0,il=morphAttribute.length;_i54<il;_i54++){var _attribute=morphAttribute[_i54];var _newAttribute=convertBufferAttribute(_attribute,indices);morphArray.push(_newAttribute);}geometry2.morphAttributes[_name]=morphArray;}geometry2.morphTargetsRelative=this.morphTargetsRelative;// groups
  var groups=this.groups;for(var _i55=0,l=groups.length;_i55<l;_i55++){var group=groups[_i55];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;}},{key:"toJSON",value:function toJSON(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(Object.keys(this.userData).length>0)data.userData=this.userData;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}// for simplicity the code assumes attributes are not shared across geometries, see #15811
  data.data={attributes:{}};var index=this.index;if(index!==null){data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)};}var attributes=this.attributes;for(var _key in attributes){var attribute=attributes[_key];data.data.attributes[_key]=attribute.toJSON(data.data);}var morphAttributes={};var hasMorphAttributes=false;for(var _key2 in this.morphAttributes){var attributeArray=this.morphAttributes[_key2];var array=[];for(var _i56=0,il=attributeArray.length;_i56<il;_i56++){var _attribute2=attributeArray[_i56];array.push(_attribute2.toJSON(data.data));}if(array.length>0){morphAttributes[_key2]=array;hasMorphAttributes=true;}}if(hasMorphAttributes){data.data.morphAttributes=morphAttributes;data.data.morphTargetsRelative=this.morphTargetsRelative;}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){// reset
  this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// used for storing cloned, shared data
  var data={};// name
  this.name=source.name;// index
  var index=source.index;if(index!==null){this.setIndex(index.clone(data));}// attributes
  var attributes=source.attributes;for(var name in attributes){var attribute=attributes[name];this.setAttribute(name,attribute.clone(data));}// morph attributes
  var morphAttributes=source.morphAttributes;for(var _name2 in morphAttributes){var array=[];var morphAttribute=morphAttributes[_name2];// morphAttribute: array of Float32BufferAttributes
  for(var _i57=0,l=morphAttribute.length;_i57<l;_i57++){array.push(morphAttribute[_i57].clone(data));}this.morphAttributes[_name2]=array;}this.morphTargetsRelative=source.morphTargetsRelative;// groups
  var groups=source.groups;for(var _i58=0,_l3=groups.length;_i58<_l3;_i58++){var group=groups[_i58];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
  var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
  var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
  this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;// user data
  this.userData=source.userData;// geometry generator parameters
  if(source.parameters!==undefined)this.parameters=Object.assign({},source.parameters);return this;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}}]);return BufferGeometry;}(EventDispatcher);BufferGeometry.prototype.isBufferGeometry=true;var _inverseMatrix$2=/*@__PURE__*/new Matrix4$1();var _ray$2=/*@__PURE__*/new Ray();var _sphere$3=/*@__PURE__*/new Sphere();var _vA$1=/*@__PURE__*/new Vector3();var _vB$1=/*@__PURE__*/new Vector3();var _vC$1=/*@__PURE__*/new Vector3();var _tempA=/*@__PURE__*/new Vector3();var _tempB=/*@__PURE__*/new Vector3();var _tempC=/*@__PURE__*/new Vector3();var _morphA=/*@__PURE__*/new Vector3();var _morphB=/*@__PURE__*/new Vector3();var _morphC=/*@__PURE__*/new Vector3();var _uvA$1=/*@__PURE__*/new Vector2();var _uvB$1=/*@__PURE__*/new Vector2();var _uvC$1=/*@__PURE__*/new Vector2();var _intersectionPoint=/*@__PURE__*/new Vector3();var _intersectionPointWorld=/*@__PURE__*/new Vector3();var Mesh=/*#__PURE__*/function(_Object3D){_inherits(Mesh,_Object3D);var _super19=_createSuper(Mesh);function Mesh(){var _this10;var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new BufferGeometry();var material=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new MeshBasicMaterial$1();_classCallCheck(this,Mesh);_this10=_super19.call(this);_this10.type='Mesh';_this10.geometry=geometry;_this10.material=material;_this10.updateMorphTargets();return _this10;}_createClass(Mesh,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(Mesh.prototype),"copy",this).call(this,source);if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}this.material=source.material;this.geometry=source.geometry;return this;}},{key:"updateMorphTargets",value:function updateMorphTargets(){var geometry=this.geometry;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphAttribute.length;m<ml;m++){var name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else {var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}}},{key:"raycast",value:function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$3.copy(geometry.boundingSphere);_sphere$3.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(_sphere$3)===false)return;//
  _inverseMatrix$2.copy(matrixWorld).invert();_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);// Check boundingBox before continuing
  if(geometry.boundingBox!==null){if(_ray$2.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var index=geometry.index;var position=geometry.attributes.position;var morphPosition=geometry.morphAttributes.position;var morphTargetsRelative=geometry.morphTargetsRelative;var uv=geometry.attributes.uv;var uv2=geometry.attributes.uv2;var groups=geometry.groups;var drawRange=geometry.drawRange;if(index!==null){// indexed buffer geometry
  if(Array.isArray(material)){for(var _i59=0,il=groups.length;_i59<il;_i59++){var group=groups[_i59];var groupMaterial=material[group.materialIndex];var start=Math.max(group.start,drawRange.start);var end=Math.min(index.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(var j=start,jl=end;j<jl;j+=3){var a=index.getX(j);var b=index.getX(j+1);var c=index.getX(j+2);intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
  intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else {var _start3=Math.max(0,drawRange.start);var _end2=Math.min(index.count,drawRange.start+drawRange.count);for(var _i60=_start3,_il6=_end2;_i60<_il6;_i60+=3){var _a=index.getX(_i60);var _b=index.getX(_i60+1);var _c=index.getX(_i60+2);intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a,_b,_c);if(intersection){intersection.faceIndex=Math.floor(_i60/3);// triangle number in indexed buffer semantics
  intersects.push(intersection);}}}}else if(position!==undefined){// non-indexed buffer geometry
  if(Array.isArray(material)){for(var _i61=0,_il7=groups.length;_i61<_il7;_i61++){var _group2=groups[_i61];var _groupMaterial=material[_group2.materialIndex];var _start4=Math.max(_group2.start,drawRange.start);var _end3=Math.min(position.count,Math.min(_group2.start+_group2.count,drawRange.start+drawRange.count));for(var _j2=_start4,_jl2=_end3;_j2<_jl2;_j2+=3){var _a2=_j2;var _b2=_j2+1;var _c2=_j2+2;intersection=checkBufferGeometryIntersection(this,_groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a2,_b2,_c2);if(intersection){intersection.faceIndex=Math.floor(_j2/3);// triangle number in non-indexed buffer semantics
  intersection.face.materialIndex=_group2.materialIndex;intersects.push(intersection);}}}}else {var _start5=Math.max(0,drawRange.start);var _end4=Math.min(position.count,drawRange.start+drawRange.count);for(var _i62=_start5,_il8=_end4;_i62<_il8;_i62+=3){var _a3=_i62;var _b3=_i62+1;var _c3=_i62+2;intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a3,_b3,_c3);if(intersection){intersection.faceIndex=Math.floor(_i62/3);// triangle number in non-indexed buffer semantics
  intersects.push(intersection);}}}}}else if(geometry.isGeometry){console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}}]);return Mesh;}(Object3D$1);Mesh.prototype.isMesh=true;function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){var intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else {intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide$1,point);}if(intersect===null)return null;_intersectionPointWorld.copy(point);_intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return {distance:distance,point:_intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c){_vA$1.fromBufferAttribute(position,a);_vB$1.fromBufferAttribute(position,b);_vC$1.fromBufferAttribute(position,c);var morphInfluences=object.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(var _i63=0,il=morphPosition.length;_i63<il;_i63++){var influence=morphInfluences[_i63];var morphAttribute=morphPosition[_i63];if(influence===0)continue;_tempA.fromBufferAttribute(morphAttribute,a);_tempB.fromBufferAttribute(morphAttribute,b);_tempC.fromBufferAttribute(morphAttribute,c);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);_morphB.addScaledVector(_tempB,influence);_morphC.addScaledVector(_tempC,influence);}else {_morphA.addScaledVector(_tempA.sub(_vA$1),influence);_morphB.addScaledVector(_tempB.sub(_vB$1),influence);_morphC.addScaledVector(_tempC.sub(_vC$1),influence);}}_vA$1.add(_morphA);_vB$1.add(_morphB);_vC$1.add(_morphC);}if(object.isSkinnedMesh){object.boneTransform(a,_vA$1);object.boneTransform(b,_vB$1);object.boneTransform(c,_vC$1);}var intersection=checkIntersection(object,material,raycaster,ray,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(intersection){if(uv){_uvA$1.fromBufferAttribute(uv,a);_uvB$1.fromBufferAttribute(uv,b);_uvC$1.fromBufferAttribute(uv,c);intersection.uv=Triangle$1.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}if(uv2){_uvA$1.fromBufferAttribute(uv2,a);_uvB$1.fromBufferAttribute(uv2,b);_uvC$1.fromBufferAttribute(uv2,c);intersection.uv2=Triangle$1.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}var face={a:a,b:b,c:c,normal:new Vector3(),materialIndex:0};Triangle$1.getNormal(_vA$1,_vB$1,_vC$1,face.normal);intersection.face=face;}return intersection;}var BoxGeometry=/*#__PURE__*/function(_BufferGeometry){_inherits(BoxGeometry,_BufferGeometry);var _super20=_createSuper(BoxGeometry);function BoxGeometry(){var _this11;var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var widthSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var heightSegments=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;var depthSegments=arguments.length>5&&arguments[5]!==undefined?arguments[5]:1;_classCallCheck(this,BoxGeometry);_this11=_super20.call(this);_this11.type='BoxGeometry';_this11.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=_assertThisInitialized(_this11);// segments
  widthSegments=Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);depthSegments=Math.floor(depthSegments);// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
  buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
  buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
  buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
  buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
  buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
  buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
  // build geometry
  _this11.setIndex(indices);_this11.setAttribute('position',new Float32BufferAttribute(vertices,3));_this11.setAttribute('normal',new Float32BufferAttribute(normals,3));_this11.setAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var vector=new Vector3();// generate vertices, normals and uvs
  for(var iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(var ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
  vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
  vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
  vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
  normals.push(vector.x,vector.y,vector.z);// uvs
  uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
  vertexCounter+=1;}}// indices
  // 1. you need three indices to draw a single face
  // 2. a single segment consists of two faces
  // 3. so we need to generate six (2*3) indices per segment
  for(var _iy=0;_iy<gridY;_iy++){for(var _ix=0;_ix<gridX;_ix++){var a=numberOfVertices+_ix+gridX1*_iy;var b=numberOfVertices+_ix+gridX1*(_iy+1);var c=numberOfVertices+(_ix+1)+gridX1*(_iy+1);var d=numberOfVertices+(_ix+1)+gridX1*_iy;// faces
  indices.push(a,b,d);indices.push(b,c,d);// increase counter
  groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
  groupStart+=groupCount;// update total number of vertices
  numberOfVertices+=vertexCounter;}return _this11;}_createClass(BoxGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);}}]);return BoxGeometry;}(BufferGeometry);/**
   * Uniform Utilities
   */function cloneUniforms(src){var dst={};for(var u in src){dst[u]={};for(var p in src[u]){var property=src[u][p];if(property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)){dst[u][p]=property.clone();}else if(Array.isArray(property)){dst[u][p]=property.slice();}else {dst[u][p]=property;}}}return dst;}function mergeUniforms(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var _tmp=cloneUniforms(uniforms[u]);for(var p in _tmp){merged[p]=_tmp[p];}}return merged;}// Legacy
  var UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";/**
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>
   * }
   */var ShaderMaterial=/*#__PURE__*/function(_Material2){_inherits(ShaderMaterial,_Material2);var _super21=_createSuper(ShaderMaterial);function ShaderMaterial(parameters){var _this12;_classCallCheck(this,ShaderMaterial);_this12=_super21.call(this);_this12.type='ShaderMaterial';_this12.defines={};_this12.uniforms={};_this12.vertexShader=default_vertex;_this12.fragmentShader=default_fragment;_this12.linewidth=1;_this12.wireframe=false;_this12.wireframeLinewidth=1;_this12.fog=false;// set to use scene fog
  _this12.lights=false;// set to use scene lights
  _this12.clipping=false;// set to use user-defined clipping planes
  _this12.extensions={derivatives:false,// set to use derivatives
  fragDepth:false,// set to use fragment depth values
  drawBuffers:false,// set to use draw buffers
  shaderTextureLOD:false// set to use shader texture LOD
  };// When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  _this12.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};_this12.index0AttributeName=undefined;_this12.uniformsNeedUpdate=false;_this12.glslVersion=null;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}_this12.setValues(parameters);}return _this12;}_createClass(ShaderMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(ShaderMaterial.prototype),"copy",this).call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.extensions=Object.assign({},source.extensions);this.glslVersion=source.glslVersion;return this;}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(ShaderMaterial.prototype),"toJSON",this).call(this,meta);data.glslVersion=this.glslVersion;data.uniforms={};for(var name in this.uniforms){var uniform=this.uniforms[name];var _value=uniform.value;if(_value&&_value.isTexture){data.uniforms[name]={type:'t',value:_value.toJSON(meta).uuid};}else if(_value&&_value.isColor){data.uniforms[name]={type:'c',value:_value.getHex()};}else if(_value&&_value.isVector2){data.uniforms[name]={type:'v2',value:_value.toArray()};}else if(_value&&_value.isVector3){data.uniforms[name]={type:'v3',value:_value.toArray()};}else if(_value&&_value.isVector4){data.uniforms[name]={type:'v4',value:_value.toArray()};}else if(_value&&_value.isMatrix3){data.uniforms[name]={type:'m3',value:_value.toArray()};}else if(_value&&_value.isMatrix4){data.uniforms[name]={type:'m4',value:_value.toArray()};}else {data.uniforms[name]={value:_value};// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
  }}if(Object.keys(this.defines).length>0)data.defines=this.defines;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;var extensions={};for(var key in this.extensions){if(this.extensions[key]===true)extensions[key]=true;}if(Object.keys(extensions).length>0)data.extensions=extensions;return data;}}]);return ShaderMaterial;}(Material$1);ShaderMaterial.prototype.isShaderMaterial=true;var Camera$1=/*#__PURE__*/function(_Object3D2){_inherits(Camera,_Object3D2);var _super22=_createSuper(Camera);function Camera(){var _this13;_classCallCheck(this,Camera);_this13=_super22.call(this);_this13.type='Camera';_this13.matrixWorldInverse=new Matrix4$1();_this13.projectionMatrix=new Matrix4$1();_this13.projectionMatrixInverse=new Matrix4$1();return _this13;}_createClass(Camera,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(Camera.prototype),"copy",this).call(this,source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);return this;}},{key:"getWorldDirection",value:function getWorldDirection(target){this.updateWorldMatrix(true,false);var e=this.matrixWorld.elements;return target.set(-e[8],-e[9],-e[10]).normalize();}},{key:"updateMatrixWorld",value:function updateMatrixWorld(force){_get(_getPrototypeOf(Camera.prototype),"updateMatrixWorld",this).call(this,force);this.matrixWorldInverse.copy(this.matrixWorld).invert();}},{key:"updateWorldMatrix",value:function updateWorldMatrix(updateParents,updateChildren){_get(_getPrototypeOf(Camera.prototype),"updateWorldMatrix",this).call(this,updateParents,updateChildren);this.matrixWorldInverse.copy(this.matrixWorld).invert();}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Camera;}(Object3D$1);Camera$1.prototype.isCamera=true;var PerspectiveCamera=/*#__PURE__*/function(_Camera){_inherits(PerspectiveCamera,_Camera);var _super23=_createSuper(PerspectiveCamera);function PerspectiveCamera(){var _this14;var fov=arguments.length>0&&arguments[0]!==undefined?arguments[0]:50;var aspect=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.1;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:2000;_classCallCheck(this,PerspectiveCamera);_this14=_super23.call(this);_this14.type='PerspectiveCamera';_this14.fov=fov;_this14.zoom=1;_this14.near=near;_this14.far=far;_this14.focus=10;_this14.aspect=aspect;_this14.view=null;_this14.filmGauge=35;// width of the film (default in millimeters)
  _this14.filmOffset=0;// horizontal film offset (same unit as gauge)
  _this14.updateProjectionMatrix();return _this14;}_createClass(PerspectiveCamera,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(PerspectiveCamera.prototype),"copy",this).call(this,source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;}/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */},{key:"setFocalLength",value:function setFocalLength(focalLength){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();}/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */},{key:"getFocalLength",value:function getFocalLength(){var vExtentSlope=Math.tan(DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;}},{key:"getEffectiveFOV",value:function getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*0.5*this.fov)/this.zoom);}},{key:"getFilmWidth",value:function getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
  return this.filmGauge*Math.min(this.aspect,1);}},{key:"getFilmHeight",value:function getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
  return this.filmGauge/Math.max(this.aspect,1);}/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   const w = 1920;
  	 *   const h = 1080;
  	 *   const fullWidth = w * 3;
  	 *   const fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */},{key:"setViewOffset",value:function setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}},{key:"clearViewOffset",value:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}},{key:"updateProjectionMatrix",value:function updateProjectionMatrix(){var near=this.near;var top=near*Math.tan(DEG2RAD*0.5*this.fov)/this.zoom;var height=2*top;var width=this.aspect*height;var left=-0.5*width;var view=this.view;if(this.view!==null&&this.view.enabled){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(PerspectiveCamera.prototype),"toJSON",this).call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}}]);return PerspectiveCamera;}(Camera$1);PerspectiveCamera.prototype.isPerspectiveCamera=true;var fov=90,aspect=1;var CubeCamera=/*#__PURE__*/function(_Object3D3){_inherits(CubeCamera,_Object3D3);var _super24=_createSuper(CubeCamera);function CubeCamera(near,far,renderTarget){var _this15;_classCallCheck(this,CubeCamera);_this15=_super24.call(this);_this15.type='CubeCamera';if(renderTarget.isWebGLCubeRenderTarget!==true){console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');return _possibleConstructorReturn(_this15);}_this15.renderTarget=renderTarget;var cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.layers=_this15.layers;cameraPX.up.set(0,-1,0);cameraPX.lookAt(new Vector3(1,0,0));_this15.add(cameraPX);var cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.layers=_this15.layers;cameraNX.up.set(0,-1,0);cameraNX.lookAt(new Vector3(-1,0,0));_this15.add(cameraNX);var cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.layers=_this15.layers;cameraPY.up.set(0,0,1);cameraPY.lookAt(new Vector3(0,1,0));_this15.add(cameraPY);var cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.layers=_this15.layers;cameraNY.up.set(0,0,-1);cameraNY.lookAt(new Vector3(0,-1,0));_this15.add(cameraNY);var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.layers=_this15.layers;cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new Vector3(0,0,1));_this15.add(cameraPZ);var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.layers=_this15.layers;cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new Vector3(0,0,-1));_this15.add(cameraNZ);return _this15;}_createClass(CubeCamera,[{key:"update",value:function update(renderer,scene){if(this.parent===null)this.updateMatrixWorld();var renderTarget=this.renderTarget;var _this$children=_slicedToArray(this.children,6),cameraPX=_this$children[0],cameraNX=_this$children[1],cameraPY=_this$children[2],cameraNY=_this$children[3],cameraPZ=_this$children[4],cameraNZ=_this$children[5];var currentXrEnabled=renderer.xr.enabled;var currentRenderTarget=renderer.getRenderTarget();renderer.xr.enabled=false;var generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderer.setRenderTarget(renderTarget,0);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,2);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4);renderer.render(scene,cameraPZ);renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget);renderer.xr.enabled=currentXrEnabled;}}]);return CubeCamera;}(Object3D$1);var CubeTexture=/*#__PURE__*/function(_Texture){_inherits(CubeTexture,_Texture);var _super25=_createSuper(CubeTexture);function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){var _this16;_classCallCheck(this,CubeTexture);images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;_this16=_super25.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);_this16.flipY=false;return _this16;}_createClass(CubeTexture,[{key:"images",get:function get(){return this.image;},set:function set(value){this.image=value;}}]);return CubeTexture;}(Texture);CubeTexture.prototype.isCubeTexture=true;var WebGLCubeRenderTarget=/*#__PURE__*/function(_WebGLRenderTarget3){_inherits(WebGLCubeRenderTarget,_WebGLRenderTarget3);var _super26=_createSuper(WebGLCubeRenderTarget);function WebGLCubeRenderTarget(size,options,dummy){var _this17;_classCallCheck(this,WebGLCubeRenderTarget);if(Number.isInteger(options)){console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');options=dummy;}_this17=_super26.call(this,size,size,options);options=options||{};// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
  // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
  // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
  _this17.texture=new CubeTexture(undefined,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);_this17.texture.isRenderTargetTexture=true;_this17.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;_this17.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;_this17.texture._needsFlipEnvMap=false;return _this17;}_createClass(WebGLCubeRenderTarget,[{key:"fromEquirectangularTexture",value:function fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type;this.texture.format=RGBAFormat;// see #18859
  this.texture.encoding=texture.encoding;this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;var shader={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:/* glsl */"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"};var geometry=new BoxGeometry(5,5,5);var material=new ShaderMaterial({name:'CubemapFromEquirect',uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;var mesh=new Mesh(geometry,material);var currentMinFilter=texture.minFilter;// Avoid blurred poles
  if(texture.minFilter===LinearMipmapLinearFilter)texture.minFilter=LinearFilter;var camera=new CubeCamera(1,10,this);camera.update(renderer,mesh);texture.minFilter=currentMinFilter;mesh.geometry.dispose();mesh.material.dispose();return this;}},{key:"clear",value:function clear(renderer,color,depth,stencil){var currentRenderTarget=renderer.getRenderTarget();for(var _i64=0;_i64<6;_i64++){renderer.setRenderTarget(this,_i64);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(currentRenderTarget);}}]);return WebGLCubeRenderTarget;}(WebGLRenderTarget);WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=true;var _vector1=/*@__PURE__*/new Vector3();var _vector2=/*@__PURE__*/new Vector3();var _normalMatrix=/*@__PURE__*/new Matrix3$1();var Plane$1=/*#__PURE__*/function(){function Plane(){var normal=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3(1,0,0);var constant=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;_classCallCheck(this,Plane);// normal is assumed to be normalized
  this.normal=normal;this.constant=constant;}_createClass(Plane,[{key:"set",value:function set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;}},{key:"setComponents",value:function setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;}},{key:"setFromNormalAndCoplanarPoint",value:function setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;}},{key:"setFromCoplanarPoints",value:function setFromCoplanarPoints(a,b,c){var normal=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
  this.setFromNormalAndCoplanarPoint(normal,a);return this;}},{key:"copy",value:function copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;}},{key:"normalize",value:function normalize(){// Note: will lead to a divide by zero if the plane is invalid.
  var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;}},{key:"negate",value:function negate(){this.constant*=-1;this.normal.negate();return this;}},{key:"distanceToPoint",value:function distanceToPoint(point){return this.normal.dot(point)+this.constant;}},{key:"distanceToSphere",value:function distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;}},{key:"projectPoint",value:function projectPoint(point,target){return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);}},{key:"intersectLine",value:function intersectLine(line,target){var direction=line.delta(_vector1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
  if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
  return null;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return null;}return target.copy(direction).multiplyScalar(t).add(line.start);}},{key:"intersectsLine",value:function intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
  var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;}},{key:"intersectsBox",value:function intersectsBox(box){return box.intersectsPlane(this);}},{key:"intersectsSphere",value:function intersectsSphere(sphere){return sphere.intersectsPlane(this);}},{key:"coplanarPoint",value:function coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant);}},{key:"applyMatrix4",value:function applyMatrix4(matrix,optionalNormalMatrix){var normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);var referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;}},{key:"translate",value:function translate(offset){this.constant-=offset.dot(this.normal);return this;}},{key:"equals",value:function equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Plane;}();Plane$1.prototype.isPlane=true;var _sphere$2=/*@__PURE__*/new Sphere();var _vector$7=/*@__PURE__*/new Vector3();var Frustum=/*#__PURE__*/function(){function Frustum(){var p0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Plane$1();var p1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Plane$1();var p2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Plane$1();var p3=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Plane$1();var p4=arguments.length>4&&arguments[4]!==undefined?arguments[4]:new Plane$1();var p5=arguments.length>5&&arguments[5]!==undefined?arguments[5]:new Plane$1();_classCallCheck(this,Frustum);this.planes=[p0,p1,p2,p3,p4,p5];}_createClass(Frustum,[{key:"set",value:function set(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;}},{key:"copy",value:function copy(frustum){var planes=this.planes;for(var _i65=0;_i65<6;_i65++){planes[_i65].copy(frustum.planes[_i65]);}return this;}},{key:"setFromProjectionMatrix",value:function setFromProjectionMatrix(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;}},{key:"intersectsObject",value:function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(_sphere$2);}},{key:"intersectsSprite",value:function intersectsSprite(sprite){_sphere$2.center.set(0,0,0);_sphere$2.radius=0.7071067811865476;_sphere$2.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$2);}},{key:"intersectsSphere",value:function intersectsSphere(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var _i66=0;_i66<6;_i66++){var distance=planes[_i66].distanceToPoint(center);if(distance<negRadius){return false;}}return true;}},{key:"intersectsBox",value:function intersectsBox(box){var planes=this.planes;for(var _i67=0;_i67<6;_i67++){var plane=planes[_i67];// corner at max distance
  _vector$7.x=plane.normal.x>0?box.max.x:box.min.x;_vector$7.y=plane.normal.y>0?box.max.y:box.min.y;_vector$7.z=plane.normal.z>0?box.max.z:box.min.z;if(plane.distanceToPoint(_vector$7)<0){return false;}}return true;}},{key:"containsPoint",value:function containsPoint(point){var planes=this.planes;for(var _i68=0;_i68<6;_i68++){if(planes[_i68].distanceToPoint(point)<0){return false;}}return true;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Frustum;}();function WebGLAnimation(){var context=null;var isAnimating=false;var animationLoop=null;var requestId=null;function onAnimationFrame(time,frame){animationLoop(time,frame);requestId=context.requestAnimationFrame(onAnimationFrame);}return {start:function start(){if(isAnimating===true)return;if(animationLoop===null)return;requestId=context.requestAnimationFrame(onAnimationFrame);isAnimating=true;},stop:function stop(){context.cancelAnimationFrame(requestId);isAnimating=false;},setAnimationLoop:function setAnimationLoop(callback){animationLoop=callback;},setContext:function setContext(value){context=value;}};}function WebGLAttributes(gl,capabilities){var isWebGL2=capabilities.isWebGL2;var buffers=new WeakMap();function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.usage;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type=5126;if(array instanceof Float32Array){type=5126;}else if(array instanceof Float64Array){console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');}else if(array instanceof Uint16Array){if(attribute.isFloat16BufferAttribute){if(isWebGL2){type=5131;}else {console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');}}else {type=5123;}}else if(array instanceof Int16Array){type=5122;}else if(array instanceof Uint32Array){type=5125;}else if(array instanceof Int32Array){type=5124;}else if(array instanceof Int8Array){type=5120;}else if(array instanceof Uint8Array){type=5121;}else if(array instanceof Uint8ClampedArray){type=5121;}return {buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(updateRange.count===-1){// Not using update ranges
  gl.bufferSubData(bufferType,0,array);}else {if(isWebGL2){gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array,updateRange.offset,updateRange.count);}else {gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));}updateRange.count=-1;// reset range
  }}//
  function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers["delete"](attribute);}}function update(attribute,bufferType){if(attribute.isGLBufferAttribute){var cached=buffers.get(attribute);if(!cached||cached.version<attribute.version){buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});}return;}if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return {get:get,remove:remove,update:update};}var PlaneGeometry=/*#__PURE__*/function(_BufferGeometry2){_inherits(PlaneGeometry,_BufferGeometry2);var _super27=_createSuper(PlaneGeometry);function PlaneGeometry(){var _this18;var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var widthSegments=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var heightSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,PlaneGeometry);_this18=_super27.call(this);_this18.type='PlaneGeometry';_this18.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments);var gridY=Math.floor(heightSegments);var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;//
  var indices=[];var vertices=[];var normals=[];var uvs=[];for(var iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(var ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}for(var _iy2=0;_iy2<gridY;_iy2++){for(var _ix2=0;_ix2<gridX;_ix2++){var a=_ix2+gridX1*_iy2;var b=_ix2+gridX1*(_iy2+1);var c=_ix2+1+gridX1*(_iy2+1);var d=_ix2+1+gridX1*_iy2;indices.push(a,b,d);indices.push(b,c,d);}}_this18.setIndex(indices);_this18.setAttribute('position',new Float32BufferAttribute(vertices,3));_this18.setAttribute('normal',new Float32BufferAttribute(normals,3));_this18.setAttribute('uv',new Float32BufferAttribute(uvs,2));return _this18;}_createClass(PlaneGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments);}}]);return PlaneGeometry;}(BufferGeometry);var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var alphatest_fragment="#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";var alphatest_pars_fragment="#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="vec3 transformed = vec3( position );";var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var bsdfs="vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenTint * ( D * V );\n}\n#endif";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var color_fragment="#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_pars_vertex="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_vertex="#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";var common="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";var defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var encodings_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";var envmap_fragment="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var envmap_common_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";var envmap_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var envmap_vertex="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var fog_vertex="#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";var lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";var envmap_physical_pars_fragment="#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";var lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";var lights_toon_pars_fragment="varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_phong_pars_fragment="varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var map_particle_pars_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";var normal_fragment_begin="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";var normal_fragment_maps="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";var normal_pars_fragment="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_pars_vertex="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_vertex="#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";var clearcoat_normal_fragment_begin="#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";var clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";var clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";var output_fragment="#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var dithering_fragment="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var dithering_pars_fragment="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var tonemapping_pars_fragment="#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";var transmission_fragment="#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";var transmission_pars_fragment="#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";var uv_pars_fragment="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";var uv_vertex="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";var vertex$g="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";var fragment$g="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$f="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";var fragment$f="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$e="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";var fragment$e="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";var vertex$d="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";var fragment$d="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";var vertex$c="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";var fragment$c="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$b="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var fragment$b="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var vertex$a="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$a="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$9="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$9="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$8="#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";var fragment$8="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$7="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";var fragment$7="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";var vertex$6="#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$6="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$5="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";var fragment$5="#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n\tuniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$4="#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$4="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$3="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";var fragment$3="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var vertex$2="#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$2="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var vertex$1="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var fragment$1="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,alphatest_pars_fragment:alphatest_pars_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_common_pars_fragment:envmap_common_pars_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_physical_pars_fragment:envmap_physical_pars_fragment,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars_begin:lights_pars_begin,lights_toon_fragment:lights_toon_fragment,lights_toon_pars_fragment:lights_toon_pars_fragment,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normal_pars_fragment:normal_pars_fragment,normal_pars_vertex:normal_pars_vertex,normal_vertex:normal_vertex,normalmap_pars_fragment:normalmap_pars_fragment,clearcoat_normal_fragment_begin:clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:clearcoat_normal_fragment_maps,clearcoat_pars_fragment:clearcoat_pars_fragment,output_fragment:output_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,transmission_fragment:transmission_fragment,transmission_pars_fragment:transmission_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,background_vert:vertex$g,background_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1};/**
   * Uniforms library for shared webgl shaders
   */var UniformsLib={common:{diffuse:{value:new Color$2(0xffffff)},opacity:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3$1()},uv2Transform:{value:new Matrix3$1()},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},// basic, lambert, phong
  ior:{value:1.5},// standard, physical
  refractionRatio:{value:0.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color$2(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color$2(0xffffff)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3$1()}},sprite:{diffuse:{value:new Color$2(0xffffff)},opacity:{value:1.0},center:{value:new Vector2(0.5,0.5)},rotation:{value:0.0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3$1()}}};var ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$2(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$2(0x000000)},specular:{value:new Color$2(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$2(0x000000)},roughness:{value:1.0},metalness:{value:0.0},envMapIntensity:{value:1}// temporary
  }]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$2(0x000000)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3$1()},t2D:{value:null}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},/* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */cube:{uniforms:mergeUniforms([UniformsLib.envmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color$2(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenTint:{value:new Color$2(0x000000)},sheenRoughness:{value:0},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Vector2()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new Color$2(0x000000)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new Color$2(1,1,1)},specularTintMap:{value:null}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};function WebGLBackground(renderer,cubemaps,state,objects,premultipliedAlpha){var clearColor=new Color$2(0x000000);var clearAlpha=0;var planeMesh;var boxMesh;var currentBackground=null;var currentBackgroundVersion=0;var currentTonemapping=null;function render(renderList,scene){var forceClear=false;var background=scene.isScene===true?scene.background:null;if(background&&background.isTexture){background=cubemaps.get(background);}// Ignore background in AR
  // TODO: Reconsider this.
  var xr=renderer.xr;var session=xr.getSession&&xr.getSession();if(session&&session.environmentBlendMode==='additive'){background=null;}if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}if(renderer.autoClear||forceClear){renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}if(background&&(background.isCubeTexture||background.mapping===CubeUVReflectionMapping)){if(boxMesh===undefined){boxMesh=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:'BackgroundCubeMaterial',uniforms:cloneUniforms(ShaderLib.cube.uniforms),vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));boxMesh.geometry.deleteAttribute('normal');boxMesh.geometry.deleteAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};// enable code injection for non-built-in material
  Object.defineProperty(boxMesh.material,'envMap',{get:function get(){return this.uniforms.envMap.value;}});objects.update(boxMesh);}boxMesh.material.uniforms.envMap.value=background;boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&background.isRenderTargetTexture===false?-1:1;if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){boxMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
  renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);}else if(background&&background.isTexture){if(planeMesh===undefined){planeMesh=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:'BackgroundMaterial',uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:false,depthWrite:false,fog:false}));planeMesh.geometry.deleteAttribute('normal');// enable code injection for non-built-in material
  Object.defineProperty(planeMesh.material,'map',{get:function get(){return this.uniforms.t2D.value;}});objects.update(planeMesh);}planeMesh.material.uniforms.t2D.value=background;if(background.matrixAutoUpdate===true){background.updateMatrix();}planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){planeMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
  renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);}}function setClear(color,alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);}return {getClearColor:function getClearColor(){return clearColor;},setClearColor:function setClearColor(color){var alpha=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;clearColor.set(color);clearAlpha=alpha;setClear(clearColor,clearAlpha);},getClearAlpha:function getClearAlpha(){return clearAlpha;},setClearAlpha:function setClearAlpha(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render};}function WebGLBindingStates(gl,extensions,attributes,capabilities){var maxVertexAttributes=gl.getParameter(34921);var extension=capabilities.isWebGL2?null:extensions.get('OES_vertex_array_object');var vaoAvailable=capabilities.isWebGL2||extension!==null;var bindingStates={};var defaultState=createBindingState(null);var currentState=defaultState;function setup(object,material,program,geometry,index){var updateBuffers=false;if(vaoAvailable){var state=getBindingState(geometry,program,material);if(currentState!==state){currentState=state;bindVertexArrayObject(currentState.object);}updateBuffers=needsUpdate(geometry,index);if(updateBuffers)saveCache(geometry,index);}else {var wireframe=material.wireframe===true;if(currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==wireframe){currentState.geometry=geometry.id;currentState.program=program.id;currentState.wireframe=wireframe;updateBuffers=true;}}if(object.isInstancedMesh===true){updateBuffers=true;}if(index!==null){attributes.update(index,34963);}if(updateBuffers){setupVertexAttributes(object,material,program,geometry);if(index!==null){gl.bindBuffer(34963,attributes.get(index).buffer);}}}function createVertexArrayObject(){if(capabilities.isWebGL2)return gl.createVertexArray();return extension.createVertexArrayOES();}function bindVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.bindVertexArray(vao);return extension.bindVertexArrayOES(vao);}function deleteVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.deleteVertexArray(vao);return extension.deleteVertexArrayOES(vao);}function getBindingState(geometry,program,material){var wireframe=material.wireframe===true;var programMap=bindingStates[geometry.id];if(programMap===undefined){programMap={};bindingStates[geometry.id]=programMap;}var stateMap=programMap[program.id];if(stateMap===undefined){stateMap={};programMap[program.id]=stateMap;}var state=stateMap[wireframe];if(state===undefined){state=createBindingState(createVertexArrayObject());stateMap[wireframe]=state;}return state;}function createBindingState(vao){var newAttributes=[];var enabledAttributes=[];var attributeDivisors=[];for(var _i69=0;_i69<maxVertexAttributes;_i69++){newAttributes[_i69]=0;enabledAttributes[_i69]=0;attributeDivisors[_i69]=0;}return {// for backward compatibility on non-VAO support browser
  geometry:null,program:null,wireframe:false,newAttributes:newAttributes,enabledAttributes:enabledAttributes,attributeDivisors:attributeDivisors,object:vao,attributes:{},index:null};}function needsUpdate(geometry,index){var cachedAttributes=currentState.attributes;var geometryAttributes=geometry.attributes;var attributesNum=0;for(var key in geometryAttributes){var cachedAttribute=cachedAttributes[key];var geometryAttribute=geometryAttributes[key];if(cachedAttribute===undefined)return true;if(cachedAttribute.attribute!==geometryAttribute)return true;if(cachedAttribute.data!==geometryAttribute.data)return true;attributesNum++;}if(currentState.attributesNum!==attributesNum)return true;if(currentState.index!==index)return true;return false;}function saveCache(geometry,index){var cache={};var attributes=geometry.attributes;var attributesNum=0;for(var key in attributes){var attribute=attributes[key];var data={};data.attribute=attribute;if(attribute.data){data.data=attribute.data;}cache[key]=data;attributesNum++;}currentState.attributes=cache;currentState.attributesNum=attributesNum;currentState.index=index;}function initAttributes(){var newAttributes=currentState.newAttributes;for(var _i70=0,il=newAttributes.length;_i70<il;_i70++){newAttributes[_i70]=0;}}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0);}function enableAttributeAndDivisor(attribute,meshPerAttribute){var newAttributes=currentState.newAttributes;var enabledAttributes=currentState.enabledAttributes;var attributeDivisors=currentState.attributeDivisors;newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var _extension=capabilities.isWebGL2?gl:extensions.get('ANGLE_instanced_arrays');_extension[capabilities.isWebGL2?'vertexAttribDivisor':'vertexAttribDivisorANGLE'](attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){var newAttributes=currentState.newAttributes;var enabledAttributes=currentState.enabledAttributes;for(var _i71=0,il=enabledAttributes.length;_i71<il;_i71++){if(enabledAttributes[_i71]!==newAttributes[_i71]){gl.disableVertexAttribArray(_i71);enabledAttributes[_i71]=0;}}}function vertexAttribPointer(index,size,type,normalized,stride,offset){if(capabilities.isWebGL2===true&&(type===5124||type===5125)){gl.vertexAttribIPointer(index,size,type,stride,offset);}else {gl.vertexAttribPointer(index,size,type,normalized,stride,offset);}}function setupVertexAttributes(object,material,program,geometry){if(capabilities.isWebGL2===false&&(object.isInstancedMesh||geometry.isInstancedBufferGeometry)){if(extensions.get('ANGLE_instanced_arrays')===null)return;}initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute.location>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
  if(attribute===undefined)continue;var buffer=attribute.buffer;var type=attribute.type;var bytesPerElement=attribute.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){for(var _i72=0;_i72<programAttribute.locationSize;_i72++){enableAttributeAndDivisor(programAttribute.location+_i72,data.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=data.meshPerAttribute*data.count;}}else {for(var _i73=0;_i73<programAttribute.locationSize;_i73++){enableAttribute(programAttribute.location+_i73);}}gl.bindBuffer(34962,buffer);for(var _i74=0;_i74<programAttribute.locationSize;_i74++){vertexAttribPointer(programAttribute.location+_i74,size/programAttribute.locationSize,type,normalized,stride*bytesPerElement,(offset+size/programAttribute.locationSize*_i74)*bytesPerElement);}}else {if(geometryAttribute.isInstancedBufferAttribute){for(var _i75=0;_i75<programAttribute.locationSize;_i75++){enableAttributeAndDivisor(programAttribute.location+_i75,geometryAttribute.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else {for(var _i76=0;_i76<programAttribute.locationSize;_i76++){enableAttribute(programAttribute.location+_i76);}}gl.bindBuffer(34962,buffer);for(var _i77=0;_i77<programAttribute.locationSize;_i77++){vertexAttribPointer(programAttribute.location+_i77,size/programAttribute.locationSize,type,normalized,size*bytesPerElement,size/programAttribute.locationSize*_i77*bytesPerElement);}}}else if(materialDefaultAttributeValues!==undefined){var _value2=materialDefaultAttributeValues[name];if(_value2!==undefined){switch(_value2.length){case 2:gl.vertexAttrib2fv(programAttribute.location,_value2);break;case 3:gl.vertexAttrib3fv(programAttribute.location,_value2);break;case 4:gl.vertexAttrib4fv(programAttribute.location,_value2);break;default:gl.vertexAttrib1fv(programAttribute.location,_value2);}}}}}disableUnusedAttributes();}function dispose(){reset();for(var geometryId in bindingStates){var programMap=bindingStates[geometryId];for(var programId in programMap){var stateMap=programMap[programId];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometryId];}}function releaseStatesOfGeometry(geometry){if(bindingStates[geometry.id]===undefined)return;var programMap=bindingStates[geometry.id];for(var programId in programMap){var stateMap=programMap[programId];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometry.id];}function releaseStatesOfProgram(program){for(var geometryId in bindingStates){var programMap=bindingStates[geometryId];if(programMap[program.id]===undefined)continue;var stateMap=programMap[program.id];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[program.id];}}function reset(){resetDefaultState();if(currentState===defaultState)return;currentState=defaultState;bindVertexArrayObject(currentState.object);}// for backward-compatilibity
  function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=false;}return {setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes};}function WebGLBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawArraysInstanced';}else {extension=extensions.get('ANGLE_instanced_arrays');methodName='drawArraysInstancedANGLE';if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,start,count,primcount);info.update(count,mode,primcount);}//
  this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;if(extensions.has('EXT_texture_filter_anisotropic')===true){var extension=extensions.get('EXT_texture_filter_anisotropic');maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else {maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(35633,36338).precision>0&&gl.getShaderPrecisionFormat(35632,36338).precision>0){return 'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(35633,36337).precision>0&&gl.getShaderPrecisionFormat(35632,36337).precision>0){return 'mediump';}}return 'lowp';}/* eslint-disable no-undef */var isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&gl instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!=='undefined'&&gl instanceof WebGL2ComputeRenderingContext;/* eslint-enable no-undef */var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var drawBuffers=isWebGL2||extensions.has('WEBGL_draw_buffers');var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;var maxTextures=gl.getParameter(34930);var maxVertexTextures=gl.getParameter(35660);var maxTextureSize=gl.getParameter(3379);var maxCubemapSize=gl.getParameter(34076);var maxAttributes=gl.getParameter(34921);var maxVertexUniforms=gl.getParameter(36347);var maxVaryings=gl.getParameter(36348);var maxFragmentUniforms=gl.getParameter(36349);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=isWebGL2||extensions.has('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;var maxSamples=isWebGL2?gl.getParameter(36183):0;return {isWebGL2:isWebGL2,drawBuffers:drawBuffers,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures,maxSamples:maxSamples};}function WebGLClipping(properties){var scope=this;var globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false;var plane=new Plane$1(),viewNormalMatrix=new Matrix3$1(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
  // run another frame in order to reset the state:
  numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(material,camera,useCache){var planes=material.clippingPlanes,clipIntersection=material.clipIntersection,clipShadows=material.clipShadows;var materialProperties=properties.get(material);if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
  if(renderingShadows){// there's no global clipping
  projectPlanes(null);}else {resetGlobalState();}}else {var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4;var dstArray=materialProperties.clippingState||null;uniform.value=dstArray;// ensure unique state
  dstArray=projectPlanes(planes,camera,lGlobal,useCache);for(var _i78=0;_i78!==lGlobal;++_i78){dstArray[_i78]=globalState[_i78];}materialProperties.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0;var dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var _i79=0,i4=dstOffset;_i79!==nPlanes;++_i79,i4+=4){plane.copy(planes[_i79]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray;}}function WebGLCubeMaps(renderer){var cubemaps=new WeakMap();function mapTextureMapping(texture,mapping){if(mapping===EquirectangularReflectionMapping){texture.mapping=CubeReflectionMapping;}else if(mapping===EquirectangularRefractionMapping){texture.mapping=CubeRefractionMapping;}return texture;}function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===false){var mapping=texture.mapping;if(mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping){if(cubemaps.has(texture)){var cubemap=cubemaps.get(texture).texture;return mapTextureMapping(cubemap,texture.mapping);}else {var image=texture.image;if(image&&image.height>0){var currentRenderTarget=renderer.getRenderTarget();var renderTarget=new WebGLCubeRenderTarget(image.height/2);renderTarget.fromEquirectangularTexture(renderer,texture);cubemaps.set(texture,renderTarget);renderer.setRenderTarget(currentRenderTarget);texture.addEventListener('dispose',onTextureDispose);return mapTextureMapping(renderTarget.texture,texture.mapping);}else {// image not yet ready. try the conversion next frame
  return null;}}}}return texture;}function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);var cubemap=cubemaps.get(texture);if(cubemap!==undefined){cubemaps["delete"](texture);cubemap.dispose();}}function dispose(){cubemaps=new WeakMap();}return {get:get,dispose:dispose};}var OrthographicCamera=/*#__PURE__*/function(_Camera2){_inherits(OrthographicCamera,_Camera2);var _super28=_createSuper(OrthographicCamera);function OrthographicCamera(){var _this19;var left=arguments.length>0&&arguments[0]!==undefined?arguments[0]:-1;var right=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var top=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var bottom=arguments.length>3&&arguments[3]!==undefined?arguments[3]:-1;var near=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0.1;var far=arguments.length>5&&arguments[5]!==undefined?arguments[5]:2000;_classCallCheck(this,OrthographicCamera);_this19=_super28.call(this);_this19.type='OrthographicCamera';_this19.zoom=1;_this19.view=null;_this19.left=left;_this19.right=right;_this19.top=top;_this19.bottom=bottom;_this19.near=near;_this19.far=far;_this19.updateProjectionMatrix();return _this19;}_createClass(OrthographicCamera,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(OrthographicCamera.prototype),"copy",this).call(this,source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;}},{key:"setViewOffset",value:function setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}},{key:"clearViewOffset",value:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}},{key:"updateProjectionMatrix",value:function updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null&&this.view.enabled){var scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom;var scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX;right=left+scaleW*this.view.width;top-=scaleH*this.view.offsetY;bottom=top-scaleH*this.view.height;}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(OrthographicCamera.prototype),"toJSON",this).call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}}]);return OrthographicCamera;}(Camera$1);OrthographicCamera.prototype.isOrthographicCamera=true;var RawShaderMaterial=/*#__PURE__*/function(_ShaderMaterial){_inherits(RawShaderMaterial,_ShaderMaterial);var _super29=_createSuper(RawShaderMaterial);function RawShaderMaterial(parameters){var _this20;_classCallCheck(this,RawShaderMaterial);_this20=_super29.call(this,parameters);_this20.type='RawShaderMaterial';return _this20;}return _createClass(RawShaderMaterial);}(ShaderMaterial);RawShaderMaterial.prototype.isRawShaderMaterial=true;var LOD_MIN=4;var LOD_MAX=8;var SIZE_MAX=Math.pow(2,LOD_MAX);// The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  var EXTRA_LOD_SIGMA=[0.125,0.215,0.35,0.446,0.526,0.582];var TOTAL_LODS=LOD_MAX-LOD_MIN+1+EXTRA_LOD_SIGMA.length;// The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  var MAX_SAMPLES=20;var ENCODINGS=(_ENCODINGS={},_defineProperty(_ENCODINGS,LinearEncoding,0),_defineProperty(_ENCODINGS,sRGBEncoding,1),_defineProperty(_ENCODINGS,RGBEEncoding,2),_defineProperty(_ENCODINGS,RGBM7Encoding,3),_defineProperty(_ENCODINGS,RGBM16Encoding,4),_defineProperty(_ENCODINGS,RGBDEncoding,5),_defineProperty(_ENCODINGS,GammaEncoding,6),_ENCODINGS);var _flatCamera=/*@__PURE__*/new OrthographicCamera();var _createPlanes2=/*@__PURE__*/_createPlanes(),_lodPlanes=_createPlanes2._lodPlanes,_sizeLods=_createPlanes2._sizeLods,_sigmas=_createPlanes2._sigmas;var _clearColor=/*@__PURE__*/new Color$2();var _oldTarget=null;// Golden Ratio
  var PHI=(1+Math.sqrt(5))/2;var INV_PHI=1/PHI;// Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  var _axisDirections=[/*@__PURE__*/new Vector3(1,1,1),/*@__PURE__*/new Vector3(-1,1,1),/*@__PURE__*/new Vector3(1,1,-1),/*@__PURE__*/new Vector3(-1,1,-1),/*@__PURE__*/new Vector3(0,PHI,INV_PHI),/*@__PURE__*/new Vector3(0,PHI,-INV_PHI),/*@__PURE__*/new Vector3(INV_PHI,0,PHI),/*@__PURE__*/new Vector3(-INV_PHI,0,PHI),/*@__PURE__*/new Vector3(PHI,INV_PHI,0),/*@__PURE__*/new Vector3(-PHI,INV_PHI,0)];/**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting
   * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
  */var PMREMGenerator=/*#__PURE__*/function(){function PMREMGenerator(renderer){_classCallCheck(this,PMREMGenerator);this._renderer=renderer;this._pingPongRenderTarget=null;this._blurMaterial=_getBlurShader(MAX_SAMPLES);this._equirectShader=null;this._cubemapShader=null;this._compileMaterial(this._blurMaterial);}/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
  	 * is placed at the origin).
  	 */_createClass(PMREMGenerator,[{key:"fromScene",value:function fromScene(scene){var sigma=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.1;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;_oldTarget=this._renderer.getRenderTarget();var cubeUVRenderTarget=this._allocateTargets();this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget);if(sigma>0){this._blur(cubeUVRenderTarget,0,0,sigma);}this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */},{key:"fromEquirectangular",value:function fromEquirectangular(equirectangular){return this._fromTexture(equirectangular);}/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */},{key:"fromCubemap",value:function fromCubemap(cubemap){return this._fromTexture(cubemap);}/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */},{key:"compileCubemapShader",value:function compileCubemapShader(){if(this._cubemapShader===null){this._cubemapShader=_getCubemapShader();this._compileMaterial(this._cubemapShader);}}/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */},{key:"compileEquirectangularShader",value:function compileEquirectangularShader(){if(this._equirectShader===null){this._equirectShader=_getEquirectShader();this._compileMaterial(this._equirectShader);}}/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */},{key:"dispose",value:function dispose(){this._blurMaterial.dispose();if(this._cubemapShader!==null)this._cubemapShader.dispose();if(this._equirectShader!==null)this._equirectShader.dispose();for(var _i80=0;_i80<_lodPlanes.length;_i80++){_lodPlanes[_i80].dispose();}}// private interface
  },{key:"_cleanup",value:function _cleanup(outputTarget){this._pingPongRenderTarget.dispose();this._renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=false;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height);}},{key:"_fromTexture",value:function _fromTexture(texture){_oldTarget=this._renderer.getRenderTarget();var cubeUVRenderTarget=this._allocateTargets(texture);this._textureToCubeUV(texture,cubeUVRenderTarget);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}},{key:"_allocateTargets",value:function _allocateTargets(texture){// warning: null texture is valid
  var params={magFilter:NearestFilter,minFilter:NearestFilter,generateMipmaps:false,type:UnsignedByteType,format:RGBEFormat,encoding:_isLDR(texture)?texture.encoding:RGBEEncoding,depthBuffer:false};var cubeUVRenderTarget=_createRenderTarget(params);cubeUVRenderTarget.depthBuffer=texture?false:true;this._pingPongRenderTarget=_createRenderTarget(params);return cubeUVRenderTarget;}},{key:"_compileMaterial",value:function _compileMaterial(material){var tmpMesh=new Mesh(_lodPlanes[0],material);this._renderer.compile(tmpMesh,_flatCamera);}},{key:"_sceneToCubeUV",value:function _sceneToCubeUV(scene,near,far,cubeUVRenderTarget){var fov=90;var aspect=1;var cubeCamera=new PerspectiveCamera(fov,aspect,near,far);var upSign=[1,-1,1,1,1,1];var forwardSign=[1,1,1,-1,-1,-1];var renderer=this._renderer;var originalAutoClear=renderer.autoClear;var outputEncoding=renderer.outputEncoding;var toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);renderer.toneMapping=NoToneMapping;renderer.outputEncoding=LinearEncoding;renderer.autoClear=false;var backgroundMaterial=new MeshBasicMaterial$1({name:'PMREM.Background',side:BackSide,depthWrite:false,depthTest:false});var backgroundBox=new Mesh(new BoxGeometry(),backgroundMaterial);var useSolidColor=false;var background=scene.background;if(background){if(background.isColor){backgroundMaterial.color.copy(background);scene.background=null;useSolidColor=true;}}else {backgroundMaterial.color.copy(_clearColor);useSolidColor=true;}for(var _i81=0;_i81<6;_i81++){var col=_i81%3;if(col==0){cubeCamera.up.set(0,upSign[_i81],0);cubeCamera.lookAt(forwardSign[_i81],0,0);}else if(col==1){cubeCamera.up.set(0,0,upSign[_i81]);cubeCamera.lookAt(0,forwardSign[_i81],0);}else {cubeCamera.up.set(0,upSign[_i81],0);cubeCamera.lookAt(0,0,forwardSign[_i81]);}_setViewport(cubeUVRenderTarget,col*SIZE_MAX,_i81>2?SIZE_MAX:0,SIZE_MAX,SIZE_MAX);renderer.setRenderTarget(cubeUVRenderTarget);if(useSolidColor){renderer.render(backgroundBox,cubeCamera);}renderer.render(scene,cubeCamera);}backgroundBox.geometry.dispose();backgroundBox.material.dispose();renderer.toneMapping=toneMapping;renderer.outputEncoding=outputEncoding;renderer.autoClear=originalAutoClear;scene.background=background;}},{key:"_setEncoding",value:function _setEncoding(uniform,texture){if(this._renderer.capabilities.isWebGL2===true&&texture.format===RGBAFormat&&texture.type===UnsignedByteType&&texture.encoding===sRGBEncoding){uniform.value=ENCODINGS[LinearEncoding];}else {uniform.value=ENCODINGS[texture.encoding];}}},{key:"_textureToCubeUV",value:function _textureToCubeUV(texture,cubeUVRenderTarget){var renderer=this._renderer;if(texture.isCubeTexture){if(this._cubemapShader==null){this._cubemapShader=_getCubemapShader();}}else {if(this._equirectShader==null){this._equirectShader=_getEquirectShader();}}var material=texture.isCubeTexture?this._cubemapShader:this._equirectShader;var mesh=new Mesh(_lodPlanes[0],material);var uniforms=material.uniforms;uniforms['envMap'].value=texture;if(!texture.isCubeTexture){uniforms['texelSize'].value.set(1.0/texture.image.width,1.0/texture.image.height);}this._setEncoding(uniforms['inputEncoding'],texture);this._setEncoding(uniforms['outputEncoding'],cubeUVRenderTarget.texture);_setViewport(cubeUVRenderTarget,0,0,3*SIZE_MAX,2*SIZE_MAX);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(mesh,_flatCamera);}},{key:"_applyPMREM",value:function _applyPMREM(cubeUVRenderTarget){var renderer=this._renderer;var autoClear=renderer.autoClear;renderer.autoClear=false;for(var _i82=1;_i82<TOTAL_LODS;_i82++){var sigma=Math.sqrt(_sigmas[_i82]*_sigmas[_i82]-_sigmas[_i82-1]*_sigmas[_i82-1]);var poleAxis=_axisDirections[(_i82-1)%_axisDirections.length];this._blur(cubeUVRenderTarget,_i82-1,_i82,sigma,poleAxis);}renderer.autoClear=autoClear;}/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 */},{key:"_blur",value:function _blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){var pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,'latitudinal',poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,'longitudinal',poleAxis);}},{key:"_halfBlur",value:function _halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){var renderer=this._renderer;var blurMaterial=this._blurMaterial;if(direction!=='latitudinal'&&direction!=='longitudinal'){console.error('blur direction must be either latitudinal or longitudinal!');}// Number of standard deviations at which to cut off the discrete approximation.
  var STANDARD_DEVIATIONS=3;var blurMesh=new Mesh(_lodPlanes[lodOut],blurMaterial);var blurUniforms=blurMaterial.uniforms;var pixels=_sizeLods[lodIn]-1;var radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1);var sigmaPixels=sigmaRadians/radiansPerPixel;var samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;if(samples>MAX_SAMPLES){console.warn("sigmaRadians, ".concat(sigmaRadians,", is too large and will clip, as it requested ").concat(samples," samples when the maximum is set to ").concat(MAX_SAMPLES));}var weights=[];var sum=0;for(var _i83=0;_i83<MAX_SAMPLES;++_i83){var _x2=_i83/sigmaPixels;var weight=Math.exp(-_x2*_x2/2);weights.push(weight);if(_i83==0){sum+=weight;}else if(_i83<samples){sum+=2*weight;}}for(var _i84=0;_i84<weights.length;_i84++){weights[_i84]=weights[_i84]/sum;}blurUniforms['envMap'].value=targetIn.texture;blurUniforms['samples'].value=samples;blurUniforms['weights'].value=weights;blurUniforms['latitudinal'].value=direction==='latitudinal';if(poleAxis){blurUniforms['poleAxis'].value=poleAxis;}blurUniforms['dTheta'].value=radiansPerPixel;blurUniforms['mipInt'].value=LOD_MAX-lodIn;this._setEncoding(blurUniforms['inputEncoding'],targetIn.texture);this._setEncoding(blurUniforms['outputEncoding'],targetIn.texture);var outputSize=_sizeLods[lodOut];var x=3*Math.max(0,SIZE_MAX-2*outputSize);var y=(lodOut===0?0:2*SIZE_MAX)+2*outputSize*(lodOut>LOD_MAX-LOD_MIN?lodOut-LOD_MAX+LOD_MIN:0);_setViewport(targetOut,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera);}}]);return PMREMGenerator;}();function _isLDR(texture){if(texture===undefined||texture.type!==UnsignedByteType)return false;return texture.encoding===LinearEncoding||texture.encoding===sRGBEncoding||texture.encoding===GammaEncoding;}function _createPlanes(){var _lodPlanes=[];var _sizeLods=[];var _sigmas=[];var lod=LOD_MAX;for(var _i85=0;_i85<TOTAL_LODS;_i85++){var sizeLod=Math.pow(2,lod);_sizeLods.push(sizeLod);var sigma=1.0/sizeLod;if(_i85>LOD_MAX-LOD_MIN){sigma=EXTRA_LOD_SIGMA[_i85-LOD_MAX+LOD_MIN-1];}else if(_i85==0){sigma=0;}_sigmas.push(sigma);var texelSize=1.0/(sizeLod-1);var min=-texelSize/2;var max=1+texelSize/2;var uv1=[min,min,max,min,max,max,min,min,max,max,min,max];var cubeFaces=6;var vertices=6;var positionSize=3;var uvSize=2;var faceIndexSize=1;var position=new Float32Array(positionSize*vertices*cubeFaces);var uv=new Float32Array(uvSize*vertices*cubeFaces);var faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(var face=0;face<cubeFaces;face++){var x=face%3*2/3-1;var y=face>2?0:-1;var coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0];position.set(coordinates,positionSize*vertices*face);uv.set(uv1,uvSize*vertices*face);var fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face);}var planes=new BufferGeometry();planes.setAttribute('position',new BufferAttribute(position,positionSize));planes.setAttribute('uv',new BufferAttribute(uv,uvSize));planes.setAttribute('faceIndex',new BufferAttribute(faceIndex,faceIndexSize));_lodPlanes.push(planes);if(lod>LOD_MIN){lod--;}}return {_lodPlanes:_lodPlanes,_sizeLods:_sizeLods,_sigmas:_sigmas};}function _createRenderTarget(params){var cubeUVRenderTarget=new WebGLRenderTarget(3*SIZE_MAX,3*SIZE_MAX,params);cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping;cubeUVRenderTarget.texture.name='PMREM.cubeUv';cubeUVRenderTarget.scissorTest=true;return cubeUVRenderTarget;}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height);}function _getBlurShader(maxSamples){var weights=new Float32Array(maxSamples);var poleAxis=new Vector3(0,1,0);var shaderMaterial=new RawShaderMaterial({name:'SphericalGaussianBlur',defines:{'n':maxSamples},uniforms:{'envMap':{value:null},'samples':{value:1},'weights':{value:weights},'latitudinal':{value:false},'dTheta':{value:0},'mipInt':{value:0},'poleAxis':{value:poleAxis},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t".concat(_getEncodings(),"\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getEquirectShader(){var texelSize=new Vector2(1,1);var shaderMaterial=new RawShaderMaterial({name:'EquirectangularToCubeUV',uniforms:{'envMap':{value:null},'texelSize':{value:texelSize},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t".concat(_getEncodings(),"\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getCubemapShader(){var shaderMaterial=new RawShaderMaterial({name:'CubemapToCubeUV',uniforms:{'envMap':{value:null},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t".concat(_getEncodings(),"\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getCommonVertexShader(){return(/* glsl */"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t");}function _getEncodings(){return(/* glsl */"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t");}function WebGLCubeUVMaps(renderer){var cubeUVmaps=new WeakMap();var pmremGenerator=null;function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===false){var mapping=texture.mapping;var isEquirectMap=mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping;var isCubeMap=mapping===CubeReflectionMapping||mapping===CubeRefractionMapping;if(isEquirectMap||isCubeMap){// equirect/cube map to cubeUV conversion
  if(cubeUVmaps.has(texture)){return cubeUVmaps.get(texture).texture;}else {var image=texture.image;if(isEquirectMap&&image&&image.height>0||isCubeMap&&image&&isCubeTextureComplete(image)){var currentRenderTarget=renderer.getRenderTarget();if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);var renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture);cubeUVmaps.set(texture,renderTarget);renderer.setRenderTarget(currentRenderTarget);texture.addEventListener('dispose',onTextureDispose);return renderTarget.texture;}else {// image not yet ready. try the conversion next frame
  return null;}}}}return texture;}function isCubeTextureComplete(image){var count=0;var length=6;for(var _i86=0;_i86<length;_i86++){if(image[_i86]!==undefined)count++;}return count===length;}function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);var cubemapUV=cubeUVmaps.get(texture);if(cubemapUV!==undefined){cubeUVmaps["delete"](texture);cubemapUV.dispose();}}function dispose(){cubeUVmaps=new WeakMap();if(pmremGenerator!==null){pmremGenerator.dispose();pmremGenerator=null;}}return {get:get,dispose:dispose};}function WebGLExtensions(gl){var extensions={};function getExtension(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}extensions[name]=extension;return extension;}return {has:function has(name){return getExtension(name)!==null;},init:function init(capabilities){if(capabilities.isWebGL2){getExtension('EXT_color_buffer_float');}else {getExtension('WEBGL_depth_texture');getExtension('OES_texture_float');getExtension('OES_texture_half_float');getExtension('OES_texture_half_float_linear');getExtension('OES_standard_derivatives');getExtension('OES_element_index_uint');getExtension('OES_vertex_array_object');getExtension('ANGLE_instanced_arrays');}getExtension('OES_texture_float_linear');getExtension('EXT_color_buffer_half_float');},get:function get(name){var extension=getExtension(name);if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}return extension;}};}function WebGLGeometries(gl,attributes,info,bindingStates){var geometries={};var wireframeAttributes=new WeakMap();function onGeometryDispose(event){var geometry=event.target;if(geometry.index!==null){attributes.remove(geometry.index);}for(var name in geometry.attributes){attributes.remove(geometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];var attribute=wireframeAttributes.get(geometry);if(attribute){attributes.remove(attribute);wireframeAttributes["delete"](geometry);}bindingStates.releaseStatesOfGeometry(geometry);if(geometry.isInstancedBufferGeometry===true){delete geometry._maxInstanceCount;}//
  info.memory.geometries--;}function get(object,geometry){if(geometries[geometry.id]===true)return geometry;geometry.addEventListener('dispose',onGeometryDispose);geometries[geometry.id]=true;info.memory.geometries++;return geometry;}function update(geometry){var geometryAttributes=geometry.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
  for(var name in geometryAttributes){attributes.update(geometryAttributes[name],34962);}// morph targets
  var morphAttributes=geometry.morphAttributes;for(var _name3 in morphAttributes){var array=morphAttributes[_name3];for(var _i87=0,l=array.length;_i87<l;_i87++){attributes.update(array[_i87],34962);}}}function updateWireframeAttribute(geometry){var indices=[];var geometryIndex=geometry.index;var geometryPosition=geometry.attributes.position;var version=0;if(geometryIndex!==null){var array=geometryIndex.array;version=geometryIndex.version;for(var _i88=0,l=array.length;_i88<l;_i88+=3){var a=array[_i88+0];var b=array[_i88+1];var c=array[_i88+2];indices.push(a,b,b,c,c,a);}}else {var _array=geometryPosition.array;version=geometryPosition.version;for(var _i89=0,_l4=_array.length/3-1;_i89<_l4;_i89+=3){var _a4=_i89+0;var _b4=_i89+1;var _c4=_i89+2;indices.push(_a4,_b4,_b4,_c4,_c4,_a4);}}var attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attribute.version=version;// Updating index buffer in VAO now. See WebGLBindingStates
  //
  var previousAttribute=wireframeAttributes.get(geometry);if(previousAttribute)attributes.remove(previousAttribute);//
  wireframeAttributes.set(geometry,attribute);}function getWireframeAttribute(geometry){var currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){var geometryIndex=geometry.index;if(geometryIndex!==null){// if the attribute is obsolete, create a new one
  if(currentAttribute.version<geometryIndex.version){updateWireframeAttribute(geometry);}}}else {updateWireframeAttribute(geometry);}return wireframeAttributes.get(geometry);}return {get:get,update:update,getWireframeAttribute:getWireframeAttribute};}function WebGLIndexedBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}var type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawElementsInstanced';}else {extension=extensions.get('ANGLE_instanced_arrays');methodName='drawElementsInstancedANGLE';if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,count,type,start*bytesPerElement,primcount);info.update(count,mode,primcount);}//
  this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}function WebGLInfo(gl){var memory={geometries:0,textures:0};var render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){render.calls++;switch(mode){case 4:render.triangles+=instanceCount*(count/3);break;case 1:render.lines+=instanceCount*(count/2);break;case 3:render.lines+=instanceCount*(count-1);break;case 2:render.lines+=instanceCount*count;break;case 0:render.points+=instanceCount*count;break;default:console.error('THREE.WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.frame++;render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return {memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}var DataTexture2DArray=/*#__PURE__*/function(_Texture2){_inherits(DataTexture2DArray,_Texture2);var _super30=_createSuper(DataTexture2DArray);function DataTexture2DArray(){var _this21;var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var depth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,DataTexture2DArray);_this21=_super30.call(this,null);_this21.image={data:data,width:width,height:height,depth:depth};_this21.magFilter=NearestFilter;_this21.minFilter=NearestFilter;_this21.wrapR=ClampToEdgeWrapping;_this21.generateMipmaps=false;_this21.flipY=false;_this21.unpackAlignment=1;_this21.needsUpdate=true;return _this21;}return _createClass(DataTexture2DArray);}(Texture);DataTexture2DArray.prototype.isDataTexture2DArray=true;function numericalSort(a,b){return a[0]-b[0];}function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1]);}function denormalize(morph,attribute){var denominator=1;var array=attribute.isInterleavedBufferAttribute?attribute.data.array:attribute.array;if(array instanceof Int8Array)denominator=127;else if(array instanceof Int16Array)denominator=32767;else if(array instanceof Int32Array)denominator=2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ',array);morph.divideScalar(denominator);}function WebGLMorphtargets(gl,capabilities,textures){var influencesList={};var morphInfluences=new Float32Array(8);var morphTextures=new WeakMap();var morph=new Vector3();var workInfluences=[];for(var _i90=0;_i90<8;_i90++){workInfluences[_i90]=[_i90,0];}function update(object,geometry,material,program){var objectInfluences=object.morphTargetInfluences;if(capabilities.isWebGL2===true){// instead of using attributes, the WebGL 2 code path encodes morph targets
  // into an array of data textures. Each layer represents a single morph target.
  var numberOfMorphTargets=geometry.morphAttributes.position.length;var entry=morphTextures.get(geometry);if(entry===undefined||entry.count!==numberOfMorphTargets){if(entry!==undefined)entry.texture.dispose();var hasMorphNormals=geometry.morphAttributes.normal!==undefined;var morphTargets=geometry.morphAttributes.position;var morphNormals=geometry.morphAttributes.normal||[];var numberOfVertices=geometry.attributes.position.count;var numberOfVertexData=hasMorphNormals===true?2:1;// (v,n) vs. (v)
  var width=numberOfVertices*numberOfVertexData;var height=1;if(width>capabilities.maxTextureSize){height=Math.ceil(width/capabilities.maxTextureSize);width=capabilities.maxTextureSize;}var buffer=new Float32Array(width*height*4*numberOfMorphTargets);var texture=new DataTexture2DArray(buffer,width,height,numberOfMorphTargets);texture.format=RGBAFormat;// using RGBA since RGB might be emulated (and is thus slower)
  texture.type=FloatType;// fill buffer
  var vertexDataStride=numberOfVertexData*4;for(var _i91=0;_i91<numberOfMorphTargets;_i91++){var morphTarget=morphTargets[_i91];var morphNormal=morphNormals[_i91];var offset=width*height*4*_i91;for(var j=0;j<morphTarget.count;j++){morph.fromBufferAttribute(morphTarget,j);if(morphTarget.normalized===true)denormalize(morph,morphTarget);var stride=j*vertexDataStride;buffer[offset+stride+0]=morph.x;buffer[offset+stride+1]=morph.y;buffer[offset+stride+2]=morph.z;buffer[offset+stride+3]=0;if(hasMorphNormals===true){morph.fromBufferAttribute(morphNormal,j);if(morphNormal.normalized===true)denormalize(morph,morphNormal);buffer[offset+stride+4]=morph.x;buffer[offset+stride+5]=morph.y;buffer[offset+stride+6]=morph.z;buffer[offset+stride+7]=0;}}}entry={count:numberOfMorphTargets,texture:texture,size:new Vector2(width,height)};morphTextures.set(geometry,entry);}//
  var morphInfluencesSum=0;for(var _i92=0;_i92<objectInfluences.length;_i92++){morphInfluencesSum+=objectInfluences[_i92];}var morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',objectInfluences);program.getUniforms().setValue(gl,'morphTargetsTexture',entry.texture,textures);program.getUniforms().setValue(gl,'morphTargetsTextureSize',entry.size);}else {// When object doesn't have morph target influences defined, we treat it as a 0-length array
  // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
  var length=objectInfluences===undefined?0:objectInfluences.length;var influences=influencesList[geometry.id];if(influences===undefined||influences.length!==length){// initialise list
  influences=[];for(var _i93=0;_i93<length;_i93++){influences[_i93]=[_i93,0];}influencesList[geometry.id]=influences;}// Collect influences
  for(var _i94=0;_i94<length;_i94++){var influence=influences[_i94];influence[0]=_i94;influence[1]=objectInfluences[_i94];}influences.sort(absNumericalSort);for(var _i95=0;_i95<8;_i95++){if(_i95<length&&influences[_i95][1]){workInfluences[_i95][0]=influences[_i95][0];workInfluences[_i95][1]=influences[_i95][1];}else {workInfluences[_i95][0]=Number.MAX_SAFE_INTEGER;workInfluences[_i95][1]=0;}}workInfluences.sort(numericalSort);var _morphTargets=geometry.morphAttributes.position;var _morphNormals=geometry.morphAttributes.normal;var _morphInfluencesSum=0;for(var _i96=0;_i96<8;_i96++){var _influence=workInfluences[_i96];var index=_influence[0];var _value3=_influence[1];if(index!==Number.MAX_SAFE_INTEGER&&_value3){if(_morphTargets&&geometry.getAttribute('morphTarget'+_i96)!==_morphTargets[index]){geometry.setAttribute('morphTarget'+_i96,_morphTargets[index]);}if(_morphNormals&&geometry.getAttribute('morphNormal'+_i96)!==_morphNormals[index]){geometry.setAttribute('morphNormal'+_i96,_morphNormals[index]);}morphInfluences[_i96]=_value3;_morphInfluencesSum+=_value3;}else {if(_morphTargets&&geometry.hasAttribute('morphTarget'+_i96)===true){geometry.deleteAttribute('morphTarget'+_i96);}if(_morphNormals&&geometry.hasAttribute('morphNormal'+_i96)===true){geometry.deleteAttribute('morphNormal'+_i96);}morphInfluences[_i96]=0;}}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
  // This allows us to switch between absolute morphs and relative morphs without changing shader code
  // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
  var _morphBaseInfluence=geometry.morphTargetsRelative?1:1-_morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',_morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);}}return {update:update};}function WebGLObjects(gl,geometries,attributes,info){var updateMap=new WeakMap();function update(object){var frame=info.render.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
  if(updateMap.get(buffergeometry)!==frame){geometries.update(buffergeometry);updateMap.set(buffergeometry,frame);}if(object.isInstancedMesh){if(object.hasEventListener('dispose',onInstancedMeshDispose)===false){object.addEventListener('dispose',onInstancedMeshDispose);}attributes.update(object.instanceMatrix,34962);if(object.instanceColor!==null){attributes.update(object.instanceColor,34962);}}return buffergeometry;}function dispose(){updateMap=new WeakMap();}function onInstancedMeshDispose(event){var instancedMesh=event.target;instancedMesh.removeEventListener('dispose',onInstancedMeshDispose);attributes.remove(instancedMesh.instanceMatrix);if(instancedMesh.instanceColor!==null)attributes.remove(instancedMesh.instanceColor);}return {update:update,dispose:dispose};}var DataTexture3D=/*#__PURE__*/function(_Texture3){_inherits(DataTexture3D,_Texture3);var _super31=_createSuper(DataTexture3D);function DataTexture3D(){var _this22;var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var depth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,DataTexture3D);// We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	const texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839
  _this22=_super31.call(this,null);_this22.image={data:data,width:width,height:height,depth:depth};_this22.magFilter=NearestFilter;_this22.minFilter=NearestFilter;_this22.wrapR=ClampToEdgeWrapping;_this22.generateMipmaps=false;_this22.flipY=false;_this22.unpackAlignment=1;_this22.needsUpdate=true;return _this22;}return _createClass(DataTexture3D);}(Texture);DataTexture3D.prototype.isDataTexture3D=true;/**
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [textures] )
   *
   * 		uploads a uniform value(s)
   *  	the 'textures' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (textures factorizations):
   *
   * .upload( gl, seq, values, textures )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (textures factorizations):
   *
   * .setValue( gl, name, value, textures )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */var emptyTexture=new Texture();var emptyTexture2dArray=new DataTexture2DArray();var emptyTexture3d=new DataTexture3D();var emptyCubeTexture=new CubeTexture();// --- Utilities ---
  // Array Caches (provide typed arrays for temporary by size)
  var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
  var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);var mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
  function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983
  var n=nBlocks*blockSize;var r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var _i97=1,offset=0;_i97!==nBlocks;++_i97){offset+=blockSize;array[_i97].toArray(r,offset);}}return r;}function arraysEqual(a,b){if(a.length!==b.length)return false;for(var _i98=0,l=a.length;_i98<l;_i98++){if(a[_i98]!==b[_i98])return false;}return true;}function copyArray(a,b){for(var _i99=0,l=b.length;_i99<l;_i99++){a[_i99]=b[_i99];}}// Texture unit allocation
  function allocTexUnits(textures,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var _i100=0;_i100!==n;++_i100){r[_i100]=textures.allocateTextureUnit();}return r;}// --- Setters ---
  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.
  // Single scalar
  function setValueV1f(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1f(this.addr,v);cache[0]=v;}// Single float vector (from flat array or THREE.VectorN)
  function setValueV2f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2f(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2fv(this.addr,v);copyArray(cache,v);}}function setValueV3f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3f(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else if(v.r!==undefined){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){gl.uniform3f(this.addr,v.r,v.g,v.b);cache[0]=v.r;cache[1]=v.g;cache[2]=v.b;}}else {if(arraysEqual(cache,v))return;gl.uniform3fv(this.addr,v);copyArray(cache,v);}}function setValueV4f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4fv(this.addr,v);copyArray(cache,v);}}// Single matrix (from flat array or THREE.MatrixN)
  function setValueM2(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix2fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat2array.set(elements);gl.uniformMatrix2fv(this.addr,false,mat2array);copyArray(cache,elements);}}function setValueM3(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix3fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat3array.set(elements);gl.uniformMatrix3fv(this.addr,false,mat3array);copyArray(cache,elements);}}function setValueM4(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix4fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat4array.set(elements);gl.uniformMatrix4fv(this.addr,false,mat4array);copyArray(cache,elements);}}// Single integer / boolean
  function setValueV1i(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1i(this.addr,v);cache[0]=v;}// Single integer / boolean vector (from flat array)
  function setValueV2i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2iv(this.addr,v);copyArray(cache,v);}function setValueV3i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3iv(this.addr,v);copyArray(cache,v);}function setValueV4i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4iv(this.addr,v);copyArray(cache,v);}// Single unsigned integer
  function setValueV1ui(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1ui(this.addr,v);cache[0]=v;}// Single unsigned integer vector (from flat array)
  function setValueV2ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2uiv(this.addr,v);copyArray(cache,v);}function setValueV3ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3uiv(this.addr,v);copyArray(cache,v);}function setValueV4ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4uiv(this.addr,v);copyArray(cache,v);}// Single texture (2D / Cube)
  function setValueT1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTexture2D(v||emptyTexture,unit);}function setValueT3D1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture3D(v||emptyTexture3d,unit);}function setValueT6(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTextureCube(v||emptyCubeTexture,unit);}function setValueT2DArray1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2DArray(v||emptyTexture2dArray,unit);}// Helper to pick the right setter for the singular case
  function getSingularSetter(type){switch(type){case 0x1406:return setValueV1f;// FLOAT
  case 0x8b50:return setValueV2f;// _VEC2
  case 0x8b51:return setValueV3f;// _VEC3
  case 0x8b52:return setValueV4f;// _VEC4
  case 0x8b5a:return setValueM2;// _MAT2
  case 0x8b5b:return setValueM3;// _MAT3
  case 0x8b5c:return setValueM4;// _MAT4
  case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
  case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
  case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
  case 0x1405:return setValueV1ui;// UINT
  case 0x8dc6:return setValueV2ui;// _VEC2
  case 0x8dc7:return setValueV3ui;// _VEC3
  case 0x8dc8:return setValueV4ui;// _VEC4
  case 0x8b5e:// SAMPLER_2D
  case 0x8d66:// SAMPLER_EXTERNAL_OES
  case 0x8dca:// INT_SAMPLER_2D
  case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
  case 0x8b62:// SAMPLER_2D_SHADOW
  return setValueT1;case 0x8b5f:// SAMPLER_3D
  case 0x8dcb:// INT_SAMPLER_3D
  case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
  return setValueT3D1;case 0x8b60:// SAMPLER_CUBE
  case 0x8dcc:// INT_SAMPLER_CUBE
  case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
  case 0x8dc5:// SAMPLER_CUBE_SHADOW
  return setValueT6;case 0x8dc1:// SAMPLER_2D_ARRAY
  case 0x8dcf:// INT_SAMPLER_2D_ARRAY
  case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
  case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
  return setValueT2DArray1;}}// Array of scalars
  function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v);}// Array of vectors (from flat array or array of THREE.VectorN)
  function setValueV2fArray(gl,v){var data=flatten(v,this.size,2);gl.uniform2fv(this.addr,data);}function setValueV3fArray(gl,v){var data=flatten(v,this.size,3);gl.uniform3fv(this.addr,data);}function setValueV4fArray(gl,v){var data=flatten(v,this.size,4);gl.uniform4fv(this.addr,data);}// Array of matrices (from flat array or array of THREE.MatrixN)
  function setValueM2Array(gl,v){var data=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,false,data);}function setValueM3Array(gl,v){var data=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,false,data);}function setValueM4Array(gl,v){var data=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,false,data);}// Array of integer / boolean
  function setValueV1iArray(gl,v){gl.uniform1iv(this.addr,v);}// Array of integer / boolean vectors (from flat array)
  function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v);}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v);}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v);}// Array of unsigned integer
  function setValueV1uiArray(gl,v){gl.uniform1uiv(this.addr,v);}// Array of unsigned integer vectors (from flat array)
  function setValueV2uiArray(gl,v){gl.uniform2uiv(this.addr,v);}function setValueV3uiArray(gl,v){gl.uniform3uiv(this.addr,v);}function setValueV4uiArray(gl,v){gl.uniform4uiv(this.addr,v);}// Array of textures (2D / Cube)
  function setValueT1Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var _i101=0;_i101!==n;++_i101){textures.safeSetTexture2D(v[_i101]||emptyTexture,units[_i101]);}}function setValueT6Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var _i102=0;_i102!==n;++_i102){textures.safeSetTextureCube(v[_i102]||emptyCubeTexture,units[_i102]);}}// Helper to pick the right setter for a pure (bottom-level) array
  function getPureArraySetter(type){switch(type){case 0x1406:return setValueV1fArray;// FLOAT
  case 0x8b50:return setValueV2fArray;// _VEC2
  case 0x8b51:return setValueV3fArray;// _VEC3
  case 0x8b52:return setValueV4fArray;// _VEC4
  case 0x8b5a:return setValueM2Array;// _MAT2
  case 0x8b5b:return setValueM3Array;// _MAT3
  case 0x8b5c:return setValueM4Array;// _MAT4
  case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
  case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
  case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
  case 0x1405:return setValueV1uiArray;// UINT
  case 0x8dc6:return setValueV2uiArray;// _VEC2
  case 0x8dc7:return setValueV3uiArray;// _VEC3
  case 0x8dc8:return setValueV4uiArray;// _VEC4
  case 0x8b5e:// SAMPLER_2D
  case 0x8d66:// SAMPLER_EXTERNAL_OES
  case 0x8dca:// INT_SAMPLER_2D
  case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
  case 0x8b62:// SAMPLER_2D_SHADOW
  return setValueT1Array;case 0x8b60:// SAMPLER_CUBE
  case 0x8dcc:// INT_SAMPLER_CUBE
  case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
  case 0x8dc5:// SAMPLER_CUBE_SHADOW
  return setValueT6Array;}}// --- Uniform Classes ---
  function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  }function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  }PureArrayUniform.prototype.updateCache=function(data){var cache=this.cache;if(data instanceof Float32Array&&cache.length!==data.length){this.cache=new Float32Array(data.length);}copyArray(cache,data);};function StructuredUniform(id){this.id=id;this.seq=[];this.map={};}StructuredUniform.prototype.setValue=function(gl,value,textures){var seq=this.seq;for(var _i103=0,n=seq.length;_i103!==n;++_i103){var u=seq[_i103];u.setValue(gl,value[u.id],textures);}};// --- Top-level ---
  // Parser - builds up the property tree from the path strings
  var RePathPart=/(\w+)(\])?(\[|\.)?/g;// extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.
  function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
  RePathPart.lastIndex=0;while(true){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex;var id=match[1];var idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
  if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
  addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else {// step into inner node / create it in case it doesn't exist
  var map=container.map;var next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
  function WebGLUniforms(gl,program){this.seq=[];this.map={};var n=gl.getProgramParameter(program,35718);for(var _i104=0;_i104<n;++_i104){var info=gl.getActiveUniform(program,_i104),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value,textures){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,textures);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
  WebGLUniforms.upload=function(gl,seq,values,textures){for(var _i105=0,n=seq.length;_i105!==n;++_i105){var u=seq[_i105],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
  u.setValue(gl,v.value,textures);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var _i106=0,n=seq.length;_i106!==n;++_i106){var u=seq[_i106];if(u.id in values)r.push(u);}return r;};function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);return shader;}var programIdCount=0;function addLineNumbers(string){var lines=string.split('\n');for(var _i107=0;_i107<lines.length;_i107++){lines[_i107]=_i107+1+': '+lines[_i107];}return lines.join('\n');}function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return ['Linear','( value )'];case sRGBEncoding:return ['sRGB','( value )'];case RGBEEncoding:return ['RGBE','( value )'];case RGBM7Encoding:return ['RGBM','( value, 7.0 )'];case RGBM16Encoding:return ['RGBM','( value, 16.0 )'];case RGBDEncoding:return ['RGBD','( value, 256.0 )'];case GammaEncoding:return ['Gamma','( value, float( GAMMA_FACTOR ) )'];case LogLuvEncoding:return ['LogLuv','( value )'];default:console.warn('THREE.WebGLProgram: Unsupported encoding:',encoding);return ['Linear','( value )'];}}function getShaderErrors(gl,shader,type){var status=gl.getShaderParameter(shader,35713);var errors=gl.getShaderInfoLog(shader).trim();if(status&&errors==='')return '';// --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
  return type.toUpperCase()+'\n\n'+errors+'\n\n'+addLineNumbers(gl.getShaderSource(shader));}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return 'vec4 '+functionName+'( vec4 value ) { return '+components[0]+'ToLinear'+components[1]+'; }';}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return 'vec4 '+functionName+'( vec4 value ) { return LinearTo'+components[0]+components[1]+'; }';}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case CineonToneMapping:toneMappingName='OptimizedCineon';break;case ACESFilmicToneMapping:toneMappingName='ACESFilmic';break;case CustomToneMapping:toneMappingName='Custom';break;default:console.warn('THREE.WebGLProgram: Unsupported toneMapping:',toneMapping);toneMappingName='Linear';}return 'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}function generateExtensions(parameters){var chunks=[parameters.extensionDerivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.tangentSpaceNormalMap||parameters.clearcoatNormalMap||parameters.flatShading||parameters.shaderID==='physical'?'#extension GL_OES_standard_derivatives : enable':'',(parameters.extensionFragDepth||parameters.logarithmicDepthBuffer)&&parameters.rendererExtensionFragDepth?'#extension GL_EXT_frag_depth : enable':'',parameters.extensionDrawBuffers&&parameters.rendererExtensionDrawBuffers?'#extension GL_EXT_draw_buffers : require':'',(parameters.extensionShaderTextureLOD||parameters.envMap||parameters.transmission)&&parameters.rendererExtensionShaderTextureLod?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var _value4=defines[name];if(_value4===false)continue;chunks.push('#define '+name+' '+_value4);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){var attributes={};var n=gl.getProgramParameter(program,35721);for(var _i108=0;_i108<n;_i108++){var info=gl.getActiveAttrib(program,_i108);var name=info.name;var locationSize=1;if(info.type===35674)locationSize=2;if(info.type===35675)locationSize=3;if(info.type===35676)locationSize=4;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
  attributes[name]={type:info.type,location:gl.getAttribLocation(program,name),locationSize:locationSize};}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}// Resolve Includes
  var includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer);}function includeReplacer(match,include){var string=ShaderChunk[include];if(string===undefined){throw new Error('Can not resolve #include <'+include+'>');}return resolveIncludes(string);}// Unroll Loops
  var deprecatedUnrollLoopPattern=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;var unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer).replace(deprecatedUnrollLoopPattern,deprecatedLoopReplacer);}function deprecatedLoopReplacer(match,start,end,snippet){console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');return loopReplacer(match,start,end,snippet);}function loopReplacer(match,start,end,snippet){var string='';for(var _i109=parseInt(start);_i109<parseInt(end);_i109++){string+=snippet.replace(/\[\s*i\s*\]/g,'[ '+_i109+' ]').replace(/UNROLLED_LOOP_INDEX/g,_i109);}return string;}//
  function generatePrecision(parameters){var precisionstring='precision '+parameters.precision+' float;\nprecision '+parameters.precision+' int;';if(parameters.precision==='highp'){precisionstring+='\n#define HIGH_PRECISION';}else if(parameters.precision==='mediump'){precisionstring+='\n#define MEDIUM_PRECISION';}else if(parameters.precision==='lowp'){precisionstring+='\n#define LOW_PRECISION';}return precisionstring;}function generateShadowMapTypeDefine(parameters){var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}else if(parameters.shadowMapType===VSMShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_VSM';}return shadowMapTypeDefine;}function generateEnvMapTypeDefine(parameters){var envMapTypeDefine='ENVMAP_TYPE_CUBE';if(parameters.envMap){switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;}}return envMapTypeDefine;}function generateEnvMapModeDefine(parameters){var envMapModeDefine='ENVMAP_MODE_REFLECTION';if(parameters.envMap){switch(parameters.envMapMode){case CubeRefractionMapping:case CubeUVRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}}return envMapModeDefine;}function generateEnvMapBlendingDefine(parameters){var envMapBlendingDefine='ENVMAP_BLENDING_NONE';if(parameters.envMap){switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}return envMapBlendingDefine;}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){// TODO Send this event to Three.js DevTools
  // console.log( 'WebGLProgram', cacheKey );
  var gl=renderer.getContext();var defines=parameters.defines;var vertexShader=parameters.vertexShader;var fragmentShader=parameters.fragmentShader;var shadowMapTypeDefine=generateShadowMapTypeDefine(parameters);var envMapTypeDefine=generateEnvMapTypeDefine(parameters);var envMapModeDefine=generateEnvMapModeDefine(parameters);var envMapBlendingDefine=generateEnvMapBlendingDefine(parameters);var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;var customExtensions=parameters.isWebGL2?'':generateExtensions(parameters);var customDefines=generateDefines(defines);var program=gl.createProgram();var prefixVertex,prefixFragment;var versionString=parameters.glslVersion?'#version '+parameters.glslVersion+'\n':'';if(parameters.isRawShaderMaterial){prefixVertex=[customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=[customExtensions,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else {prefixVertex=[generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.instancing?'#define USE_INSTANCING':'',parameters.instancingColor?'#define USE_INSTANCING_COLOR':'',parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularTintMap?'#define USE_SPECULARTINTMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.morphTargets&&parameters.isWebGL2?'#define MORPHTARGETS_TEXTURE':'',parameters.morphTargets&&parameters.isWebGL2?'#define MORPHTARGETS_COUNT '+parameters.morphTargetsCount:'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;','#ifdef USE_INSTANCING','	attribute mat4 instanceMatrix;','#endif','#ifdef USE_INSTANCING_COLOR','	attribute vec3 instanceColor;','#endif','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_TANGENT','	attribute vec4 tangent;','#endif','#if defined( USE_COLOR_ALPHA )','	attribute vec4 color;','#elif defined( USE_COLOR )','	attribute vec3 color;','#endif','#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,'#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.matcap?'#define USE_MATCAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoat?'#define USE_CLEARCOAT':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularTintMap?'#define USE_SPECULARTINTMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.alphaTest?'#define USE_ALPHATEST':'',parameters.sheen?'#define USE_SHEEN':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors||parameters.instancingColor?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'',(parameters.extensionShaderTextureLOD||parameters.envMap)&&parameters.rendererExtensionShaderTextureLod?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
  parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.format===RGBFormat?'#define OPAQUE':'',ShaderChunk['encodings_pars_fragment'],// this code is required here because it is used by the various encoding/decoding function defined below
  parameters.map?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.matcap?getTexelDecodingFunction('matcapTexelToLinear',parameters.matcapEncoding):'',parameters.envMap?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMap?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.specularTintMap?getTexelDecodingFunction('specularTintMapTexelToLinear',parameters.specularTintMapEncoding):'',parameters.lightMap?getTexelDecodingFunction('lightMapTexelToLinear',parameters.lightMapEncoding):'',getTexelEncodingFunction('linearToOutputTexel',parameters.outputEncoding),parameters.depthPacking?'#define DEPTH_PACKING '+parameters.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=resolveIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=resolveIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);if(parameters.isWebGL2&&parameters.isRawShaderMaterial!==true){// GLSL 3.0 conversion for built-in materials and ShaderMaterial
  versionString='#version 300 es\n';prefixVertex=['precision mediump sampler2DArray;','#define attribute in','#define varying out','#define texture2D texture'].join('\n')+'\n'+prefixVertex;prefixFragment=['#define varying in',parameters.glslVersion===GLSL3?'':'out highp vec4 pc_fragColor;',parameters.glslVersion===GLSL3?'':'#define gl_FragColor pc_fragColor','#define gl_FragDepthEXT gl_FragDepth','#define texture2D texture','#define textureCube texture','#define texture2DProj textureProj','#define texture2DLodEXT textureLod','#define texture2DProjLodEXT textureProjLod','#define textureCubeLodEXT textureLod','#define texture2DGradEXT textureGrad','#define texture2DProjGradEXT textureProjGrad','#define textureCubeGradEXT textureGrad'].join('\n')+'\n'+prefixFragment;}var vertexGlsl=versionString+prefixVertex+vertexShader;var fragmentGlsl=versionString+prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );
  var glVertexShader=WebGLShader(gl,35633,vertexGlsl);var glFragmentShader=WebGLShader(gl,35632,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
  if(parameters.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,parameters.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
  gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);// check for link errors
  if(renderer.debug.checkShaderErrors){var programLog=gl.getProgramInfoLog(program).trim();var vertexLog=gl.getShaderInfoLog(glVertexShader).trim();var fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();var runnable=true;var haveDiagnostics=true;if(gl.getProgramParameter(program,35714)===false){runnable=false;var vertexErrors=getShaderErrors(gl,glVertexShader,'vertex');var fragmentErrors=getShaderErrors(gl,glFragmentShader,'fragment');console.error('THREE.WebGLProgram: Shader Error '+gl.getError()+' - '+'VALIDATE_STATUS '+gl.getProgramParameter(program,35715)+'\n\n'+'Program Info Log: '+programLog+'\n'+vertexErrors+'\n'+fragmentErrors);}else if(programLog!==''){console.warn('THREE.WebGLProgram: Program Info Log:',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}}// Clean up
  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );
  gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
  var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program);}return cachedUniforms;};// set up caching for attribute locations
  var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
  this.destroy=function(){bindingStates.releaseStatesOfProgram(this);gl.deleteProgram(program);this.program=undefined;};//
  this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping){var programs=[];var isWebGL2=capabilities.isWebGL2;var logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer;var floatVertexTextures=capabilities.floatVertexTextures;var maxVertexUniforms=capabilities.maxVertexUniforms;var vertexTextures=capabilities.vertexTextures;var precision=capabilities.precision;var shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'toon',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshMatcapMaterial:'matcap',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow',SpriteMaterial:'sprite'};var parameterNames=['precision','isWebGL2','supportsVertexTextures','outputEncoding','instancing','instancingColor','map','mapEncoding','matcap','matcapEncoding','envMap','envMapMode','envMapEncoding','envMapCubeUV','lightMap','lightMapEncoding','aoMap','emissiveMap','emissiveMapEncoding','bumpMap','normalMap','objectSpaceNormalMap','tangentSpaceNormalMap','clearcoat','clearcoatMap','clearcoatRoughnessMap','clearcoatNormalMap','displacementMap','specularMap','specularIntensityMap','specularTintMap','specularTintMapEncoding','roughnessMap','metalnessMap','gradientMap','alphaMap','alphaTest','combine','vertexColors','vertexAlphas','vertexTangents','vertexUvs','uvsVertexOnly','fog','useFog','fogExp2','flatShading','sizeAttenuation','logarithmicDepthBuffer','skinning','maxBones','useVertexTexture','morphTargets','morphNormals','morphTargetsCount','premultipliedAlpha','numDirLights','numPointLights','numSpotLights','numHemiLights','numRectAreaLights','numDirLightShadows','numPointLightShadows','numSpotLightShadows','shadowMapEnabled','shadowMapType','toneMapping','physicallyCorrectLights','doubleSided','flipSided','numClippingPlanes','numClipIntersection','depthPacking','dithering','format','sheen','transmission','transmissionMap','thicknessMap'];function getMaxBones(object){var skeleton=object.skeleton;var bones=skeleton.bones;if(floatVertexTextures){return 1024;}else {// default for when object is not specified
  // ( for example when prebuilding shader to be used with multiple objects )
  //
  //  - leave some extra space for other uniforms
  //  - limit here is ANGLE's 254 max uniform vectors
  //    (up to 54 should be safe)
  var nVertexUniforms=maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');return 0;}return maxBones;}}function getTextureEncodingFromMap(map){var encoding;if(map&&map.isTexture){encoding=map.encoding;}else if(map&&map.isWebGLRenderTarget){console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');encoding=map.texture.encoding;}else {encoding=LinearEncoding;}if(isWebGL2&&map&&map.isTexture&&map.format===RGBAFormat&&map.type===UnsignedByteType&&map.encoding===sRGBEncoding){encoding=LinearEncoding;// disable inline decode for sRGB textures in WebGL 2
  }return encoding;}function getParameters(material,lights,shadows,scene,object){var fog=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null;var envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
  // (not to blow over maxLights budget)
  var maxBones=object.isSkinnedMesh?getMaxBones(object):0;if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var vertexShader,fragmentShader;if(shaderID){var shader=ShaderLib[shaderID];vertexShader=shader.vertexShader;fragmentShader=shader.fragmentShader;}else {vertexShader=material.vertexShader;fragmentShader=material.fragmentShader;}var currentRenderTarget=renderer.getRenderTarget();var useAlphaTest=material.alphaTest>0;var useClearcoat=material.clearcoat>0;var parameters={isWebGL2:isWebGL2,shaderID:shaderID,shaderName:material.type,vertexShader:vertexShader,fragmentShader:fragmentShader,defines:material.defines,isRawShaderMaterial:material.isRawShaderMaterial===true,glslVersion:material.glslVersion,precision:precision,instancing:object.isInstancedMesh===true,instancingColor:object.isInstancedMesh===true&&object.instanceColor!==null,supportsVertexTextures:vertexTextures,outputEncoding:currentRenderTarget!==null?getTextureEncodingFromMap(currentRenderTarget.texture):renderer.outputEncoding,map:!!material.map,mapEncoding:getTextureEncodingFromMap(material.map),matcap:!!material.matcap,matcapEncoding:getTextureEncodingFromMap(material.matcap),envMap:!!envMap,envMapMode:envMap&&envMap.mapping,envMapEncoding:getTextureEncodingFromMap(envMap),envMapCubeUV:!!envMap&&(envMap.mapping===CubeUVReflectionMapping||envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,lightMapEncoding:getTextureEncodingFromMap(material.lightMap),aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,objectSpaceNormalMap:material.normalMapType===ObjectSpaceNormalMap,tangentSpaceNormalMap:material.normalMapType===TangentSpaceNormalMap,clearcoat:useClearcoat,clearcoatMap:useClearcoat&&!!material.clearcoatMap,clearcoatRoughnessMap:useClearcoat&&!!material.clearcoatRoughnessMap,clearcoatNormalMap:useClearcoat&&!!material.clearcoatNormalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,specularIntensityMap:!!material.specularIntensityMap,specularTintMap:!!material.specularTintMap,specularTintMapEncoding:getTextureEncodingFromMap(material.specularTintMap),alphaMap:!!material.alphaMap,alphaTest:useAlphaTest,gradientMap:!!material.gradientMap,sheen:material.sheen>0,transmission:material.transmission>0,transmissionMap:!!material.transmissionMap,thicknessMap:!!material.thicknessMap,combine:material.combine,vertexTangents:!!material.normalMap&&!!object.geometry&&!!object.geometry.attributes.tangent,vertexColors:material.vertexColors,vertexAlphas:material.vertexColors===true&&!!object.geometry&&!!object.geometry.attributes.color&&object.geometry.attributes.color.itemSize===4,vertexUvs:!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatMap||!!material.clearcoatRoughnessMap||!!material.clearcoatNormalMap||!!material.displacementMap||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularTintMap,uvsVertexOnly:!(!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatNormalMap||material.transmission>0||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularTintMap)&&!!material.displacementMap,fog:!!fog,useFog:material.fog,fogExp2:fog&&fog.isFogExp2,flatShading:!!material.flatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:logarithmicDepthBuffer,skinning:object.isSkinnedMesh===true&&maxBones>0,maxBones:maxBones,useVertexTexture:floatVertexTextures,morphTargets:!!object.geometry&&!!object.geometry.morphAttributes.position,morphNormals:!!object.geometry&&!!object.geometry.morphAttributes.normal,morphTargetsCount:!!object.geometry&&!!object.geometry.morphAttributes.position?object.geometry.morphAttributes.position.length:0,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,format:material.format,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:material.toneMapped?renderer.toneMapping:NoToneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,doubleSided:material.side===DoubleSide$1,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false,index0AttributeName:material.index0AttributeName,extensionDerivatives:material.extensions&&material.extensions.derivatives,extensionFragDepth:material.extensions&&material.extensions.fragDepth,extensionDrawBuffers:material.extensions&&material.extensions.drawBuffers,extensionShaderTextureLOD:material.extensions&&material.extensions.shaderTextureLOD,rendererExtensionFragDepth:isWebGL2||extensions.has('EXT_frag_depth'),rendererExtensionDrawBuffers:isWebGL2||extensions.has('WEBGL_draw_buffers'),rendererExtensionShaderTextureLod:isWebGL2||extensions.has('EXT_shader_texture_lod'),customProgramCacheKey:material.customProgramCacheKey()};return parameters;}function getProgramCacheKey(parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else {array.push(parameters.fragmentShader);array.push(parameters.vertexShader);}if(parameters.defines!==undefined){for(var name in parameters.defines){array.push(name);array.push(parameters.defines[name]);}}if(parameters.isRawShaderMaterial===false){for(var _i110=0;_i110<parameterNames.length;_i110++){array.push(parameters[parameterNames[_i110]]);}array.push(renderer.outputEncoding);array.push(renderer.gammaFactor);}array.push(parameters.customProgramCacheKey);return array.join();}function getUniforms(material){var shaderID=shaderIDs[material.type];var uniforms;if(shaderID){var shader=ShaderLib[shaderID];uniforms=UniformsUtils.clone(shader.uniforms);}else {uniforms=material.uniforms;}return uniforms;}function acquireProgram(parameters,cacheKey){var program;// Check if code has been already compiled
  for(var p=0,pl=programs.length;p<pl;p++){var preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates);programs.push(program);}return program;}function releaseProgram(program){if(--program.usedTimes===0){// Remove from unordered set
  var _i111=programs.indexOf(program);programs[_i111]=programs[programs.length-1];programs.pop();// Free WebGL resources
  program.destroy();}}return {getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,// Exposed for resource monitoring & error feedback via renderer.info:
  programs:programs};}function WebGLProperties(){var properties=new WeakMap();function get(object){var map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties["delete"](object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new WeakMap();}return {get:get,remove:remove,update:update,dispose:dispose};}function painterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else {return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else {return a.id-b.id;}}function WebGLRenderList(properties){var renderItems=[];var renderItemsIndex=0;var opaque=[];var transmissive=[];var transparent=[];var defaultProgram={id:-1};function init(){renderItemsIndex=0;opaque.length=0;transmissive.length=0;transparent.length=0;}function getNextRenderItem(object,geometry,material,groupOrder,z,group){var renderItem=renderItems[renderItemsIndex];var materialProperties=properties.get(material);if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,program:materialProperties.program||defaultProgram,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else {renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=materialProperties.program||defaultProgram;renderItem.groupOrder=groupOrder;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}renderItemsIndex++;return renderItem;}function push(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.push(renderItem);}else if(material.transparent===true){transparent.push(renderItem);}else {opaque.push(renderItem);}}function unshift(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.unshift(renderItem);}else if(material.transparent===true){transparent.unshift(renderItem);}else {opaque.unshift(renderItem);}}function sort(customOpaqueSort,customTransparentSort){if(opaque.length>1)opaque.sort(customOpaqueSort||painterSortStable);if(transmissive.length>1)transmissive.sort(customTransparentSort||reversePainterSortStable);if(transparent.length>1)transparent.sort(customTransparentSort||reversePainterSortStable);}function finish(){// Clear references from inactive renderItems in the list
  for(var _i112=renderItemsIndex,il=renderItems.length;_i112<il;_i112++){var renderItem=renderItems[_i112];if(renderItem.id===null)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.program=null;renderItem.group=null;}}return {opaque:opaque,transmissive:transmissive,transparent:transparent,init:init,push:push,unshift:unshift,finish:finish,sort:sort};}function WebGLRenderLists(properties){var lists=new WeakMap();function get(scene,renderCallDepth){var list;if(lists.has(scene)===false){list=new WebGLRenderList(properties);lists.set(scene,[list]);}else {if(renderCallDepth>=lists.get(scene).length){list=new WebGLRenderList(properties);lists.get(scene).push(list);}else {list=lists.get(scene)[renderCallDepth];}}return list;}function dispose(){lists=new WeakMap();}return {get:get,dispose:dispose};}function UniformsCache(){var lights={};return {get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color$2()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color$2(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case'PointLight':uniforms={position:new Vector3(),color:new Color$2(),distance:0,decay:0};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color$2(),groundColor:new Color$2()};break;case'RectAreaLight':uniforms={color:new Color$2(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()};break;}lights[light.id]=uniforms;return uniforms;}};}function ShadowUniformsCache(){var lights={};return {get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraNear:1,shadowCameraFar:1000};break;// TODO (abelnation): set RectAreaLight shadow uniforms
  }lights[light.id]=uniforms;return uniforms;}};}var nextVersion=0;function shadowCastingLightsFirst(lightA,lightB){return (lightB.castShadow?1:0)-(lightA.castShadow?1:0);}function WebGLLights(extensions,capabilities){var cache=new UniformsCache();var shadowCache=ShadowUniformsCache();var state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(var _i113=0;_i113<9;_i113++)state.probe.push(new Vector3());var vector3=new Vector3();var matrix4=new Matrix4$1();var matrix42=new Matrix4$1();function setup(lights,physicallyCorrectLights){var r=0,g=0,b=0;for(var _i114=0;_i114<9;_i114++)state.probe[_i114].set(0,0,0);var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var numDirectionalShadows=0;var numPointShadows=0;var numSpotShadows=0;lights.sort(shadowCastingLightsFirst);// artist-friendly light intensity scaling factor
  var scaleFactor=physicallyCorrectLights!==true?Math.PI:1;for(var _i115=0,l=lights.length;_i115<l;_i115++){var light=lights[_i115];var color=light.color;var intensity=light.intensity;var distance=light.distance;var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity*scaleFactor;g+=color.g*intensity*scaleFactor;b+=color.b*intensity*scaleFactor;}else if(light.isLightProbe){for(var j=0;j<9;j++){state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);}}else if(light.isDirectionalLight){var uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor);if(light.castShadow){var shadow=light.shadow;var shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.directionalShadow[directionalLength]=shadowUniforms;state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;numDirectionalShadows++;}state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var _uniforms=cache.get(light);_uniforms.position.setFromMatrixPosition(light.matrixWorld);_uniforms.color.copy(color).multiplyScalar(intensity*scaleFactor);_uniforms.distance=distance;_uniforms.coneCos=Math.cos(light.angle);_uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));_uniforms.decay=light.decay;if(light.castShadow){var _shadow=light.shadow;var _shadowUniforms=shadowCache.get(light);_shadowUniforms.shadowBias=_shadow.bias;_shadowUniforms.shadowNormalBias=_shadow.normalBias;_shadowUniforms.shadowRadius=_shadow.radius;_shadowUniforms.shadowMapSize=_shadow.mapSize;state.spotShadow[spotLength]=_shadowUniforms;state.spotShadowMap[spotLength]=shadowMap;state.spotShadowMatrix[spotLength]=light.shadow.matrix;numSpotShadows++;}state.spot[spotLength]=_uniforms;spotLength++;}else if(light.isRectAreaLight){var _uniforms2=cache.get(light);// (a) intensity is the total visible light emitted
  //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
  // (b) intensity is the brightness of the light
  _uniforms2.color.copy(color).multiplyScalar(intensity);_uniforms2.halfWidth.set(light.width*0.5,0.0,0.0);_uniforms2.halfHeight.set(0.0,light.height*0.5,0.0);state.rectArea[rectAreaLength]=_uniforms2;rectAreaLength++;}else if(light.isPointLight){var _uniforms3=cache.get(light);_uniforms3.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor);_uniforms3.distance=light.distance;_uniforms3.decay=light.decay;if(light.castShadow){var _shadow2=light.shadow;var _shadowUniforms2=shadowCache.get(light);_shadowUniforms2.shadowBias=_shadow2.bias;_shadowUniforms2.shadowNormalBias=_shadow2.normalBias;_shadowUniforms2.shadowRadius=_shadow2.radius;_shadowUniforms2.shadowMapSize=_shadow2.mapSize;_shadowUniforms2.shadowCameraNear=_shadow2.camera.near;_shadowUniforms2.shadowCameraFar=_shadow2.camera.far;state.pointShadow[pointLength]=_shadowUniforms2;state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;numPointShadows++;}state.point[pointLength]=_uniforms3;pointLength++;}else if(light.isHemisphereLight){var _uniforms4=cache.get(light);_uniforms4.skyColor.copy(light.color).multiplyScalar(intensity*scaleFactor);_uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity*scaleFactor);state.hemi[hemiLength]=_uniforms4;hemiLength++;}}if(rectAreaLength>0){if(capabilities.isWebGL2){// WebGL 2
  state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else {// WebGL 1
  if(extensions.has('OES_texture_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else if(extensions.has('OES_texture_half_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_HALF_1;state.rectAreaLTC2=UniformsLib.LTC_HALF_2;}else {console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');}}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;var hash=state.hash;if(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows){state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.directionalShadow.length=numDirectionalShadows;state.directionalShadowMap.length=numDirectionalShadows;state.pointShadow.length=numPointShadows;state.pointShadowMap.length=numPointShadows;state.spotShadow.length=numSpotShadows;state.spotShadowMap.length=numSpotShadows;state.directionalShadowMatrix.length=numDirectionalShadows;state.pointShadowMatrix.length=numPointShadows;state.spotShadowMatrix.length=numSpotShadows;hash.directionalLength=directionalLength;hash.pointLength=pointLength;hash.spotLength=spotLength;hash.rectAreaLength=rectAreaLength;hash.hemiLength=hemiLength;hash.numDirectionalShadows=numDirectionalShadows;hash.numPointShadows=numPointShadows;hash.numSpotShadows=numSpotShadows;state.version=nextVersion++;}}function setupView(lights,camera){var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var viewMatrix=camera.matrixWorldInverse;for(var _i116=0,l=lights.length;_i116<l;_i116++){var light=lights[_i116];if(light.isDirectionalLight){var uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);directionalLength++;}else if(light.isSpotLight){var _uniforms5=state.spot[spotLength];_uniforms5.position.setFromMatrixPosition(light.matrixWorld);_uniforms5.position.applyMatrix4(viewMatrix);_uniforms5.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);_uniforms5.direction.sub(vector3);_uniforms5.direction.transformDirection(viewMatrix);spotLength++;}else if(light.isRectAreaLight){var _uniforms6=state.rectArea[rectAreaLength];_uniforms6.position.setFromMatrixPosition(light.matrixWorld);_uniforms6.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
  matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);_uniforms6.halfWidth.set(light.width*0.5,0.0,0.0);_uniforms6.halfHeight.set(0.0,light.height*0.5,0.0);_uniforms6.halfWidth.applyMatrix4(matrix42);_uniforms6.halfHeight.applyMatrix4(matrix42);rectAreaLength++;}else if(light.isPointLight){var _uniforms7=state.point[pointLength];_uniforms7.position.setFromMatrixPosition(light.matrixWorld);_uniforms7.position.applyMatrix4(viewMatrix);pointLength++;}else if(light.isHemisphereLight){var _uniforms8=state.hemi[hemiLength];_uniforms8.direction.setFromMatrixPosition(light.matrixWorld);_uniforms8.direction.transformDirection(viewMatrix);_uniforms8.direction.normalize();hemiLength++;}}}return {setup:setup,setupView:setupView,state:state};}function WebGLRenderState(extensions,capabilities){var lights=new WebGLLights(extensions,capabilities);var lightsArray=[];var shadowsArray=[];function init(){lightsArray.length=0;shadowsArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function setupLights(physicallyCorrectLights){lights.setup(lightsArray,physicallyCorrectLights);}function setupLightsView(camera){lights.setupView(lightsArray,camera);}var state={lightsArray:lightsArray,shadowsArray:shadowsArray,lights:lights};return {init:init,state:state,setupLights:setupLights,setupLightsView:setupLightsView,pushLight:pushLight,pushShadow:pushShadow};}function WebGLRenderStates(extensions,capabilities){var renderStates=new WeakMap();function get(scene){var renderCallDepth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var renderState;if(renderStates.has(scene)===false){renderState=new WebGLRenderState(extensions,capabilities);renderStates.set(scene,[renderState]);}else {if(renderCallDepth>=renderStates.get(scene).length){renderState=new WebGLRenderState(extensions,capabilities);renderStates.get(scene).push(renderState);}else {renderState=renderStates.get(scene)[renderCallDepth];}}return renderState;}function dispose(){renderStates=new WeakMap();}return {get:get,dispose:dispose};}/**
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */var MeshDepthMaterial=/*#__PURE__*/function(_Material3){_inherits(MeshDepthMaterial,_Material3);var _super32=_createSuper(MeshDepthMaterial);function MeshDepthMaterial(parameters){var _this23;_classCallCheck(this,MeshDepthMaterial);_this23=_super32.call(this);_this23.type='MeshDepthMaterial';_this23.depthPacking=BasicDepthPacking;_this23.map=null;_this23.alphaMap=null;_this23.displacementMap=null;_this23.displacementScale=1;_this23.displacementBias=0;_this23.wireframe=false;_this23.wireframeLinewidth=1;_this23.fog=false;_this23.setValues(parameters);return _this23;}_createClass(MeshDepthMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshDepthMaterial.prototype),"copy",this).call(this,source);this.depthPacking=source.depthPacking;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;}}]);return MeshDepthMaterial;}(Material$1);MeshDepthMaterial.prototype.isMeshDepthMaterial=true;/**
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */var MeshDistanceMaterial=/*#__PURE__*/function(_Material4){_inherits(MeshDistanceMaterial,_Material4);var _super33=_createSuper(MeshDistanceMaterial);function MeshDistanceMaterial(parameters){var _this24;_classCallCheck(this,MeshDistanceMaterial);_this24=_super33.call(this);_this24.type='MeshDistanceMaterial';_this24.referencePosition=new Vector3();_this24.nearDistance=1;_this24.farDistance=1000;_this24.map=null;_this24.alphaMap=null;_this24.displacementMap=null;_this24.displacementScale=1;_this24.displacementBias=0;_this24.fog=false;_this24.setValues(parameters);return _this24;}_createClass(MeshDistanceMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshDistanceMaterial.prototype),"copy",this).call(this,source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;}}]);return MeshDistanceMaterial;}(Material$1);MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;var vertex="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";var fragment="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function WebGLShadowMap(_renderer,_objects,_capabilities){var _frustum=new Frustum();var _shadowMapSize=new Vector2(),_viewportSize=new Vector2(),_viewport=new Vector4(),_depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),_distanceMaterial=new MeshDistanceMaterial(),_materialCache={},_maxTextureSize=_capabilities.maxTextureSize;var shadowSide={0:BackSide,1:FrontSide,2:DoubleSide$1};var shadowMaterialVertical=new ShaderMaterial({uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2()},radius:{value:4.0},samples:{value:8.0}},vertexShader:vertex,fragmentShader:fragment});var shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;var fullScreenTri=new BufferGeometry();fullScreenTri.setAttribute('position',new BufferAttribute(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));var fullScreenMesh=new Mesh(fullScreenTri,shadowMaterialVertical);var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;var currentRenderTarget=_renderer.getRenderTarget();var activeCubeFace=_renderer.getActiveCubeFace();var activeMipmapLevel=_renderer.getActiveMipmapLevel();var _state=_renderer.state;// Set GL state for depth map.
  _state.setBlending(NoBlending);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
  for(var _i117=0,il=lights.length;_i117<il;_i117++){var light=lights[_i117];var shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}if(shadow.autoUpdate===false&&shadow.needsUpdate===false)continue;_shadowMapSize.copy(shadow.mapSize);var shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize){if(_shadowMapSize.x>_maxTextureSize){_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x);_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x;shadow.mapSize.x=_viewportSize.x;}if(_shadowMapSize.y>_maxTextureSize){_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y);_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y;shadow.mapSize.y=_viewportSize.y;}}if(shadow.map===null&&!shadow.isPointLightShadow&&this.type===VSMShadowMap){var pars={minFilter:LinearFilter,magFilter:LinearFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.camera.updateProjectionMatrix();}if(shadow.map===null){var _pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,_pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.camera.updateProjectionMatrix();}_renderer.setRenderTarget(shadow.map);_renderer.clear();var viewportCount=shadow.getViewportCount();for(var vp=0;vp<viewportCount;vp++){var viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type);}// do blur pass for VSM
  if(!shadow.isPointLightShadow&&this.type===VSMShadowMap){VSMPass(shadow,camera);}shadow.needsUpdate=false;}scope.needsUpdate=false;_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel);};function VSMPass(shadow,camera){var geometry=_objects.update(fullScreenMesh);// vertical pass
  shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture;shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize;shadowMaterialVertical.uniforms.radius.value=shadow.radius;shadowMaterialVertical.uniforms.samples.value=shadow.blurSamples;_renderer.setRenderTarget(shadow.mapPass);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null);// horizontal pass
  shadowMaterialHorizontal.uniforms.shadow_pass.value=shadow.mapPass.texture;shadowMaterialHorizontal.uniforms.resolution.value=shadow.mapSize;shadowMaterialHorizontal.uniforms.radius.value=shadow.radius;shadowMaterialHorizontal.uniforms.samples.value=shadow.blurSamples;_renderer.setRenderTarget(shadow.map);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizontal,fullScreenMesh,null);}function getDepthMaterial(object,geometry,material,light,shadowCameraNear,shadowCameraFar,type){var result=null;var customMaterial=light.isPointLight===true?object.customDistanceMaterial:object.customDepthMaterial;if(customMaterial!==undefined){result=customMaterial;}else {result=light.isPointLight===true?_distanceMaterial:_depthMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0||material.displacementMap&&material.displacementScale!==0||material.alphaMap&&material.alphaTest>0){// in this case we need a unique material instance reflecting the
  // appropriate state
  var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;if(type===VSMShadowMap){result.side=material.shadowSide!==null?material.shadowSide:material.side;}else {result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side];}result.alphaMap=material.alphaMap;result.alphaTest=material.alphaTest;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.displacementMap=material.displacementMap;result.displacementScale=material.displacementScale;result.displacementBias=material.displacementBias;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(light.isPointLight===true&&result.isMeshDistanceMaterial===true){result.referencePosition.setFromMatrixPosition(light.matrixWorld);result.nearDistance=shadowCameraNear;result.farDistance=shadowCameraFar;}return result;}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if((object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,geometry,groupMaterial,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var _depthMaterial2=getDepthMaterial(object,geometry,material,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,_depthMaterial2,object,null);}}}var children=object.children;for(var _i118=0,l=children.length;_i118<l;_i118++){renderObject(children[_i118],camera,shadowCamera,light,type);}}}function WebGLState(gl,extensions,capabilities){var _equationToGL,_factorToGL;var isWebGL2=capabilities.isWebGL2;function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4(0,0,0,0);return {setMask:function setMask(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function reset(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
  }};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return {setTest:function setTest(depthTest){if(depthTest){enable(2929);}else {disable(2929);}},setMask:function setMask(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function setFunc(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(512);break;case AlwaysDepth:gl.depthFunc(519);break;case LessDepth:gl.depthFunc(513);break;case LessEqualDepth:gl.depthFunc(515);break;case EqualDepth:gl.depthFunc(514);break;case GreaterEqualDepth:gl.depthFunc(518);break;case GreaterDepth:gl.depthFunc(516);break;case NotEqualDepth:gl.depthFunc(517);break;default:gl.depthFunc(515);}}else {gl.depthFunc(515);}currentDepthFunc=depthFunc;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function reset(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return {setTest:function setTest(stencilTest){if(!locked){if(stencilTest){enable(2960);}else {disable(2960);}}},setMask:function setMask(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function setFunc(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function setOp(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function reset(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
  var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var enabledCapabilities={};var xrFramebuffer=null;var currentBoundFramebuffers={};var currentProgram=null;var currentBlendingEnabled=false;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var maxTextures=gl.getParameter(35661);var lineWidthAvailable=false;var version=0;var glVersion=gl.getParameter(7938);if(glVersion.indexOf('WebGL')!==-1){version=parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}var currentTextureSlot=null;var currentBoundTextures={};var scissorParam=gl.getParameter(3088);var viewportParam=gl.getParameter(2978);var currentScissor=new Vector4().fromArray(scissorParam);var currentViewport=new Vector4().fromArray(viewportParam);function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
  var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,10241,9728);gl.texParameteri(type,10240,9728);for(var _i119=0;_i119<count;_i119++){gl.texImage2D(target+_i119,0,6408,1,1,0,6408,5121,data);}return texture;}var emptyTextures={};emptyTextures[3553]=createTexture(3553,3553,1);emptyTextures[34067]=createTexture(34067,34069,6);// init
  colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(2929);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(2884);setBlending(NoBlending);//
  function enable(id){if(enabledCapabilities[id]!==true){gl.enable(id);enabledCapabilities[id]=true;}}function disable(id){if(enabledCapabilities[id]!==false){gl.disable(id);enabledCapabilities[id]=false;}}function bindXRFramebuffer(framebuffer){if(framebuffer!==xrFramebuffer){gl.bindFramebuffer(36160,framebuffer);xrFramebuffer=framebuffer;}}function bindFramebuffer(target,framebuffer){if(framebuffer===null&&xrFramebuffer!==null)framebuffer=xrFramebuffer;// use active XR framebuffer if available
  if(currentBoundFramebuffers[target]!==framebuffer){gl.bindFramebuffer(target,framebuffer);currentBoundFramebuffers[target]=framebuffer;if(isWebGL2){// 36009 is equivalent to 36160
  if(target===36009){currentBoundFramebuffers[36160]=framebuffer;}if(target===36160){currentBoundFramebuffers[36009]=framebuffer;}}return true;}return false;}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}var equationToGL=(_equationToGL={},_defineProperty(_equationToGL,AddEquation,32774),_defineProperty(_equationToGL,SubtractEquation,32778),_defineProperty(_equationToGL,ReverseSubtractEquation,32779),_equationToGL);if(isWebGL2){equationToGL[MinEquation]=32775;equationToGL[MaxEquation]=32776;}else {var extension=extensions.get('EXT_blend_minmax');if(extension!==null){equationToGL[MinEquation]=extension.MIN_EXT;equationToGL[MaxEquation]=extension.MAX_EXT;}}var factorToGL=(_factorToGL={},_defineProperty(_factorToGL,ZeroFactor,0),_defineProperty(_factorToGL,OneFactor,1),_defineProperty(_factorToGL,SrcColorFactor,768),_defineProperty(_factorToGL,SrcAlphaFactor,770),_defineProperty(_factorToGL,SrcAlphaSaturateFactor,776),_defineProperty(_factorToGL,DstColorFactor,774),_defineProperty(_factorToGL,DstAlphaFactor,772),_defineProperty(_factorToGL,OneMinusSrcColorFactor,769),_defineProperty(_factorToGL,OneMinusSrcAlphaFactor,771),_defineProperty(_factorToGL,OneMinusDstColorFactor,775),_defineProperty(_factorToGL,OneMinusDstAlphaFactor,773),_factorToGL);function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending===NoBlending){if(currentBlendingEnabled===true){disable(3042);currentBlendingEnabled=false;}return;}if(currentBlendingEnabled===false){enable(3042);currentBlendingEnabled=true;}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){gl.blendEquation(32774);currentBlendEquation=AddEquation;currentBlendEquationAlpha=AddEquation;}if(premultipliedAlpha){switch(blending){case NormalBlending:gl.blendFuncSeparate(1,771,1,771);break;case AdditiveBlending:gl.blendFunc(1,1);break;case SubtractiveBlending:gl.blendFuncSeparate(0,0,769,771);break;case MultiplyBlending:gl.blendFuncSeparate(0,768,0,770);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}else {switch(blending){case NormalBlending:gl.blendFuncSeparate(770,771,1,771);break;case AdditiveBlending:gl.blendFunc(770,1);break;case SubtractiveBlending:gl.blendFunc(0,769);break;case MultiplyBlending:gl.blendFunc(0,768);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}currentBlendSrc=null;currentBlendDst=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}return;}// custom blending
  blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]);currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]);currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}currentBlending=blending;currentPremultipledAlpha=null;}function setMaterial(material,frontFaceCW){material.side===DoubleSide$1?disable(2884):enable(2884);var flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.blending===NormalBlending&&material.transparent===false?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);var stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite);if(stencilWrite){stencilBuffer.setMask(material.stencilWriteMask);stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask);stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass);}setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);material.alphaToCoverage===true?enable(32926):disable(32926);}//
  function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(2304);}else {gl.frontFace(2305);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(2884);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(1029);}else if(cullFace===CullFaceFront){gl.cullFace(1028);}else {gl.cullFace(1032);}}}else {disable(2884);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(32823);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else {disable(32823);}}function setScissorTest(scissorTest){if(scissorTest){enable(3089);}else {disable(3089);}}// texture
  function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=33984+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function unbindTexture(){var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture!==undefined&&boundTexture.type!==undefined){gl.bindTexture(boundTexture.type,null);boundTexture.type=undefined;boundTexture.texture=undefined;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage3D(){try{gl.texImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
  function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
  function reset(){// reset state
  gl.disable(3042);gl.disable(2884);gl.disable(2929);gl.disable(32823);gl.disable(3089);gl.disable(2960);gl.disable(32926);gl.blendEquation(32774);gl.blendFunc(1,0);gl.blendFuncSeparate(1,0,1,0);gl.colorMask(true,true,true,true);gl.clearColor(0,0,0,0);gl.depthMask(true);gl.depthFunc(513);gl.clearDepth(1);gl.stencilMask(0xffffffff);gl.stencilFunc(519,0,0xffffffff);gl.stencilOp(7680,7680,7680);gl.clearStencil(0);gl.cullFace(1029);gl.frontFace(2305);gl.polygonOffset(0,0);gl.activeTexture(33984);gl.bindFramebuffer(36160,null);if(isWebGL2===true){gl.bindFramebuffer(36009,null);gl.bindFramebuffer(36008,null);}gl.useProgram(null);gl.lineWidth(1);gl.scissor(0,0,gl.canvas.width,gl.canvas.height);gl.viewport(0,0,gl.canvas.width,gl.canvas.height);// reset internals
  enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};xrFramebuffer=null;currentBoundFramebuffers={};currentProgram=null;currentBlendingEnabled=false;currentBlending=null;currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentPremultipledAlpha=false;currentFlipSided=null;currentCullFace=null;currentLineWidth=null;currentPolygonOffsetFactor=null;currentPolygonOffsetUnits=null;currentScissor.set(0,0,gl.canvas.width,gl.canvas.height);currentViewport.set(0,0,gl.canvas.width,gl.canvas.height);colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return {buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable:enable,disable:disable,bindFramebuffer:bindFramebuffer,bindXRFramebuffer:bindXRFramebuffer,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,scissor:scissor,viewport:viewport,reset:reset};}function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){var _wrappingToGL,_filterToGL;var isWebGL2=capabilities.isWebGL2;var maxTextures=capabilities.maxTextures;var maxCubemapSize=capabilities.maxCubemapSize;var maxTextureSize=capabilities.maxTextureSize;var maxSamples=capabilities.maxSamples;var _videoTextures=new WeakMap();var _canvas;// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
  var useOffscreenCanvas=false;try{useOffscreenCanvas=typeof OffscreenCanvas!=='undefined'&&new OffscreenCanvas(1,1).getContext('2d')!==null;}catch(err){// Ignore any errors
  }function createCanvas(width,height){// Use OffscreenCanvas when available. Specially needed in web workers
  return useOffscreenCanvas?new OffscreenCanvas(width,height):createElementNS('canvas');}function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){var scale=1;// handle case if texture exceeds max size
  if(image.width>maxSize||image.height>maxSize){scale=maxSize/Math.max(image.width,image.height);}// only perform resize if necessary
  if(scale<1||needsPowerOfTwo===true){// only perform resize for certain image types
  if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){var floor=needsPowerOfTwo?floorPowerOfTwo:Math.floor;var width=floor(scale*image.width);var height=floor(scale*image.height);if(_canvas===undefined)_canvas=createCanvas(width,height);// cube textures can't reuse the same canvas
  var canvas=needsNewCanvas?createCanvas(width,height):_canvas;canvas.width=width;canvas.height=height;var context=canvas.getContext('2d');context.drawImage(image,0,0,width,height);console.warn('THREE.WebGLRenderer: Texture has been resized from ('+image.width+'x'+image.height+') to ('+width+'x'+height+').');return canvas;}else {if('data'in image){console.warn('THREE.WebGLRenderer: Image in DataTexture is too big ('+image.width+'x'+image.height+').');}return image;}}return image;}function isPowerOfTwo$1(image){return isPowerOfTwo(image.width)&&isPowerOfTwo(image.height);}function textureNeedsPowerOfTwo(texture){if(isWebGL2)return false;return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function textureNeedsGenerateMipmaps(texture,supportsMips){return texture.generateMipmaps&&supportsMips&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function generateMipmap(target,texture,width,height){var depth=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;_gl.generateMipmap(target);var textureProperties=properties.get(texture);textureProperties.__maxMipLevel=Math.log2(Math.max(width,height,depth));}function getInternalFormat(internalFormatName,glFormat,glType,encoding){if(isWebGL2===false)return glFormat;if(internalFormatName!==null){if(_gl[internalFormatName]!==undefined)return _gl[internalFormatName];console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \''+internalFormatName+'\'');}var internalFormat=glFormat;if(glFormat===6403){if(glType===5126)internalFormat=33326;if(glType===5131)internalFormat=33325;if(glType===5121)internalFormat=33321;}if(glFormat===6407){if(glType===5126)internalFormat=34837;if(glType===5131)internalFormat=34843;if(glType===5121)internalFormat=32849;}if(glFormat===6408){if(glType===5126)internalFormat=34836;if(glType===5131)internalFormat=34842;if(glType===5121)internalFormat=encoding===sRGBEncoding?35907:32856;}if(internalFormat===33325||internalFormat===33326||internalFormat===34842||internalFormat===34836){extensions.get('EXT_color_buffer_float');}return internalFormat;}// Fallback filters for non-power-of-2 textures
  function filterFallback(f){if(f===NearestFilter||f===NearestMipmapNearestFilter||f===NearestMipmapLinearFilter){return 9728;}return 9729;}//
  function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){_videoTextures["delete"](texture);}info.memory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);}//
  function deallocateTexture(texture){var textureProperties=properties.get(texture);if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);properties.remove(texture);}function deallocateRenderTarget(renderTarget){var texture=renderTarget.texture;var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);info.memory.textures--;}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLCubeRenderTarget){for(var _i120=0;_i120<6;_i120++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[_i120]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[_i120]);}}else {_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);if(renderTargetProperties.__webglMultisampledFramebuffer)_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);if(renderTargetProperties.__webglDepthRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);}if(renderTarget.isWebGLMultipleRenderTargets){for(var _i121=0,il=texture.length;_i121<il;_i121++){var attachmentProperties=properties.get(texture[_i121]);if(attachmentProperties.__webglTexture){_gl.deleteTexture(attachmentProperties.__webglTexture);info.memory.textures--;}properties.remove(texture[_i121]);}}properties.remove(texture);properties.remove(renderTarget);}//
  var textureUnits=0;function resetTextureUnits(){textureUnits=0;}function allocateTextureUnit(){var textureUnit=textureUnits;if(textureUnit>=maxTextures){console.warn('THREE.WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+maxTextures);}textureUnits+=1;return textureUnit;}//
  function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');}else {uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(33984+slot);state.bindTexture(3553,textureProperties.__webglTexture);}function setTexture2DArray(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(35866,textureProperties.__webglTexture);}function setTexture3D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(32879,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadCubeTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);}var wrappingToGL=(_wrappingToGL={},_defineProperty(_wrappingToGL,RepeatWrapping,10497),_defineProperty(_wrappingToGL,ClampToEdgeWrapping,33071),_defineProperty(_wrappingToGL,MirroredRepeatWrapping,33648),_wrappingToGL);var filterToGL=(_filterToGL={},_defineProperty(_filterToGL,NearestFilter,9728),_defineProperty(_filterToGL,NearestMipmapNearestFilter,9984),_defineProperty(_filterToGL,NearestMipmapLinearFilter,9986),_defineProperty(_filterToGL,LinearFilter,9729),_defineProperty(_filterToGL,LinearMipmapNearestFilter,9985),_defineProperty(_filterToGL,LinearMipmapLinearFilter,9987),_filterToGL);function setTextureParameters(textureType,texture,supportsMips){if(supportsMips){_gl.texParameteri(textureType,10242,wrappingToGL[texture.wrapS]);_gl.texParameteri(textureType,10243,wrappingToGL[texture.wrapT]);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,wrappingToGL[texture.wrapR]);}_gl.texParameteri(textureType,10240,filterToGL[texture.magFilter]);_gl.texParameteri(textureType,10241,filterToGL[texture.minFilter]);}else {_gl.texParameteri(textureType,10242,33071);_gl.texParameteri(textureType,10243,33071);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,33071);}if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');}_gl.texParameteri(textureType,10240,filterFallback(texture.magFilter));_gl.texParameteri(textureType,10241,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');}}if(extensions.has('EXT_texture_filter_anisotropic')===true){var extension=extensions.get('EXT_texture_filter_anisotropic');if(texture.type===FloatType&&extensions.has('OES_texture_float_linear')===false)return;// verify extension for WebGL 1 and WebGL 2
  if(isWebGL2===false&&texture.type===HalfFloatType&&extensions.has('OES_texture_half_float_linear')===false)return;// verify extension for WebGL 1 only
  if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function initTexture(textureProperties,texture){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}function uploadTexture(textureProperties,texture,slot){var textureType=3553;if(texture.isDataTexture2DArray)textureType=35866;if(texture.isDataTexture3D)textureType=32879;initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(textureType,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);var needsPowerOfTwo=textureNeedsPowerOfTwo(texture)&&isPowerOfTwo$1(texture.image)===false;var image=resizeImage(texture.image,needsPowerOfTwo,false,maxTextureSize);var supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);setTextureParameters(textureType,texture,supportsMips);var mipmap;var mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
  glInternalFormat=6402;if(isWebGL2){if(texture.type===FloatType){glInternalFormat=36012;}else if(texture.type===UnsignedIntType){glInternalFormat=33190;}else if(texture.type===UnsignedInt248Type){glInternalFormat=35056;}else {glInternalFormat=33189;// WebGL2 requires sized internalformat for glTexImage2D
  }}else {if(texture.type===FloatType){console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');}}// validation checks for WebGL 1
  if(texture.format===DepthFormat&&glInternalFormat===6402){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=utils.convert(texture.type);}}if(texture.format===DepthStencilFormat&&glInternalFormat===6402){// Depth stencil textures need the DEPTH_STENCIL internal format
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  glInternalFormat=34041;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=utils.convert(texture.type);}}//
  state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&supportsMips){for(var _i122=0,il=mipmaps.length;_i122<il;_i122++){mipmap=mipmaps[_i122];state.texImage2D(3553,_i122,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else {state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}}else if(texture.isCompressedTexture){for(var _i123=0,_il9=mipmaps.length;_i123<_il9;_i123++){mipmap=mipmaps[_i123];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(3553,_i123,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else {state.texImage2D(3553,_i123,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}textureProperties.__maxMipLevel=mipmaps.length-1;}else if(texture.isDataTexture2DArray){state.texImage3D(35866,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else if(texture.isDataTexture3D){state.texImage3D(32879,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else {// regular Texture (image, video, canvas)
  // use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&supportsMips){for(var _i124=0,_il10=mipmaps.length;_i124<_il10;_i124++){mipmap=mipmaps[_i124];state.texImage2D(3553,_i124,glInternalFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else {state.texImage2D(3553,0,glInternalFormat,glFormat,glType,image);textureProperties.__maxMipLevel=0;}}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(textureType,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}function uploadCubeTexture(textureProperties,texture,slot){if(texture.image.length!==6)return;initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);var isCompressed=texture&&(texture.isCompressedTexture||texture.image[0].isCompressedTexture);var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var _i125=0;_i125<6;_i125++){if(!isCompressed&&!isDataTexture){cubeImage[_i125]=resizeImage(texture.image[_i125],false,true,maxCubemapSize);}else {cubeImage[_i125]=isDataTexture?texture.image[_i125].image:texture.image[_i125];}}var image=cubeImage[0],supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);setTextureParameters(34067,texture,supportsMips);var mipmaps;if(isCompressed){for(var _i126=0;_i126<6;_i126++){mipmaps=cubeImage[_i126].mipmaps;for(var j=0;j<mipmaps.length;j++){var mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(34069+_i126,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else {state.texImage2D(34069+_i126,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}textureProperties.__maxMipLevel=mipmaps.length-1;}else {mipmaps=texture.mipmaps;for(var _i127=0;_i127<6;_i127++){if(isDataTexture){state.texImage2D(34069+_i127,0,glInternalFormat,cubeImage[_i127].width,cubeImage[_i127].height,0,glFormat,glType,cubeImage[_i127].data);for(var _j3=0;_j3<mipmaps.length;_j3++){var _mipmap=mipmaps[_j3];var mipmapImage=_mipmap.image[_i127].image;state.texImage2D(34069+_i127,_j3+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data);}}else {state.texImage2D(34069+_i127,0,glInternalFormat,glFormat,glType,cubeImage[_i127]);for(var _j4=0;_j4<mipmaps.length;_j4++){var _mipmap2=mipmaps[_j4];state.texImage2D(34069+_i127,_j4+1,glInternalFormat,glFormat,glType,_mipmap2.image[_i127]);}}}textureProperties.__maxMipLevel=mipmaps.length;}if(textureNeedsGenerateMipmaps(texture,supportsMips)){// We assume images for cube map have the same size.
  generateMipmap(34067,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget){var glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type);var glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);if(textureTarget===32879||textureTarget===35866){state.texImage3D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,renderTarget.depth,0,glFormat,glType,null);}else {state.texImage2D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);}state.bindFramebuffer(36160,framebuffer);_gl.framebufferTexture2D(36160,attachment,textureTarget,properties.get(texture).__webglTexture,0);state.bindFramebuffer(36160,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(36161,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){var glInternalFormat=33189;if(isMultisample){var depthTexture=renderTarget.depthTexture;if(depthTexture&&depthTexture.isDepthTexture){if(depthTexture.type===FloatType){glInternalFormat=36012;}else if(depthTexture.type===UnsignedIntType){glInternalFormat=33190;}}var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){if(isMultisample){var _samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,_samples,35056,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,34041,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);}else {// Use the first texture for MRT so far
  var texture=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture[0]:renderTarget.texture;var glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type);var _glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);if(isMultisample){var _samples2=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,_samples2,_glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,_glInternalFormat,renderTarget.width,renderTarget.height);}}_gl.bindRenderbuffer(36161,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
  function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLCubeRenderTarget;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');state.bindFramebuffer(36160,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
  if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(36160,36096,3553,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(36160,33306,3553,webglDepthTexture,0);}else {throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLCubeRenderTarget===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else {if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var _i128=0;_i128<6;_i128++){state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer[_i128]);renderTargetProperties.__webglDepthbuffer[_i128]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[_i128],renderTarget,false);}}else {state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,false);}}state.bindFramebuffer(36160,null);}// Set up GL resources for the render target
  function setupRenderTarget(renderTarget){var texture=renderTarget.texture;var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);if(renderTarget.isWebGLMultipleRenderTargets!==true){textureProperties.__webglTexture=_gl.createTexture();textureProperties.__version=texture.version;info.memory.textures++;}var isCube=renderTarget.isWebGLCubeRenderTarget===true;var isMultipleRenderTargets=renderTarget.isWebGLMultipleRenderTargets===true;var isMultisample=renderTarget.isWebGLMultisampleRenderTarget===true;var isRenderTarget3D=texture.isDataTexture3D||texture.isDataTexture2DArray;var supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;// Handles WebGL2 RGBFormat fallback - #18858
  if(isWebGL2&&texture.format===RGBFormat&&(texture.type===FloatType||texture.type===HalfFloatType)){texture.format=RGBAFormat;console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');}// Setup framebuffer
  if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var _i129=0;_i129<6;_i129++){renderTargetProperties.__webglFramebuffer[_i129]=_gl.createFramebuffer();}}else {renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();if(isMultipleRenderTargets){if(capabilities.drawBuffers){var textures=renderTarget.texture;for(var _i130=0,il=textures.length;_i130<il;_i130++){var attachmentProperties=properties.get(textures[_i130]);if(attachmentProperties.__webglTexture===undefined){attachmentProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}}else {console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');}}else if(isMultisample){if(isWebGL2){renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=_gl.createRenderbuffer();_gl.bindRenderbuffer(36161,renderTargetProperties.__webglColorRenderbuffer);var glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type);var glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);state.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(36160,36064,36161,renderTargetProperties.__webglColorRenderbuffer);_gl.bindRenderbuffer(36161,null);if(renderTarget.depthBuffer){renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);}state.bindFramebuffer(36160,null);}else {console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');}}}// Setup color buffer
  if(isCube){state.bindTexture(34067,textureProperties.__webglTexture);setTextureParameters(34067,texture,supportsMips);for(var _i131=0;_i131<6;_i131++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i131],renderTarget,texture,36064,34069+_i131);}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(34067,texture,renderTarget.width,renderTarget.height);}state.unbindTexture();}else if(isMultipleRenderTargets){var _textures=renderTarget.texture;for(var _i132=0,_il11=_textures.length;_i132<_il11;_i132++){var attachment=_textures[_i132];var _attachmentProperties=properties.get(attachment);state.bindTexture(3553,_attachmentProperties.__webglTexture);setTextureParameters(3553,attachment,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,attachment,36064+_i132,3553);if(textureNeedsGenerateMipmaps(attachment,supportsMips)){generateMipmap(3553,attachment,renderTarget.width,renderTarget.height);}}state.unbindTexture();}else {var glTextureType=3553;if(isRenderTarget3D){// Render targets containing layers, i.e: Texture 3D and 2d arrays
  if(isWebGL2){var isTexture3D=texture.isDataTexture3D;glTextureType=isTexture3D?32879:35866;}else {console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');}}state.bindTexture(glTextureType,textureProperties.__webglTexture);setTextureParameters(glTextureType,texture,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,36064,glTextureType);if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(glTextureType,texture,renderTarget.width,renderTarget.height,renderTarget.depth);}state.unbindTexture();}// Setup depth and stencil buffers
  if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;var textures=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture:[renderTarget.texture];for(var _i133=0,il=textures.length;_i133<il;_i133++){var texture=textures[_i133];if(textureNeedsGenerateMipmaps(texture,supportsMips)){var target=renderTarget.isWebGLCubeRenderTarget?34067:3553;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);generateMipmap(target,texture,renderTarget.width,renderTarget.height);state.unbindTexture();}}}function updateMultisampleRenderTarget(renderTarget){if(renderTarget.isWebGLMultisampleRenderTarget){if(isWebGL2){var width=renderTarget.width;var height=renderTarget.height;var mask=16384;if(renderTarget.depthBuffer)mask|=256;if(renderTarget.stencilBuffer)mask|=1024;var renderTargetProperties=properties.get(renderTarget);state.bindFramebuffer(36008,renderTargetProperties.__webglMultisampledFramebuffer);state.bindFramebuffer(36009,renderTargetProperties.__webglFramebuffer);_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,9728);state.bindFramebuffer(36008,null);state.bindFramebuffer(36009,renderTargetProperties.__webglMultisampledFramebuffer);}else {console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');}}}function getRenderTargetSamples(renderTarget){return isWebGL2&&renderTarget.isWebGLMultisampleRenderTarget?Math.min(maxSamples,renderTarget.samples):0;}function updateVideoTexture(texture){var frame=info.render.frame;// Check the last frame we updated the VideoTexture
  if(_videoTextures.get(texture)!==frame){_videoTextures.set(texture,frame);texture.update();}}// backwards compatibility
  var warnedTexture2D=false;var warnedTextureCube=false;function safeSetTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(warnedTexture2D===false){console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');warnedTexture2D=true;}texture=texture.texture;}setTexture2D(texture,slot);}function safeSetTextureCube(texture,slot){if(texture&&texture.isWebGLCubeRenderTarget){if(warnedTextureCube===false){console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');warnedTextureCube=true;}texture=texture.texture;}setTextureCube(texture,slot);}//
  this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.safeSetTexture2D=safeSetTexture2D;this.safeSetTextureCube=safeSetTextureCube;}function WebGLUtils(gl,extensions,capabilities){var isWebGL2=capabilities.isWebGL2;function convert(p){var extension;if(p===UnsignedByteType)return 5121;if(p===UnsignedShort4444Type)return 32819;if(p===UnsignedShort5551Type)return 32820;if(p===UnsignedShort565Type)return 33635;if(p===ByteType)return 5120;if(p===ShortType)return 5122;if(p===UnsignedShortType)return 5123;if(p===IntType)return 5124;if(p===UnsignedIntType)return 5125;if(p===FloatType)return 5126;if(p===HalfFloatType){if(isWebGL2)return 5131;extension=extensions.get('OES_texture_half_float');if(extension!==null){return extension.HALF_FLOAT_OES;}else {return null;}}if(p===AlphaFormat)return 6406;if(p===RGBFormat)return 6407;if(p===RGBAFormat)return 6408;if(p===LuminanceFormat)return 6409;if(p===LuminanceAlphaFormat)return 6410;if(p===DepthFormat)return 6402;if(p===DepthStencilFormat)return 34041;if(p===RedFormat)return 6403;// WebGL2 formats.
  if(p===RedIntegerFormat)return 36244;if(p===RGFormat)return 33319;if(p===RGIntegerFormat)return 33320;if(p===RGBIntegerFormat)return 36248;if(p===RGBAIntegerFormat)return 36249;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else {return null;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else {return null;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null){return extension.COMPRESSED_RGB_ETC1_WEBGL;}else {return null;}}if(p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){extension=extensions.get('WEBGL_compressed_texture_etc');if(extension!==null){if(p===RGB_ETC2_Format)return extension.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return extension.COMPRESSED_RGBA8_ETC2_EAC;}}if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format||p===SRGB8_ALPHA8_ASTC_4x4_Format||p===SRGB8_ALPHA8_ASTC_5x4_Format||p===SRGB8_ALPHA8_ASTC_5x5_Format||p===SRGB8_ALPHA8_ASTC_6x5_Format||p===SRGB8_ALPHA8_ASTC_6x6_Format||p===SRGB8_ALPHA8_ASTC_8x5_Format||p===SRGB8_ALPHA8_ASTC_8x6_Format||p===SRGB8_ALPHA8_ASTC_8x8_Format||p===SRGB8_ALPHA8_ASTC_10x5_Format||p===SRGB8_ALPHA8_ASTC_10x6_Format||p===SRGB8_ALPHA8_ASTC_10x8_Format||p===SRGB8_ALPHA8_ASTC_10x10_Format||p===SRGB8_ALPHA8_ASTC_12x10_Format||p===SRGB8_ALPHA8_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){// TODO Complete?
  return p;}else {return null;}}if(p===RGBA_BPTC_Format){extension=extensions.get('EXT_texture_compression_bptc');if(extension!==null){// TODO Complete?
  return p;}else {return null;}}if(p===UnsignedInt248Type){if(isWebGL2)return 34042;extension=extensions.get('WEBGL_depth_texture');if(extension!==null){return extension.UNSIGNED_INT_24_8_WEBGL;}else {return null;}}}return {convert:convert};}var ArrayCamera=/*#__PURE__*/function(_PerspectiveCamera){_inherits(ArrayCamera,_PerspectiveCamera);var _super34=_createSuper(ArrayCamera);function ArrayCamera(){var _this25;var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];_classCallCheck(this,ArrayCamera);_this25=_super34.call(this);_this25.cameras=array;return _this25;}return _createClass(ArrayCamera);}(PerspectiveCamera);ArrayCamera.prototype.isArrayCamera=true;var Group$1=/*#__PURE__*/function(_Object3D4){_inherits(Group,_Object3D4);var _super35=_createSuper(Group);function Group(){var _this26;_classCallCheck(this,Group);_this26=_super35.call(this);_this26.type='Group';return _this26;}return _createClass(Group);}(Object3D$1);Group$1.prototype.isGroup=true;var _moveEvent={type:'move'};var WebXRController=/*#__PURE__*/function(){function WebXRController(){_classCallCheck(this,WebXRController);this._targetRay=null;this._grip=null;this._hand=null;}_createClass(WebXRController,[{key:"getHandSpace",value:function getHandSpace(){if(this._hand===null){this._hand=new Group$1();this._hand.matrixAutoUpdate=false;this._hand.visible=false;this._hand.joints={};this._hand.inputState={pinching:false};}return this._hand;}},{key:"getTargetRaySpace",value:function getTargetRaySpace(){if(this._targetRay===null){this._targetRay=new Group$1();this._targetRay.matrixAutoUpdate=false;this._targetRay.visible=false;this._targetRay.hasLinearVelocity=false;this._targetRay.linearVelocity=new Vector3();this._targetRay.hasAngularVelocity=false;this._targetRay.angularVelocity=new Vector3();}return this._targetRay;}},{key:"getGripSpace",value:function getGripSpace(){if(this._grip===null){this._grip=new Group$1();this._grip.matrixAutoUpdate=false;this._grip.visible=false;this._grip.hasLinearVelocity=false;this._grip.linearVelocity=new Vector3();this._grip.hasAngularVelocity=false;this._grip.angularVelocity=new Vector3();}return this._grip;}},{key:"dispatchEvent",value:function dispatchEvent(event){if(this._targetRay!==null){this._targetRay.dispatchEvent(event);}if(this._grip!==null){this._grip.dispatchEvent(event);}if(this._hand!==null){this._hand.dispatchEvent(event);}return this;}},{key:"disconnect",value:function disconnect(inputSource){this.dispatchEvent({type:'disconnected',data:inputSource});if(this._targetRay!==null){this._targetRay.visible=false;}if(this._grip!==null){this._grip.visible=false;}if(this._hand!==null){this._hand.visible=false;}return this;}},{key:"update",value:function update(inputSource,frame,referenceSpace){var inputPose=null;var gripPose=null;var handPose=null;var targetRay=this._targetRay;var grip=this._grip;var hand=this._hand;if(inputSource&&frame.session.visibilityState!=='visible-blurred'){if(targetRay!==null){inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);if(inputPose!==null){targetRay.matrix.fromArray(inputPose.transform.matrix);targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale);if(inputPose.linearVelocity){targetRay.hasLinearVelocity=true;targetRay.linearVelocity.copy(inputPose.linearVelocity);}else {targetRay.hasLinearVelocity=false;}if(inputPose.angularVelocity){targetRay.hasAngularVelocity=true;targetRay.angularVelocity.copy(inputPose.angularVelocity);}else {targetRay.hasAngularVelocity=false;}this.dispatchEvent(_moveEvent);}}if(hand&&inputSource.hand){handPose=true;var _iterator=_createForOfIteratorHelper(inputSource.hand.values()),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var inputjoint=_step.value;// Update the joints groups with the XRJoint poses
  var jointPose=frame.getJointPose(inputjoint,referenceSpace);if(hand.joints[inputjoint.jointName]===undefined){// The transform of this joint will be updated with the joint pose on each frame
  var _joint=new Group$1();_joint.matrixAutoUpdate=false;_joint.visible=false;hand.joints[inputjoint.jointName]=_joint;// ??
  hand.add(_joint);}var joint=hand.joints[inputjoint.jointName];if(jointPose!==null){joint.matrix.fromArray(jointPose.transform.matrix);joint.matrix.decompose(joint.position,joint.rotation,joint.scale);joint.jointRadius=jointPose.radius;}joint.visible=jointPose!==null;}// Custom events
  // Check pinchz
  }catch(err){_iterator.e(err);}finally{_iterator.f();}var indexTip=hand.joints['index-finger-tip'];var thumbTip=hand.joints['thumb-tip'];var distance=indexTip.position.distanceTo(thumbTip.position);var distanceToPinch=0.02;var threshold=0.005;if(hand.inputState.pinching&&distance>distanceToPinch+threshold){hand.inputState.pinching=false;this.dispatchEvent({type:'pinchend',handedness:inputSource.handedness,target:this});}else if(!hand.inputState.pinching&&distance<=distanceToPinch-threshold){hand.inputState.pinching=true;this.dispatchEvent({type:'pinchstart',handedness:inputSource.handedness,target:this});}}else {if(grip!==null&&inputSource.gripSpace){gripPose=frame.getPose(inputSource.gripSpace,referenceSpace);if(gripPose!==null){grip.matrix.fromArray(gripPose.transform.matrix);grip.matrix.decompose(grip.position,grip.rotation,grip.scale);if(gripPose.linearVelocity){grip.hasLinearVelocity=true;grip.linearVelocity.copy(gripPose.linearVelocity);}else {grip.hasLinearVelocity=false;}if(gripPose.angularVelocity){grip.hasAngularVelocity=true;grip.angularVelocity.copy(gripPose.angularVelocity);}else {grip.hasAngularVelocity=false;}}}}}if(targetRay!==null){targetRay.visible=inputPose!==null;}if(grip!==null){grip.visible=gripPose!==null;}if(hand!==null){hand.visible=handPose!==null;}return this;}}]);return WebXRController;}();var WebXRManager=/*#__PURE__*/function(_EventDispatcher6){_inherits(WebXRManager,_EventDispatcher6);var _super36=_createSuper(WebXRManager);function WebXRManager(renderer,gl){var _this27;_classCallCheck(this,WebXRManager);_this27=_super36.call(this);var scope=_assertThisInitialized(_this27);var state=renderer.state;var session=null;var framebufferScaleFactor=1.0;var referenceSpace=null;var referenceSpaceType='local-floor';var pose=null;var glBinding=null;var glFramebuffer=null;var glProjLayer=null;var glBaseLayer=null;var isMultisample=false;var glMultisampledFramebuffer=null;var glColorRenderbuffer=null;var glDepthRenderbuffer=null;var xrFrame=null;var depthStyle=null;var clearStyle=null;var controllers=[];var inputSourcesMap=new Map();//
  var cameraL=new PerspectiveCamera();cameraL.layers.enable(1);cameraL.viewport=new Vector4();var cameraR=new PerspectiveCamera();cameraR.layers.enable(2);cameraR.viewport=new Vector4();var cameras=[cameraL,cameraR];var cameraVR=new ArrayCamera();cameraVR.layers.enable(1);cameraVR.layers.enable(2);var _currentDepthNear=null;var _currentDepthFar=null;//
  _this27.cameraAutoUpdate=true;_this27.enabled=false;_this27.isPresenting=false;_this27.getController=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getTargetRaySpace();};_this27.getControllerGrip=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getGripSpace();};_this27.getHand=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getHandSpace();};//
  function onSessionEvent(event){var controller=inputSourcesMap.get(event.inputSource);if(controller){controller.dispatchEvent({type:event.type,data:event.inputSource});}}function onSessionEnd(){inputSourcesMap.forEach(function(controller,inputSource){controller.disconnect(inputSource);});inputSourcesMap.clear();_currentDepthNear=null;_currentDepthFar=null;// restore framebuffer/rendering state
  state.bindXRFramebuffer(null);renderer.setRenderTarget(renderer.getRenderTarget());if(glFramebuffer)gl.deleteFramebuffer(glFramebuffer);if(glMultisampledFramebuffer)gl.deleteFramebuffer(glMultisampledFramebuffer);if(glColorRenderbuffer)gl.deleteRenderbuffer(glColorRenderbuffer);if(glDepthRenderbuffer)gl.deleteRenderbuffer(glDepthRenderbuffer);glFramebuffer=null;glMultisampledFramebuffer=null;glColorRenderbuffer=null;glDepthRenderbuffer=null;glBaseLayer=null;glProjLayer=null;glBinding=null;session=null;//
  animation.stop();scope.isPresenting=false;scope.dispatchEvent({type:'sessionend'});}_this27.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');}};_this27.setReferenceSpaceType=function(value){referenceSpaceType=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');}};_this27.getReferenceSpace=function(){return referenceSpace;};_this27.getBaseLayer=function(){return glProjLayer!==null?glProjLayer:glBaseLayer;};_this27.getBinding=function(){return glBinding;};_this27.getFrame=function(){return xrFrame;};_this27.getSession=function(){return session;};_this27.setSession=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(value){var attributes,layerInit,_layerInit,depthFormat,projectionlayerInit;return _regeneratorRuntime().wrap(function _callee$(_context5){while(1)switch(_context5.prev=_context5.next){case 0:session=value;if(!(session!==null)){_context5.next=22;break;}session.addEventListener('select',onSessionEvent);session.addEventListener('selectstart',onSessionEvent);session.addEventListener('selectend',onSessionEvent);session.addEventListener('squeeze',onSessionEvent);session.addEventListener('squeezestart',onSessionEvent);session.addEventListener('squeezeend',onSessionEvent);session.addEventListener('end',onSessionEnd);session.addEventListener('inputsourceschange',onInputSourcesChange);attributes=gl.getContextAttributes();if(!(attributes.xrCompatible!==true)){_context5.next=14;break;}_context5.next=14;return gl.makeXRCompatible();case 14:if(session.renderState.layers===undefined){layerInit={antialias:attributes.antialias,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({baseLayer:glBaseLayer});}else if(gl instanceof WebGLRenderingContext){// Use old style webgl layer because we can't use MSAA
  // WebGL2 support.
  _layerInit={antialias:true,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,_layerInit);session.updateRenderState({layers:[glBaseLayer]});}else {isMultisample=attributes.antialias;depthFormat=null;if(attributes.depth){clearStyle=256;if(attributes.stencil)clearStyle|=1024;depthStyle=attributes.stencil?33306:36096;depthFormat=attributes.stencil?35056:33190;}projectionlayerInit={colorFormat:attributes.alpha?32856:32849,depthFormat:depthFormat,scaleFactor:framebufferScaleFactor};glBinding=new XRWebGLBinding(session,gl);glProjLayer=glBinding.createProjectionLayer(projectionlayerInit);glFramebuffer=gl.createFramebuffer();session.updateRenderState({layers:[glProjLayer]});if(isMultisample){glMultisampledFramebuffer=gl.createFramebuffer();glColorRenderbuffer=gl.createRenderbuffer();gl.bindRenderbuffer(36161,glColorRenderbuffer);gl.renderbufferStorageMultisample(36161,4,32856,glProjLayer.textureWidth,glProjLayer.textureHeight);state.bindFramebuffer(36160,glMultisampledFramebuffer);gl.framebufferRenderbuffer(36160,36064,36161,glColorRenderbuffer);gl.bindRenderbuffer(36161,null);if(depthFormat!==null){glDepthRenderbuffer=gl.createRenderbuffer();gl.bindRenderbuffer(36161,glDepthRenderbuffer);gl.renderbufferStorageMultisample(36161,4,depthFormat,glProjLayer.textureWidth,glProjLayer.textureHeight);gl.framebufferRenderbuffer(36160,depthStyle,36161,glDepthRenderbuffer);gl.bindRenderbuffer(36161,null);}state.bindFramebuffer(36160,null);}}_context5.next=17;return session.requestReferenceSpace(referenceSpaceType);case 17:referenceSpace=_context5.sent;animation.setContext(session);animation.start();scope.isPresenting=true;scope.dispatchEvent({type:'sessionstart'});case 22:case"end":return _context5.stop();}},_callee);}));return function(_x3){return _ref.apply(this,arguments);};}();function onInputSourcesChange(event){var inputSources=session.inputSources;// Assign inputSources to available controllers
  for(var _i134=0;_i134<controllers.length;_i134++){inputSourcesMap.set(inputSources[_i134],controllers[_i134]);}// Notify disconnected
  for(var _i135=0;_i135<event.removed.length;_i135++){var inputSource=event.removed[_i135];var controller=inputSourcesMap.get(inputSource);if(controller){controller.dispatchEvent({type:'disconnected',data:inputSource});inputSourcesMap["delete"](inputSource);}}// Notify connected
  for(var _i136=0;_i136<event.added.length;_i136++){var _inputSource=event.added[_i136];var _controller=inputSourcesMap.get(_inputSource);if(_controller){_controller.dispatchEvent({type:'connected',data:_inputSource});}}}//
  var cameraLPos=new Vector3();var cameraRPos=new Vector3();/**
  		 * Assumes 2 cameras that are parallel and share an X-axis, and that
  		 * the cameras' projection and world matrices have already been set.
  		 * And that near and far planes are identical for both cameras.
  		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
  		 */function setProjectionFromUnion(camera,cameraL,cameraR){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);var ipd=cameraLPos.distanceTo(cameraRPos);var projL=cameraL.projectionMatrix.elements;var projR=cameraR.projectionMatrix.elements;// VR systems will have identical far and near planes, and
  // most likely identical top and bottom frustum extents.
  // Use the left camera for these values.
  var near=projL[14]/(projL[10]-1);var far=projL[14]/(projL[10]+1);var topFov=(projL[9]+1)/projL[5];var bottomFov=(projL[9]-1)/projL[5];var leftFov=(projL[8]-1)/projL[0];var rightFov=(projR[8]+1)/projR[0];var left=near*leftFov;var right=near*rightFov;// Calculate the new camera's position offset from the
  // left camera. xOffset should be roughly half `ipd`.
  var zOffset=ipd/(-leftFov+rightFov);var xOffset=zOffset*-leftFov;// TODO: Better way to apply this offset?
  cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);camera.translateX(xOffset);camera.translateZ(zOffset);camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);camera.matrixWorldInverse.copy(camera.matrixWorld).invert();// Find the union of the frustum values of the cameras and scale
  // the values so that the near plane's position does not change in world space,
  // although must now be relative to the new union camera.
  var near2=near+zOffset;var far2=far+zOffset;var left2=left-xOffset;var right2=right+(ipd-xOffset);var top2=topFov*far/far2*near2;var bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);}function updateCamera(camera,parent){if(parent===null){camera.matrixWorld.copy(camera.matrix);}else {camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);}camera.matrixWorldInverse.copy(camera.matrixWorld).invert();}_this27.updateCamera=function(camera){if(session===null)return;cameraVR.near=cameraR.near=cameraL.near=camera.near;cameraVR.far=cameraR.far=cameraL.far=camera.far;if(_currentDepthNear!==cameraVR.near||_currentDepthFar!==cameraVR.far){// Note that the new renderState won't apply until the next frame. See #18320
  session.updateRenderState({depthNear:cameraVR.near,depthFar:cameraVR.far});_currentDepthNear=cameraVR.near;_currentDepthFar=cameraVR.far;}var parent=camera.parent;var cameras=cameraVR.cameras;updateCamera(cameraVR,parent);for(var _i137=0;_i137<cameras.length;_i137++){updateCamera(cameras[_i137],parent);}cameraVR.matrixWorld.decompose(cameraVR.position,cameraVR.quaternion,cameraVR.scale);// update user camera and its children
  camera.position.copy(cameraVR.position);camera.quaternion.copy(cameraVR.quaternion);camera.scale.copy(cameraVR.scale);camera.matrix.copy(cameraVR.matrix);camera.matrixWorld.copy(cameraVR.matrixWorld);var children=camera.children;for(var _i138=0,l=children.length;_i138<l;_i138++){children[_i138].updateMatrixWorld(true);}// update projection matrix for proper view frustum culling
  if(cameras.length===2){setProjectionFromUnion(cameraVR,cameraL,cameraR);}else {// assume single camera setup (AR)
  cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);}};_this27.getCamera=function(){return cameraVR;};_this27.getFoveation=function(){if(glProjLayer!==null){return glProjLayer.fixedFoveation;}if(glBaseLayer!==null){return glBaseLayer.fixedFoveation;}return undefined;};_this27.setFoveation=function(foveation){// 0 = no foveation = full resolution
  // 1 = maximum foveation = the edges render at lower resolution
  if(glProjLayer!==null){glProjLayer.fixedFoveation=foveation;}if(glBaseLayer!==null&&glBaseLayer.fixedFoveation!==undefined){glBaseLayer.fixedFoveation=foveation;}};// Animation Loop
  var onAnimationFrameCallback=null;function onAnimationFrame(time,frame){pose=frame.getViewerPose(referenceSpace);xrFrame=frame;if(pose!==null){var views=pose.views;if(glBaseLayer!==null){state.bindXRFramebuffer(glBaseLayer.framebuffer);}var cameraVRNeedsUpdate=false;// check if it's necessary to rebuild cameraVR's camera list
  if(views.length!==cameraVR.cameras.length){cameraVR.cameras.length=0;cameraVRNeedsUpdate=true;}for(var _i139=0;_i139<views.length;_i139++){var view=views[_i139];var viewport=null;if(glBaseLayer!==null){viewport=glBaseLayer.getViewport(view);}else {var glSubImage=glBinding.getViewSubImage(glProjLayer,view);state.bindXRFramebuffer(glFramebuffer);if(glSubImage.depthStencilTexture!==undefined){gl.framebufferTexture2D(36160,depthStyle,3553,glSubImage.depthStencilTexture,0);}gl.framebufferTexture2D(36160,36064,3553,glSubImage.colorTexture,0);viewport=glSubImage.viewport;}var camera=cameras[_i139];camera.matrix.fromArray(view.transform.matrix);camera.projectionMatrix.fromArray(view.projectionMatrix);camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);if(_i139===0){cameraVR.matrix.copy(camera.matrix);}if(cameraVRNeedsUpdate===true){cameraVR.cameras.push(camera);}}if(isMultisample){state.bindXRFramebuffer(glMultisampledFramebuffer);if(clearStyle!==null)gl.clear(clearStyle);}}//
  var inputSources=session.inputSources;for(var _i140=0;_i140<controllers.length;_i140++){var controller=controllers[_i140];var inputSource=inputSources[_i140];controller.update(inputSource,frame,referenceSpace);}if(onAnimationFrameCallback)onAnimationFrameCallback(time,frame);if(isMultisample){var width=glProjLayer.textureWidth;var height=glProjLayer.textureHeight;state.bindFramebuffer(36008,glMultisampledFramebuffer);state.bindFramebuffer(36009,glFramebuffer);// Invalidate the depth here to avoid flush of the depth data to main memory.
  gl.invalidateFramebuffer(36008,[depthStyle]);gl.invalidateFramebuffer(36009,[depthStyle]);gl.blitFramebuffer(0,0,width,height,0,0,width,height,16384,9728);// Invalidate the MSAA buffer because it's not needed anymore.
  gl.invalidateFramebuffer(36008,[36064]);state.bindFramebuffer(36008,null);state.bindFramebuffer(36009,null);state.bindFramebuffer(36160,glMultisampledFramebuffer);}xrFrame=null;}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);_this27.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;};_this27.dispose=function(){};return _this27;}return _createClass(WebXRManager);}(EventDispatcher);function WebGLMaterials(properties){function refreshFogUniforms(uniforms,fog){uniforms.fogColor.value.copy(fog.color);if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshMaterialUniforms(uniforms,material,pixelRatio,height,transmissionRenderTarget){if(material.isMeshBasicMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsLambert(uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsToon(uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsPhong(uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsCommon(uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(uniforms,material,transmissionRenderTarget);}else {refreshUniformsStandard(uniforms,material);}}else if(material.isMeshMatcapMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsMatcap(uniforms,material);}else if(material.isMeshDepthMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDepth(uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDistance(uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsNormal(uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(uniforms,material,pixelRatio,height);}else if(material.isSpriteMaterial){refreshUniformsSprites(uniforms,material);}else if(material.isShadowMaterial){uniforms.color.value.copy(material.color);uniforms.opacity.value=material.opacity;}else if(material.isShaderMaterial){material.uniformsNeedUpdate=false;// #15581
  }}function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value.copy(material.color);}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.specularMap){uniforms.specularMap.value=material.specularMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}var envMap=properties.get(material).envMap;if(envMap){uniforms.envMap.value=envMap;uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;uniforms.reflectivity.value=material.reflectivity;uniforms.ior.value=material.ior;uniforms.refractionRatio.value=material.refractionRatio;var maxMipLevel=properties.get(envMap).__maxMipLevel;if(maxMipLevel!==undefined){uniforms.maxMipLevel.value=maxMipLevel;}}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. specular map
  // 3. displacementMap map
  // 4. normal map
  // 5. bump map
  // 6. roughnessMap map
  // 7. metalnessMap map
  // 8. alphaMap map
  // 9. emissiveMap map
  // 10. clearcoat map
  // 11. clearcoat normal map
  // 12. clearcoat roughnessMap map
  // 13. specular intensity map
  // 14. specular tint map
  // 15. transmission map
  // 16. thickness map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}else if(material.clearcoatMap){uvScaleMap=material.clearcoatMap;}else if(material.clearcoatNormalMap){uvScaleMap=material.clearcoatNormalMap;}else if(material.clearcoatRoughnessMap){uvScaleMap=material.clearcoatRoughnessMap;}else if(material.specularIntensityMap){uvScaleMap=material.specularIntensityMap;}else if(material.specularTintMap){uvScaleMap=material.specularTintMap;}else if(material.transmissionMap){uvScaleMap=material.transmissionMap;}else if(material.thicknessMap){uvScaleMap=material.thicknessMap;}if(uvScaleMap!==undefined){// backwards compatibility
  if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}// uv repeat and offset setting priorities for uv2
  // 1. ao map
  // 2. light map
  var uv2ScaleMap;if(material.aoMap){uv2ScaleMap=material.aoMap;}else if(material.lightMap){uv2ScaleMap=material.lightMap;}if(uv2ScaleMap!==undefined){// backwards compatibility
  if(uv2ScaleMap.isWebGLRenderTarget){uv2ScaleMap=uv2ScaleMap.texture;}if(uv2ScaleMap.matrixAutoUpdate===true){uv2ScaleMap.updateMatrix();}uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material,pixelRatio,height){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*pixelRatio;uniforms.scale.value=height*0.5;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. alpha map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. alpha map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
  if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}var envMap=properties.get(material).envMap;if(envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
  uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material,transmissionRenderTarget){refreshUniformsStandard(uniforms,material);uniforms.ior.value=material.ior;// also part of uniforms common
  if(material.sheen>0){uniforms.sheenTint.value.copy(material.sheenTint).multiplyScalar(material.sheen);uniforms.sheenRoughness.value=material.sheenRoughness;}if(material.clearcoat>0){uniforms.clearcoat.value=material.clearcoat;uniforms.clearcoatRoughness.value=material.clearcoatRoughness;if(material.clearcoatMap){uniforms.clearcoatMap.value=material.clearcoatMap;}if(material.clearcoatRoughnessMap){uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap;}if(material.clearcoatNormalMap){uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap;if(material.side===BackSide){uniforms.clearcoatNormalScale.value.negate();}}}if(material.transmission>0){uniforms.transmission.value=material.transmission;uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture;uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height);if(material.transmissionMap){uniforms.transmissionMap.value=material.transmissionMap;}uniforms.thickness.value=material.thickness;if(material.thicknessMap){uniforms.thicknessMap.value=material.thicknessMap;}uniforms.attenuationDistance.value=material.attenuationDistance;uniforms.attenuationTint.value.copy(material.attenuationTint);}uniforms.specularIntensity.value=material.specularIntensity;uniforms.specularTint.value.copy(material.specularTint);if(material.specularIntensityMap){uniforms.specularIntensityMap.value=material.specularIntensityMap;}if(material.specularTintMap){uniforms.specularTintMap.value=material.specularTintMap;}}function refreshUniformsMatcap(uniforms,material){if(material.matcap){uniforms.matcap.value=material.matcap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDepth(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDistance(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}uniforms.referencePosition.value.copy(material.referencePosition);uniforms.nearDistance.value=material.nearDistance;uniforms.farDistance.value=material.farDistance;}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}return {refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms};}function createCanvasElement(){var canvas=createElementNS('canvas');canvas.style.display='block';return canvas;}function WebGLRenderer(){var parameters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var _canvas=parameters.canvas!==undefined?parameters.canvas:createCanvasElement(),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false,_powerPreference=parameters.powerPreference!==undefined?parameters.powerPreference:'default',_failIfMajorPerformanceCaveat=parameters.failIfMajorPerformanceCaveat!==undefined?parameters.failIfMajorPerformanceCaveat:false;var currentRenderList=null;var currentRenderState=null;// render() can be called from within a callback triggered by another render.
  // We track this so that the nested render call gets its list and state isolated from the parent render call.
  var renderListStack=[];var renderStateStack=[];// public properties
  this.domElement=_canvas;// Debug configuration container
  this.debug={/**
  		 * Enables error checking and reporting when shader programs are being compiled
  		 * @type {boolean}
  		 */checkShaderErrors:true};// clearing
  this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
  this.sortObjects=true;// user-defined clipping
  this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
  this.gammaFactor=2.0;// for backwards compatibility
  this.outputEncoding=LinearEncoding;// physical lights
  this.physicallyCorrectLights=false;// tone mapping
  this.toneMapping=NoToneMapping;this.toneMappingExposure=1.0;// internal properties
  var _this=this;var _isContextLost=false;// internal state cache
  var _currentActiveCubeFace=0;var _currentActiveMipmapLevel=0;var _currentRenderTarget=null;var _currentMaterialId=-1;var _currentCamera=null;var _currentViewport=new Vector4();var _currentScissor=new Vector4();var _currentScissorTest=null;//
  var _width=_canvas.width;var _height=_canvas.height;var _pixelRatio=1;var _opaqueSort=null;var _transparentSort=null;var _viewport=new Vector4(0,0,_width,_height);var _scissor=new Vector4(0,0,_width,_height);var _scissorTest=false;//
  var _currentDrawBuffers=[];// frustum
  var _frustum=new Frustum();// clipping
  var _clippingEnabled=false;var _localClippingEnabled=false;// transmission
  var _transmissionRenderTarget=null;// camera matrices cache
  var _projScreenMatrix=new Matrix4$1();var _vector3=new Vector3();var _emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:true};function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
  var _gl=_context;function getContext(contextNames,contextAttributes){for(var _i141=0;_i141<contextNames.length;_i141++){var contextName=contextNames[_i141];var context=_canvas.getContext(contextName,contextAttributes);if(context!==null)return context;}return null;}try{var contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer,powerPreference:_powerPreference,failIfMajorPerformanceCaveat:_failIfMajorPerformanceCaveat};// event listeners must be registered before WebGL context is created, see #12753
  _canvas.addEventListener('webglcontextlost',onContextLost,false);_canvas.addEventListener('webglcontextrestored',onContextRestore,false);if(_gl===null){var contextNames=['webgl2','webgl','experimental-webgl'];if(_this.isWebGL1Renderer===true){contextNames.shift();}_gl=getContext(contextNames,contextAttributes);if(_gl===null){if(getContext(contextNames)){throw new Error('Error creating WebGL context with your selected attributes.');}else {throw new Error('Error creating WebGL context.');}}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
  if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return {'rangeMin':1,'rangeMax':1,'precision':1};};}}catch(error){console.error('THREE.WebGLRenderer: '+error.message);throw error;}var extensions,capabilities,state,info;var properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects;var programCache,materials,renderLists,renderStates,clipping,shadowMap;var background,morphtargets,bufferRenderer,indexedBufferRenderer;var utils,bindingStates;function initGLContext(){extensions=new WebGLExtensions(_gl);capabilities=new WebGLCapabilities(_gl,extensions,parameters);extensions.init(capabilities);utils=new WebGLUtils(_gl,extensions,capabilities);state=new WebGLState(_gl,extensions,capabilities);_currentDrawBuffers[0]=1029;info=new WebGLInfo();properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);cubemaps=new WebGLCubeMaps(_this);cubeuvmaps=new WebGLCubeUVMaps(_this);attributes=new WebGLAttributes(_gl,capabilities);bindingStates=new WebGLBindingStates(_gl,extensions,attributes,capabilities);geometries=new WebGLGeometries(_gl,attributes,info,bindingStates);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl,capabilities,textures);clipping=new WebGLClipping(properties);programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping);materials=new WebGLMaterials(properties);renderLists=new WebGLRenderLists(properties);renderStates=new WebGLRenderStates(extensions,capabilities);background=new WebGLBackground(_this,cubemaps,state,objects,_premultipliedAlpha);shadowMap=new WebGLShadowMap(_this,objects,capabilities);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info,capabilities);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info,capabilities);info.programs=programCache.programs;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.shadowMap=shadowMap;_this.state=state;_this.info=info;}initGLContext();// xr
  var xr=new WebXRManager(_this,_gl);this.xr=xr;// API
  this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(target){return target.set(_width,_height);};this.setSize=function(width,height,updateStyle){if(xr.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;_canvas.width=Math.floor(width*_pixelRatio);_canvas.height=Math.floor(height*_pixelRatio);if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor();};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=Math.floor(width*pixelRatio);_canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height);};this.getCurrentViewport=function(target){return target.copy(_currentViewport);};this.getViewport=function(target){return target.copy(_viewport);};this.setViewport=function(x,y,width,height){if(x.isVector4){_viewport.set(x.x,x.y,x.z,x.w);}else {_viewport.set(x,y,width,height);}state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());};this.getScissor=function(target){return target.copy(_scissor);};this.setScissor=function(x,y,width,height){if(x.isVector4){_scissor.set(x.x,x.y,x.z,x.w);}else {_scissor.set(x,y,width,height);}state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());};this.getScissorTest=function(){return _scissorTest;};this.setScissorTest=function(_boolean){state.setScissorTest(_scissorTest=_boolean);};this.setOpaqueSort=function(method){_opaqueSort=method;};this.setTransparentSort=function(method){_transparentSort=method;};// Clearing
  this.getClearColor=function(target){return target.copy(background.getClearColor());};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=16384;if(depth===undefined||depth)bits|=256;if(stencil===undefined||stencil)bits|=1024;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};//
  this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);renderLists.dispose();renderStates.dispose();properties.dispose();cubemaps.dispose();cubeuvmaps.dispose();objects.dispose();bindingStates.dispose();xr.dispose();xr.removeEventListener('sessionstart',onXRSessionStart);xr.removeEventListener('sessionend',onXRSessionEnd);if(_transmissionRenderTarget){_transmissionRenderTarget.dispose();_transmissionRenderTarget=null;}animation.stop();};// Events
  function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function onContextRestore(/* event */){console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;var infoAutoReset=info.autoReset;var shadowMapEnabled=shadowMap.enabled;var shadowMapAutoUpdate=shadowMap.autoUpdate;var shadowMapNeedsUpdate=shadowMap.needsUpdate;var shadowMapType=shadowMap.type;initGLContext();info.autoReset=infoAutoReset;shadowMap.enabled=shadowMapEnabled;shadowMap.autoUpdate=shadowMapAutoUpdate;shadowMap.needsUpdate=shadowMapNeedsUpdate;shadowMap.type=shadowMapType;}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
  function deallocateMaterial(material){releaseMaterialProgramReferences(material);properties.remove(material);}function releaseMaterialProgramReferences(material){var programs=properties.get(material).programs;if(programs!==undefined){programs.forEach(function(program){programCache.releaseProgram(program);});}}// Buffer rendering
  function renderObjectImmediate(object,program){object.render(function(object){_this.renderBufferImmediate(object,program);});}this.renderBufferImmediate=function(object,program){bindingStates.initAttributes();var buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();var programAttributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(34962,buffers.position);_gl.bufferData(34962,object.positionArray,35048);bindingStates.enableAttribute(programAttributes.position.location);_gl.vertexAttribPointer(programAttributes.position.location,3,5126,false,0,0);}if(object.hasNormals){_gl.bindBuffer(34962,buffers.normal);_gl.bufferData(34962,object.normalArray,35048);bindingStates.enableAttribute(programAttributes.normal.location);_gl.vertexAttribPointer(programAttributes.normal.location,3,5126,false,0,0);}if(object.hasUvs){_gl.bindBuffer(34962,buffers.uv);_gl.bufferData(34962,object.uvArray,35048);bindingStates.enableAttribute(programAttributes.uv.location);_gl.vertexAttribPointer(programAttributes.uv.location,2,5126,false,0,0);}if(object.hasColors){_gl.bindBuffer(34962,buffers.color);_gl.bufferData(34962,object.colorArray,35048);bindingStates.enableAttribute(programAttributes.color.location);_gl.vertexAttribPointer(programAttributes.color.location,3,5126,false,0,0);}bindingStates.disableUnusedAttributes();_gl.drawArrays(4,0,object.count);object.count=0;};this.renderBufferDirect=function(camera,scene,geometry,material,object,group){if(scene===null)scene=_emptyScene;// renderBufferDirect second parameter used to be fog (could be null)
  var frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;var program=setProgram(camera,scene,geometry,material,object);state.setMaterial(material,frontFaceCW);//
  var index=geometry.index;var position=geometry.attributes.position;//
  if(index===null){if(position===undefined||position.count===0)return;}else if(index.count===0){return;}//
  var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}bindingStates.setup(object,material,program,geometry,index);var attribute;var renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}//
  var dataCount=index!==null?index.count:position.count;var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
  if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(1);}else {renderer.setMode(4);}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
  state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(1);}else if(object.isLineLoop){renderer.setMode(2);}else {renderer.setMode(3);}}else if(object.isPoints){renderer.setMode(0);}else if(object.isSprite){renderer.setMode(4);}if(object.isInstancedMesh){renderer.renderInstances(drawStart,drawCount,object.count);}else if(geometry.isInstancedBufferGeometry){var instanceCount=Math.min(geometry.instanceCount,geometry._maxInstanceCount);renderer.renderInstances(drawStart,drawCount,instanceCount);}else {renderer.render(drawStart,drawCount);}};// Compile
  this.compile=function(scene,camera){currentRenderState=renderStates.get(scene);currentRenderState.init();renderStateStack.push(currentRenderState);scene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});currentRenderState.setupLights(_this.physicallyCorrectLights);scene.traverse(function(object){var material=object.material;if(material){if(Array.isArray(material)){for(var _i142=0;_i142<material.length;_i142++){var material2=material[_i142];getProgram(material2,scene,object);}}else {getProgram(material,scene,object);}}});renderStateStack.pop();currentRenderState=null;};// Animation Loop
  var onAnimationFrameCallback=null;function onAnimationFrame(time){if(onAnimationFrameCallback)onAnimationFrameCallback(time);}function onXRSessionStart(){animation.stop();}function onXRSessionEnd(){animation.start();}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);if(typeof window!=='undefined')animation.setContext(window);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;xr.setAnimationLoop(callback);callback===null?animation.stop():animation.start();};xr.addEventListener('sessionstart',onXRSessionStart);xr.addEventListener('sessionend',onXRSessionEnd);// Rendering
  this.render=function(scene,camera){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost===true)return;// update scene graph
  if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
  if(camera.parent===null)camera.updateMatrixWorld();if(xr.enabled===true&&xr.isPresenting===true){if(xr.cameraAutoUpdate===true)xr.updateCamera(camera);camera=xr.getCamera();// use XR camera for rendering
  }//
  if(scene.isScene===true)scene.onBeforeRender(_this,scene,camera,_currentRenderTarget);currentRenderState=renderStates.get(scene,renderStateStack.length);currentRenderState.init();renderStateStack.push(currentRenderState);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,renderListStack.length);currentRenderList.init();renderListStack.push(currentRenderList);projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort(_opaqueSort,_transparentSort);}//
  if(_clippingEnabled===true)clipping.beginShadows();var shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);if(_clippingEnabled===true)clipping.endShadows();//
  if(this.info.autoReset===true)this.info.reset();//
  background.render(currentRenderList,scene);// render scene
  currentRenderState.setupLights(_this.physicallyCorrectLights);if(camera.isArrayCamera){var cameras=camera.cameras;for(var _i143=0,l=cameras.length;_i143<l;_i143++){var camera2=cameras[_i143];renderScene(currentRenderList,scene,camera2,camera2.viewport);}}else {renderScene(currentRenderList,scene,camera);}//
  if(_currentRenderTarget!==null){// resolve multisample renderbuffers to a single-sample texture if necessary
  textures.updateMultisampleRenderTarget(_currentRenderTarget);// Generate mipmap if we're using any kind of mipmap filtering
  textures.updateRenderTargetMipmap(_currentRenderTarget);}//
  if(scene.isScene===true)scene.onAfterRender(_this,scene,camera);// Ensure depth buffer writing is enabled so it can be cleared on next render
  state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);// _gl.finish();
  bindingStates.resetDefaultState();_currentMaterialId=-1;_currentCamera=null;renderStateStack.pop();if(renderStateStack.length>0){currentRenderState=renderStateStack[renderStateStack.length-1];}else {currentRenderState=null;}renderListStack.pop();if(renderListStack.length>0){currentRenderList=renderListStack[renderListStack.length-1];}else {currentRenderList=null;}};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible){if(object.isGroup){groupOrder=object.renderOrder;}else if(object.isLOD){if(object.autoUpdate===true)object.update(camera);}else if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);}}}else if(object.isImmediateRenderObject){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}currentRenderList.push(object,null,object.material,groupOrder,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){// update skeleton only once in a frame
  if(object.skeleton.frame!==info.render.frame){object.skeleton.update();object.skeleton.frame=info.render.frame;}}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var _geometry2=objects.update(object);var _material=object.material;if(Array.isArray(_material)){var groups=_geometry2.groups;for(var _i144=0,l=groups.length;_i144<l;_i144++){var group=groups[_i144];var groupMaterial=_material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,_geometry2,groupMaterial,groupOrder,_vector3.z,group);}}}else if(_material.visible){currentRenderList.push(object,_geometry2,_material,groupOrder,_vector3.z,null);}}}}var children=object.children;for(var _i145=0,_l5=children.length;_i145<_l5;_i145++){projectObject(children[_i145],camera,groupOrder,sortObjects);}}function renderScene(currentRenderList,scene,camera,viewport){var opaqueObjects=currentRenderList.opaque;var transmissiveObjects=currentRenderList.transmissive;var transparentObjects=currentRenderList.transparent;currentRenderState.setupLightsView(camera);if(transmissiveObjects.length>0)renderTransmissionPass(opaqueObjects,scene,camera);if(viewport)state.viewport(_currentViewport.copy(viewport));if(opaqueObjects.length>0)renderObjects(opaqueObjects,scene,camera);if(transmissiveObjects.length>0)renderObjects(transmissiveObjects,scene,camera);if(transparentObjects.length>0)renderObjects(transparentObjects,scene,camera);}function renderTransmissionPass(opaqueObjects,scene,camera){if(_transmissionRenderTarget===null){var needsAntialias=_antialias===true&&capabilities.isWebGL2===true;var renderTargetType=needsAntialias?WebGLMultisampleRenderTarget:WebGLRenderTarget;_transmissionRenderTarget=new renderTargetType(1024,1024,{generateMipmaps:true,type:utils.convert(HalfFloatType)!==null?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,magFilter:NearestFilter,wrapS:ClampToEdgeWrapping,wrapT:ClampToEdgeWrapping});}var currentRenderTarget=_this.getRenderTarget();_this.setRenderTarget(_transmissionRenderTarget);_this.clear();// Turn off the features which can affect the frag color for opaque objects pass.
  // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
  var currentToneMapping=_this.toneMapping;_this.toneMapping=NoToneMapping;renderObjects(opaqueObjects,scene,camera);_this.toneMapping=currentToneMapping;textures.updateMultisampleRenderTarget(_transmissionRenderTarget);textures.updateRenderTargetMipmap(_transmissionRenderTarget);_this.setRenderTarget(currentRenderTarget);}function renderObjects(renderList,scene,camera){var overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;for(var _i146=0,l=renderList.length;_i146<l;_i146++){var renderItem=renderList[_i146];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===null?renderItem.material:overrideMaterial;var group=renderItem.group;if(object.layers.test(camera.layers)){renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);material.onBeforeRender(_this,scene,camera,geometry,object,group);if(object.isImmediateRenderObject){var program=setProgram(camera,scene,geometry,material,object);state.setMaterial(material);bindingStates.reset();renderObjectImmediate(object,program);}else {if(material.transparent===true&&material.side===DoubleSide$1){material.side=BackSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=FrontSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=DoubleSide$1;}else {_this.renderBufferDirect(camera,scene,geometry,material,object,group);}}object.onAfterRender(_this,scene,camera,geometry,material,group);}function getProgram(material,scene,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
  var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;var shadowsArray=currentRenderState.state.shadowsArray;var lightsStateVersion=lights.state.version;var parameters=programCache.getParameters(material,lights.state,shadowsArray,scene,object);var programCacheKey=programCache.getProgramCacheKey(parameters);var programs=materialProperties.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
  materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.fog=scene.fog;materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||materialProperties.environment);if(programs===undefined){// new material
  material.addEventListener('dispose',onMaterialDispose);programs=new Map();materialProperties.programs=programs;}var program=programs.get(programCacheKey);if(program!==undefined){// early out if program and light state is identical
  if(materialProperties.currentProgram===program&&materialProperties.lightsStateVersion===lightsStateVersion){updateCommonMaterialProperties(material,parameters);return program;}}else {parameters.uniforms=programCache.getUniforms(material);material.onBuild(parameters,_this);material.onBeforeCompile(parameters,_this);program=programCache.acquireProgram(parameters,programCacheKey);programs.set(programCacheKey,program);materialProperties.uniforms=parameters.uniforms;}var uniforms=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){uniforms.clippingPlanes=clipping.uniform;}updateCommonMaterialProperties(material,parameters);// store the light setup it was created for
  materialProperties.needsLights=materialNeedsLights(material);materialProperties.lightsStateVersion=lightsStateVersion;if(materialProperties.needsLights){// wire up the material to this renderer's lighting state
  uniforms.ambientLightColor.value=lights.state.ambient;uniforms.lightProbe.value=lights.state.probe;uniforms.directionalLights.value=lights.state.directional;uniforms.directionalLightShadows.value=lights.state.directionalShadow;uniforms.spotLights.value=lights.state.spot;uniforms.spotLightShadows.value=lights.state.spotShadow;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.ltc_1.value=lights.state.rectAreaLTC1;uniforms.ltc_2.value=lights.state.rectAreaLTC2;uniforms.pointLights.value=lights.state.point;uniforms.pointLightShadows.value=lights.state.pointShadow;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotShadowMatrix.value=lights.state.spotShadowMatrix;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
  }var progUniforms=program.getUniforms();var uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.currentProgram=program;materialProperties.uniformsList=uniformsList;return program;}function updateCommonMaterialProperties(material,parameters){var materialProperties=properties.get(material);materialProperties.outputEncoding=parameters.outputEncoding;materialProperties.instancing=parameters.instancing;materialProperties.skinning=parameters.skinning;materialProperties.morphTargets=parameters.morphTargets;materialProperties.morphNormals=parameters.morphNormals;materialProperties.morphTargetsCount=parameters.morphTargetsCount;materialProperties.numClippingPlanes=parameters.numClippingPlanes;materialProperties.numIntersection=parameters.numClipIntersection;materialProperties.vertexAlphas=parameters.vertexAlphas;materialProperties.vertexTangents=parameters.vertexTangents;}function setProgram(camera,scene,geometry,material,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
  textures.resetTextureUnits();var fog=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null;var encoding=_currentRenderTarget===null?_this.outputEncoding:_currentRenderTarget.texture.encoding;var envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);var vertexAlphas=material.vertexColors===true&&!!geometry&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4;var vertexTangents=!!material.normalMap&&!!geometry&&!!geometry.attributes.tangent;var morphTargets=!!geometry&&!!geometry.morphAttributes.position;var morphNormals=!!geometry&&!!geometry.morphAttributes.normal;var morphTargetsCount=!!geometry&&!!geometry.morphAttributes.position?geometry.morphAttributes.position.length:0;var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;if(_clippingEnabled===true){if(_localClippingEnabled===true||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
  // object instead of the material, once it becomes feasible
  // (#8465, #8379)
  clipping.setState(material,camera,useCache);}}//
  var needsProgramChange=false;if(material.version===materialProperties.__version){if(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version){needsProgramChange=true;}else if(materialProperties.outputEncoding!==encoding){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancing===false){needsProgramChange=true;}else if(!object.isInstancedMesh&&materialProperties.instancing===true){needsProgramChange=true;}else if(object.isSkinnedMesh&&materialProperties.skinning===false){needsProgramChange=true;}else if(!object.isSkinnedMesh&&materialProperties.skinning===true){needsProgramChange=true;}else if(materialProperties.envMap!==envMap){needsProgramChange=true;}else if(material.fog&&materialProperties.fog!==fog){needsProgramChange=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==clipping.numPlanes||materialProperties.numIntersection!==clipping.numIntersection)){needsProgramChange=true;}else if(materialProperties.vertexAlphas!==vertexAlphas){needsProgramChange=true;}else if(materialProperties.vertexTangents!==vertexTangents){needsProgramChange=true;}else if(materialProperties.morphTargets!==morphTargets){needsProgramChange=true;}else if(materialProperties.morphNormals!==morphNormals){needsProgramChange=true;}else if(capabilities.isWebGL2===true&&materialProperties.morphTargetsCount!==morphTargetsCount){needsProgramChange=true;}}else {needsProgramChange=true;materialProperties.__version=material.version;}//
  var program=materialProperties.currentProgram;if(needsProgramChange===true){program=getProgram(material,scene,object);}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||_currentCamera!==camera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(_currentCamera!==camera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
  // now, in case this material supports lights - or later, when
  // the next material that does gets activated:
  refreshMaterial=true;// set to true on material change
  refreshLights=true;// remains set until update done
  }// load material specific uniforms
  // (shader material also gets them for the sake of genericity)
  if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial){p_uniforms.setValue(_gl,'isOrthographic',camera.isOrthographicCamera===true);}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.isShadowMaterial||object.isSkinnedMesh){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}}// skinning and morph target uniforms must be set even if material didn't change
  // auto-setting of texture unit for bone and morph texture must go before other textures
  // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
  if(object.isSkinnedMesh){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){if(capabilities.floatVertexTextures){if(skeleton.boneTexture===null)skeleton.computeBoneTexture();p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else {p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(!!geometry&&(geometry.morphAttributes.position!==undefined||geometry.morphAttributes.normal!==undefined)){morphtargets.update(object,geometry,material,program);}if(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow){materialProperties.receiveShadow=object.receiveShadow;p_uniforms.setValue(_gl,'receiveShadow',object.receiveShadow);}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);if(materialProperties.needsLights){// the current material requires lighting info
  // note: all lighting uniforms are always set correctly
  // they simply reference the renderer's state for their
  // values
  //
  // use the current material's .needsUpdate flags to set
  // the GL state when required
  markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
  if(fog&&material.fog){materials.refreshFogUniforms(m_uniforms,fog);}materials.refreshMaterialUniforms(m_uniforms,material,_pixelRatio,_height,_transmissionRenderTarget);WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);material.uniformsNeedUpdate=false;}if(material.isSpriteMaterial){p_uniforms.setValue(_gl,'center',object.center);}// common matrices
  p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
  function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.lightProbe.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.directionalLightShadows.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.pointLightShadows.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.spotLightShadows.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===true;}this.getActiveCubeFace=function(){return _currentActiveCubeFace;};this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel;};this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget){var activeCubeFace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var activeMipmapLevel=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var framebuffer=null;var isCube=false;var isRenderTarget3D=false;if(renderTarget){var texture=renderTarget.texture;if(texture.isDataTexture3D||texture.isDataTexture2DArray){isRenderTarget3D=true;}var __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget){framebuffer=__webglFramebuffer[activeCubeFace];isCube=true;}else if(renderTarget.isWebGLMultisampleRenderTarget){framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;}else {framebuffer=__webglFramebuffer;}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else {_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();_currentScissorTest=_scissorTest;}var framebufferBound=state.bindFramebuffer(36160,framebuffer);if(framebufferBound&&capabilities.drawBuffers){var needsUpdate=false;if(renderTarget){if(renderTarget.isWebGLMultipleRenderTargets){var _textures2=renderTarget.texture;if(_currentDrawBuffers.length!==_textures2.length||_currentDrawBuffers[0]!==36064){for(var _i147=0,il=_textures2.length;_i147<il;_i147++){_currentDrawBuffers[_i147]=36064+_i147;}_currentDrawBuffers.length=_textures2.length;needsUpdate=true;}}else {if(_currentDrawBuffers.length!==1||_currentDrawBuffers[0]!==36064){_currentDrawBuffers[0]=36064;_currentDrawBuffers.length=1;needsUpdate=true;}}}else {if(_currentDrawBuffers.length!==1||_currentDrawBuffers[0]!==1029){_currentDrawBuffers[0]=1029;_currentDrawBuffers.length=1;needsUpdate=true;}}if(needsUpdate){if(capabilities.isWebGL2){_gl.drawBuffers(_currentDrawBuffers);}else {extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);}}}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(36160,36064,34069+activeCubeFace,textureProperties.__webglTexture,activeMipmapLevel);}else if(isRenderTarget3D){var _textureProperties=properties.get(renderTarget.texture);var layer=activeCubeFace||0;_gl.framebufferTextureLayer(36160,36064,_textureProperties.__webglTexture,activeMipmapLevel||0,layer);}_currentMaterialId=-1;// reset current material to ensure correct uniform bindings
  };this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){state.bindFramebuffer(36160,framebuffer);try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(35739)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}var halfFloatSupportedByExt=textureType===HalfFloatType&&(extensions.has('EXT_color_buffer_half_float')||capabilities.isWebGL2&&extensions.has('EXT_color_buffer_float'));if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(35738)&&// Edge and Chrome Mac < 52 (#9513)
  !(textureType===FloatType&&(capabilities.isWebGL2||extensions.has('OES_texture_float')||extensions.has('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
  !halfFloatSupportedByExt){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(36160)===36053){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
  if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}else {console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{// restore framebuffer of current render target if necessary
  var _framebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(36160,_framebuffer);}}};this.copyFramebufferToTexture=function(position,texture){var level=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var levelScale=Math.pow(2,-level);var width=Math.floor(texture.image.width*levelScale);var height=Math.floor(texture.image.height*levelScale);var glFormat=utils.convert(texture.format);if(capabilities.isWebGL2){// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
  // Not needed in Chrome 93+
  if(glFormat===6407)glFormat=32849;if(glFormat===6408)glFormat=32856;}textures.setTexture2D(texture,0);_gl.copyTexImage2D(3553,level,glFormat,position.x,position.y,width,height,0);state.unbindTexture();};this.copyTextureToTexture=function(position,srcTexture,dstTexture){var level=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var width=srcTexture.image.width;var height=srcTexture.image.height;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);textures.setTexture2D(dstTexture,0);// As another texture upload may have changed pixelStorei
  // parameters, make sure they are correct for the dstTexture
  _gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);if(srcTexture.isDataTexture){_gl.texSubImage2D(3553,level,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data);}else {if(srcTexture.isCompressedTexture){_gl.compressedTexSubImage2D(3553,level,position.x,position.y,srcTexture.mipmaps[0].width,srcTexture.mipmaps[0].height,glFormat,srcTexture.mipmaps[0].data);}else {_gl.texSubImage2D(3553,level,position.x,position.y,glFormat,glType,srcTexture.image);}}// Generate mipmaps only when copying level 0
  if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(3553);state.unbindTexture();};this.copyTextureToTexture3D=function(sourceBox,position,srcTexture,dstTexture){var level=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;if(_this.isWebGL1Renderer){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');return;}var width=sourceBox.max.x-sourceBox.min.x+1;var height=sourceBox.max.y-sourceBox.min.y+1;var depth=sourceBox.max.z-sourceBox.min.z+1;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);var glTarget;if(dstTexture.isDataTexture3D){textures.setTexture3D(dstTexture,0);glTarget=32879;}else if(dstTexture.isDataTexture2DArray){textures.setTexture2DArray(dstTexture,0);glTarget=35866;}else {console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');return;}_gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);var unpackRowLen=_gl.getParameter(3314);var unpackImageHeight=_gl.getParameter(32878);var unpackSkipPixels=_gl.getParameter(3316);var unpackSkipRows=_gl.getParameter(3315);var unpackSkipImages=_gl.getParameter(32877);var image=srcTexture.isCompressedTexture?srcTexture.mipmaps[0]:srcTexture.image;_gl.pixelStorei(3314,image.width);_gl.pixelStorei(32878,image.height);_gl.pixelStorei(3316,sourceBox.min.x);_gl.pixelStorei(3315,sourceBox.min.y);_gl.pixelStorei(32877,sourceBox.min.z);if(srcTexture.isDataTexture||srcTexture.isDataTexture3D){_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image.data);}else {if(srcTexture.isCompressedTexture){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');_gl.compressedTexSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,image.data);}else {_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image);}}_gl.pixelStorei(3314,unpackRowLen);_gl.pixelStorei(32878,unpackImageHeight);_gl.pixelStorei(3316,unpackSkipPixels);_gl.pixelStorei(3315,unpackSkipRows);_gl.pixelStorei(32877,unpackSkipImages);// Generate mipmaps only when copying level 0
  if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(glTarget);state.unbindTexture();};this.initTexture=function(texture){textures.setTexture2D(texture,0);state.unbindTexture();};this.resetState=function(){_currentActiveCubeFace=0;_currentActiveMipmapLevel=0;_currentRenderTarget=null;state.reset();bindingStates.reset();};if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));// eslint-disable-line no-undef
  }}var WebGL1Renderer=/*#__PURE__*/function(_WebGLRenderer){_inherits(WebGL1Renderer,_WebGLRenderer);var _super37=_createSuper(WebGL1Renderer);function WebGL1Renderer(){_classCallCheck(this,WebGL1Renderer);return _super37.apply(this,arguments);}return _createClass(WebGL1Renderer);}(WebGLRenderer);WebGL1Renderer.prototype.isWebGL1Renderer=true;var Scene$1=/*#__PURE__*/function(_Object3D5){_inherits(Scene,_Object3D5);var _super38=_createSuper(Scene);function Scene(){var _this28;_classCallCheck(this,Scene);_this28=_super38.call(this);_this28.type='Scene';_this28.background=null;_this28.environment=null;_this28.fog=null;_this28.overrideMaterial=null;_this28.autoUpdate=true;// checked by the renderer
  if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:_assertThisInitialized(_this28)}));// eslint-disable-line no-undef
  }return _this28;}_createClass(Scene,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(Scene.prototype),"copy",this).call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.environment!==null)this.environment=source.environment.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(Scene.prototype),"toJSON",this).call(this,meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}}]);return Scene;}(Object3D$1);Scene$1.prototype.isScene=true;var InterleavedBuffer=/*#__PURE__*/function(){function InterleavedBuffer(array,stride){_classCallCheck(this,InterleavedBuffer);this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;this.uuid=generateUUID();}_createClass(InterleavedBuffer,[{key:"onUploadCallback",value:function onUploadCallback(){}},{key:"needsUpdate",set:function set(value){if(value===true)this.version++;}},{key:"setUsage",value:function setUsage(value){this.usage=value;return this;}},{key:"copy",value:function copy(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.usage=source.usage;return this;}},{key:"copyAt",value:function copyAt(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(var _i148=0,l=this.stride;_i148<l;_i148++){this.array[index1+_i148]=attribute.array[index2+_i148];}return this;}},{key:"set",value:function set(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.array.set(value,offset);return this;}},{key:"clone",value:function clone(data){if(data.arrayBuffers===undefined){data.arrayBuffers={};}if(this.array.buffer._uuid===undefined){this.array.buffer._uuid=generateUUID();}if(data.arrayBuffers[this.array.buffer._uuid]===undefined){data.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer;}var array=new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);var ib=new this.constructor(array,this.stride);ib.setUsage(this.usage);return ib;}},{key:"onUpload",value:function onUpload(callback){this.onUploadCallback=callback;return this;}},{key:"toJSON",value:function toJSON(data){if(data.arrayBuffers===undefined){data.arrayBuffers={};}// generate UUID for array buffer if necessary
  if(this.array.buffer._uuid===undefined){this.array.buffer._uuid=generateUUID();}if(data.arrayBuffers[this.array.buffer._uuid]===undefined){data.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer));}//
  return {uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride};}}]);return InterleavedBuffer;}();InterleavedBuffer.prototype.isInterleavedBuffer=true;var _vector$6=/*@__PURE__*/new Vector3();var InterleavedBufferAttribute=/*#__PURE__*/function(){function InterleavedBufferAttribute(interleavedBuffer,itemSize,offset){var normalized=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;_classCallCheck(this,InterleavedBufferAttribute);this.name='';this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}_createClass(InterleavedBufferAttribute,[{key:"count",get:function get(){return this.data.count;}},{key:"array",get:function get(){return this.data.array;}},{key:"needsUpdate",set:function set(value){this.data.needsUpdate=value;}},{key:"applyMatrix4",value:function applyMatrix4(m){for(var _i149=0,l=this.data.count;_i149<l;_i149++){_vector$6.x=this.getX(_i149);_vector$6.y=this.getY(_i149);_vector$6.z=this.getZ(_i149);_vector$6.applyMatrix4(m);this.setXYZ(_i149,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}},{key:"applyNormalMatrix",value:function applyNormalMatrix(m){for(var _i150=0,l=this.count;_i150<l;_i150++){_vector$6.x=this.getX(_i150);_vector$6.y=this.getY(_i150);_vector$6.z=this.getZ(_i150);_vector$6.applyNormalMatrix(m);this.setXYZ(_i150,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}},{key:"transformDirection",value:function transformDirection(m){for(var _i151=0,l=this.count;_i151<l;_i151++){_vector$6.x=this.getX(_i151);_vector$6.y=this.getY(_i151);_vector$6.z=this.getZ(_i151);_vector$6.transformDirection(m);this.setXYZ(_i151,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}},{key:"setX",value:function setX(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;}},{key:"setY",value:function setY(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;}},{key:"setZ",value:function setZ(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;}},{key:"setW",value:function setW(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;}},{key:"getX",value:function getX(index){return this.data.array[index*this.data.stride+this.offset];}},{key:"getY",value:function getY(index){return this.data.array[index*this.data.stride+this.offset+1];}},{key:"getZ",value:function getZ(index){return this.data.array[index*this.data.stride+this.offset+2];}},{key:"getW",value:function getW(index){return this.data.array[index*this.data.stride+this.offset+3];}},{key:"setXY",value:function setXY(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;}},{key:"setXYZ",value:function setXYZ(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;}},{key:"setXYZW",value:function setXYZW(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}},{key:"clone",value:function clone(data){if(data===undefined){console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');var array=[];for(var _i152=0;_i152<this.count;_i152++){var index=_i152*this.data.stride+this.offset;for(var j=0;j<this.itemSize;j++){array.push(this.data.array[index+j]);}}return new BufferAttribute(new this.array.constructor(array),this.itemSize,this.normalized);}else {if(data.interleavedBuffers===undefined){data.interleavedBuffers={};}if(data.interleavedBuffers[this.data.uuid]===undefined){data.interleavedBuffers[this.data.uuid]=this.data.clone(data);}return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);}}},{key:"toJSON",value:function toJSON(data){if(data===undefined){console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');var array=[];for(var _i153=0;_i153<this.count;_i153++){var index=_i153*this.data.stride+this.offset;for(var j=0;j<this.itemSize;j++){array.push(this.data.array[index+j]);}}// deinterleave data and save it as an ordinary buffer attribute for now
  return {itemSize:this.itemSize,type:this.array.constructor.name,array:array,normalized:this.normalized};}else {// save as true interlaved attribtue
  if(data.interleavedBuffers===undefined){data.interleavedBuffers={};}if(data.interleavedBuffers[this.data.uuid]===undefined){data.interleavedBuffers[this.data.uuid]=this.data.toJSON(data);}return {isInterleavedBufferAttribute:true,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};}}}]);return InterleavedBufferAttribute;}();InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute=true;/**
   * parameters = {
   *  color: <hex>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *  rotation: <float>,
   *  sizeAttenuation: <bool>
   * }
   */var SpriteMaterial=/*#__PURE__*/function(_Material5){_inherits(SpriteMaterial,_Material5);var _super39=_createSuper(SpriteMaterial);function SpriteMaterial(parameters){var _this29;_classCallCheck(this,SpriteMaterial);_this29=_super39.call(this);_this29.type='SpriteMaterial';_this29.color=new Color$2(0xffffff);_this29.map=null;_this29.alphaMap=null;_this29.rotation=0;_this29.sizeAttenuation=true;_this29.transparent=true;_this29.setValues(parameters);return _this29;}_createClass(SpriteMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(SpriteMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.rotation=source.rotation;this.sizeAttenuation=source.sizeAttenuation;return this;}}]);return SpriteMaterial;}(Material$1);SpriteMaterial.prototype.isSpriteMaterial=true;var _geometry$2;var _intersectPoint=/*@__PURE__*/new Vector3();var _worldScale=/*@__PURE__*/new Vector3();var _mvPosition=/*@__PURE__*/new Vector3();var _alignedPosition=/*@__PURE__*/new Vector2();var _rotatedPosition=/*@__PURE__*/new Vector2();var _viewWorldMatrix=/*@__PURE__*/new Matrix4$1();var _vA$2=/*@__PURE__*/new Vector3();var _vB$2=/*@__PURE__*/new Vector3();var _vC$2=/*@__PURE__*/new Vector3();var _uvA=/*@__PURE__*/new Vector2();var _uvB=/*@__PURE__*/new Vector2();var _uvC=/*@__PURE__*/new Vector2();var Sprite=/*#__PURE__*/function(_Object3D6){_inherits(Sprite,_Object3D6);var _super40=_createSuper(Sprite);function Sprite(material){var _this30;_classCallCheck(this,Sprite);_this30=_super40.call(this);_this30.type='Sprite';if(_geometry$2===undefined){_geometry$2=new BufferGeometry();var float32Array=new Float32Array([-0.5,-0.5,0,0,0,0.5,-0.5,0,1,0,0.5,0.5,0,1,1,-0.5,0.5,0,0,1]);var interleavedBuffer=new InterleavedBuffer(float32Array,5);_geometry$2.setIndex([0,1,2,0,2,3]);_geometry$2.setAttribute('position',new InterleavedBufferAttribute(interleavedBuffer,3,0,false));_geometry$2.setAttribute('uv',new InterleavedBufferAttribute(interleavedBuffer,2,3,false));}_this30.geometry=_geometry$2;_this30.material=material!==undefined?material:new SpriteMaterial();_this30.center=new Vector2(0.5,0.5);return _this30;}_createClass(Sprite,[{key:"raycast",value:function raycast(raycaster,intersects){if(raycaster.camera===null){console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');}_worldScale.setFromMatrixScale(this.matrixWorld);_viewWorldMatrix.copy(raycaster.camera.matrixWorld);this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse,this.matrixWorld);_mvPosition.setFromMatrixPosition(this.modelViewMatrix);if(raycaster.camera.isPerspectiveCamera&&this.material.sizeAttenuation===false){_worldScale.multiplyScalar(-_mvPosition.z);}var rotation=this.material.rotation;var sin,cos;if(rotation!==0){cos=Math.cos(rotation);sin=Math.sin(rotation);}var center=this.center;transformVertex(_vA$2.set(-0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vB$2.set(0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vC$2.set(0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvA.set(0,0);_uvB.set(1,0);_uvC.set(1,1);// check first triangle
  var intersect=raycaster.ray.intersectTriangle(_vA$2,_vB$2,_vC$2,false,_intersectPoint);if(intersect===null){// check second triangle
  transformVertex(_vB$2.set(-0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvB.set(0,1);intersect=raycaster.ray.intersectTriangle(_vA$2,_vC$2,_vB$2,false,_intersectPoint);if(intersect===null){return;}}var distance=raycaster.ray.origin.distanceTo(_intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:_intersectPoint.clone(),uv:Triangle$1.getUV(_intersectPoint,_vA$2,_vB$2,_vC$2,_uvA,_uvB,_uvC,new Vector2()),face:null,object:this});}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(Sprite.prototype),"copy",this).call(this,source);if(source.center!==undefined)this.center.copy(source.center);this.material=source.material;return this;}}]);return Sprite;}(Object3D$1);Sprite.prototype.isSprite=true;function transformVertex(vertexPosition,mvPosition,center,scale,sin,cos){// compute position in camera space
  _alignedPosition.subVectors(vertexPosition,center).addScalar(0.5).multiply(scale);// to check if rotation is not zero
  if(sin!==undefined){_rotatedPosition.x=cos*_alignedPosition.x-sin*_alignedPosition.y;_rotatedPosition.y=sin*_alignedPosition.x+cos*_alignedPosition.y;}else {_rotatedPosition.copy(_alignedPosition);}vertexPosition.copy(mvPosition);vertexPosition.x+=_rotatedPosition.x;vertexPosition.y+=_rotatedPosition.y;// transform to world space
  vertexPosition.applyMatrix4(_viewWorldMatrix);}var _basePosition=/*@__PURE__*/new Vector3();var _skinIndex=/*@__PURE__*/new Vector4();var _skinWeight=/*@__PURE__*/new Vector4();var _vector$5=/*@__PURE__*/new Vector3();var _matrix=/*@__PURE__*/new Matrix4$1();var SkinnedMesh=/*#__PURE__*/function(_Mesh){_inherits(SkinnedMesh,_Mesh);var _super42=_createSuper(SkinnedMesh);function SkinnedMesh(geometry,material){var _this32;_classCallCheck(this,SkinnedMesh);_this32=_super42.call(this,geometry,material);_this32.type='SkinnedMesh';_this32.bindMode='attached';_this32.bindMatrix=new Matrix4$1();_this32.bindMatrixInverse=new Matrix4$1();return _this32;}_createClass(SkinnedMesh,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(SkinnedMesh.prototype),"copy",this).call(this,source);this.bindMode=source.bindMode;this.bindMatrix.copy(source.bindMatrix);this.bindMatrixInverse.copy(source.bindMatrixInverse);this.skeleton=source.skeleton;return this;}},{key:"bind",value:function bind(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.copy(bindMatrix).invert();}},{key:"pose",value:function pose(){this.skeleton.pose();}},{key:"normalizeSkinWeights",value:function normalizeSkinWeights(){var vector=new Vector4();var skinWeight=this.geometry.attributes.skinWeight;for(var _i158=0,l=skinWeight.count;_i158<l;_i158++){vector.x=skinWeight.getX(_i158);vector.y=skinWeight.getY(_i158);vector.z=skinWeight.getZ(_i158);vector.w=skinWeight.getW(_i158);var scale=1.0/vector.manhattanLength();if(scale!==Infinity){vector.multiplyScalar(scale);}else {vector.set(1,0,0,0);// do something reasonable
  }skinWeight.setXYZW(_i158,vector.x,vector.y,vector.z,vector.w);}}},{key:"updateMatrixWorld",value:function updateMatrixWorld(force){_get(_getPrototypeOf(SkinnedMesh.prototype),"updateMatrixWorld",this).call(this,force);if(this.bindMode==='attached'){this.bindMatrixInverse.copy(this.matrixWorld).invert();}else if(this.bindMode==='detached'){this.bindMatrixInverse.copy(this.bindMatrix).invert();}else {console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);}}},{key:"boneTransform",value:function boneTransform(index,target){var skeleton=this.skeleton;var geometry=this.geometry;_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex,index);_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight,index);_basePosition.copy(target).applyMatrix4(this.bindMatrix);target.set(0,0,0);for(var _i159=0;_i159<4;_i159++){var weight=_skinWeight.getComponent(_i159);if(weight!==0){var boneIndex=_skinIndex.getComponent(_i159);_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld,skeleton.boneInverses[boneIndex]);target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix),weight);}}return target.applyMatrix4(this.bindMatrixInverse);}}]);return SkinnedMesh;}(Mesh);SkinnedMesh.prototype.isSkinnedMesh=true;var Bone=/*#__PURE__*/function(_Object3D8){_inherits(Bone,_Object3D8);var _super43=_createSuper(Bone);function Bone(){var _this33;_classCallCheck(this,Bone);_this33=_super43.call(this);_this33.type='Bone';return _this33;}return _createClass(Bone);}(Object3D$1);Bone.prototype.isBone=true;var DataTexture=/*#__PURE__*/function(_Texture4){_inherits(DataTexture,_Texture4);var _super44=_createSuper(DataTexture);function DataTexture(){var _this34;var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var format=arguments.length>3?arguments[3]:undefined;var type=arguments.length>4?arguments[4]:undefined;var mapping=arguments.length>5?arguments[5]:undefined;var wrapS=arguments.length>6?arguments[6]:undefined;var wrapT=arguments.length>7?arguments[7]:undefined;var magFilter=arguments.length>8&&arguments[8]!==undefined?arguments[8]:NearestFilter;var minFilter=arguments.length>9&&arguments[9]!==undefined?arguments[9]:NearestFilter;var anisotropy=arguments.length>10?arguments[10]:undefined;var encoding=arguments.length>11?arguments[11]:undefined;_classCallCheck(this,DataTexture);_this34=_super44.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);_this34.image={data:data,width:width,height:height};_this34.magFilter=magFilter;_this34.minFilter=minFilter;_this34.generateMipmaps=false;_this34.flipY=false;_this34.unpackAlignment=1;_this34.needsUpdate=true;return _this34;}return _createClass(DataTexture);}(Texture);DataTexture.prototype.isDataTexture=true;var _offsetMatrix=/*@__PURE__*/new Matrix4$1();var _identityMatrix=/*@__PURE__*/new Matrix4$1();var Skeleton=/*#__PURE__*/function(){function Skeleton(){var bones=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var boneInverses=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];_classCallCheck(this,Skeleton);this.uuid=generateUUID();this.bones=bones.slice(0);this.boneInverses=boneInverses;this.boneMatrices=null;this.boneTexture=null;this.boneTextureSize=0;this.frame=-1;this.init();}_createClass(Skeleton,[{key:"init",value:function init(){var bones=this.bones;var boneInverses=this.boneInverses;this.boneMatrices=new Float32Array(bones.length*16);// calculate inverse bone matrices if necessary
  if(boneInverses.length===0){this.calculateInverses();}else {// handle special case
  if(bones.length!==boneInverses.length){console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');this.boneInverses=[];for(var _i160=0,il=this.bones.length;_i160<il;_i160++){this.boneInverses.push(new Matrix4$1());}}}}},{key:"calculateInverses",value:function calculateInverses(){this.boneInverses.length=0;for(var _i161=0,il=this.bones.length;_i161<il;_i161++){var inverse=new Matrix4$1();if(this.bones[_i161]){inverse.copy(this.bones[_i161].matrixWorld).invert();}this.boneInverses.push(inverse);}}},{key:"pose",value:function pose(){// recover the bind-time world matrices
  for(var _i162=0,il=this.bones.length;_i162<il;_i162++){var bone=this.bones[_i162];if(bone){bone.matrixWorld.copy(this.boneInverses[_i162]).invert();}}// compute the local matrices, positions, rotations and scales
  for(var _i163=0,_il12=this.bones.length;_i163<_il12;_i163++){var _bone=this.bones[_i163];if(_bone){if(_bone.parent&&_bone.parent.isBone){_bone.matrix.copy(_bone.parent.matrixWorld).invert();_bone.matrix.multiply(_bone.matrixWorld);}else {_bone.matrix.copy(_bone.matrixWorld);}_bone.matrix.decompose(_bone.position,_bone.quaternion,_bone.scale);}}}},{key:"update",value:function update(){var bones=this.bones;var boneInverses=this.boneInverses;var boneMatrices=this.boneMatrices;var boneTexture=this.boneTexture;// flatten bone matrices to array
  for(var _i164=0,il=bones.length;_i164<il;_i164++){// compute the offset between the current and the original transform
  var matrix=bones[_i164]?bones[_i164].matrixWorld:_identityMatrix;_offsetMatrix.multiplyMatrices(matrix,boneInverses[_i164]);_offsetMatrix.toArray(boneMatrices,_i164*16);}if(boneTexture!==null){boneTexture.needsUpdate=true;}}},{key:"clone",value:function clone(){return new Skeleton(this.bones,this.boneInverses);}},{key:"computeBoneTexture",value:function computeBoneTexture(){// layout (1 matrix = 4 pixels)
  //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
  var size=Math.sqrt(this.bones.length*4);// 4 pixels needed for 1 matrix
  size=ceilPowerOfTwo(size);size=Math.max(size,4);var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
  boneMatrices.set(this.boneMatrices);// copy current values
  var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);this.boneMatrices=boneMatrices;this.boneTexture=boneTexture;this.boneTextureSize=size;return this;}},{key:"getBoneByName",value:function getBoneByName(name){for(var _i165=0,il=this.bones.length;_i165<il;_i165++){var bone=this.bones[_i165];if(bone.name===name){return bone;}}return undefined;}},{key:"dispose",value:function dispose(){if(this.boneTexture!==null){this.boneTexture.dispose();this.boneTexture=null;}}},{key:"fromJSON",value:function fromJSON(json,bones){this.uuid=json.uuid;for(var _i166=0,l=json.bones.length;_i166<l;_i166++){var uuid=json.bones[_i166];var bone=bones[uuid];if(bone===undefined){console.warn('THREE.Skeleton: No bone found with UUID:',uuid);bone=new Bone();}this.bones.push(bone);this.boneInverses.push(new Matrix4$1().fromArray(json.boneInverses[_i166]));}this.init();return this;}},{key:"toJSON",value:function toJSON(){var data={metadata:{version:4.5,type:'Skeleton',generator:'Skeleton.toJSON'},bones:[],boneInverses:[]};data.uuid=this.uuid;var bones=this.bones;var boneInverses=this.boneInverses;for(var _i167=0,l=bones.length;_i167<l;_i167++){var bone=bones[_i167];data.bones.push(bone.uuid);var boneInverse=boneInverses[_i167];data.boneInverses.push(boneInverse.toArray());}return data;}}]);return Skeleton;}();/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */var LineBasicMaterial=/*#__PURE__*/function(_Material6){_inherits(LineBasicMaterial,_Material6);var _super47=_createSuper(LineBasicMaterial);function LineBasicMaterial(parameters){var _this37;_classCallCheck(this,LineBasicMaterial);_this37=_super47.call(this);_this37.type='LineBasicMaterial';_this37.color=new Color$2(0xffffff);_this37.linewidth=1;_this37.linecap='round';_this37.linejoin='round';_this37.setValues(parameters);return _this37;}_createClass(LineBasicMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(LineBasicMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;}}]);return LineBasicMaterial;}(Material$1);LineBasicMaterial.prototype.isLineBasicMaterial=true;var _start$1=/*@__PURE__*/new Vector3();var _end$1=/*@__PURE__*/new Vector3();var _inverseMatrix$1=/*@__PURE__*/new Matrix4$1();var _ray$1=/*@__PURE__*/new Ray();var _sphere$1=/*@__PURE__*/new Sphere();var Line=/*#__PURE__*/function(_Object3D9){_inherits(Line,_Object3D9);var _super48=_createSuper(Line);function Line(){var _this38;var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new BufferGeometry();var material=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new LineBasicMaterial();_classCallCheck(this,Line);_this38=_super48.call(this);_this38.type='Line';_this38.geometry=geometry;_this38.material=material;_this38.updateMorphTargets();return _this38;}_createClass(Line,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(Line.prototype),"copy",this).call(this,source);this.material=source.material;this.geometry=source.geometry;return this;}},{key:"computeLineDistances",value:function computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
  if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[0];for(var _i169=1,l=positionAttribute.count;_i169<l;_i169++){_start$1.fromBufferAttribute(positionAttribute,_i169-1);_end$1.fromBufferAttribute(positionAttribute,_i169);lineDistances[_i169]=lineDistances[_i169-1];lineDistances[_i169]+=_start$1.distanceTo(_end$1);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else {console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}return this;}},{key:"raycast",value:function raycast(raycaster,intersects){var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Line.threshold;var drawRange=geometry.drawRange;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$1.copy(geometry.boundingSphere);_sphere$1.applyMatrix4(matrixWorld);_sphere$1.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere$1)===false)return;//
  _inverseMatrix$1.copy(matrixWorld).invert();_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positionAttribute=attributes.position;if(index!==null){var start=Math.max(0,drawRange.start);var end=Math.min(index.count,drawRange.start+drawRange.count);for(var _i170=start,l=end-1;_i170<l;_i170+=step){var a=index.getX(_i170);var b=index.getX(_i170+1);vStart.fromBufferAttribute(positionAttribute,a);vEnd.fromBufferAttribute(positionAttribute,b);var distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
  var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
  // point: raycaster.ray.at( distance ),
  point:interSegment.clone().applyMatrix4(this.matrixWorld),index:_i170,face:null,faceIndex:null,object:this});}}else {var _start6=Math.max(0,drawRange.start);var _end5=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(var _i171=_start6,_l6=_end5-1;_i171<_l6;_i171+=step){vStart.fromBufferAttribute(positionAttribute,_i171);vEnd.fromBufferAttribute(positionAttribute,_i171+1);var _distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(_distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
  var _distance=raycaster.ray.origin.distanceTo(interRay);if(_distance<raycaster.near||_distance>raycaster.far)continue;intersects.push({distance:_distance,// What do we want? intersection point on the ray or on the segment??
  // point: raycaster.ray.at( distance ),
  point:interSegment.clone().applyMatrix4(this.matrixWorld),index:_i171,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}},{key:"updateMorphTargets",value:function updateMorphTargets(){var geometry=this.geometry;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphAttribute.length;m<ml;m++){var name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else {var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');}}}}]);return Line;}(Object3D$1);Line.prototype.isLine=true;var _start=/*@__PURE__*/new Vector3();var _end=/*@__PURE__*/new Vector3();var LineSegments=/*#__PURE__*/function(_Line){_inherits(LineSegments,_Line);var _super49=_createSuper(LineSegments);function LineSegments(geometry,material){var _this39;_classCallCheck(this,LineSegments);_this39=_super49.call(this,geometry,material);_this39.type='LineSegments';return _this39;}_createClass(LineSegments,[{key:"computeLineDistances",value:function computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
  if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[];for(var _i172=0,l=positionAttribute.count;_i172<l;_i172+=2){_start.fromBufferAttribute(positionAttribute,_i172);_end.fromBufferAttribute(positionAttribute,_i172+1);lineDistances[_i172]=_i172===0?0:lineDistances[_i172-1];lineDistances[_i172+1]=lineDistances[_i172]+_start.distanceTo(_end);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else {console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}return this;}}]);return LineSegments;}(Line);LineSegments.prototype.isLineSegments=true;var LineLoop=/*#__PURE__*/function(_Line2){_inherits(LineLoop,_Line2);var _super50=_createSuper(LineLoop);function LineLoop(geometry,material){var _this40;_classCallCheck(this,LineLoop);_this40=_super50.call(this,geometry,material);_this40.type='LineLoop';return _this40;}return _createClass(LineLoop);}(Line);LineLoop.prototype.isLineLoop=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   *
   * }
   */var PointsMaterial=/*#__PURE__*/function(_Material7){_inherits(PointsMaterial,_Material7);var _super51=_createSuper(PointsMaterial);function PointsMaterial(parameters){var _this41;_classCallCheck(this,PointsMaterial);_this41=_super51.call(this);_this41.type='PointsMaterial';_this41.color=new Color$2(0xffffff);_this41.map=null;_this41.alphaMap=null;_this41.size=1;_this41.sizeAttenuation=true;_this41.setValues(parameters);return _this41;}_createClass(PointsMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(PointsMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;}}]);return PointsMaterial;}(Material$1);PointsMaterial.prototype.isPointsMaterial=true;var _inverseMatrix=/*@__PURE__*/new Matrix4$1();var _ray=/*@__PURE__*/new Ray();var _sphere=/*@__PURE__*/new Sphere();var _position$2=/*@__PURE__*/new Vector3();var Points=/*#__PURE__*/function(_Object3D10){_inherits(Points,_Object3D10);var _super52=_createSuper(Points);function Points(){var _this42;var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new BufferGeometry();var material=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new PointsMaterial();_classCallCheck(this,Points);_this42=_super52.call(this);_this42.type='Points';_this42.geometry=geometry;_this42.material=material;_this42.updateMorphTargets();return _this42;}_createClass(Points,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(Points.prototype),"copy",this).call(this,source);this.material=source.material;this.geometry=source.geometry;return this;}},{key:"raycast",value:function raycast(raycaster,intersects){var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;var drawRange=geometry.drawRange;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere.copy(geometry.boundingSphere);_sphere.applyMatrix4(matrixWorld);_sphere.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere)===false)return;//
  _inverseMatrix.copy(matrixWorld).invert();_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positionAttribute=attributes.position;if(index!==null){var start=Math.max(0,drawRange.start);var end=Math.min(index.count,drawRange.start+drawRange.count);for(var _i173=start,il=end;_i173<il;_i173++){var a=index.getX(_i173);_position$2.fromBufferAttribute(positionAttribute,a);testPoint(_position$2,a,localThresholdSq,matrixWorld,raycaster,intersects,this);}}else {var _start7=Math.max(0,drawRange.start);var _end6=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(var _i174=_start7,l=_end6;_i174<l;_i174++){_position$2.fromBufferAttribute(positionAttribute,_i174);testPoint(_position$2,_i174,localThresholdSq,matrixWorld,raycaster,intersects,this);}}}else {console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}},{key:"updateMorphTargets",value:function updateMorphTargets(){var geometry=this.geometry;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphAttribute.length;m<ml;m++){var name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else {var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');}}}}]);return Points;}(Object3D$1);Points.prototype.isPoints=true;function testPoint(point,index,localThresholdSq,matrixWorld,raycaster,intersects,object){var rayPointDistanceSq=_ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){var intersectPoint=new Vector3();_ray.closestPointToPoint(point,intersectPoint);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint,index:index,face:null,object:object});}}var CompressedTexture=/*#__PURE__*/function(_Texture6){_inherits(CompressedTexture,_Texture6);var _super54=_createSuper(CompressedTexture);function CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){var _this44;_classCallCheck(this,CompressedTexture);_this44=_super54.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);_this44.image={width:width,height:height};_this44.mipmaps=mipmaps;// no flipping for cube textures
  // (also flipping doesn't work for compressed textures )
  _this44.flipY=false;// can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files
  _this44.generateMipmaps=false;return _this44;}return _createClass(CompressedTexture);}(Texture);CompressedTexture.prototype.isCompressedTexture=true;var CanvasTexture=/*#__PURE__*/function(_Texture7){_inherits(CanvasTexture,_Texture7);var _super55=_createSuper(CanvasTexture);function CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){var _this45;_classCallCheck(this,CanvasTexture);_this45=_super55.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);_this45.needsUpdate=true;return _this45;}return _createClass(CanvasTexture);}(Texture);CanvasTexture.prototype.isCanvasTexture=true;var DepthTexture=/*#__PURE__*/function(_Texture8){_inherits(DepthTexture,_Texture8);var _super56=_createSuper(DepthTexture);function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){var _this46;_classCallCheck(this,DepthTexture);format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;_this46=_super56.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);_this46.image={width:width,height:height};_this46.magFilter=magFilter!==undefined?magFilter:NearestFilter;_this46.minFilter=minFilter!==undefined?minFilter:NearestFilter;_this46.flipY=false;_this46.generateMipmaps=false;return _this46;}return _createClass(DepthTexture);}(Texture);DepthTexture.prototype.isDepthTexture=true;var CircleGeometry=/*#__PURE__*/function(_BufferGeometry3){_inherits(CircleGeometry,_BufferGeometry3);var _super57=_createSuper(CircleGeometry);function CircleGeometry(){var _this47;var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var segments=arguments.length>1&&arguments[1]!==undefined?arguments[1]:8;var thetaStart=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var thetaLength=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Math.PI*2;_classCallCheck(this,CircleGeometry);_this47=_super57.call(this);_this47.type='CircleGeometry';_this47.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};segments=Math.max(3,segments);// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var vertex=new Vector3();var uv=new Vector2();// center point
  vertices.push(0,0,0);normals.push(0,0,1);uvs.push(0.5,0.5);for(var s=0,_i175=3;s<=segments;s++,_i175+=3){var segment=thetaStart+s/segments*thetaLength;// vertex
  vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normals.push(0,0,1);// uvs
  uv.x=(vertices[_i175]/radius+1)/2;uv.y=(vertices[_i175+1]/radius+1)/2;uvs.push(uv.x,uv.y);}// indices
  for(var _i176=1;_i176<=segments;_i176++){indices.push(_i176,_i176+1,0);}// build geometry
  _this47.setIndex(indices);_this47.setAttribute('position',new Float32BufferAttribute(vertices,3));_this47.setAttribute('normal',new Float32BufferAttribute(normals,3));_this47.setAttribute('uv',new Float32BufferAttribute(uvs,2));return _this47;}_createClass(CircleGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new CircleGeometry(data.radius,data.segments,data.thetaStart,data.thetaLength);}}]);return CircleGeometry;}(BufferGeometry);var CylinderGeometry=/*#__PURE__*/function(_BufferGeometry4){_inherits(CylinderGeometry,_BufferGeometry4);var _super58=_createSuper(CylinderGeometry);function CylinderGeometry(){var _this48;var radiusTop=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var radiusBottom=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var radialSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:8;var heightSegments=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;var openEnded=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;var thetaStart=arguments.length>6&&arguments[6]!==undefined?arguments[6]:0;var thetaLength=arguments.length>7&&arguments[7]!==undefined?arguments[7]:Math.PI*2;_classCallCheck(this,CylinderGeometry);_this48=_super58.call(this);_this48.type='CylinderGeometry';_this48.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};var scope=_assertThisInitialized(_this48);radialSegments=Math.floor(radialSegments);heightSegments=Math.floor(heightSegments);// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var index=0;var indexArray=[];var halfHeight=height/2;var groupStart=0;// generate geometry
  generateTorso();if(openEnded===false){if(radiusTop>0)generateCap(true);if(radiusBottom>0)generateCap(false);}// build geometry
  _this48.setIndex(indices);_this48.setAttribute('position',new Float32BufferAttribute(vertices,3));_this48.setAttribute('normal',new Float32BufferAttribute(normals,3));_this48.setAttribute('uv',new Float32BufferAttribute(uvs,2));function generateTorso(){var normal=new Vector3();var vertex=new Vector3();var groupCount=0;// this will be used to calculate the normal
  var slope=(radiusBottom-radiusTop)/height;// generate vertices, normals and uvs
  for(var y=0;y<=heightSegments;y++){var indexRow=[];var v=y/heightSegments;// calculate the radius of the current row
  var radius=v*(radiusBottom-radiusTop)+radiusTop;for(var x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);// vertex
  vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normal.set(sinTheta,slope,cosTheta).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(u,1-v);// save index of vertex in respective row
  indexRow.push(index++);}// now save vertices of the row in our index array
  indexArray.push(indexRow);}// generate indices
  for(var _x4=0;_x4<radialSegments;_x4++){for(var _y2=0;_y2<heightSegments;_y2++){// we use the index array to access the correct indices
  var a=indexArray[_y2][_x4];var b=indexArray[_y2+1][_x4];var c=indexArray[_y2+1][_x4+1];var d=indexArray[_y2][_x4+1];// faces
  indices.push(a,b,d);indices.push(b,c,d);// update group counter
  groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,0);// calculate new start value for groups
  groupStart+=groupCount;}function generateCap(top){// save the index of the first center vertex
  var centerIndexStart=index;var uv=new Vector2();var vertex=new Vector3();var groupCount=0;var radius=top===true?radiusTop:radiusBottom;var sign=top===true?1:-1;// first we generate the center vertex data of the cap.
  // because the geometry needs one set of uvs per face,
  // we must generate a center vertex per face/segment
  for(var x=1;x<=radialSegments;x++){// vertex
  vertices.push(0,halfHeight*sign,0);// normal
  normals.push(0,sign,0);// uv
  uvs.push(0.5,0.5);// increase index
  index++;}// save the index of the last center vertex
  var centerIndexEnd=index;// now we generate the surrounding vertices, normals and uvs
  for(var _x5=0;_x5<=radialSegments;_x5++){var u=_x5/radialSegments;var theta=u*thetaLength+thetaStart;var cosTheta=Math.cos(theta);var sinTheta=Math.sin(theta);// vertex
  vertex.x=radius*sinTheta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normals.push(0,sign,0);// uv
  uv.x=cosTheta*0.5+0.5;uv.y=sinTheta*0.5*sign+0.5;uvs.push(uv.x,uv.y);// increase index
  index++;}// generate indices
  for(var _x6=0;_x6<radialSegments;_x6++){var c=centerIndexStart+_x6;var _i177=centerIndexEnd+_x6;if(top===true){// face top
  indices.push(_i177,_i177+1,c);}else {// face bottom
  indices.push(_i177+1,_i177,c);}groupCount+=3;}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,top===true?1:2);// calculate new start value for groups
  groupStart+=groupCount;}return _this48;}_createClass(CylinderGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new CylinderGeometry(data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);}}]);return CylinderGeometry;}(BufferGeometry);var ConeGeometry=/*#__PURE__*/function(_CylinderGeometry){_inherits(ConeGeometry,_CylinderGeometry);var _super59=_createSuper(ConeGeometry);function ConeGeometry(){var _this49;var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var radialSegments=arguments.length>2&&arguments[2]!==undefined?arguments[2]:8;var heightSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var openEnded=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var thetaStart=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;var thetaLength=arguments.length>6&&arguments[6]!==undefined?arguments[6]:Math.PI*2;_classCallCheck(this,ConeGeometry);_this49=_super59.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);_this49.type='ConeGeometry';_this49.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};return _this49;}_createClass(ConeGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new ConeGeometry(data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);}}]);return ConeGeometry;}(CylinderGeometry);var _v0=new Vector3();var _v1$1=new Vector3();var _normal=new Vector3();var _triangle=new Triangle$1();var EdgesGeometry=/*#__PURE__*/function(_BufferGeometry6){_inherits(EdgesGeometry,_BufferGeometry6);var _super62=_createSuper(EdgesGeometry);function EdgesGeometry(){var _this52;var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var thresholdAngle=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;_classCallCheck(this,EdgesGeometry);_this52=_super62.call(this);_this52.type='EdgesGeometry';_this52.parameters={geometry:geometry,thresholdAngle:thresholdAngle};if(geometry!==null){var precisionPoints=4;var precision=Math.pow(10,precisionPoints);var thresholdDot=Math.cos(DEG2RAD*thresholdAngle);var indexAttr=geometry.getIndex();var positionAttr=geometry.getAttribute('position');var indexCount=indexAttr?indexAttr.count:positionAttr.count;var indexArr=[0,0,0];var vertKeys=['a','b','c'];var hashes=new Array(3);var edgeData={};var vertices=[];for(var _i185=0;_i185<indexCount;_i185+=3){if(indexAttr){indexArr[0]=indexAttr.getX(_i185);indexArr[1]=indexAttr.getX(_i185+1);indexArr[2]=indexAttr.getX(_i185+2);}else {indexArr[0]=_i185;indexArr[1]=_i185+1;indexArr[2]=_i185+2;}var a=_triangle.a,b=_triangle.b,c=_triangle.c;a.fromBufferAttribute(positionAttr,indexArr[0]);b.fromBufferAttribute(positionAttr,indexArr[1]);c.fromBufferAttribute(positionAttr,indexArr[2]);_triangle.getNormal(_normal);// create hashes for the edge from the vertices
  hashes[0]="".concat(Math.round(a.x*precision),",").concat(Math.round(a.y*precision),",").concat(Math.round(a.z*precision));hashes[1]="".concat(Math.round(b.x*precision),",").concat(Math.round(b.y*precision),",").concat(Math.round(b.z*precision));hashes[2]="".concat(Math.round(c.x*precision),",").concat(Math.round(c.y*precision),",").concat(Math.round(c.z*precision));// skip degenerate triangles
  if(hashes[0]===hashes[1]||hashes[1]===hashes[2]||hashes[2]===hashes[0]){continue;}// iterate over every edge
  for(var j=0;j<3;j++){// get the first and next vertex making up the edge
  var jNext=(j+1)%3;var vecHash0=hashes[j];var vecHash1=hashes[jNext];var v0=_triangle[vertKeys[j]];var v1=_triangle[vertKeys[jNext]];var hash="".concat(vecHash0,"_").concat(vecHash1);var reverseHash="".concat(vecHash1,"_").concat(vecHash0);if(reverseHash in edgeData&&edgeData[reverseHash]){// if we found a sibling edge add it into the vertex array if
  // it meets the angle threshold and delete the edge from the map.
  if(_normal.dot(edgeData[reverseHash].normal)<=thresholdDot){vertices.push(v0.x,v0.y,v0.z);vertices.push(v1.x,v1.y,v1.z);}edgeData[reverseHash]=null;}else if(!(hash in edgeData)){// if we've already got an edge here then skip adding a new one
  edgeData[hash]={index0:indexArr[j],index1:indexArr[jNext],normal:_normal.clone()};}}}// iterate over all remaining, unmatched edges and add them to the vertex array
  for(var key in edgeData){if(edgeData[key]){var _edgeData$key=edgeData[key],index0=_edgeData$key.index0,index1=_edgeData$key.index1;_v0.fromBufferAttribute(positionAttr,index0);_v1$1.fromBufferAttribute(positionAttr,index1);vertices.push(_v0.x,_v0.y,_v0.z);vertices.push(_v1$1.x,_v1$1.y,_v1$1.z);}}_this52.setAttribute('position',new Float32BufferAttribute(vertices,3));}return _this52;}return _createClass(EdgesGeometry);}(BufferGeometry);/**
   * Extensible curve object.
   *
   * Some common of curve methods:
   * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
   * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/var Curve=/*#__PURE__*/function(){function Curve(){_classCallCheck(this,Curve);this.type='Curve';this.arcLengthDivisions=200;}// Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  _createClass(Curve,[{key:"getPoint",value:function getPoint(/* t, optionalTarget */){console.warn('THREE.Curve: .getPoint() not implemented.');return null;}// Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  },{key:"getPointAt",value:function getPointAt(u,optionalTarget){var t=this.getUtoTmapping(u);return this.getPoint(t,optionalTarget);}// Get sequence of points using getPoint( t )
  },{key:"getPoints",value:function getPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;}// Get sequence of points using getPointAt( u )
  },{key:"getSpacedPoints",value:function getSpacedPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;}// Get total curve arc length
  },{key:"getLength",value:function getLength(){var lengths=this.getLengths();return lengths[lengths.length-1];}// Get list of cumulative segment lengths
  },{key:"getLengths",value:function getLengths(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var sum=0;cache.push(0);for(var p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
  }},{key:"updateArcLengths",value:function updateArcLengths(){this.needsUpdate=true;this.getLengths();}// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  },{key:"getUtoTmapping",value:function getUtoTmapping(u,distance){var arcLengths=this.getLengths();var i=0;var il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
  if(distance){targetArcLength=distance;}else {targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
  var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
  comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else {high=i;break;// DONE
  }}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
  var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
  var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
  var t=(i+segmentFraction)/(il-1);return t;}// Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  },{key:"getTangent",value:function getTangent(t,optionalTarget){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
  if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var tangent=optionalTarget||(pt1.isVector2?new Vector2():new Vector3());tangent.copy(pt2).sub(pt1).normalize();return tangent;}},{key:"getTangentAt",value:function getTangentAt(u,optionalTarget){var t=this.getUtoTmapping(u);return this.getTangent(t,optionalTarget);}},{key:"computeFrenetFrames",value:function computeFrenetFrames(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
  var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4$1();// compute the tangent vectors for each segment on the curve
  for(var _i186=0;_i186<=segments;_i186++){var u=_i186/segments;tangents[_i186]=this.getTangentAt(u,new Vector3());}// select an initial normal vector perpendicular to the first tangent vector,
  // and in the direction of the minimum tangent xyz component
  normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
  for(var _i187=1;_i187<=segments;_i187++){normals[_i187]=normals[_i187-1].clone();binormals[_i187]=binormals[_i187-1].clone();vec.crossVectors(tangents[_i187-1],tangents[_i187]);if(vec.length()>Number.EPSILON){vec.normalize();var theta=Math.acos(clamp(tangents[_i187-1].dot(tangents[_i187]),-1,1));// clamp for floating pt errors
  normals[_i187].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[_i187].crossVectors(tangents[_i187],normals[_i187]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
  if(closed===true){var _theta=Math.acos(clamp(normals[0].dot(normals[segments]),-1,1));_theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){_theta=-_theta;}for(var _i188=1;_i188<=segments;_i188++){// twist a little...
  normals[_i188].applyMatrix4(mat.makeRotationAxis(tangents[_i188],_theta*_i188));binormals[_i188].crossVectors(tangents[_i188],normals[_i188]);}}return {tangents:tangents,normals:normals,binormals:binormals};}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){this.arcLengthDivisions=source.arcLengthDivisions;return this;}},{key:"toJSON",value:function toJSON(){var data={metadata:{version:4.5,type:'Curve',generator:'Curve.toJSON'}};data.arcLengthDivisions=this.arcLengthDivisions;data.type=this.type;return data;}},{key:"fromJSON",value:function fromJSON(json){this.arcLengthDivisions=json.arcLengthDivisions;return this;}}]);return Curve;}();var EllipseCurve=/*#__PURE__*/function(_Curve){_inherits(EllipseCurve,_Curve);var _super63=_createSuper(EllipseCurve);function EllipseCurve(){var _this53;var aX=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var aY=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var xRadius=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var yRadius=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var aStartAngle=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var aEndAngle=arguments.length>5&&arguments[5]!==undefined?arguments[5]:Math.PI*2;var aClockwise=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;var aRotation=arguments.length>7&&arguments[7]!==undefined?arguments[7]:0;_classCallCheck(this,EllipseCurve);_this53=_super63.call(this);_this53.type='EllipseCurve';_this53.aX=aX;_this53.aY=aY;_this53.xRadius=xRadius;_this53.yRadius=yRadius;_this53.aStartAngle=aStartAngle;_this53.aEndAngle=aEndAngle;_this53.aClockwise=aClockwise;_this53.aRotation=aRotation;return _this53;}_createClass(EllipseCurve,[{key:"getPoint",value:function getPoint(t,optionalTarget){var point=optionalTarget||new Vector2();var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
  while(deltaAngle<0)deltaAngle+=twoPi;while(deltaAngle>twoPi)deltaAngle-=twoPi;if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else {deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else {deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
  x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return point.set(x,y);}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(EllipseCurve.prototype),"copy",this).call(this,source);this.aX=source.aX;this.aY=source.aY;this.xRadius=source.xRadius;this.yRadius=source.yRadius;this.aStartAngle=source.aStartAngle;this.aEndAngle=source.aEndAngle;this.aClockwise=source.aClockwise;this.aRotation=source.aRotation;return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(EllipseCurve.prototype),"toJSON",this).call(this);data.aX=this.aX;data.aY=this.aY;data.xRadius=this.xRadius;data.yRadius=this.yRadius;data.aStartAngle=this.aStartAngle;data.aEndAngle=this.aEndAngle;data.aClockwise=this.aClockwise;data.aRotation=this.aRotation;return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(EllipseCurve.prototype),"fromJSON",this).call(this,json);this.aX=json.aX;this.aY=json.aY;this.xRadius=json.xRadius;this.yRadius=json.yRadius;this.aStartAngle=json.aStartAngle;this.aEndAngle=json.aEndAngle;this.aClockwise=json.aClockwise;this.aRotation=json.aRotation;return this;}}]);return EllipseCurve;}(Curve);EllipseCurve.prototype.isEllipseCurve=true;var ArcCurve=/*#__PURE__*/function(_EllipseCurve){_inherits(ArcCurve,_EllipseCurve);var _super64=_createSuper(ArcCurve);function ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var _this54;_classCallCheck(this,ArcCurve);_this54=_super64.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);_this54.type='ArcCurve';return _this54;}return _createClass(ArcCurve);}(EllipseCurve);ArcCurve.prototype.isArcCurve=true;/**
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */ /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
  	 * Compute coefficients for a cubic polynomial
  	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
  	 * such that
  	 *   p(0) = x0, p(1) = x1
  	 *  and
  	 *   p'(0) = t0, p'(1) = t1.
  	 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return {initCatmullRom:function initCatmullRom(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function initNonuniformCatmullRom(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
  var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
  t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function calc(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
  var tmp=new Vector3();var px=new CubicPoly(),py=new CubicPoly(),pz=new CubicPoly();var CatmullRomCurve3=/*#__PURE__*/function(_Curve2){_inherits(CatmullRomCurve3,_Curve2);var _super65=_createSuper(CatmullRomCurve3);function CatmullRomCurve3(){var _this55;var points=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var closed=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var curveType=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'centripetal';var tension=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0.5;_classCallCheck(this,CatmullRomCurve3);_this55=_super65.call(this);_this55.type='CatmullRomCurve3';_this55.points=points;_this55.closed=closed;_this55.curveType=curveType;_this55.tension=tension;return _this55;}_createClass(CatmullRomCurve3,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;var points=this.points;var l=points.length;var p=(l-(this.closed?0:1))*t;var intPoint=Math.floor(p);var weight=p-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l)+1)*l;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p3;// 4 points (p1 & p2 defined below)
  if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else {// extrapolate first point
  tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}var p1=points[intPoint%l];var p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else {// extrapolate last point
  tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.curveType==='centripetal'||this.curveType==='chordal'){// init Centripetal / Chordal Catmull-Rom
  var pow=this.curveType==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
  if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.curveType==='catmullrom'){px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,this.tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,this.tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,this.tension);}point.set(px.calc(weight),py.calc(weight),pz.calc(weight));return point;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(CatmullRomCurve3.prototype),"copy",this).call(this,source);this.points=[];for(var _i189=0,l=source.points.length;_i189<l;_i189++){var point=source.points[_i189];this.points.push(point.clone());}this.closed=source.closed;this.curveType=source.curveType;this.tension=source.tension;return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(CatmullRomCurve3.prototype),"toJSON",this).call(this);data.points=[];for(var _i190=0,l=this.points.length;_i190<l;_i190++){var point=this.points[_i190];data.points.push(point.toArray());}data.closed=this.closed;data.curveType=this.curveType;data.tension=this.tension;return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(CatmullRomCurve3.prototype),"fromJSON",this).call(this,json);this.points=[];for(var _i191=0,l=json.points.length;_i191<l;_i191++){var point=json.points[_i191];this.points.push(new Vector3().fromArray(point));}this.closed=json.closed;this.curveType=json.curveType;this.tension=json.tension;return this;}}]);return CatmullRomCurve3;}(Curve);CatmullRomCurve3.prototype.isCatmullRomCurve3=true;/**
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/Bézier_curve
   */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return (2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
  function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
  function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}var CubicBezierCurve=/*#__PURE__*/function(_Curve3){_inherits(CubicBezierCurve,_Curve3);var _super66=_createSuper(CubicBezierCurve);function CubicBezierCurve(){var _this56;var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector2();var v3=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Vector2();_classCallCheck(this,CubicBezierCurve);_this56=_super66.call(this);_this56.type='CubicBezierCurve';_this56.v0=v0;_this56.v1=v1;_this56.v2=v2;_this56.v3=v3;return _this56;}_createClass(CubicBezierCurve,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));return point;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(CubicBezierCurve.prototype),"copy",this).call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(CubicBezierCurve.prototype),"toJSON",this).call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(CubicBezierCurve.prototype),"fromJSON",this).call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;}}]);return CubicBezierCurve;}(Curve);CubicBezierCurve.prototype.isCubicBezierCurve=true;var CubicBezierCurve3=/*#__PURE__*/function(_Curve4){_inherits(CubicBezierCurve3,_Curve4);var _super67=_createSuper(CubicBezierCurve3);function CubicBezierCurve3(){var _this57;var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector3();var v3=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Vector3();_classCallCheck(this,CubicBezierCurve3);_this57=_super67.call(this);_this57.type='CubicBezierCurve3';_this57.v0=v0;_this57.v1=v1;_this57.v2=v2;_this57.v3=v3;return _this57;}_createClass(CubicBezierCurve3,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));return point;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(CubicBezierCurve3.prototype),"copy",this).call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(CubicBezierCurve3.prototype),"toJSON",this).call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(CubicBezierCurve3.prototype),"fromJSON",this).call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;}}]);return CubicBezierCurve3;}(Curve);CubicBezierCurve3.prototype.isCubicBezierCurve3=true;var LineCurve=/*#__PURE__*/function(_Curve5){_inherits(LineCurve,_Curve5);var _super68=_createSuper(LineCurve);function LineCurve(){var _this58;var v1=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();var v2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();_classCallCheck(this,LineCurve);_this58=_super68.call(this);_this58.type='LineCurve';_this58.v1=v1;_this58.v2=v2;return _this58;}_createClass(LineCurve,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;if(t===1){point.copy(this.v2);}else {point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;}// Line curve is linear, so we can overwrite default getPointAt
  },{key:"getPointAt",value:function getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget);}},{key:"getTangent",value:function getTangent(t,optionalTarget){var tangent=optionalTarget||new Vector2();tangent.copy(this.v2).sub(this.v1).normalize();return tangent;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(LineCurve.prototype),"copy",this).call(this,source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(LineCurve.prototype),"toJSON",this).call(this);data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(LineCurve.prototype),"fromJSON",this).call(this,json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}]);return LineCurve;}(Curve);LineCurve.prototype.isLineCurve=true;var LineCurve3=/*#__PURE__*/function(_Curve6){_inherits(LineCurve3,_Curve6);var _super69=_createSuper(LineCurve3);function LineCurve3(){var _this59;var v1=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var v2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();_classCallCheck(this,LineCurve3);_this59=_super69.call(this);_this59.type='LineCurve3';_this59.isLineCurve3=true;_this59.v1=v1;_this59.v2=v2;return _this59;}_createClass(LineCurve3,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;if(t===1){point.copy(this.v2);}else {point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;}// Line curve is linear, so we can overwrite default getPointAt
  },{key:"getPointAt",value:function getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget);}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(LineCurve3.prototype),"copy",this).call(this,source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(LineCurve3.prototype),"toJSON",this).call(this);data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(LineCurve3.prototype),"fromJSON",this).call(this,json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}]);return LineCurve3;}(Curve);var QuadraticBezierCurve=/*#__PURE__*/function(_Curve7){_inherits(QuadraticBezierCurve,_Curve7);var _super70=_createSuper(QuadraticBezierCurve);function QuadraticBezierCurve(){var _this60;var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector2();_classCallCheck(this,QuadraticBezierCurve);_this60=_super70.call(this);_this60.type='QuadraticBezierCurve';_this60.v0=v0;_this60.v1=v1;_this60.v2=v2;return _this60;}_createClass(QuadraticBezierCurve,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));return point;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(QuadraticBezierCurve.prototype),"copy",this).call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(QuadraticBezierCurve.prototype),"toJSON",this).call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(QuadraticBezierCurve.prototype),"fromJSON",this).call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}]);return QuadraticBezierCurve;}(Curve);QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;var QuadraticBezierCurve3=/*#__PURE__*/function(_Curve8){_inherits(QuadraticBezierCurve3,_Curve8);var _super71=_createSuper(QuadraticBezierCurve3);function QuadraticBezierCurve3(){var _this61;var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector3();_classCallCheck(this,QuadraticBezierCurve3);_this61=_super71.call(this);_this61.type='QuadraticBezierCurve3';_this61.v0=v0;_this61.v1=v1;_this61.v2=v2;return _this61;}_createClass(QuadraticBezierCurve3,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));return point;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(QuadraticBezierCurve3.prototype),"copy",this).call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(QuadraticBezierCurve3.prototype),"toJSON",this).call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(QuadraticBezierCurve3.prototype),"fromJSON",this).call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}]);return QuadraticBezierCurve3;}(Curve);QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;var SplineCurve=/*#__PURE__*/function(_Curve9){_inherits(SplineCurve,_Curve9);var _super72=_createSuper(SplineCurve);function SplineCurve(){var _this62;var points=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];_classCallCheck(this,SplineCurve);_this62=_super72.call(this);_this62.type='SplineCurve';_this62.points=points;return _this62;}_createClass(SplineCurve,[{key:"getPoint",value:function getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;var points=this.points;var p=(points.length-1)*t;var intPoint=Math.floor(p);var weight=p-intPoint;var p0=points[intPoint===0?intPoint:intPoint-1];var p1=points[intPoint];var p2=points[intPoint>points.length-2?points.length-1:intPoint+1];var p3=points[intPoint>points.length-3?points.length-1:intPoint+2];point.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));return point;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(SplineCurve.prototype),"copy",this).call(this,source);this.points=[];for(var _i192=0,l=source.points.length;_i192<l;_i192++){var point=source.points[_i192];this.points.push(point.clone());}return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(SplineCurve.prototype),"toJSON",this).call(this);data.points=[];for(var _i193=0,l=this.points.length;_i193<l;_i193++){var point=this.points[_i193];data.points.push(point.toArray());}return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(SplineCurve.prototype),"fromJSON",this).call(this,json);this.points=[];for(var _i194=0,l=json.points.length;_i194<l;_i194++){var point=json.points[_i194];this.points.push(new Vector2().fromArray(point));}return this;}}]);return SplineCurve;}(Curve);SplineCurve.prototype.isSplineCurve=true;var Curves=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});/**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/var CurvePath=/*#__PURE__*/function(_Curve10){_inherits(CurvePath,_Curve10);var _super73=_createSuper(CurvePath);function CurvePath(){var _this63;_classCallCheck(this,CurvePath);_this63=_super73.call(this);_this63.type='CurvePath';_this63.curves=[];_this63.autoClose=false;// Automatically closes the path
  return _this63;}_createClass(CurvePath,[{key:"add",value:function add(curve){this.curves.push(curve);}},{key:"closePath",value:function closePath(){// Add a line curve if start and end of lines are not connected
  var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}}// To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  },{key:"getPoint",value:function getPoint(t,optionalTarget){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
  while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u,optionalTarget);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
  }// We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  },{key:"getLength",value:function getLength(){var lens=this.getCurveLengths();return lens[lens.length-1];}// cacheLengths must be recalculated.
  },{key:"updateArcLengths",value:function updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();}// Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  },{key:"getCurveLengths",value:function getCurveLengths(){// We use cache values if curves and cache array are same length
  if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
  // Push sums into cached array
  var lengths=[];var sums=0;for(var _i195=0,l=this.curves.length;_i195<l;_i195++){sums+=this.curves[_i195].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;}},{key:"getSpacedPoints",value:function getSpacedPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:40;var points=[];for(var _i196=0;_i196<=divisions;_i196++){points.push(this.getPoint(_i196/divisions));}if(this.autoClose){points.push(points[0]);}return points;}},{key:"getPoints",value:function getPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:12;var points=[];var last;for(var _i197=0,curves=this.curves;_i197<curves.length;_i197++){var curve=curves[_i197];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&(curve.isLineCurve||curve.isLineCurve3)?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
  points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(CurvePath.prototype),"copy",this).call(this,source);this.curves=[];for(var _i198=0,l=source.curves.length;_i198<l;_i198++){var curve=source.curves[_i198];this.curves.push(curve.clone());}this.autoClose=source.autoClose;return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(CurvePath.prototype),"toJSON",this).call(this);data.autoClose=this.autoClose;data.curves=[];for(var _i199=0,l=this.curves.length;_i199<l;_i199++){var curve=this.curves[_i199];data.curves.push(curve.toJSON());}return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(CurvePath.prototype),"fromJSON",this).call(this,json);this.autoClose=json.autoClose;this.curves=[];for(var _i200=0,l=json.curves.length;_i200<l;_i200++){var curve=json.curves[_i200];this.curves.push(new Curves[curve.type]().fromJSON(curve));}return this;}}]);return CurvePath;}(Curve);var Path=/*#__PURE__*/function(_CurvePath){_inherits(Path,_CurvePath);var _super74=_createSuper(Path);function Path(points){var _this64;_classCallCheck(this,Path);_this64=_super74.call(this);_this64.type='Path';_this64.currentPoint=new Vector2();if(points){_this64.setFromPoints(points);}return _this64;}_createClass(Path,[{key:"setFromPoints",value:function setFromPoints(points){this.moveTo(points[0].x,points[0].y);for(var _i201=1,l=points.length;_i201<l;_i201++){this.lineTo(points[_i201].x,points[_i201].y);}return this;}},{key:"moveTo",value:function moveTo(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
  return this;}},{key:"lineTo",value:function lineTo(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);return this;}},{key:"quadraticCurveTo",value:function quadraticCurveTo(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;}},{key:"bezierCurveTo",value:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;}},{key:"splineThru",value:function splineThru(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);return this;}},{key:"arc",value:function arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);return this;}},{key:"absarc",value:function absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);return this;}},{key:"ellipse",value:function ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);return this;}},{key:"absellipse",value:function absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
  var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);return this;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(Path.prototype),"copy",this).call(this,source);this.currentPoint.copy(source.currentPoint);return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(Path.prototype),"toJSON",this).call(this);data.currentPoint=this.currentPoint.toArray();return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(Path.prototype),"fromJSON",this).call(this,json);this.currentPoint.fromArray(json.currentPoint);return this;}}]);return Path;}(CurvePath);var Shape=/*#__PURE__*/function(_Path){_inherits(Shape,_Path);var _super75=_createSuper(Shape);function Shape(points){var _this65;_classCallCheck(this,Shape);_this65=_super75.call(this,points);_this65.uuid=generateUUID();_this65.type='Shape';_this65.holes=[];return _this65;}_createClass(Shape,[{key:"getPointsHoles",value:function getPointsHoles(divisions){var holesPts=[];for(var _i202=0,l=this.holes.length;_i202<l;_i202++){holesPts[_i202]=this.holes[_i202].getPoints(divisions);}return holesPts;}// get points of shape and holes (keypoints based on segments parameter)
  },{key:"extractPoints",value:function extractPoints(divisions){return {shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(Shape.prototype),"copy",this).call(this,source);this.holes=[];for(var _i203=0,l=source.holes.length;_i203<l;_i203++){var hole=source.holes[_i203];this.holes.push(hole.clone());}return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(Shape.prototype),"toJSON",this).call(this);data.uuid=this.uuid;data.holes=[];for(var _i204=0,l=this.holes.length;_i204<l;_i204++){var hole=this.holes[_i204];data.holes.push(hole.toJSON());}return data;}},{key:"fromJSON",value:function fromJSON(json){_get(_getPrototypeOf(Shape.prototype),"fromJSON",this).call(this,json);this.uuid=json.uuid;this.holes=[];for(var _i205=0,l=json.holes.length;_i205<l;_i205++){var hole=json.holes[_i205];this.holes.push(new Path().fromJSON(hole));}return this;}}]);return Shape;}(Path);/**
   * Port from https://github.com/mapbox/earcut (v2.2.2)
   */var Earcut={triangulate:function triangulate(data,holeIndices){var dim=arguments.length>2&&arguments[2]!==undefined?arguments[2]:2;var hasHoles=holeIndices&&holeIndices.length;var outerLen=hasHoles?holeIndices[0]*dim:data.length;var outerNode=linkedList$1(data,0,outerLen,dim,true);var triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles$1(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
  if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var _i206=dim;_i206<outerLen;_i206+=dim){x=data[_i206];y=data[_i206+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
  invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked$1(outerNode,triangles,dim,minX,minY,invSize);return triangles;}};// create a circular doubly linked list from polygon points in the specified winding order
  function linkedList$1(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea$1(data,start,end,dim)>0){for(i=start;i<end;i+=dim)last=insertNode$1(i,data[i],data[i+1],last);}else {for(i=end-dim;i>=start;i-=dim)last=insertNode$1(i,data[i],data[i+1],last);}if(last&&equals$2(last,last.next)){removeNode$1(last);last=last.next;}return last;}// eliminate colinear or duplicate points
  function filterPoints$1(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals$2(p,p.next)||area$1(p.prev,p,p.next)===0)){removeNode$1(p);p=end=p.prev;if(p===p.next)break;again=true;}else {p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked$1(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
  if(!pass&&invSize)indexCurve$1(ear,minX,minY,invSize);var stop=ear,prev,next;// iterate through ears, slicing them one by one
  while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed$1(ear,minX,minY,invSize):isEar$1(ear)){// cut off the triangle
  triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode$1(ear);// skipping the next vertex leads to less sliver triangles
  ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
  if(ear===stop){// try filtering points and slicing again
  if(!pass){earcutLinked$1(filterPoints$1(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
  }else if(pass===1){ear=cureLocalIntersections$1(filterPoints$1(ear),triangles,dim);earcutLinked$1(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
  }else if(pass===2){splitEarcut$1(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
  function isEar$1(ear){var a=ear.prev,b=ear,c=ear.next;if(area$1(a,b,c)>=0)return false;// reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear
  var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle$1(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area$1(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed$1(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area$1(a,b,c)>=0)return false;// reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed
  var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
  var minZ=zOrder$1(minTX,minTY,minX,minY,invSize),maxZ=zOrder$1(maxTX,maxTY,minX,minY,invSize);var p=ear.prevZ,n=ear.nextZ;// look for points inside the triangle in both directions
  while(p&&p.z>=minZ&&n&&n.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle$1(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area$1(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(n!==ear.prev&&n!==ear.next&&pointInTriangle$1(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area$1(n.prev,n,n.next)>=0)return false;n=n.nextZ;}// look for remaining points in decreasing z-order
  while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle$1(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area$1(p.prev,p,p.next)>=0)return false;p=p.prevZ;}// look for remaining points in increasing z-order
  while(n&&n.z<=maxZ){if(n!==ear.prev&&n!==ear.next&&pointInTriangle$1(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area$1(n.prev,n,n.next)>=0)return false;n=n.nextZ;}return true;}// go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections$1(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals$2(a,b)&&intersects$1(a,p,p.next,b)&&locallyInside$1(a,b)&&locallyInside$1(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
  removeNode$1(p);removeNode$1(p.next);p=start=b;}p=p.next;}while(p!==start);return filterPoints$1(p);}// try splitting polygon into two and triangulate them independently
  function splitEarcut$1(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
  var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal$1(a,b)){// split the polygon in two by the diagonal
  var c=splitPolygon$1(a,b);// filter colinear points around the cuts
  a=filterPoints$1(a,a.next);c=filterPoints$1(c,c.next);// run earcut on each half
  earcutLinked$1(a,triangles,dim,minX,minY,invSize);earcutLinked$1(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles$1(data,holeIndices,outerNode,dim){var queue=[];var i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList$1(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost$1(list));}queue.sort(compareX$1);// process holes from left to right
  for(i=0;i<queue.length;i++){eliminateHole$1(queue[i],outerNode);outerNode=filterPoints$1(outerNode,outerNode.next);}return outerNode;}function compareX$1(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole$1(hole,outerNode){outerNode=findHoleBridge$1(hole,outerNode);if(outerNode){var b=splitPolygon$1(outerNode,hole);// filter collinear points around the cuts
  filterPoints$1(outerNode,outerNode.next);filterPoints$1(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge$1(hole,outerNode){var p=outerNode;var hx=hole.x;var hy=hole.y;var qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point
  do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m;// hole touches outer segment; pick leftmost endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point
  var stop=m,mx=m.x,my=m.y;var tanMin=Infinity,tan;p=m;do{if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle$1(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
  if(locallyInside$1(p,hole)&&(tan<tanMin||tan===tanMin&&(p.x>m.x||p.x===m.x&&sectorContainsSector$1(m,p)))){m=p;tanMin=tan;}}p=p.next;}while(p!==stop);return m;}// whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector$1(m,p){return area$1(m.prev,m,p.prev)<0&&area$1(p.next,m,m.next)<0;}// interlink polygon nodes in z-order
  function indexCurve$1(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder$1(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked$1(p);}// Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked$1(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else {e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder$1(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
  x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
  function getLeftmost$1(start){var p=start,leftmost=start;do{if(p.x<leftmost.x||p.x===leftmost.x&&p.y<leftmost.y)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
  function pointInTriangle$1(ax,ay,bx,by,cx,cy,px,py){return (cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal$1(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon$1(a,b)&&(// dones't intersect other edges
  locallyInside$1(a,b)&&locallyInside$1(b,a)&&middleInside$1(a,b)&&(// locally visible
  area$1(a.prev,a,b.prev)||area$1(a,b.prev,b))||// does not create opposite-facing sectors
  equals$2(a,b)&&area$1(a.prev,a,a.next)>0&&area$1(b.prev,b,b.next)>0);// special zero-length case
  }// signed area of a triangle
  function area$1(p,q,r){return (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
  function equals$2(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
  function intersects$1(p1,q1,p2,q2){var o1=sign$2(area$1(p1,q1,p2));var o2=sign$2(area$1(p1,q1,q2));var o3=sign$2(area$1(p2,q2,p1));var o4=sign$2(area$1(p2,q2,q1));if(o1!==o2&&o3!==o4)return true;// general case
  if(o1===0&&onSegment$1(p1,p2,q1))return true;// p1, q1 and p2 are collinear and p2 lies on p1q1
  if(o2===0&&onSegment$1(p1,q2,q1))return true;// p1, q1 and q2 are collinear and q2 lies on p1q1
  if(o3===0&&onSegment$1(p2,p1,q2))return true;// p2, q2 and p1 are collinear and p1 lies on p2q2
  if(o4===0&&onSegment$1(p2,q1,q2))return true;// p2, q2 and q1 are collinear and q1 lies on p2q2
  return false;}// for collinear points p, q, r, check if point q lies on segment pr
  function onSegment$1(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y);}function sign$2(num){return num>0?1:num<0?-1:0;}// check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon$1(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects$1(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
  function locallyInside$1(a,b){return area$1(a.prev,a,a.next)<0?area$1(a,b,a.next)>=0&&area$1(a,a.prev,b)>=0:area$1(a,b,a.prev)<0||area$1(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
  function middleInside$1(a,b){var p=a,inside=false;var px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon$1(a,b){var a2=new Node$2(a.i,a.x,a.y),b2=new Node$2(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode$1(i,x,y,last){var p=new Node$2(i,x,y);if(!last){p.prev=p;p.next=p;}else {p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode$1(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node$2(i,x,y){// vertex index in coordinates array
  this.i=i;// vertex coordinates
  this.x=x;this.y=y;// previous and next vertex nodes in a polygon ring
  this.prev=null;this.next=null;// z-order curve value
  this.z=null;// previous and next nodes in z-order
  this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
  this.steiner=false;}function signedArea$1(data,start,end,dim){var sum=0;for(var _i207=start,j=end-dim;_i207<end;_i207+=dim){sum+=(data[j]-data[_i207])*(data[_i207+1]+data[j+1]);j=_i207;}return sum;}var ShapeUtils=/*#__PURE__*/function(){function ShapeUtils(){_classCallCheck(this,ShapeUtils);}_createClass(ShapeUtils,null,[{key:"area",value:// calculate area of the contour polygon
  function area(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;}},{key:"isClockWise",value:function isClockWise(pts){return ShapeUtils.area(pts)<0;}},{key:"triangulateShape",value:function triangulateShape(contour,holes){var vertices=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
  var holeIndices=[];// array of hole indices
  var faces=[];// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
  removeDupEndPts(contour);addContour(vertices,contour);//
  var holeIndex=contour.length;holes.forEach(removeDupEndPts);for(var _i208=0;_i208<holes.length;_i208++){holeIndices.push(holeIndex);holeIndex+=holes[_i208].length;addContour(vertices,holes[_i208]);}//
  var triangles=Earcut.triangulate(vertices,holeIndices);//
  for(var _i209=0;_i209<triangles.length;_i209+=3){faces.push(triangles.slice(_i209,_i209+3));}return faces;}}]);return ShapeUtils;}();function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}function addContour(vertices,contour){for(var _i210=0;_i210<contour.length;_i210++){vertices.push(contour[_i210].x);vertices.push(contour[_i210].y);}}/**
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  depth: <float>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
   *  bevelOffset: <float>, // how far from shape outline does bevel start
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */var ExtrudeGeometry=/*#__PURE__*/function(_BufferGeometry7){_inherits(ExtrudeGeometry,_BufferGeometry7);var _super76=_createSuper(ExtrudeGeometry);function ExtrudeGeometry(){var _this66;var shapes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Shape([new Vector2(0.5,0.5),new Vector2(-0.5,0.5),new Vector2(-0.5,-0.5),new Vector2(0.5,-0.5)]);var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ExtrudeGeometry);_this66=_super76.call(this);_this66.type='ExtrudeGeometry';_this66.parameters={shapes:shapes,options:options};shapes=Array.isArray(shapes)?shapes:[shapes];var scope=_assertThisInitialized(_this66);var verticesArray=[];var uvArray=[];for(var _i211=0,l=shapes.length;_i211<l;_i211++){var shape=shapes[_i211];addShape(shape);}// build geometry
  _this66.setAttribute('position',new Float32BufferAttribute(verticesArray,3));_this66.setAttribute('uv',new Float32BufferAttribute(uvArray,2));_this66.computeVertexNormals();// functions
  function addShape(shape){var placeholder=[];// options
  var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var depth=options.depth!==undefined?options.depth:1;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:0.2;var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-0.1;var bevelOffset=options.bevelOffset!==undefined?options.bevelOffset:0;var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var extrudePath=options.extrudePath;var uvgen=options.UVGenerator!==undefined?options.UVGenerator:WorldUVGenerator;// deprecated options
  if(options.amount!==undefined){console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');depth=options.amount;}//
  var extrudePts,extrudeByPath=false;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
  // SETUP TNB variables
  // TODO1 - have a .isClosed in spline?
  splineTube=extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
  binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
  if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;bevelOffset=0;}// Variables initialization
  var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
  for(var h=0,hl=holes.length;h<hl;h++){var ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
  for(var _h=0,_hl=holes.length;_h<_hl;_h++){var _ahole=holes[_h];vertices=vertices.concat(_ahole);}function scalePt2(pt,vec,size){if(!vec)console.error('THREE.ExtrudeGeometry: vec does not exist');return vec.clone().multiplyScalar(size).add(pt);}var vlen=vertices.length,flen=faces.length;// Find directions for point movement
  function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
  //   shifted by 1 unit (length of normalized vector) to the left
  // if we walk along contour clockwise, this new contour is outside the old one
  //
  // inPt' is the intersection of the two lines parallel to the two
  //  adjacent edges of inPt at a distance of 1 unit on the left side.
  var v_trans_x,v_trans_y,shrink_by;// resulting translation vector for inPt
  // good reading for geometry algorithms (here: line-line intersection)
  // http://geomalgorithms.com/a05-_intersect-1.html
  var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
  var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){// not collinear
  // length of vectors for normalizing
  var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
  var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
  var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
  v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
  //  but prevent crazy spikes
  var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else {shrink_by=Math.sqrt(v_trans_lensq/2);}}else {// handle special case of collinear edges
  var direction_eq=false;// assumes: opposite
  if(v_prev_x>Number.EPSILON){if(v_next_x>Number.EPSILON){direction_eq=true;}}else {if(v_prev_x<-Number.EPSILON){if(v_next_x<-Number.EPSILON){direction_eq=true;}}else {if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
  v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else {// console.log("Warning: lines are a straight spike");
  v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var _i212=0,il=contour.length,j=il-1,k=_i212+1;_i212<il;_i212++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
  // console.log('i,j,k', i, j , k)
  contourMovements[_i212]=getBevelVec(contour[_i212],contour[j],contour[k]);}var holesMovements=[];var oneHoleMovements,verticesMovements=contourMovements.concat();for(var _h2=0,_hl2=holes.length;_h2<_hl2;_h2++){var _ahole2=holes[_h2];oneHoleMovements=[];for(var _i213=0,_il13=_ahole2.length,_j6=_il13-1,_k=_i213+1;_i213<_il13;_i213++,_j6++,_k++){if(_j6===_il13)_j6=0;if(_k===_il13)_k=0;//  (j)---(i)---(k)
  oneHoleMovements[_i213]=getBevelVec(_ahole2[_i213],_ahole2[_j6],_ahole2[_k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
  for(var b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
  var t=b/bevelSegments;var z=bevelThickness*Math.cos(t*Math.PI/2);var _bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;// contract shape
  for(var _i214=0,_il14=contour.length;_i214<_il14;_i214++){var vert=scalePt2(contour[_i214],contourMovements[_i214],_bs);v(vert.x,vert.y,-z);}// expand holes
  for(var _h3=0,_hl3=holes.length;_h3<_hl3;_h3++){var _ahole3=holes[_h3];oneHoleMovements=holesMovements[_h3];for(var _i215=0,_il15=_ahole3.length;_i215<_il15;_i215++){var _vert=scalePt2(_ahole3[_i215],oneHoleMovements[_i215],_bs);v(_vert.x,_vert.y,-z);}}}var bs=bevelSize+bevelOffset;// Back facing vertices
  for(var _i216=0;_i216<vlen;_i216++){var _vert2=bevelEnabled?scalePt2(vertices[_i216],verticesMovements[_i216],bs):vertices[_i216];if(!extrudeByPath){v(_vert2.x,_vert2.y,0);}else {// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
  normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
  // Including front facing vertices
  for(var s=1;s<=steps;s++){for(var _i217=0;_i217<vlen;_i217++){var _vert3=bevelEnabled?scalePt2(vertices[_i217],verticesMovements[_i217],bs):vertices[_i217];if(!extrudeByPath){v(_vert3.x,_vert3.y,depth/steps*s);}else {// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
  normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for(var _b5=bevelSegments-1;_b5>=0;_b5--){var _t=_b5/bevelSegments;var _z2=bevelThickness*Math.cos(_t*Math.PI/2);var _bs2=bevelSize*Math.sin(_t*Math.PI/2)+bevelOffset;// contract shape
  for(var _i218=0,_il16=contour.length;_i218<_il16;_i218++){var _vert4=scalePt2(contour[_i218],contourMovements[_i218],_bs2);v(_vert4.x,_vert4.y,depth+_z2);}// expand holes
  for(var _h4=0,_hl4=holes.length;_h4<_hl4;_h4++){var _ahole4=holes[_h4];oneHoleMovements=holesMovements[_h4];for(var _i219=0,_il17=_ahole4.length;_i219<_il17;_i219++){var _vert5=scalePt2(_ahole4[_i219],oneHoleMovements[_i219],_bs2);if(!extrudeByPath){v(_vert5.x,_vert5.y,depth+_z2);}else {v(_vert5.x,_vert5.y+extrudePts[steps-1].y,extrudePts[steps-1].x+_z2);}}}}/* Faces */ // Top and bottom faces
  buildLidFaces();// Sides faces
  buildSideFaces();/////  Internal functions
  function buildLidFaces(){var start=verticesArray.length/3;if(bevelEnabled){var layer=0;// steps + 1
  var offset=vlen*layer;// Bottom faces
  for(var _i220=0;_i220<flen;_i220++){var face=faces[_i220];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
  for(var _i221=0;_i221<flen;_i221++){var _face=faces[_i221];f3(_face[0]+offset,_face[1]+offset,_face[2]+offset);}}else {// Bottom faces
  for(var _i222=0;_i222<flen;_i222++){var _face2=faces[_i222];f3(_face2[2],_face2[1],_face2[0]);}// Top faces
  for(var _i223=0;_i223<flen;_i223++){var _face3=faces[_i223];f3(_face3[0]+vlen*steps,_face3[1]+vlen*steps,_face3[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,0);}// Create faces for the z-sides of the shape
  function buildSideFaces(){var start=verticesArray.length/3;var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(var _h5=0,_hl5=holes.length;_h5<_hl5;_h5++){var _ahole5=holes[_h5];sidewalls(_ahole5,layeroffset);//, true
  layeroffset+=_ahole5.length;}scope.addGroup(start,verticesArray.length/3-start,1);}function sidewalls(contour,layeroffset){var i=contour.length;while(--i>=0){var _j7=i;var _k2=i-1;if(_k2<0)_k2=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
  for(var _s4=0,sl=steps+bevelSegments*2;_s4<sl;_s4++){var slen1=vlen*_s4;var slen2=vlen*(_s4+1);var a=layeroffset+_j7+slen1,_b6=layeroffset+_k2+slen1,c=layeroffset+_k2+slen2,d=layeroffset+_j7+slen2;f4(a,_b6,c,d);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}}return _this66;}_createClass(ExtrudeGeometry,[{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(ExtrudeGeometry.prototype),"toJSON",this).call(this);var shapes=this.parameters.shapes;var options=this.parameters.options;return toJSON$1(shapes,options,data);}}],[{key:"fromJSON",value:function fromJSON(data,shapes){var geometryShapes=[];for(var j=0,jl=data.shapes.length;j<jl;j++){var shape=shapes[data.shapes[j]];geometryShapes.push(shape);}var extrudePath=data.options.extrudePath;if(extrudePath!==undefined){data.options.extrudePath=new Curves[extrudePath.type]().fromJSON(extrudePath);}return new ExtrudeGeometry(geometryShapes,data.options);}}]);return ExtrudeGeometry;}(BufferGeometry);var WorldUVGenerator={generateTopUV:function generateTopUV(geometry,vertices,indexA,indexB,indexC){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];return [new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function generateSideWallUV(geometry,vertices,indexA,indexB,indexC,indexD){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var a_z=vertices[indexA*3+2];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var b_z=vertices[indexB*3+2];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];var c_z=vertices[indexC*3+2];var d_x=vertices[indexD*3];var d_y=vertices[indexD*3+1];var d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<Math.abs(a_x-b_x)){return [new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else {return [new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};function toJSON$1(shapes,options,data){data.shapes=[];if(Array.isArray(shapes)){for(var _i224=0,l=shapes.length;_i224<l;_i224++){var shape=shapes[_i224];data.shapes.push(shape.uuid);}}else {data.shapes.push(shapes.uuid);}if(options.extrudePath!==undefined)data.options.extrudePath=options.extrudePath.toJSON();return data;}var ShapeGeometry=/*#__PURE__*/function(_BufferGeometry10){_inherits(ShapeGeometry,_BufferGeometry10);var _super81=_createSuper(ShapeGeometry);function ShapeGeometry(){var _this71;var shapes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Shape([new Vector2(0,0.5),new Vector2(-0.5,-0.5),new Vector2(0.5,-0.5)]);var curveSegments=arguments.length>1&&arguments[1]!==undefined?arguments[1]:12;_classCallCheck(this,ShapeGeometry);_this71=_super81.call(this);_this71.type='ShapeGeometry';_this71.parameters={shapes:shapes,curveSegments:curveSegments};// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
  if(Array.isArray(shapes)===false){addShape(shapes);}else {for(var _i230=0;_i230<shapes.length;_i230++){addShape(shapes[_i230]);_this71.addGroup(groupStart,groupCount,_i230);// enables MultiMaterial support
  groupStart+=groupCount;groupCount=0;}}// build geometry
  _this71.setIndex(indices);_this71.setAttribute('position',new Float32BufferAttribute(vertices,3));_this71.setAttribute('normal',new Float32BufferAttribute(normals,3));_this71.setAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
  function addShape(shape){var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
  if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();}for(var _i231=0,l=shapeHoles.length;_i231<l;_i231++){var shapeHole=shapeHoles[_i231];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[_i231]=shapeHole.reverse();}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
  for(var _i232=0,_l7=shapeHoles.length;_i232<_l7;_i232++){var _shapeHole=shapeHoles[_i232];shapeVertices=shapeVertices.concat(_shapeHole);}// vertices, normals, uvs
  for(var _i233=0,_l8=shapeVertices.length;_i233<_l8;_i233++){var _vertex=shapeVertices[_i233];vertices.push(_vertex.x,_vertex.y,0);normals.push(0,0,1);uvs.push(_vertex.x,_vertex.y);// world uvs
  }// incides
  for(var _i234=0,_l9=faces.length;_i234<_l9;_i234++){var face=faces[_i234];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}return _this71;}_createClass(ShapeGeometry,[{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(ShapeGeometry.prototype),"toJSON",this).call(this);var shapes=this.parameters.shapes;return _toJSON(shapes,data);}}],[{key:"fromJSON",value:function fromJSON(data,shapes){var geometryShapes=[];for(var j=0,jl=data.shapes.length;j<jl;j++){var shape=shapes[data.shapes[j]];geometryShapes.push(shape);}return new ShapeGeometry(geometryShapes,data.curveSegments);}}]);return ShapeGeometry;}(BufferGeometry);function _toJSON(shapes,data){data.shapes=[];if(Array.isArray(shapes)){for(var _i235=0,l=shapes.length;_i235<l;_i235++){var shape=shapes[_i235];data.shapes.push(shape.uuid);}}else {data.shapes.push(shapes.uuid);}return data;}var SphereGeometry=/*#__PURE__*/function(_BufferGeometry11){_inherits(SphereGeometry,_BufferGeometry11);var _super82=_createSuper(SphereGeometry);function SphereGeometry(){var _this72;var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var widthSegments=arguments.length>1&&arguments[1]!==undefined?arguments[1]:32;var heightSegments=arguments.length>2&&arguments[2]!==undefined?arguments[2]:16;var phiStart=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var phiLength=arguments.length>4&&arguments[4]!==undefined?arguments[4]:Math.PI*2;var thetaStart=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;var thetaLength=arguments.length>6&&arguments[6]!==undefined?arguments[6]:Math.PI;_classCallCheck(this,SphereGeometry);_this72=_super82.call(this);_this72.type='SphereGeometry';_this72.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};widthSegments=Math.max(3,Math.floor(widthSegments));heightSegments=Math.max(2,Math.floor(heightSegments));var thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);var index=0;var grid=[];var vertex=new Vector3();var normal=new Vector3();// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
  for(var iy=0;iy<=heightSegments;iy++){var verticesRow=[];var v=iy/heightSegments;// special case for the poles
  var uOffset=0;if(iy==0&&thetaStart==0){uOffset=0.5/widthSegments;}else if(iy==heightSegments&&thetaEnd==Math.PI){uOffset=-0.5/widthSegments;}for(var ix=0;ix<=widthSegments;ix++){var u=ix/widthSegments;// vertex
  vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normal.copy(vertex).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(u+uOffset,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
  for(var _iy3=0;_iy3<heightSegments;_iy3++){for(var _ix3=0;_ix3<widthSegments;_ix3++){var a=grid[_iy3][_ix3+1];var b=grid[_iy3][_ix3];var c=grid[_iy3+1][_ix3];var d=grid[_iy3+1][_ix3+1];if(_iy3!==0||thetaStart>0)indices.push(a,b,d);if(_iy3!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
  _this72.setIndex(indices);_this72.setAttribute('position',new Float32BufferAttribute(vertices,3));_this72.setAttribute('normal',new Float32BufferAttribute(normals,3));_this72.setAttribute('uv',new Float32BufferAttribute(uvs,2));return _this72;}_createClass(SphereGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new SphereGeometry(data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);}}]);return SphereGeometry;}(BufferGeometry);/**
   * parameters = {
   *  color: <THREE.Color>
   * }
   */var ShadowMaterial=/*#__PURE__*/function(_Material8){_inherits(ShadowMaterial,_Material8);var _super88=_createSuper(ShadowMaterial);function ShadowMaterial(parameters){var _this78;_classCallCheck(this,ShadowMaterial);_this78=_super88.call(this);_this78.type='ShadowMaterial';_this78.color=new Color$2(0x000000);_this78.transparent=true;_this78.setValues(parameters);return _this78;}_createClass(ShadowMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(ShadowMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);return this;}}]);return ShadowMaterial;}(Material$1);ShadowMaterial.prototype.isShadowMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  flatShading: <bool>
   * }
   */var MeshStandardMaterial=/*#__PURE__*/function(_Material9){_inherits(MeshStandardMaterial,_Material9);var _super89=_createSuper(MeshStandardMaterial);function MeshStandardMaterial(parameters){var _this79;_classCallCheck(this,MeshStandardMaterial);_this79=_super89.call(this);_this79.defines={'STANDARD':''};_this79.type='MeshStandardMaterial';_this79.color=new Color$2(0xffffff);// diffuse
  _this79.roughness=1.0;_this79.metalness=0.0;_this79.map=null;_this79.lightMap=null;_this79.lightMapIntensity=1.0;_this79.aoMap=null;_this79.aoMapIntensity=1.0;_this79.emissive=new Color$2(0x000000);_this79.emissiveIntensity=1.0;_this79.emissiveMap=null;_this79.bumpMap=null;_this79.bumpScale=1;_this79.normalMap=null;_this79.normalMapType=TangentSpaceNormalMap;_this79.normalScale=new Vector2(1,1);_this79.displacementMap=null;_this79.displacementScale=1;_this79.displacementBias=0;_this79.roughnessMap=null;_this79.metalnessMap=null;_this79.alphaMap=null;_this79.envMap=null;_this79.envMapIntensity=1.0;_this79.refractionRatio=0.98;_this79.wireframe=false;_this79.wireframeLinewidth=1;_this79.wireframeLinecap='round';_this79.wireframeLinejoin='round';_this79.flatShading=false;_this79.setValues(parameters);return _this79;}_createClass(MeshStandardMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshStandardMaterial.prototype),"copy",this).call(this,source);this.defines={'STANDARD':''};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;return this;}}]);return MeshStandardMaterial;}(Material$1);MeshStandardMaterial.prototype.isMeshStandardMaterial=true;/**
   * parameters = {
   *  clearcoat: <float>,
   *  clearcoatMap: new THREE.Texture( <Image> ),
   *  clearcoatRoughness: <float>,
   *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
   *  clearcoatNormalScale: <Vector2>,
   *  clearcoatNormalMap: new THREE.Texture( <Image> ),
   *
   *  ior: <float>,
   *  reflectivity: <float>,
   *
   *  sheen: <float>,
   *  sheenTint: <Color>,
   *  sheenRoughness: <float>,
   *
   *  transmission: <float>,
   *  transmissionMap: new THREE.Texture( <Image> ),
   *
   *  thickness: <float>,
   *  thicknessMap: new THREE.Texture( <Image> ),
   *  attenuationDistance: <float>,
   *  attenuationTint: <Color>,
   *
   *  specularIntensity: <float>,
   *  specularIntensityhMap: new THREE.Texture( <Image> ),
   *  specularTint: <Color>,
   *  specularTintMap: new THREE.Texture( <Image> )
   * }
   */var MeshPhysicalMaterial=/*#__PURE__*/function(_MeshStandardMaterial){_inherits(MeshPhysicalMaterial,_MeshStandardMaterial);var _super90=_createSuper(MeshPhysicalMaterial);function MeshPhysicalMaterial(parameters){var _this80;_classCallCheck(this,MeshPhysicalMaterial);_this80=_super90.call(this);_this80.defines={'STANDARD':'','PHYSICAL':''};_this80.type='MeshPhysicalMaterial';_this80.clearcoatMap=null;_this80.clearcoatRoughness=0.0;_this80.clearcoatRoughnessMap=null;_this80.clearcoatNormalScale=new Vector2(1,1);_this80.clearcoatNormalMap=null;_this80.ior=1.5;Object.defineProperty(_assertThisInitialized(_this80),'reflectivity',{get:function get(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1);},set:function set(reflectivity){this.ior=(1+0.4*reflectivity)/(1-0.4*reflectivity);}});_this80.sheenTint=new Color$2(0x000000);_this80.sheenRoughness=1.0;_this80.transmissionMap=null;_this80.thickness=0.01;_this80.thicknessMap=null;_this80.attenuationDistance=0.0;_this80.attenuationTint=new Color$2(1,1,1);_this80.specularIntensity=1.0;_this80.specularIntensityMap=null;_this80.specularTint=new Color$2(1,1,1);_this80.specularTintMap=null;_this80._sheen=0.0;_this80._clearcoat=0;_this80._transmission=0;_this80.setValues(parameters);return _this80;}_createClass(MeshPhysicalMaterial,[{key:"sheen",get:function get(){return this._sheen;},set:function set(value){if(this._sheen>0!==value>0){this.version++;}this._sheen=value;}},{key:"clearcoat",get:function get(){return this._clearcoat;},set:function set(value){if(this._clearcoat>0!==value>0){this.version++;}this._clearcoat=value;}},{key:"transmission",get:function get(){return this._transmission;},set:function set(value){if(this._transmission>0!==value>0){this.version++;}this._transmission=value;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshPhysicalMaterial.prototype),"copy",this).call(this,source);this.defines={'STANDARD':'','PHYSICAL':''};this.clearcoat=source.clearcoat;this.clearcoatMap=source.clearcoatMap;this.clearcoatRoughness=source.clearcoatRoughness;this.clearcoatRoughnessMap=source.clearcoatRoughnessMap;this.clearcoatNormalMap=source.clearcoatNormalMap;this.clearcoatNormalScale.copy(source.clearcoatNormalScale);this.ior=source.ior;this.sheen=source.sheen;this.sheenTint.copy(source.sheenTint);this.sheenRoughness=source.sheenRoughness;this.transmission=source.transmission;this.transmissionMap=source.transmissionMap;this.thickness=source.thickness;this.thicknessMap=source.thicknessMap;this.attenuationDistance=source.attenuationDistance;this.attenuationTint.copy(source.attenuationTint);this.specularIntensity=source.specularIntensity;this.specularIntensityMap=source.specularIntensityMap;this.specularTint.copy(source.specularTint);this.specularTintMap=source.specularTintMap;return this;}}]);return MeshPhysicalMaterial;}(MeshStandardMaterial);MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.MultiplyOperation,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  flatShading: <bool>
   * }
   */var MeshPhongMaterial=/*#__PURE__*/function(_Material10){_inherits(MeshPhongMaterial,_Material10);var _super91=_createSuper(MeshPhongMaterial);function MeshPhongMaterial(parameters){var _this81;_classCallCheck(this,MeshPhongMaterial);_this81=_super91.call(this);_this81.type='MeshPhongMaterial';_this81.color=new Color$2(0xffffff);// diffuse
  _this81.specular=new Color$2(0x111111);_this81.shininess=30;_this81.map=null;_this81.lightMap=null;_this81.lightMapIntensity=1.0;_this81.aoMap=null;_this81.aoMapIntensity=1.0;_this81.emissive=new Color$2(0x000000);_this81.emissiveIntensity=1.0;_this81.emissiveMap=null;_this81.bumpMap=null;_this81.bumpScale=1;_this81.normalMap=null;_this81.normalMapType=TangentSpaceNormalMap;_this81.normalScale=new Vector2(1,1);_this81.displacementMap=null;_this81.displacementScale=1;_this81.displacementBias=0;_this81.specularMap=null;_this81.alphaMap=null;_this81.envMap=null;_this81.combine=MultiplyOperation;_this81.reflectivity=1;_this81.refractionRatio=0.98;_this81.wireframe=false;_this81.wireframeLinewidth=1;_this81.wireframeLinecap='round';_this81.wireframeLinejoin='round';_this81.flatShading=false;_this81.setValues(parameters);return _this81;}_createClass(MeshPhongMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshPhongMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;return this;}}]);return MeshPhongMaterial;}(Material$1);MeshPhongMaterial.prototype.isMeshPhongMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *
   *  map: new THREE.Texture( <Image> ),
   *  gradientMap: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   * }
   */var MeshToonMaterial=/*#__PURE__*/function(_Material11){_inherits(MeshToonMaterial,_Material11);var _super92=_createSuper(MeshToonMaterial);function MeshToonMaterial(parameters){var _this82;_classCallCheck(this,MeshToonMaterial);_this82=_super92.call(this);_this82.defines={'TOON':''};_this82.type='MeshToonMaterial';_this82.color=new Color$2(0xffffff);_this82.map=null;_this82.gradientMap=null;_this82.lightMap=null;_this82.lightMapIntensity=1.0;_this82.aoMap=null;_this82.aoMapIntensity=1.0;_this82.emissive=new Color$2(0x000000);_this82.emissiveIntensity=1.0;_this82.emissiveMap=null;_this82.bumpMap=null;_this82.bumpScale=1;_this82.normalMap=null;_this82.normalMapType=TangentSpaceNormalMap;_this82.normalScale=new Vector2(1,1);_this82.displacementMap=null;_this82.displacementScale=1;_this82.displacementBias=0;_this82.alphaMap=null;_this82.wireframe=false;_this82.wireframeLinewidth=1;_this82.wireframeLinecap='round';_this82.wireframeLinejoin='round';_this82.setValues(parameters);return _this82;}_createClass(MeshToonMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshToonMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.map=source.map;this.gradientMap=source.gradientMap;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}]);return MeshToonMaterial;}(Material$1);MeshToonMaterial.prototype.isMeshToonMaterial=true;/**
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  flatShading: <bool>
   * }
   */var MeshNormalMaterial=/*#__PURE__*/function(_Material12){_inherits(MeshNormalMaterial,_Material12);var _super93=_createSuper(MeshNormalMaterial);function MeshNormalMaterial(parameters){var _this83;_classCallCheck(this,MeshNormalMaterial);_this83=_super93.call(this);_this83.type='MeshNormalMaterial';_this83.bumpMap=null;_this83.bumpScale=1;_this83.normalMap=null;_this83.normalMapType=TangentSpaceNormalMap;_this83.normalScale=new Vector2(1,1);_this83.displacementMap=null;_this83.displacementScale=1;_this83.displacementBias=0;_this83.wireframe=false;_this83.wireframeLinewidth=1;_this83.fog=false;_this83.flatShading=false;_this83.setValues(parameters);return _this83;}_createClass(MeshNormalMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshNormalMaterial.prototype),"copy",this).call(this,source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.flatShading=source.flatShading;return this;}}]);return MeshNormalMaterial;}(Material$1);MeshNormalMaterial.prototype.isMeshNormalMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   * }
   */var MeshLambertMaterial=/*#__PURE__*/function(_Material13){_inherits(MeshLambertMaterial,_Material13);var _super94=_createSuper(MeshLambertMaterial);function MeshLambertMaterial(parameters){var _this84;_classCallCheck(this,MeshLambertMaterial);_this84=_super94.call(this);_this84.type='MeshLambertMaterial';_this84.color=new Color$2(0xffffff);// diffuse
  _this84.map=null;_this84.lightMap=null;_this84.lightMapIntensity=1.0;_this84.aoMap=null;_this84.aoMapIntensity=1.0;_this84.emissive=new Color$2(0x000000);_this84.emissiveIntensity=1.0;_this84.emissiveMap=null;_this84.specularMap=null;_this84.alphaMap=null;_this84.envMap=null;_this84.combine=MultiplyOperation;_this84.reflectivity=1;_this84.refractionRatio=0.98;_this84.wireframe=false;_this84.wireframeLinewidth=1;_this84.wireframeLinecap='round';_this84.wireframeLinejoin='round';_this84.setValues(parameters);return _this84;}_createClass(MeshLambertMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshLambertMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}]);return MeshLambertMaterial;}(Material$1);MeshLambertMaterial.prototype.isMeshLambertMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  matcap: new THREE.Texture( <Image> ),
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  flatShading: <bool>
   * }
   */var MeshMatcapMaterial=/*#__PURE__*/function(_Material14){_inherits(MeshMatcapMaterial,_Material14);var _super95=_createSuper(MeshMatcapMaterial);function MeshMatcapMaterial(parameters){var _this85;_classCallCheck(this,MeshMatcapMaterial);_this85=_super95.call(this);_this85.defines={'MATCAP':''};_this85.type='MeshMatcapMaterial';_this85.color=new Color$2(0xffffff);// diffuse
  _this85.matcap=null;_this85.map=null;_this85.bumpMap=null;_this85.bumpScale=1;_this85.normalMap=null;_this85.normalMapType=TangentSpaceNormalMap;_this85.normalScale=new Vector2(1,1);_this85.displacementMap=null;_this85.displacementScale=1;_this85.displacementBias=0;_this85.alphaMap=null;_this85.flatShading=false;_this85.setValues(parameters);return _this85;}_createClass(MeshMatcapMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshMatcapMaterial.prototype),"copy",this).call(this,source);this.defines={'MATCAP':''};this.color.copy(source.color);this.matcap=source.matcap;this.map=source.map;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.flatShading=source.flatShading;return this;}}]);return MeshMatcapMaterial;}(Material$1);MeshMatcapMaterial.prototype.isMeshMatcapMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */var LineDashedMaterial=/*#__PURE__*/function(_LineBasicMaterial){_inherits(LineDashedMaterial,_LineBasicMaterial);var _super96=_createSuper(LineDashedMaterial);function LineDashedMaterial(parameters){var _this86;_classCallCheck(this,LineDashedMaterial);_this86=_super96.call(this);_this86.type='LineDashedMaterial';_this86.scale=1;_this86.dashSize=3;_this86.gapSize=1;_this86.setValues(parameters);return _this86;}_createClass(LineDashedMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(LineDashedMaterial.prototype),"copy",this).call(this,source);this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;}}]);return LineDashedMaterial;}(LineBasicMaterial);LineDashedMaterial.prototype.isLineDashedMaterial=true;var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
  arraySlice:function arraySlice(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
  // but array.subarray(from) or array.subarray(from, len) is correct
  return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
  convertArray:function convertArray(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
  !forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
  }return Array.prototype.slice.call(array);// create Array
  },isTypedArray:function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
  getKeyframeOrder:function getKeyframeOrder(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var _i245=0;_i245!==n;++_i245)result[_i245]=_i245;result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray:function sortedArray(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var _i246=0,dstOffset=0;dstOffset!==nValues;++_i246){var srcOffset=order[_i246]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
  flattenJSON:function flattenJSON(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
  var value=key[valuePropertyName];if(value===undefined)return;// no data
  if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
  }key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
  do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else {// otherwise push as-is
  do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}},subclip:function subclip(sourceClip,name,startFrame,endFrame){var fps=arguments.length>4&&arguments[4]!==undefined?arguments[4]:30;var clip=sourceClip.clone();clip.name=name;var tracks=[];for(var _i247=0;_i247<clip.tracks.length;++_i247){var track=clip.tracks[_i247];var valueSize=track.getValueSize();var times=[];var values=[];for(var j=0;j<track.times.length;++j){var frame=track.times[j]*fps;if(frame<startFrame||frame>=endFrame)continue;times.push(track.times[j]);for(var k=0;k<valueSize;++k){values.push(track.values[j*valueSize+k]);}}if(times.length===0)continue;track.times=AnimationUtils.convertArray(times,track.times.constructor);track.values=AnimationUtils.convertArray(values,track.values.constructor);tracks.push(track);}clip.tracks=tracks;// find minimum .times value across all tracks in the trimmed clip
  var minStartTime=Infinity;for(var _i248=0;_i248<clip.tracks.length;++_i248){if(minStartTime>clip.tracks[_i248].times[0]){minStartTime=clip.tracks[_i248].times[0];}}// shift all tracks such that clip begins at t=0
  for(var _i249=0;_i249<clip.tracks.length;++_i249){clip.tracks[_i249].shift(-1*minStartTime);}clip.resetDuration();return clip;},makeClipAdditive:function makeClipAdditive(targetClip){var referenceFrame=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var referenceClip=arguments.length>2&&arguments[2]!==undefined?arguments[2]:targetClip;var fps=arguments.length>3&&arguments[3]!==undefined?arguments[3]:30;if(fps<=0)fps=30;var numTracks=referenceClip.tracks.length;var referenceTime=referenceFrame/fps;// Make each track's values relative to the values at the reference frame
  var _loop=function _loop(){var referenceTrack=referenceClip.tracks[_i250];var referenceTrackType=referenceTrack.ValueTypeName;// Skip this track if it's non-numeric
  if(referenceTrackType==='bool'||referenceTrackType==='string')return "continue";// Find the track in the target clip whose name and type matches the reference track
  var targetTrack=targetClip.tracks.find(function(track){return track.name===referenceTrack.name&&track.ValueTypeName===referenceTrackType;});if(targetTrack===undefined)return "continue";var referenceOffset=0;var referenceValueSize=referenceTrack.getValueSize();if(referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline){referenceOffset=referenceValueSize/3;}var targetOffset=0;var targetValueSize=targetTrack.getValueSize();if(targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline){targetOffset=targetValueSize/3;}var lastIndex=referenceTrack.times.length-1;var referenceValue;// Find the value to subtract out of the track
  if(referenceTime<=referenceTrack.times[0]){// Reference frame is earlier than the first keyframe, so just use the first keyframe
  var startIndex=referenceOffset;var endIndex=referenceValueSize-referenceOffset;referenceValue=AnimationUtils.arraySlice(referenceTrack.values,startIndex,endIndex);}else if(referenceTime>=referenceTrack.times[lastIndex]){// Reference frame is after the last keyframe, so just use the last keyframe
  var _startIndex=lastIndex*referenceValueSize+referenceOffset;var _endIndex=_startIndex+referenceValueSize-referenceOffset;referenceValue=AnimationUtils.arraySlice(referenceTrack.values,_startIndex,_endIndex);}else {// Interpolate to the reference value
  var interpolant=referenceTrack.createInterpolant();var _startIndex2=referenceOffset;var _endIndex2=referenceValueSize-referenceOffset;interpolant.evaluate(referenceTime);referenceValue=AnimationUtils.arraySlice(interpolant.resultBuffer,_startIndex2,_endIndex2);}// Conjugate the quaternion
  if(referenceTrackType==='quaternion'){var referenceQuat=new Quaternion().fromArray(referenceValue).normalize().conjugate();referenceQuat.toArray(referenceValue);}// Subtract the reference value from all of the track values
  var numTimes=targetTrack.times.length;for(var j=0;j<numTimes;++j){var valueStart=j*targetValueSize+targetOffset;if(referenceTrackType==='quaternion'){// Multiply the conjugate for quaternion track types
  Quaternion.multiplyQuaternionsFlat(targetTrack.values,valueStart,referenceValue,0,targetTrack.values,valueStart);}else {var valueEnd=targetValueSize-targetOffset*2;// Subtract each value for all other numeric track types
  for(var k=0;k<valueEnd;++k){targetTrack.values[valueStart+k]-=referenceValue[k];}}}};for(var _i250=0;_i250<numTracks;++_i250){var _ret=_loop();if(_ret==="continue")continue;}targetClip.blendMode=AdditiveAnimationBlendMode;return targetClip;}};/**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   */var Interpolant=/*#__PURE__*/function(){function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,Interpolant);this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;this.settings=null;this.DefaultSettings_={};}_createClass(Interpolant,[{key:"evaluate",value:function evaluate(t){var pp=this.parameterPositions;var i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
  //- slower code:
  //-
  //- 				if ( t >= t1 || t1 === undefined ) {
  forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
  i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
  t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the right side of the index
  right=pp.length;break linear_scan;}//- slower code:
  //-					if ( t < t0 || t0 === undefined ) {
  if(!(t>=t0)){// looping?
  var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
  t0=t1global;}// linear reverse scan
  for(var _giveUpAt=i1-2;;){if(t0===undefined){// before start
  this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===_giveUpAt)break;// this loop
  t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the left side of the index
  right=i1;i1=0;break linear_scan;}// the interval is valid
  break validate_interval;}// linear scan
  // binary search
  while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else {i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
  if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
  this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
  return this.interpolate_(i1,t0,t,t1);}},{key:"getSettings_",value:function getSettings_(){return this.settings||this.DefaultSettings_;}},{key:"copySampleValue_",value:function copySampleValue_(index){// copies a sample value to the result buffer
  var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var _i251=0;_i251!==stride;++_i251){result[_i251]=values[offset+_i251];}return result;}// Template methods for derived classes:
  },{key:"interpolate_",value:function interpolate_(/* i1, t0, t, t1 */){throw new Error('call to abstract method');// implementations shall return this.resultBuffer
  }},{key:"intervalChanged_",value:function intervalChanged_(/* i1, t0, t1 */){// empty
  }}]);return Interpolant;}();// ALIAS DEFINITIONS
  Interpolant.prototype.beforeStart_=Interpolant.prototype.copySampleValue_;Interpolant.prototype.afterEnd_=Interpolant.prototype.copySampleValue_;/**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   */var CubicInterpolant=/*#__PURE__*/function(_Interpolant){_inherits(CubicInterpolant,_Interpolant);var _super97=_createSuper(CubicInterpolant);function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){var _this87;_classCallCheck(this,CubicInterpolant);_this87=_super97.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);_this87._weightPrev=-0;_this87._offsetPrev=-0;_this87._weightNext=-0;_this87._offsetNext=-0;_this87.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};return _this87;}_createClass(CubicInterpolant,[{key:"intervalChanged_",value:function intervalChanged_(i1,t0,t1){var pp=this.parameterPositions;var iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
  iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
  iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
  // f''(t0) = 0 a.k.a. Natural Spline
  iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
  iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
  iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
  // f''(tN) = 0, a.k.a. Natural Spline
  iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;}},{key:"interpolate_",value:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
  var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
  for(var _i252=0;_i252!==stride;++_i252){result[_i252]=sP*values[oP+_i252]+s0*values[o0+_i252]+s1*values[o1+_i252]+sN*values[oN+_i252];}return result;}}]);return CubicInterpolant;}(Interpolant);var LinearInterpolant=/*#__PURE__*/function(_Interpolant2){_inherits(LinearInterpolant,_Interpolant2);var _super98=_createSuper(LinearInterpolant);function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,LinearInterpolant);return _super98.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}_createClass(LinearInterpolant,[{key:"interpolate_",value:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var _i253=0;_i253!==stride;++_i253){result[_i253]=values[offset0+_i253]*weight0+values[offset1+_i253]*weight1;}return result;}}]);return LinearInterpolant;}(Interpolant);/**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   */var DiscreteInterpolant=/*#__PURE__*/function(_Interpolant3){_inherits(DiscreteInterpolant,_Interpolant3);var _super99=_createSuper(DiscreteInterpolant);function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,DiscreteInterpolant);return _super99.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}_createClass(DiscreteInterpolant,[{key:"interpolate_",value:function interpolate_(i1/*, t0, t, t1 */){return this.copySampleValue_(i1-1);}}]);return DiscreteInterpolant;}(Interpolant);var KeyframeTrack=/*#__PURE__*/function(){function KeyframeTrack(name,times,values,interpolation){_classCallCheck(this,KeyframeTrack);if(name===undefined)throw new Error('THREE.KeyframeTrack: track name is undefined');if(times===undefined||times.length===0)throw new Error('THREE.KeyframeTrack: no keyframes in track named '+name);this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);}// Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  _createClass(KeyframeTrack,[{key:"InterpolantFactoryMethodDiscrete",value:function InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);}},{key:"InterpolantFactoryMethodLinear",value:function InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);}},{key:"InterpolantFactoryMethodSmooth",value:function InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);}},{key:"setInterpolation",value:function setInterpolation(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message='unsupported interpolation for '+this.ValueTypeName+' keyframe track named '+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
  if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else {throw new Error(message);// fatal, in this case
  }}console.warn('THREE.KeyframeTrack:',message);return this;}this.createInterpolant=factoryMethod;return this;}},{key:"getInterpolation",value:function getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}}},{key:"getValueSize",value:function getValueSize(){return this.values.length/this.times.length;}// move all keyframes either forwards or backwards in time
  },{key:"shift",value:function shift(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var _i254=0,n=times.length;_i254!==n;++_i254){times[_i254]+=timeOffset;}}return this;}// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  },{key:"scale",value:function scale(timeScale){if(timeScale!==1.0){var times=this.times;for(var _i255=0,n=times.length;_i255!==n;++_i255){times[_i255]*=timeScale;}}return this;}// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  },{key:"trim",value:function trim(startTime,endTime){var times=this.times,nKeys=times.length;var from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
  if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
  if(from>=to){to=Math.max(to,1);from=to-1;}var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;}// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  },{key:"validate",value:function validate(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error('THREE.KeyframeTrack: Invalid value size in track.',this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error('THREE.KeyframeTrack: Track is empty.',this);valid=false;}var prevTime=null;for(var _i256=0;_i256!==nKeys;_i256++){var currTime=times[_i256];if(typeof currTime==='number'&&isNaN(currTime)){console.error('THREE.KeyframeTrack: Time is not a valid number.',this,_i256,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error('THREE.KeyframeTrack: Out of order keys.',this,_i256,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var _i257=0,n=values.length;_i257!==n;++_i257){var _value5=values[_i257];if(isNaN(_value5)){console.error('THREE.KeyframeTrack: Value is not a valid number.',this,_i257,_value5);valid=false;break;}}}}return valid;}// removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  },{key:"optimize",value:function optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
  var times=AnimationUtils.arraySlice(this.times),values=AnimationUtils.arraySlice(this.values),stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,lastIndex=times.length-1;var writeIndex=1;for(var _i258=1;_i258<lastIndex;++_i258){var keep=false;var time=times[_i258];var timeNext=times[_i258+1];// remove adjacent keyframes scheduled at the same time
  if(time!==timeNext&&(_i258!==1||time!==times[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
  var offset=_i258*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var _value6=values[offset+j];if(_value6!==values[offsetP+j]||_value6!==values[offsetN+j]){keep=true;break;}}}else {keep=true;}}// in-place compaction
  if(keep){if(_i258!==writeIndex){times[writeIndex]=times[_i258];var readOffset=_i258*stride,writeOffset=writeIndex*stride;for(var _j14=0;_j14!==stride;++_j14){values[writeOffset+_j14]=values[readOffset+_j14];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
  if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var _readOffset=lastIndex*stride,_writeOffset=writeIndex*stride,_j15=0;_j15!==stride;++_j15){values[_writeOffset+_j15]=values[_readOffset+_j15];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}else {this.times=times;this.values=values;}return this;}},{key:"clone",value:function clone(){var times=AnimationUtils.arraySlice(this.times,0);var values=AnimationUtils.arraySlice(this.values,0);var TypedKeyframeTrack=this.constructor;var track=new TypedKeyframeTrack(this.name,times,values);// Interpolant argument to constructor is not saved, so copy the factory method directly.
  track.createInterpolant=this.createInterpolant;return track;}}],[{key:"toJSON",value:function toJSON(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
  if(trackType.toJSON!==this.toJSON){json=trackType.toJSON(track);}else {// by default, we assume the data can be serialized as-is
  json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
  return json;}}]);return KeyframeTrack;}();KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;/**
   * A Track of Boolean keyframe values.
   */var BooleanKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack){_inherits(BooleanKeyframeTrack,_KeyframeTrack);var _super100=_createSuper(BooleanKeyframeTrack);function BooleanKeyframeTrack(){_classCallCheck(this,BooleanKeyframeTrack);return _super100.apply(this,arguments);}return _createClass(BooleanKeyframeTrack);}(KeyframeTrack);BooleanKeyframeTrack.prototype.ValueTypeName='bool';BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track of keyframe values that represent color.
   */var ColorKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack2){_inherits(ColorKeyframeTrack,_KeyframeTrack2);var _super101=_createSuper(ColorKeyframeTrack);function ColorKeyframeTrack(){_classCallCheck(this,ColorKeyframeTrack);return _super101.apply(this,arguments);}return _createClass(ColorKeyframeTrack);}(KeyframeTrack);ColorKeyframeTrack.prototype.ValueTypeName='color';/**
   * A Track of numeric keyframe values.
   */var NumberKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack3){_inherits(NumberKeyframeTrack,_KeyframeTrack3);var _super102=_createSuper(NumberKeyframeTrack);function NumberKeyframeTrack(){_classCallCheck(this,NumberKeyframeTrack);return _super102.apply(this,arguments);}return _createClass(NumberKeyframeTrack);}(KeyframeTrack);NumberKeyframeTrack.prototype.ValueTypeName='number';/**
   * Spherical linear unit quaternion interpolant.
   */var QuaternionLinearInterpolant=/*#__PURE__*/function(_Interpolant4){_inherits(QuaternionLinearInterpolant,_Interpolant4);var _super103=_createSuper(QuaternionLinearInterpolant);function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,QuaternionLinearInterpolant);return _super103.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}_createClass(QuaternionLinearInterpolant,[{key:"interpolate_",value:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,alpha=(t-t0)/(t1-t0);var offset=i1*stride;for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}}]);return QuaternionLinearInterpolant;}(Interpolant);/**
   * A Track of quaternion keyframe values.
   */var QuaternionKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack4){_inherits(QuaternionKeyframeTrack,_KeyframeTrack4);var _super104=_createSuper(QuaternionKeyframeTrack);function QuaternionKeyframeTrack(){_classCallCheck(this,QuaternionKeyframeTrack);return _super104.apply(this,arguments);}_createClass(QuaternionKeyframeTrack,[{key:"InterpolantFactoryMethodLinear",value:function InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);}}]);return QuaternionKeyframeTrack;}(KeyframeTrack);QuaternionKeyframeTrack.prototype.ValueTypeName='quaternion';// ValueBufferType is inherited
  QuaternionKeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track that interpolates Strings
   */var StringKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack5){_inherits(StringKeyframeTrack,_KeyframeTrack5);var _super105=_createSuper(StringKeyframeTrack);function StringKeyframeTrack(){_classCallCheck(this,StringKeyframeTrack);return _super105.apply(this,arguments);}return _createClass(StringKeyframeTrack);}(KeyframeTrack);StringKeyframeTrack.prototype.ValueTypeName='string';StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track of vectored keyframe values.
   */var VectorKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack6){_inherits(VectorKeyframeTrack,_KeyframeTrack6);var _super106=_createSuper(VectorKeyframeTrack);function VectorKeyframeTrack(){_classCallCheck(this,VectorKeyframeTrack);return _super106.apply(this,arguments);}return _createClass(VectorKeyframeTrack);}(KeyframeTrack);VectorKeyframeTrack.prototype.ValueTypeName='vector';var AnimationClip=/*#__PURE__*/function(){function AnimationClip(name){var duration=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-1;var tracks=arguments.length>2?arguments[2]:undefined;var blendMode=arguments.length>3&&arguments[3]!==undefined?arguments[3]:NormalAnimationBlendMode;_classCallCheck(this,AnimationClip);this.name=name;this.tracks=tracks;this.duration=duration;this.blendMode=blendMode;this.uuid=generateUUID();// this means it should figure out its duration by scanning the tracks
  if(this.duration<0){this.resetDuration();}}_createClass(AnimationClip,[{key:"resetDuration",value:function resetDuration(){var tracks=this.tracks;var duration=0;for(var _i259=0,n=tracks.length;_i259!==n;++_i259){var track=this.tracks[_i259];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;return this;}},{key:"trim",value:function trim(){for(var _i260=0;_i260<this.tracks.length;_i260++){this.tracks[_i260].trim(0,this.duration);}return this;}},{key:"validate",value:function validate(){var valid=true;for(var _i261=0;_i261<this.tracks.length;_i261++){valid=valid&&this.tracks[_i261].validate();}return valid;}},{key:"optimize",value:function optimize(){for(var _i262=0;_i262<this.tracks.length;_i262++){this.tracks[_i262].optimize();}return this;}},{key:"clone",value:function clone(){var tracks=[];for(var _i263=0;_i263<this.tracks.length;_i263++){tracks.push(this.tracks[_i263].clone());}return new this.constructor(this.name,this.duration,tracks,this.blendMode);}},{key:"toJSON",value:function toJSON(){return this.constructor.toJSON(this);}}],[{key:"parse",value:function parse(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var _i264=0,n=jsonTracks.length;_i264!==n;++_i264){tracks.push(parseKeyframeTrack(jsonTracks[_i264]).scale(frameTime));}var clip=new this(json.name,json.duration,tracks,json.blendMode);clip.uuid=json.uuid;return clip;}},{key:"toJSON",value:function toJSON(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks,'uuid':clip.uuid,'blendMode':clip.blendMode};for(var _i265=0,n=clipTracks.length;_i265!==n;++_i265){tracks.push(KeyframeTrack.toJSON(clipTracks[_i265]));}return json;}},{key:"CreateFromMorphTargetSequence",value:function CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var _i266=0;_i266<numMorphTargets;_i266++){var times=[];var values=[];times.push((_i266+numMorphTargets-1)%numMorphTargets,_i266,(_i266+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
  // last frame as well for perfect loop.
  if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[_i266].name+']',times,values).scale(1.0/fps));}return new this(name,-1,tracks);}},{key:"findByName",value:function findByName(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var _i267=0;_i267<clipArray.length;_i267++){if(clipArray[_i267].name===name){return clipArray[_i267];}}return null;}},{key:"CreateClipsFromMorphTargetSequences",value:function CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
  // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
  // patterns like Walk_001, Walk_002, Run_001, Run_002
  for(var _i268=0,il=morphTargets.length;_i268<il;_i268++){var morphTarget=morphTargets[_i268];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var _name4 in animationToMorphTargets){clips.push(this.CreateFromMorphTargetSequence(_name4,animationToMorphTargets[_name4],fps,noLoop));}return clips;}// parse the animation.hierarchy format
  },{key:"parseAnimation",value:function parseAnimation(animation,bones){if(!animation){console.error('THREE.AnimationClip: No animation in JSONLoader data.');return null;}var addNonemptyTrack=function addNonemptyTrack(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
  if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
  if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';var fps=animation.fps||30;var blendMode=animation.blendMode;// automatic length determination in AnimationClip.
  var duration=animation.length||-1;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
  if(!animationKeys||animationKeys.length===0)continue;// process morph targets
  if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
  var morphTargetNames={};var k=void 0;for(k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
  // morphTargetInfluences except for the keys in which
  // the morphTarget is named.
  for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var _m=0;_m!==animationKeys[k].morphTargets.length;++_m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else {// ...assume skeletal animation
  var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new this(clipName,duration,tracks,blendMode);return clip;}}]);return AnimationClip;}();function getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case'scalar':case'double':case'float':case'number':case'integer':return NumberKeyframeTrack;case'vector':case'vector2':case'vector3':case'vector4':return VectorKeyframeTrack;case'color':return ColorKeyframeTrack;case'quaternion':return QuaternionKeyframeTrack;case'bool':case'boolean':return BooleanKeyframeTrack;case'string':return StringKeyframeTrack;}throw new Error('THREE.KeyframeTrack: Unsupported typeName: '+typeName);}function parseKeyframeTrack(json){if(json.type===undefined){throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');}var trackType=getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
  if(trackType.parse!==undefined){return trackType.parse(json);}else {// by default, we assume a constructor compatible with the base
  return new trackType(json.name,json.times,json.values,json.interpolation);}}var Cache={enabled:false,files:{},add:function add(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
  this.files[key]=file;},get:function get(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
  return this.files[key];},remove:function remove(key){delete this.files[key];},clear:function clear(){this.files={};}};var LoadingManager=/*#__PURE__*/_createClass(function LoadingManager(onLoad,onProgress,onError){_classCallCheck(this,LoadingManager);var scope=this;var isLoading=false;var itemsLoaded=0;var itemsTotal=0;var urlModifier=undefined;var handlers=[];// Refer to #5689 for the reason why we don't set .onStart
  // in the constructor
  this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};this.resolveURL=function(url){if(urlModifier){return urlModifier(url);}return url;};this.setURLModifier=function(transform){urlModifier=transform;return this;};this.addHandler=function(regex,loader){handlers.push(regex,loader);return this;};this.removeHandler=function(regex){var index=handlers.indexOf(regex);if(index!==-1){handlers.splice(index,2);}return this;};this.getHandler=function(file){for(var _i269=0,l=handlers.length;_i269<l;_i269+=2){var regex=handlers[_i269];var loader=handlers[_i269+1];if(regex.global)regex.lastIndex=0;// see #17920
  if(regex.test(file)){return loader;}}return null;};});var DefaultLoadingManager=new LoadingManager();var Loader=/*#__PURE__*/function(){function Loader(manager){_classCallCheck(this,Loader);this.manager=manager!==undefined?manager:DefaultLoadingManager;this.crossOrigin='anonymous';this.withCredentials=false;this.path='';this.resourcePath='';this.requestHeader={};}_createClass(Loader,[{key:"load",value:function load(/* url, onLoad, onProgress, onError */){}},{key:"loadAsync",value:function loadAsync(url,onProgress){var scope=this;return new Promise(function(resolve,reject){scope.load(url,resolve,onProgress,reject);});}},{key:"parse",value:function parse(/* data */){}},{key:"setCrossOrigin",value:function setCrossOrigin(crossOrigin){this.crossOrigin=crossOrigin;return this;}},{key:"setWithCredentials",value:function setWithCredentials(value){this.withCredentials=value;return this;}},{key:"setPath",value:function setPath(path){this.path=path;return this;}},{key:"setResourcePath",value:function setResourcePath(resourcePath){this.resourcePath=resourcePath;return this;}},{key:"setRequestHeader",value:function setRequestHeader(requestHeader){this.requestHeader=requestHeader;return this;}}]);return Loader;}();var loading={};var FileLoader=/*#__PURE__*/function(_Loader){_inherits(FileLoader,_Loader);var _super107=_createSuper(FileLoader);function FileLoader(manager){_classCallCheck(this,FileLoader);return _super107.call(this,manager);}_createClass(FileLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check if request is duplicate
  if(loading[url]!==undefined){loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});return;}// Check for data: URI
  var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);var request;// Safari can not handle Data URIs through XMLHttpRequest so process manually
  if(dataUriRegexResult){var mimeType=dataUriRegexResult[1];var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=decodeURIComponent(data);if(isBase64)data=atob(data);try{var response;var responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':var view=new Uint8Array(data.length);for(var _i270=0;_i270<data.length;_i270++){view[_i270]=data.charCodeAt(_i270);}if(responseType==='blob'){response=new Blob([view.buffer],{type:mimeType});}else {response=view.buffer;}break;case'document':var parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
  response=data;break;}// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  setTimeout(function(){if(onError)onError(error);scope.manager.itemError(url);scope.manager.itemEnd(url);},0);}}else {// Initialise array for duplicate requests
  loading[url]=[];loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=this.response;var callbacks=loading[url];delete loading[url];if(this.status===200||this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
  // e.g. 'file://' or 'data://'. Handle as success.
  if(this.status===0)console.warn('THREE.FileLoader: HTTP Status 0 received.');// Add to cache only on HTTP success, so that we do not cache
  // error response bodies as proper responses to requests.
  Cache.add(url,response);for(var _i271=0,il=callbacks.length;_i271<il;_i271++){var callback=callbacks[_i271];if(callback.onLoad)callback.onLoad(response);}scope.manager.itemEnd(url);}else {for(var _i272=0,_il18=callbacks.length;_i272<_il18;_i272++){var _callback=callbacks[_i272];if(_callback.onError)_callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);}},false);request.addEventListener('progress',function(event){var callbacks=loading[url];for(var _i273=0,il=callbacks.length;_i273<il;_i273++){var callback=callbacks[_i273];if(callback.onProgress)callback.onProgress(event);}},false);request.addEventListener('error',function(event){var callbacks=loading[url];delete loading[url];for(var _i274=0,il=callbacks.length;_i274<il;_i274++){var callback=callbacks[_i274];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);},false);request.addEventListener('abort',function(event){var callbacks=loading[url];delete loading[url];for(var _i275=0,il=callbacks.length;_i275<il;_i275++){var callback=callbacks[_i275];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');for(var header in this.requestHeader){request.setRequestHeader(header,this.requestHeader[header]);}request.send(null);}scope.manager.itemStart(url);return request;}},{key:"setResponseType",value:function setResponseType(value){this.responseType=value;return this;}},{key:"setMimeType",value:function setMimeType(value){this.mimeType=value;return this;}}]);return FileLoader;}(Loader);/**
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */var CompressedTextureLoader=/*#__PURE__*/function(_Loader3){_inherits(CompressedTextureLoader,_Loader3);var _super109=_createSuper(CompressedTextureLoader);function CompressedTextureLoader(manager){_classCallCheck(this,CompressedTextureLoader);return _super109.call(this,manager);}_createClass(CompressedTextureLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){var scope=this;var images=[];var texture=new CompressedTexture();var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType('arraybuffer');loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(scope.withCredentials);var loaded=0;function loadTexture(i){loader.load(url[i],function(buffer){var texDatas=scope.parse(buffer,true);images[i]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps};loaded+=1;if(loaded===6){if(texDatas.mipmapCount===1)texture.minFilter=LinearFilter;texture.image=images;texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);}},onProgress,onError);}if(Array.isArray(url)){for(var _i277=0,il=url.length;_i277<il;++_i277){loadTexture(_i277);}}else {// compressed cubemap texture stored in a single DDS file
  loader.load(url,function(buffer){var texDatas=scope.parse(buffer,true);if(texDatas.isCubemap){var faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(var f=0;f<faces;f++){images[f]={mipmaps:[]};for(var _i278=0;_i278<texDatas.mipmapCount;_i278++){images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+_i278]);images[f].format=texDatas.format;images[f].width=texDatas.width;images[f].height=texDatas.height;}}texture.image=images;}else {texture.image.width=texDatas.width;texture.image.height=texDatas.height;texture.mipmaps=texDatas.mipmaps;}if(texDatas.mipmapCount===1){texture.minFilter=LinearFilter;}texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);},onProgress,onError);}return texture;}}]);return CompressedTextureLoader;}(Loader);var ImageLoader=/*#__PURE__*/function(_Loader4){_inherits(ImageLoader,_Loader4);var _super110=_createSuper(ImageLoader);function ImageLoader(manager){_classCallCheck(this,ImageLoader);return _super110.call(this,manager);}_createClass(ImageLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=createElementNS('img');function onImageLoad(){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);}function onImageError(event){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);if(onError)onError(event);scope.manager.itemError(url);scope.manager.itemEnd(url);}image.addEventListener('load',onImageLoad,false);image.addEventListener('error',onImageError,false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;}}]);return ImageLoader;}(Loader);var CubeTextureLoader=/*#__PURE__*/function(_Loader5){_inherits(CubeTextureLoader,_Loader5);var _super111=_createSuper(CubeTextureLoader);function CubeTextureLoader(manager){_classCallCheck(this,CubeTextureLoader);return _super111.call(this,manager);}_createClass(CubeTextureLoader,[{key:"load",value:function load(urls,onLoad,onProgress,onError){var texture=new CubeTexture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(var _i279=0;_i279<urls.length;++_i279){loadTexture(_i279);}return texture;}}]);return CubeTextureLoader;}(Loader);var TextureLoader=/*#__PURE__*/function(_Loader7){_inherits(TextureLoader,_Loader7);var _super113=_createSuper(TextureLoader);function TextureLoader(manager){_classCallCheck(this,TextureLoader);return _super113.call(this,manager);}_createClass(TextureLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){var texture=new Texture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){texture.image=image;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;}}]);return TextureLoader;}(Loader);var Light=/*#__PURE__*/function(_Object3D11){_inherits(Light,_Object3D11);var _super114=_createSuper(Light);function Light(color){var _this88;var intensity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;_classCallCheck(this,Light);_this88=_super114.call(this);_this88.type='Light';_this88.color=new Color$2(color);_this88.intensity=intensity;return _this88;}_createClass(Light,[{key:"dispose",value:function dispose(){// Empty here in base class; some subclasses override.
  }},{key:"copy",value:function copy(source){_get(_getPrototypeOf(Light.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.intensity=source.intensity;return this;}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(Light.prototype),"toJSON",this).call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}}]);return Light;}(Object3D$1);Light.prototype.isLight=true;var _projScreenMatrix$1=/*@__PURE__*/new Matrix4$1();var _lightPositionWorld$1=/*@__PURE__*/new Vector3();var _lookTarget$1=/*@__PURE__*/new Vector3();var LightShadow=/*#__PURE__*/function(){function LightShadow(camera){_classCallCheck(this,LightShadow);this.camera=camera;this.bias=0;this.normalBias=0;this.radius=1;this.blurSamples=8;this.mapSize=new Vector2(512,512);this.map=null;this.mapPass=null;this.matrix=new Matrix4$1();this.autoUpdate=true;this.needsUpdate=false;this._frustum=new Frustum();this._frameExtents=new Vector2(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)];}_createClass(LightShadow,[{key:"getViewportCount",value:function getViewportCount(){return this._viewportCount;}},{key:"getFrustum",value:function getFrustum(){return this._frustum;}},{key:"updateMatrices",value:function updateMatrices(light){var shadowCamera=this.camera;var shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld$1);_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget$1);shadowCamera.updateMatrixWorld();_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);}},{key:"getViewport",value:function getViewport(viewportIndex){return this._viewports[viewportIndex];}},{key:"getFrameExtents",value:function getFrameExtents(){return this._frameExtents;}},{key:"dispose",value:function dispose(){if(this.map){this.map.dispose();}if(this.mapPass){this.mapPass.dispose();}}},{key:"copy",value:function copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"toJSON",value:function toJSON(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.normalBias!==0)object.normalBias=this.normalBias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}}]);return LightShadow;}();var SpotLightShadow=/*#__PURE__*/function(_LightShadow){_inherits(SpotLightShadow,_LightShadow);var _super116=_createSuper(SpotLightShadow);function SpotLightShadow(){var _this90;_classCallCheck(this,SpotLightShadow);_this90=_super116.call(this,new PerspectiveCamera(50,1,0.5,500));_this90.focus=1;return _this90;}_createClass(SpotLightShadow,[{key:"updateMatrices",value:function updateMatrices(light){var camera=this.camera;var fov=RAD2DEG*2*light.angle*this.focus;var aspect=this.mapSize.width/this.mapSize.height;var far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}_get(_getPrototypeOf(SpotLightShadow.prototype),"updateMatrices",this).call(this,light);}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(SpotLightShadow.prototype),"copy",this).call(this,source);this.focus=source.focus;return this;}}]);return SpotLightShadow;}(LightShadow);SpotLightShadow.prototype.isSpotLightShadow=true;var SpotLight=/*#__PURE__*/function(_Light2){_inherits(SpotLight,_Light2);var _super117=_createSuper(SpotLight);function SpotLight(color,intensity){var _this91;var distance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var angle=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Math.PI/3;var penumbra=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var decay=arguments.length>5&&arguments[5]!==undefined?arguments[5]:1;_classCallCheck(this,SpotLight);_this91=_super117.call(this,color,intensity);_this91.type='SpotLight';_this91.position.copy(Object3D$1.DefaultUp);_this91.updateMatrix();_this91.target=new Object3D$1();_this91.distance=distance;_this91.angle=angle;_this91.penumbra=penumbra;_this91.decay=decay;// for physically correct lights, should be 2.
  _this91.shadow=new SpotLightShadow();return _this91;}_createClass(SpotLight,[{key:"power",get:function get(){// compute the light's luminous power (in lumens) from its intensity (in candela)
  // by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
  return this.intensity*Math.PI;},set:function set(power){// set the light's intensity (in candela) from the desired luminous power (in lumens)
  this.intensity=power/Math.PI;}},{key:"dispose",value:function dispose(){this.shadow.dispose();}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(SpotLight.prototype),"copy",this).call(this,source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}]);return SpotLight;}(Light);SpotLight.prototype.isSpotLight=true;var _projScreenMatrix=/*@__PURE__*/new Matrix4$1();var _lightPositionWorld=/*@__PURE__*/new Vector3();var _lookTarget=/*@__PURE__*/new Vector3();var PointLightShadow=/*#__PURE__*/function(_LightShadow2){_inherits(PointLightShadow,_LightShadow2);var _super118=_createSuper(PointLightShadow);function PointLightShadow(){var _this92;_classCallCheck(this,PointLightShadow);_this92=_super118.call(this,new PerspectiveCamera(90,1,0.5,500));_this92._frameExtents=new Vector2(4,2);_this92._viewportCount=6;_this92._viewports=[// These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction
  // positive X
  new Vector4(2,1,1,1),// negative X
  new Vector4(0,1,1,1),// positive Z
  new Vector4(3,1,1,1),// negative Z
  new Vector4(1,1,1,1),// positive Y
  new Vector4(3,0,1,1),// negative Y
  new Vector4(1,0,1,1)];_this92._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];_this92._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];return _this92;}_createClass(PointLightShadow,[{key:"updateMatrices",value:function updateMatrices(light){var viewportIndex=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var camera=this.camera;var shadowMatrix=this.matrix;var far=light.distance||camera.far;if(far!==camera.far){camera.far=far;camera.updateProjectionMatrix();}_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);camera.position.copy(_lightPositionWorld);_lookTarget.copy(camera.position);_lookTarget.add(this._cubeDirections[viewportIndex]);camera.up.copy(this._cubeUps[viewportIndex]);camera.lookAt(_lookTarget);camera.updateMatrixWorld();shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix);}}]);return PointLightShadow;}(LightShadow);PointLightShadow.prototype.isPointLightShadow=true;var PointLight=/*#__PURE__*/function(_Light3){_inherits(PointLight,_Light3);var _super119=_createSuper(PointLight);function PointLight(color,intensity){var _this93;var distance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var decay=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,PointLight);_this93=_super119.call(this,color,intensity);_this93.type='PointLight';_this93.distance=distance;_this93.decay=decay;// for physically correct lights, should be 2.
  _this93.shadow=new PointLightShadow();return _this93;}_createClass(PointLight,[{key:"power",get:function get(){// compute the light's luminous power (in lumens) from its intensity (in candela)
  // for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
  return this.intensity*4*Math.PI;},set:function set(power){// set the light's intensity (in candela) from the desired luminous power (in lumens)
  this.intensity=power/(4*Math.PI);}},{key:"dispose",value:function dispose(){this.shadow.dispose();}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(PointLight.prototype),"copy",this).call(this,source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}}]);return PointLight;}(Light);PointLight.prototype.isPointLight=true;var DirectionalLightShadow=/*#__PURE__*/function(_LightShadow3){_inherits(DirectionalLightShadow,_LightShadow3);var _super120=_createSuper(DirectionalLightShadow);function DirectionalLightShadow(){_classCallCheck(this,DirectionalLightShadow);return _super120.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));}return _createClass(DirectionalLightShadow);}(LightShadow);DirectionalLightShadow.prototype.isDirectionalLightShadow=true;var DirectionalLight=/*#__PURE__*/function(_Light4){_inherits(DirectionalLight,_Light4);var _super121=_createSuper(DirectionalLight);function DirectionalLight(color,intensity){var _this94;_classCallCheck(this,DirectionalLight);_this94=_super121.call(this,color,intensity);_this94.type='DirectionalLight';_this94.position.copy(Object3D$1.DefaultUp);_this94.updateMatrix();_this94.target=new Object3D$1();_this94.shadow=new DirectionalLightShadow();return _this94;}_createClass(DirectionalLight,[{key:"dispose",value:function dispose(){this.shadow.dispose();}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(DirectionalLight.prototype),"copy",this).call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}]);return DirectionalLight;}(Light);DirectionalLight.prototype.isDirectionalLight=true;var AmbientLight=/*#__PURE__*/function(_Light5){_inherits(AmbientLight,_Light5);var _super122=_createSuper(AmbientLight);function AmbientLight(color,intensity){var _this95;_classCallCheck(this,AmbientLight);_this95=_super122.call(this,color,intensity);_this95.type='AmbientLight';return _this95;}return _createClass(AmbientLight);}(Light);AmbientLight.prototype.isAmbientLight=true;var SphericalHarmonics3=/*#__PURE__*/function(){function SphericalHarmonics3(){_classCallCheck(this,SphericalHarmonics3);this.coefficients=[];for(var _i280=0;_i280<9;_i280++){this.coefficients.push(new Vector3());}}_createClass(SphericalHarmonics3,[{key:"set",value:function set(coefficients){for(var _i281=0;_i281<9;_i281++){this.coefficients[_i281].copy(coefficients[_i281]);}return this;}},{key:"zero",value:function zero(){for(var _i282=0;_i282<9;_i282++){this.coefficients[_i282].set(0,0,0);}return this;}// get the radiance in the direction of the normal
  // target is a Vector3
  },{key:"getAt",value:function getAt(normal,target){// normal is assumed to be unit length
  var x=normal.x,y=normal.y,z=normal.z;var coeff=this.coefficients;// band 0
  target.copy(coeff[0]).multiplyScalar(0.282095);// band 1
  target.addScaledVector(coeff[1],0.488603*y);target.addScaledVector(coeff[2],0.488603*z);target.addScaledVector(coeff[3],0.488603*x);// band 2
  target.addScaledVector(coeff[4],1.092548*(x*y));target.addScaledVector(coeff[5],1.092548*(y*z));target.addScaledVector(coeff[6],0.315392*(3.0*z*z-1.0));target.addScaledVector(coeff[7],1.092548*(x*z));target.addScaledVector(coeff[8],0.546274*(x*x-y*y));return target;}// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  },{key:"getIrradianceAt",value:function getIrradianceAt(normal,target){// normal is assumed to be unit length
  var x=normal.x,y=normal.y,z=normal.z;var coeff=this.coefficients;// band 0
  target.copy(coeff[0]).multiplyScalar(0.886227);// π * 0.282095
  // band 1
  target.addScaledVector(coeff[1],2.0*0.511664*y);// ( 2 * π / 3 ) * 0.488603
  target.addScaledVector(coeff[2],2.0*0.511664*z);target.addScaledVector(coeff[3],2.0*0.511664*x);// band 2
  target.addScaledVector(coeff[4],2.0*0.429043*x*y);// ( π / 4 ) * 1.092548
  target.addScaledVector(coeff[5],2.0*0.429043*y*z);target.addScaledVector(coeff[6],0.743125*z*z-0.247708);// ( π / 4 ) * 0.315392 * 3
  target.addScaledVector(coeff[7],2.0*0.429043*x*z);target.addScaledVector(coeff[8],0.429043*(x*x-y*y));// ( π / 4 ) * 0.546274
  return target;}},{key:"add",value:function add(sh){for(var _i283=0;_i283<9;_i283++){this.coefficients[_i283].add(sh.coefficients[_i283]);}return this;}},{key:"addScaledSH",value:function addScaledSH(sh,s){for(var _i284=0;_i284<9;_i284++){this.coefficients[_i284].addScaledVector(sh.coefficients[_i284],s);}return this;}},{key:"scale",value:function scale(s){for(var _i285=0;_i285<9;_i285++){this.coefficients[_i285].multiplyScalar(s);}return this;}},{key:"lerp",value:function lerp(sh,alpha){for(var _i286=0;_i286<9;_i286++){this.coefficients[_i286].lerp(sh.coefficients[_i286],alpha);}return this;}},{key:"equals",value:function equals(sh){for(var _i287=0;_i287<9;_i287++){if(!this.coefficients[_i287].equals(sh.coefficients[_i287])){return false;}}return true;}},{key:"copy",value:function copy(sh){return this.set(sh.coefficients);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var coefficients=this.coefficients;for(var _i288=0;_i288<9;_i288++){coefficients[_i288].fromArray(array,offset+_i288*3);}return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var coefficients=this.coefficients;for(var _i289=0;_i289<9;_i289++){coefficients[_i289].toArray(array,offset+_i289*3);}return array;}// evaluate the basis functions
  // shBasis is an Array[ 9 ]
  }],[{key:"getBasisAt",value:function getBasisAt(normal,shBasis){// normal is assumed to be unit length
  var x=normal.x,y=normal.y,z=normal.z;// band 0
  shBasis[0]=0.282095;// band 1
  shBasis[1]=0.488603*y;shBasis[2]=0.488603*z;shBasis[3]=0.488603*x;// band 2
  shBasis[4]=1.092548*x*y;shBasis[5]=1.092548*y*z;shBasis[6]=0.315392*(3*z*z-1);shBasis[7]=1.092548*x*z;shBasis[8]=0.546274*(x*x-y*y);}}]);return SphericalHarmonics3;}();SphericalHarmonics3.prototype.isSphericalHarmonics3=true;var LightProbe=/*#__PURE__*/function(_Light7){_inherits(LightProbe,_Light7);var _super124=_createSuper(LightProbe);function LightProbe(){var _this97;var sh=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new SphericalHarmonics3();var intensity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;_classCallCheck(this,LightProbe);_this97=_super124.call(this,undefined,intensity);_this97.sh=sh;return _this97;}_createClass(LightProbe,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(LightProbe.prototype),"copy",this).call(this,source);this.sh.copy(source.sh);return this;}},{key:"fromJSON",value:function fromJSON(json){this.intensity=json.intensity;// TODO: Move this bit to Light.fromJSON();
  this.sh.fromArray(json.sh);return this;}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(LightProbe.prototype),"toJSON",this).call(this,meta);data.object.sh=this.sh.toArray();return data;}}]);return LightProbe;}(Light);LightProbe.prototype.isLightProbe=true;var LoaderUtils=/*#__PURE__*/function(){function LoaderUtils(){_classCallCheck(this,LoaderUtils);}_createClass(LoaderUtils,null,[{key:"decodeText",value:function decodeText(array){if(typeof TextDecoder!=='undefined'){return new TextDecoder().decode(array);}// Avoid the String.fromCharCode.apply(null, array) shortcut, which
  // throws a "maximum call stack size exceeded" error for large arrays.
  var s='';for(var _i290=0,il=array.length;_i290<il;_i290++){// Implicitly assumes little-endian.
  s+=String.fromCharCode(array[_i290]);}try{// merges multi-byte utf-8 characters.
  return decodeURIComponent(escape(s));}catch(e){// see #16358
  return s;}}},{key:"extractUrlBase",value:function extractUrlBase(url){var index=url.lastIndexOf('/');if(index===-1)return './';return url.substr(0,index+1);}}]);return LoaderUtils;}();var ImageBitmapLoader=/*#__PURE__*/function(_Loader11){_inherits(ImageBitmapLoader,_Loader11);var _super129=_createSuper(ImageBitmapLoader);function ImageBitmapLoader(manager){var _this100;_classCallCheck(this,ImageBitmapLoader);_this100=_super129.call(this,manager);if(typeof createImageBitmap==='undefined'){console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');}if(typeof fetch==='undefined'){console.warn('THREE.ImageBitmapLoader: fetch() not supported.');}_this100.options={premultiplyAlpha:'none'};return _this100;}_createClass(ImageBitmapLoader,[{key:"setOptions",value:function setOptions(options){this.options=options;return this;}},{key:"load",value:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var fetchOptions={};fetchOptions.credentials=this.crossOrigin==='anonymous'?'same-origin':'include';fetchOptions.headers=this.requestHeader;fetch(url,fetchOptions).then(function(res){return res.blob();}).then(function(blob){return createImageBitmap(blob,Object.assign(scope.options,{colorSpaceConversion:'none'}));}).then(function(imageBitmap){Cache.add(url,imageBitmap);if(onLoad)onLoad(imageBitmap);scope.manager.itemEnd(url);})["catch"](function(e){if(onError)onError(e);scope.manager.itemError(url);scope.manager.itemEnd(url);});scope.manager.itemStart(url);}}]);return ImageBitmapLoader;}(Loader);ImageBitmapLoader.prototype.isImageBitmapLoader=true;var _context;var AudioContext={getContext:function getContext(){if(_context===undefined){_context=new(window.AudioContext||window.webkitAudioContext)();}return _context;},setContext:function setContext(value){_context=value;}};var AudioLoader=/*#__PURE__*/function(_Loader12){_inherits(AudioLoader,_Loader12);var _super130=_createSuper(AudioLoader);function AudioLoader(manager){_classCallCheck(this,AudioLoader);return _super130.call(this,manager);}_createClass(AudioLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(buffer){try{// Create a copy of the buffer. The `decodeAudioData` method
  // detaches the buffer when complete, preventing reuse.
  var bufferCopy=buffer.slice(0);var context=AudioContext.getContext();context.decodeAudioData(bufferCopy,function(audioBuffer){onLoad(audioBuffer);});}catch(e){if(onError){onError(e);}else {console.error(e);}scope.manager.itemError(url);}},onProgress,onError);}}]);return AudioLoader;}(Loader);var HemisphereLightProbe=/*#__PURE__*/function(_LightProbe){_inherits(HemisphereLightProbe,_LightProbe);var _super131=_createSuper(HemisphereLightProbe);function HemisphereLightProbe(skyColor,groundColor){var _this101;var intensity=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;_classCallCheck(this,HemisphereLightProbe);_this101=_super131.call(this,undefined,intensity);var color1=new Color$2().set(skyColor);var color2=new Color$2().set(groundColor);var sky=new Vector3(color1.r,color1.g,color1.b);var ground=new Vector3(color2.r,color2.g,color2.b);// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
  var c0=Math.sqrt(Math.PI);var c1=c0*Math.sqrt(0.75);_this101.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);_this101.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);return _this101;}return _createClass(HemisphereLightProbe);}(LightProbe);HemisphereLightProbe.prototype.isHemisphereLightProbe=true;var AmbientLightProbe=/*#__PURE__*/function(_LightProbe2){_inherits(AmbientLightProbe,_LightProbe2);var _super132=_createSuper(AmbientLightProbe);function AmbientLightProbe(color){var _this102;var intensity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;_classCallCheck(this,AmbientLightProbe);_this102=_super132.call(this,undefined,intensity);var color1=new Color$2().set(color);// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
  _this102.sh.coefficients[0].set(color1.r,color1.g,color1.b).multiplyScalar(2*Math.sqrt(Math.PI));return _this102;}return _createClass(AmbientLightProbe);}(LightProbe);AmbientLightProbe.prototype.isAmbientLightProbe=true;var Clock=/*#__PURE__*/function(){function Clock(){var autoStart=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;_classCallCheck(this,Clock);this.autoStart=autoStart;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}_createClass(Clock,[{key:"start",value:function start(){this.startTime=now$2();this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;}},{key:"stop",value:function stop(){this.getElapsedTime();this.running=false;this.autoStart=false;}},{key:"getElapsedTime",value:function getElapsedTime(){this.getDelta();return this.elapsedTime;}},{key:"getDelta",value:function getDelta(){var diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){var newTime=now$2();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}}]);return Clock;}();function now$2(){return (typeof performance==='undefined'?Date:performance).now();// see #10732
  }var Audio=/*#__PURE__*/function(_Object3D13){_inherits(Audio,_Object3D13);var _super134=_createSuper(Audio);function Audio(listener){var _this104;_classCallCheck(this,Audio);_this104=_super134.call(this);_this104.type='Audio';_this104.listener=listener;_this104.context=listener.context;_this104.gain=_this104.context.createGain();_this104.gain.connect(listener.getInput());_this104.autoplay=false;_this104.buffer=null;_this104.detune=0;_this104.loop=false;_this104.loopStart=0;_this104.loopEnd=0;_this104.offset=0;_this104.duration=undefined;_this104.playbackRate=1;_this104.isPlaying=false;_this104.hasPlaybackControl=true;_this104.source=null;_this104.sourceType='empty';_this104._startedAt=0;_this104._progress=0;_this104._connected=false;_this104.filters=[];return _this104;}_createClass(Audio,[{key:"getOutput",value:function getOutput(){return this.gain;}},{key:"setNodeSource",value:function setNodeSource(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;}},{key:"setMediaElementSource",value:function setMediaElementSource(mediaElement){this.hasPlaybackControl=false;this.sourceType='mediaNode';this.source=this.context.createMediaElementSource(mediaElement);this.connect();return this;}},{key:"setMediaStreamSource",value:function setMediaStreamSource(mediaStream){this.hasPlaybackControl=false;this.sourceType='mediaStreamNode';this.source=this.context.createMediaStreamSource(mediaStream);this.connect();return this;}},{key:"setBuffer",value:function setBuffer(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;}},{key:"play",value:function play(){var delay=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._startedAt=this.context.currentTime+delay;var source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.loopStart=this.loopStart;source.loopEnd=this.loopEnd;source.onended=this.onEnded.bind(this);source.start(this._startedAt,this._progress+this.offset,this.duration);this.isPlaying=true;this.source=source;this.setDetune(this.detune);this.setPlaybackRate(this.playbackRate);return this.connect();}},{key:"pause",value:function pause(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}if(this.isPlaying===true){// update current progress
  this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate;if(this.loop===true){// ensure _progress does not exceed duration with looped audios
  this._progress=this._progress%(this.duration||this.buffer.duration);}this.source.stop();this.source.onended=null;this.isPlaying=false;}return this;}},{key:"stop",value:function stop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._progress=0;this.source.stop();this.source.onended=null;this.isPlaying=false;return this;}},{key:"connect",value:function connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var _i304=1,l=this.filters.length;_i304<l;_i304++){this.filters[_i304-1].connect(this.filters[_i304]);}this.filters[this.filters.length-1].connect(this.getOutput());}else {this.source.connect(this.getOutput());}this._connected=true;return this;}},{key:"disconnect",value:function disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var _i305=1,l=this.filters.length;_i305<l;_i305++){this.filters[_i305-1].disconnect(this.filters[_i305]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else {this.source.disconnect(this.getOutput());}this._connected=false;return this;}},{key:"getFilters",value:function getFilters(){return this.filters;}},{key:"setFilters",value:function setFilters(value){if(!value)value=[];if(this._connected===true){this.disconnect();this.filters=value.slice();this.connect();}else {this.filters=value.slice();}return this;}},{key:"setDetune",value:function setDetune(value){this.detune=value;if(this.source.detune===undefined)return;// only set detune when available
  if(this.isPlaying===true){this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,0.01);}return this;}},{key:"getDetune",value:function getDetune(){return this.detune;}},{key:"getFilter",value:function getFilter(){return this.getFilters()[0];}},{key:"setFilter",value:function setFilter(filter){return this.setFilters(filter?[filter]:[]);}},{key:"setPlaybackRate",value:function setPlaybackRate(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,0.01);}return this;}},{key:"getPlaybackRate",value:function getPlaybackRate(){return this.playbackRate;}},{key:"onEnded",value:function onEnded(){this.isPlaying=false;}},{key:"getLoop",value:function getLoop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;}},{key:"setLoop",value:function setLoop(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;}},{key:"setLoopStart",value:function setLoopStart(value){this.loopStart=value;return this;}},{key:"setLoopEnd",value:function setLoopEnd(value){this.loopEnd=value;return this;}},{key:"getVolume",value:function getVolume(){return this.gain.gain.value;}},{key:"setVolume",value:function setVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);return this;}}]);return Audio;}(Object3D$1);var _RESERVED_CHARS_RE='\\[\\]\\.:\\/';var _reservedRe=new RegExp('['+_RESERVED_CHARS_RE+']','g');// Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  var _wordChar='[^'+_RESERVED_CHARS_RE+']';var _wordCharOrDot='[^'+_RESERVED_CHARS_RE.replace('\\.','')+']';// Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  var _directoryRe=/((?:WC+[\/:])*)/.source.replace('WC',_wordChar);// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  var _nodeRe=/(WCOD+)?/.source.replace('WCOD',_wordCharOrDot);// Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  var _objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC',_wordChar);// Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  var _propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace('WC',_wordChar);var _trackRe=new RegExp(''+'^'+_directoryRe+_nodeRe+_objectRe+_propertyRe+'$');var _supportedObjectNames=['material','materials','bones'];var Composite=/*#__PURE__*/function(){function Composite(targetGroup,path,optionalParsedPath){_classCallCheck(this,Composite);var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);}_createClass(Composite,[{key:"getValue",value:function getValue(array,offset){this.bind();// bind all binding
  var firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
  if(binding!==undefined)binding.getValue(array,offset);}},{key:"setValue",value:function setValue(array,offset){var bindings=this._bindings;for(var _i315=this._targetGroup.nCachedObjects_,n=bindings.length;_i315!==n;++_i315){bindings[_i315].setValue(array,offset);}}},{key:"bind",value:function bind(){var bindings=this._bindings;for(var _i316=this._targetGroup.nCachedObjects_,n=bindings.length;_i316!==n;++_i316){bindings[_i316].bind();}}},{key:"unbind",value:function unbind(){var bindings=this._bindings;for(var _i317=this._targetGroup.nCachedObjects_,n=bindings.length;_i317!==n;++_i317){bindings[_i317].unbind();}}}]);return Composite;}();// Note: This class uses a State pattern on a per-method basis:
  // 'bind' sets 'this.getValue' / 'setValue' and shadows the
  // prototype version of these methods with one that represents
  // the bound state. When the property is not found, the methods
  // become no-ops.
  var PropertyBinding=/*#__PURE__*/function(){function PropertyBinding(rootNode,path,parsedPath){_classCallCheck(this,PropertyBinding);this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;// initial state of these methods that calls 'bind'
  this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}_createClass(PropertyBinding,[{key:"_getValue_unavailable",value:// these are used to "bind" a nonexistent property
  function _getValue_unavailable(){}},{key:"_setValue_unavailable",value:function _setValue_unavailable(){}// Getters
  },{key:"_getValue_direct",value:function _getValue_direct(buffer,offset){buffer[offset]=this.targetObject[this.propertyName];}},{key:"_getValue_array",value:function _getValue_array(buffer,offset){var source=this.resolvedProperty;for(var _i318=0,n=source.length;_i318!==n;++_i318){buffer[offset++]=source[_i318];}}},{key:"_getValue_arrayElement",value:function _getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];}},{key:"_getValue_toArray",value:function _getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}// Direct
  },{key:"_setValue_direct",value:function _setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];}},{key:"_setValue_direct_setNeedsUpdate",value:function _setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;}},{key:"_setValue_direct_setMatrixWorldNeedsUpdate",value:function _setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}// EntireArray
  },{key:"_setValue_array",value:function _setValue_array(buffer,offset){var dest=this.resolvedProperty;for(var _i319=0,n=dest.length;_i319!==n;++_i319){dest[_i319]=buffer[offset++];}}},{key:"_setValue_array_setNeedsUpdate",value:function _setValue_array_setNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var _i320=0,n=dest.length;_i320!==n;++_i320){dest[_i320]=buffer[offset++];}this.targetObject.needsUpdate=true;}},{key:"_setValue_array_setMatrixWorldNeedsUpdate",value:function _setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var _i321=0,n=dest.length;_i321!==n;++_i321){dest[_i321]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}// ArrayElement
  },{key:"_setValue_arrayElement",value:function _setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];}},{key:"_setValue_arrayElement_setNeedsUpdate",value:function _setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;}},{key:"_setValue_arrayElement_setMatrixWorldNeedsUpdate",value:function _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}// HasToFromArray
  },{key:"_setValue_fromArray",value:function _setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);}},{key:"_setValue_fromArray_setNeedsUpdate",value:function _setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;}},{key:"_setValue_fromArray_setMatrixWorldNeedsUpdate",value:function _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}},{key:"_getValue_unbound",value:function _getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);}},{key:"_setValue_unbound",value:function _setValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);}// create getter / setter pair for a property in the scene graph
  },{key:"bind",value:function bind(){var targetObject=this.node;var parsedPath=this.parsedPath;var objectName=parsedPath.objectName;var propertyName=parsedPath.propertyName;var propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
  this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
  if(!targetObject){console.error('THREE.PropertyBinding: Trying to update node for track: '+this.path+' but it wasn\'t found.');return;}if(objectName){var objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
  switch(objectName){case'materials':if(!targetObject.material){console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.',this);return;}if(!targetObject.material.materials){console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
  // and convert the integer string to a true integer.
  targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
  for(var _i322=0;_i322<targetObject.length;_i322++){if(targetObject[_i322].name===objectIndex){objectIndex=_i322;break;}}break;default:if(targetObject[objectName]===undefined){console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
  var nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){var nodeName=parsedPath.nodeName;console.error('THREE.PropertyBinding: Trying to update property for track: '+nodeName+'.'+propertyName+' but it wasn\'t found.',targetObject);return;}// determine versioning scheme
  var versioning=this.Versioning.None;this.targetObject=targetObject;if(targetObject.needsUpdate!==undefined){// material
  versioning=this.Versioning.NeedsUpdate;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
  versioning=this.Versioning.MatrixWorldNeedsUpdate;}// determine how the property gets bound
  var bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
  if(propertyName==='morphTargetInfluences'){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
  // support resolving morphTarget names into indices.
  if(!targetObject.geometry){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',this);return;}if(targetObject.geometry.isBufferGeometry){if(!targetObject.geometry.morphAttributes){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',this);return;}if(targetObject.morphTargetDictionary[propertyIndex]!==undefined){propertyIndex=targetObject.morphTargetDictionary[propertyIndex];}}else {console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',this);return;}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
  bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if(Array.isArray(nodeProperty)){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else {this.propertyName=propertyName;}// select getter / setter
  this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];}},{key:"unbind",value:function unbind(){this.node=null;// back to the prototype version of getValue / setValue
  // note: avoiding to mutate the shape of 'this' via 'delete'
  this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}}],[{key:"create",value:function create(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else {return new PropertyBinding.Composite(root,path,parsedPath);}}/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param {string} name Node name to be sanitized.
  	 * @return {string}
  	 */},{key:"sanitizeNodeName",value:function sanitizeNodeName(name){return name.replace(/\s/g,'_').replace(_reservedRe,'');}},{key:"parseTrackName",value:function parseTrackName(trackName){var matches=_trackRe.exec(trackName);if(!matches){throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);}var results={// directoryName: matches[ 1 ], // (tschw) currently unused
  nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],// required
  propertyIndex:matches[6]};var lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');if(lastDot!==undefined&&lastDot!==-1){var objectName=results.nodeName.substring(lastDot+1);// Object names must be checked against an allowlist. Otherwise, there
  // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  // 'bar' could be the objectName, or part of a nodeName (which can
  // include '.' characters).
  if(_supportedObjectNames.indexOf(objectName)!==-1){results.nodeName=results.nodeName.substring(0,lastDot);results.objectName=objectName;}}if(results.propertyName===null||results.propertyName.length===0){throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);}return results;}},{key:"findNode",value:function findNode(root,nodeName){if(!nodeName||nodeName===''||nodeName==='.'||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
  if(root.skeleton){var bone=root.skeleton.getBoneByName(nodeName);if(bone!==undefined){return bone;}}// search into node subtree.
  if(root.children){var searchNodeSubtree=function searchNodeSubtree(children){for(var _i323=0;_i323<children.length;_i323++){var childNode=children[_i323];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}var result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};var subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;}}]);return PropertyBinding;}();PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[// Direct
  PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[// EntireArray
  PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[// ArrayElement
  PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[// HasToFromArray
  PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];var Raycaster=/*#__PURE__*/function(){function Raycaster(origin,direction){var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Infinity;_classCallCheck(this,Raycaster);this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
  this.near=near;this.far=far;this.camera=null;this.layers=new Layers();this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}};}_createClass(Raycaster,[{key:"set",value:function set(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
  this.ray.set(origin,direction);}},{key:"setFromCamera",value:function setFromCamera(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();this.camera=camera;}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
  this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);this.camera=camera;}else {console.error('THREE.Raycaster: Unsupported camera type: '+camera.type);}}},{key:"intersectObject",value:function intersectObject(object){var recursive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var intersects=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];_intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;}},{key:"intersectObjects",value:function intersectObjects(objects){var recursive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var intersects=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];for(var _i339=0,l=objects.length;_i339<l;_i339++){_intersectObject(objects[_i339],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}}]);return Raycaster;}();function ascSort(a,b){return a.distance-b.distance;}function _intersectObject(object,raycaster,intersects,recursive){if(object.layers.test(raycaster.layers)){object.raycast(raycaster,intersects);}if(recursive===true){var children=object.children;for(var _i340=0,l=children.length;_i340<l;_i340++){_intersectObject(children[_i340],raycaster,intersects,true);}}}var ImmediateRenderObject=/*#__PURE__*/function(_Object3D14){_inherits(ImmediateRenderObject,_Object3D14);var _super138=_createSuper(ImmediateRenderObject);function ImmediateRenderObject(material){var _this108;_classCallCheck(this,ImmediateRenderObject);_this108=_super138.call(this);_this108.material=material;_this108.render=function/* renderCallback */(){};_this108.hasPositions=false;_this108.hasNormals=false;_this108.hasColors=false;_this108.hasUvs=false;_this108.positionArray=null;_this108.normalArray=null;_this108.colorArray=null;_this108.uvArray=null;_this108.count=0;return _this108;}return _createClass(ImmediateRenderObject);}(Object3D$1);ImmediateRenderObject.prototype.isImmediateRenderObject=true;var GridHelper=/*#__PURE__*/function(_LineSegments2){_inherits(GridHelper,_LineSegments2);var _super143=_createSuper(GridHelper);function GridHelper(){var _this113;var size=arguments.length>0&&arguments[0]!==undefined?arguments[0]:10;var divisions=arguments.length>1&&arguments[1]!==undefined?arguments[1]:10;var color1=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0x444444;var color2=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0x888888;_classCallCheck(this,GridHelper);color1=new Color$2(color1);color2=new Color$2(color2);var center=divisions/2;var step=size/divisions;var halfSize=size/2;var vertices=[],colors=[];for(var _i347=0,j=0,k=-halfSize;_i347<=divisions;_i347++,k+=step){vertices.push(-halfSize,0,k,halfSize,0,k);vertices.push(k,0,-halfSize,k,0,halfSize);var color=_i347===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}var geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:true,toneMapped:false});_this113=_super143.call(this,geometry,material);_this113.type='GridHelper';return _this113;}return _createClass(GridHelper);}(LineSegments);var _floatView=new Float32Array(1);new Int32Array(_floatView.buffer);var VertexColors$1=2;Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=Object.create(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
  Path.prototype.fromPoints=function(points){console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');return this.setFromPoints(points);};//
  GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};Loader.prototype.extractUrlBase=function(url){console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');return LoaderUtils.extractUrlBase(url);};Loader.Handlers={add:function add(/* regex, loader */){console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');},get:function get(/* file */){console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');}};Box3.prototype.center=function(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};Box3.prototype.empty=function(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();};Box3.prototype.isIntersectionBox=function(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Box3.prototype.isIntersectionSphere=function(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);};Box3.prototype.size=function(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);};//
  Sphere.prototype.empty=function(){console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');return this.isEmpty();};//
  Frustum.prototype.setFromMatrix=function(m){console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');return this.setFromProjectionMatrix(m);};//
  Matrix3$1.prototype.flattenToArrayOffset=function(array,offset){console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');return this.toArray(array,offset);};Matrix3$1.prototype.multiplyVector3=function(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);};Matrix3$1.prototype.multiplyVector3Array=function/* a */(){console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');};Matrix3$1.prototype.applyToBufferAttribute=function(attribute){console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');return attribute.applyMatrix3(this);};Matrix3$1.prototype.applyToVector3Array=function/* array, offset, length */(){console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');};Matrix3$1.prototype.getInverse=function(matrix){console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');return this.copy(matrix).invert();};//
  Matrix4$1.prototype.extractPosition=function(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);};Matrix4$1.prototype.flattenToArrayOffset=function(array,offset){console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');return this.toArray(array,offset);};Matrix4$1.prototype.getPosition=function(){console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return new Vector3().setFromMatrixColumn(this,3);};Matrix4$1.prototype.setRotationFromQuaternion=function(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);};Matrix4$1.prototype.multiplyToArray=function(){console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');};Matrix4$1.prototype.multiplyVector3=function(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4$1.prototype.multiplyVector4=function(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4$1.prototype.multiplyVector3Array=function/* a */(){console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');};Matrix4$1.prototype.rotateAxis=function(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);};Matrix4$1.prototype.crossVector=function(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4$1.prototype.translate=function(){console.error('THREE.Matrix4: .translate() has been removed.');};Matrix4$1.prototype.rotateX=function(){console.error('THREE.Matrix4: .rotateX() has been removed.');};Matrix4$1.prototype.rotateY=function(){console.error('THREE.Matrix4: .rotateY() has been removed.');};Matrix4$1.prototype.rotateZ=function(){console.error('THREE.Matrix4: .rotateZ() has been removed.');};Matrix4$1.prototype.rotateByAxis=function(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');};Matrix4$1.prototype.applyToBufferAttribute=function(attribute){console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');return attribute.applyMatrix4(this);};Matrix4$1.prototype.applyToVector3Array=function/* array, offset, length */(){console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');};Matrix4$1.prototype.makeFrustum=function(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);};Matrix4$1.prototype.getInverse=function(matrix){console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');return this.copy(matrix).invert();};//
  Plane$1.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};//
  Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};Quaternion.prototype.inverse=function(){console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');return this.invert();};//
  Ray.prototype.isIntersectionBox=function(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Ray.prototype.isIntersectionPlane=function(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);};Ray.prototype.isIntersectionSphere=function(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);};//
  Triangle$1.prototype.area=function(){console.warn('THREE.Triangle: .area() has been renamed to .getArea().');return this.getArea();};Triangle$1.prototype.barycoordFromPoint=function(point,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return this.getBarycoord(point,target);};Triangle$1.prototype.midpoint=function(target){console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');return this.getMidpoint(target);};Triangle$1.prototypenormal=function(target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return this.getNormal(target);};Triangle$1.prototype.plane=function(target){console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');return this.getPlane(target);};Triangle$1.barycoordFromPoint=function(point,a,b,c,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return Triangle$1.getBarycoord(point,a,b,c,target);};Triangle$1.normal=function(a,b,c,target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return Triangle$1.getNormal(a,b,c,target);};//
  Shape.prototype.extractAllPoints=function(divisions){console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');return this.extractPoints(divisions);};Shape.prototype.extrude=function(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);};Shape.prototype.makeGeometry=function(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);};//
  Vector2.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector2.prototype.distanceToManhattan=function(v){console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);};Vector2.prototype.lengthManhattan=function(){console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
  Vector3.prototype.setEulerFromRotationMatrix=function(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');};Vector3.prototype.setEulerFromQuaternion=function(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');};Vector3.prototype.getPositionFromMatrix=function(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);};Vector3.prototype.getScaleFromMatrix=function(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);};Vector3.prototype.getColumnFromMatrix=function(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);};Vector3.prototype.applyProjection=function(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);};Vector3.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector3.prototype.distanceToManhattan=function(v){console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);};Vector3.prototype.lengthManhattan=function(){console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
  Vector4.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector4.prototype.lengthManhattan=function(){console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
  Object3D$1.prototype.getChildByName=function(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);};Object3D$1.prototype.renderDepth=function(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');};Object3D$1.prototype.translate=function(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);};Object3D$1.prototype.getWorldRotation=function(){console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');};Object3D$1.prototype.applyMatrix=function(matrix){console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);};Object.defineProperties(Object3D$1.prototype,{eulerOrder:{get:function get(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function set(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function get(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function set(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});Mesh.prototype.setDrawMode=function(){console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');};Object.defineProperties(Mesh.prototype,{drawMode:{get:function get(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');return TrianglesDrawMode;},set:function set(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');}}});SkinnedMesh.prototype.initBones=function(){console.error('THREE.SkinnedMesh: initBones() has been removed.');};//
  PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn('THREE.PerspectiveCamera.setLens is deprecated. '+'Use .setFocalLength and .filmGauge for a photographic setup.');if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
  Object.defineProperties(Light.prototype,{onlyShadow:{set:function set(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function set(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function set(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function set(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function set(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function set(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function set(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function set(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function set(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function set(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function set(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function set(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function set(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
  Object.defineProperties(BufferAttribute.prototype,{length:{get:function get(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}},dynamic:{get:function get(){console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');return this.usage===DynamicDrawUsage;},set:function set(/* value */){console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');this.setUsage(DynamicDrawUsage);}}});BufferAttribute.prototype.setDynamic=function(value){console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;};BufferAttribute.prototype.copyIndicesArray=function/* indices */(){console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');},BufferAttribute.prototype.setArray=function/* array */(){console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');};//
  BufferGeometry.prototype.addIndex=function(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);};BufferGeometry.prototype.addAttribute=function(name,attribute){console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');if(!(attribute&&attribute.isBufferAttribute)&&!(attribute&&attribute.isInterleavedBufferAttribute)){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');return this.setAttribute(name,new BufferAttribute(arguments[1],arguments[2]));}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return this;}return this.setAttribute(name,attribute);};BufferGeometry.prototype.addDrawCall=function(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);};BufferGeometry.prototype.clearDrawCalls=function(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();};BufferGeometry.prototype.computeOffsets=function(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');};BufferGeometry.prototype.removeAttribute=function(name){console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');return this.deleteAttribute(name);};BufferGeometry.prototype.applyMatrix=function(matrix){console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);};Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function get(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function get(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});InterleavedBuffer.prototype.setDynamic=function(value){console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;};InterleavedBuffer.prototype.setArray=function/* array */(){console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');};//
  ExtrudeGeometry.prototype.getArrays=function(){console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');};ExtrudeGeometry.prototype.addShapeList=function(){console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');};ExtrudeGeometry.prototype.addShape=function(){console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');};//
  Scene$1.prototype.dispose=function(){console.error('THREE.Scene: .dispose() has been removed.');};//
  Object.defineProperties(Material$1.prototype,{wrapAround:{get:function get(){console.warn('THREE.Material: .wrapAround has been removed.');},set:function set(){console.warn('THREE.Material: .wrapAround has been removed.');}},overdraw:{get:function get(){console.warn('THREE.Material: .overdraw has been removed.');},set:function set(){console.warn('THREE.Material: .overdraw has been removed.');}},wrapRGB:{get:function get(){console.warn('THREE.Material: .wrapRGB has been removed.');return new Color$2();}},shading:{get:function get(){console.error('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');},set:function set(value){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=value===FlatShading;}},stencilMask:{get:function get(){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');return this.stencilFuncMask;},set:function set(value){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');this.stencilFuncMask=value;}},vertexTangents:{get:function get(){console.warn('THREE.'+this.type+': .vertexTangents has been removed.');},set:function set(){console.warn('THREE.'+this.type+': .vertexTangents has been removed.');}}});Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function get(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function set(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
  WebGLRenderer.prototype.clearTarget=function(renderTarget,color,depth,stencil){console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};WebGLRenderer.prototype.animate=function(callback){console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');this.setAnimationLoop(callback);};WebGLRenderer.prototype.getCurrentRenderTarget=function(){console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');return this.getRenderTarget();};WebGLRenderer.prototype.getMaxAnisotropy=function(){console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');return this.capabilities.getMaxAnisotropy();};WebGLRenderer.prototype.getPrecision=function(){console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');return this.capabilities.precision;};WebGLRenderer.prototype.resetGLState=function(){console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');return this.state.reset();};WebGLRenderer.prototype.supportsFloatTextures=function(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');};WebGLRenderer.prototype.supportsHalfFloatTextures=function(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');};WebGLRenderer.prototype.supportsStandardDerivatives=function(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');};WebGLRenderer.prototype.supportsCompressedTextureS3TC=function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');};WebGLRenderer.prototype.supportsCompressedTexturePVRTC=function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');};WebGLRenderer.prototype.supportsBlendMinMax=function(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');};WebGLRenderer.prototype.supportsVertexTextures=function(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;};WebGLRenderer.prototype.supportsInstancedArrays=function(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');};WebGLRenderer.prototype.enableScissorTest=function(_boolean2){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(_boolean2);};WebGLRenderer.prototype.initMaterial=function(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');};WebGLRenderer.prototype.addPrePlugin=function(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');};WebGLRenderer.prototype.addPostPlugin=function(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');};WebGLRenderer.prototype.updateShadowMap=function(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');};WebGLRenderer.prototype.setFaceCulling=function(){console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');};WebGLRenderer.prototype.allocTextureUnit=function(){console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');};WebGLRenderer.prototype.setTexture=function(){console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');};WebGLRenderer.prototype.setTexture2D=function(){console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');};WebGLRenderer.prototype.setTextureCube=function(){console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');};WebGLRenderer.prototype.getActiveMipMapLevel=function(){console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');return this.getActiveMipmapLevel();};Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function get(){return this.shadowMap.enabled;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function get(){return this.shadowMap.type;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function set(/* value */){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');}},context:{get:function get(){console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');return this.getContext();}},vr:{get:function get(){console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');return this.xr;}},gammaInput:{get:function get(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');return false;},set:function set(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');}},gammaOutput:{get:function get(){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');return false;},set:function set(value){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');this.outputEncoding=value===true?sRGBEncoding:LinearEncoding;}},toneMappingWhitePoint:{get:function get(){console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');return 1.0;},set:function set(){console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');}}});Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function set(/* cullFace */){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');}},renderReverseSided:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function set(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');}},renderSingleSided:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function set(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');}}});Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function get(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function get(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function get(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function get(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function get(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function get(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
  Audio.prototype.load=function(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');var scope=this;var audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;};CubeCamera.prototype.updateCubeMap=function(renderer,scene){console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');return this.update(renderer,scene);};CubeCamera.prototype.clear=function(renderer,color,depth,stencil){console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');return this.renderTarget.clear(renderer,color,depth,stencil);};ImageUtils.crossOrigin=undefined;ImageUtils.loadTexture=function(url,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');var loader=new TextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(url,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadTextureCube=function(urls,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');var loader=new CubeTextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(urls,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadCompressedTexture=function(){console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');};ImageUtils.loadCompressedTextureCube=function(){console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');};//
  if(typeof __THREE_DEVTOOLS__!=='undefined'){/* eslint-disable no-undef */__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{detail:{revision:REVISION}}));/* eslint-enable no-undef */}if(typeof window!=='undefined'){if(window.__THREE__){console.warn('WARNING: Multiple instances of Three.js being imported.');}else {window.__THREE__=REVISION;}}

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * @class Cartesian3
   * 一个三维笛卡尔坐标点。
   * @constructor
   *
   * @param {Number} x=0.0 <code>optional</code> X值
   * @param {Number} y=0.0 <code>optional</code> Y值
   * @param {Number} z=0.0 <code>optional</code> Z值
   *
   */
  function Cartesian3(x, y, z) {
    /*
     * The X component.
     * @type {Number}
     * @default 0.0
     */
    this.x = defaultValue$1(x, 0.0);

    /*
     * The Y component.
     * @type {Number}
     * @default 0.0
     */
    this.y = defaultValue$1(y, 0.0);

    /*
     * The Z component.
     * @type {Number}
     * @default 0.0
     */
    this.z = defaultValue$1(z, 0.0);
  }

  /**
   * 将给定的球面坐标转换为笛卡尔坐标系中的坐标。
   * @param {Spherical} spherical 要转换为笛卡尔坐标系的球面坐标。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或如果未提供则为新的 Cartesian3 实例
   */
  Cartesian3.fromSpherical = function (spherical, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('spherical', spherical);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    var clock = spherical.clock;
    var cone = spherical.cone;
    var magnitude = defaultValue$1(spherical.magnitude, 1.0);
    var radial = magnitude * Math.sin(cone);
    result.x = radial * Math.cos(clock);
    result.y = radial * Math.sin(clock);
    result.z = magnitude * Math.cos(cone);
    return result;
  };

  /**
   * 从 x、y 和 z 坐标创建一个 Cartesian3 实例。
   * @param {Number} x x 坐标。
   * @param {Number} y y 坐标。
   * @param {Number} z z 坐标。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或如果未提供则为新的 Cartesian3 实例
   */
  Cartesian3.fromElements = function (x, y, z, result) {
    if (!defined$1(result)) {
      return new Cartesian3(x, y, z);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 复制一个 Cartesian3 实例。
   * @param {Cartesian3} cartesian 要复制的 Cartesian3 实例。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或如果未提供则为新的 Cartesian3 实例。（如果 cartesian 为 undefined，则返回 undefined）
   */
  Cartesian3.clone = function (cartesian, result) {
    if (!defined$1(cartesian)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    result.z = cartesian.z;
    return result;
  };

  /**
   * 从现有的 Cartesian4 实例创建一个 Cartesian3 实例。这只需获取 Cartesian4 的 x、y 和 z 属性并删除 w。
   * @function
   * @param {Cartesian4} cartesian 要从中创建 Cartesian3 实例的 Cartesian4 实例。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或如果未提供则为新的 Cartesian3 实例。
   */
  Cartesian3.fromCartesian4 = Cartesian3.clone;

  /*
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Cartesian3.packedLength = 3;

  /**
   * 将提供的实例存储到提供的数组中。
   * @param {Cartesian3} value 要打包的值。
   * @param {Number[]} array 要打包到其中的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 开始打包元素的数组索引。
   * @returns {Number[]} 被打包的数组
   */
  Cartesian3.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex] = value.z;
    return array;
  };

  /**
   * 从打包的数组中检索实例。
   * @param {Number[]} array 打包的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 要解包的元素的起始索引。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或如果未提供则为新的 Cartesian3 实例。
   */
  Cartesian3.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex++];
    result.z = array[startingIndex];
    return result;
  };

  /**
   * 将一个 Cartesian3 数组平铺为一个组件数组。
   * @param {Cartesian3[]} array 要打包的 Cartesian3 数组。
   * @param {Number[]} result <code>optional</code> 存储结果的数组。如果这是一个类型化数组，它必须有 array.length * 3 个组件，否则将抛出 {@link DeveloperError}。如果它是一个普通数组，则会调整大小以具有 (array.length * 3) 个元素。
   * @returns {Number[]} 打包后的数组。
   */
  Cartesian3.packArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('array', array);
    //>>includeEnd('debug');

    var length = array.length;
    var resultLength = length * 3;
    if (!defined$1(result)) {
      result = new Array(resultLength);
    } else if (!Array.isArray(result) && result.length !== resultLength) {
      //>>includeStart('debug', pragmas.debug);
      throw new DeveloperError$1('If result is a typed array, it must have exactly array.length * 3 elements');
      //>>includeEnd('debug');
    } else if (result.length !== resultLength) {
      result.length = resultLength;
    }
    for (var i = 0; i < length; ++i) {
      Cartesian3.pack(array[i], result, i * 3);
    }
    return result;
  };

  /**
   * 将一个由笛卡尔坐标分量组成的数组解包为一个 Cartesian3 数组。
   * @param {Number[]} array 要解包的分量数组。
   * @param {Cartesian3[]} result <code>optional</code> 存储结果的数组。
   * @returns {Cartesian3[]} 解包后的数组。
   */
  Cartesian3.unpackArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('array', array);
    Check.typeOf.number.greaterThanOrEquals('array.length', array.length, 3);
    if (array.length % 3 !== 0) {
      throw new DeveloperError$1('array length must be a multiple of 3.');
    }
    //>>includeEnd('debug');

    var length = array.length;
    if (!defined$1(result)) {
      result = new Array(length / 3);
    } else {
      result.length = length / 3;
    }
    for (var i = 0; i < length; i += 3) {
      var index = i / 3;
      result[index] = Cartesian3.unpack(array, i, result[index]);
    }
    return result;
  };

  /**
   * 从数组中的三个连续元素创建Cartesian3。
   * @function
   * @param {Number[]} array 三个连续元素分别对应x、y和z分量的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 第一个元素的偏移量，对应于x分量的数组偏移量。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或如果未提供则为新的Cartesian3实例。
   *
   * @example
   * // Create a Cartesian3 with (1.0, 2.0, 3.0)
   * const v = [1.0, 2.0, 3.0];
   * const p = Earth.Cartesian3.fromArray(v);
   *
   * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];
   * const p2 = Earth.Cartesian3.fromArray(v2, 2);
   */
  Cartesian3.fromArray = Cartesian3.unpack;

  /**
   * 计算提供的Cartesian的最大分量的值。
   * @param {Cartesian3} cartesian 要使用的Cartesian。
   * @returns {Number} 最大分量的值。
   */
  Cartesian3.maximumComponent = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    //>>includeEnd('debug');

    return Math.max(cartesian.x, cartesian.y, cartesian.z);
  };

  /**
   * 计算给定 Cartesian 的最小分量值。
   * @param {Cartesian3} cartesian 要使用的 Cartesian。
   * @returns {Number} 最小分量的值。
   */
  Cartesian3.minimumComponent = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    //>>includeEnd('debug');

    return Math.min(cartesian.x, cartesian.y, cartesian.z);
  };

  /**
   * 比较两个Cartesian3，计算一个Cartesian3，其中包含所提供的Cartesian3的最小分量。
   * @param {Cartesian3} first 要比较的第一个Cartesian3。
   * @param {Cartesian3} second 要比较的第二个Cartesian3。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 具有最小分量的Cartesian3。
   */
  Cartesian3.minimumByComponent = function (first, second, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    result.z = Math.min(first.z, second.z);
    return result;
  };

  /**
   * 比较两个Cartesian3对象并计算一个新的Cartesian3对象，包含两个Cartesian3对象的各个分量的最大值。
   * @param {Cartesian3} first 要比较的第一个Cartesian3对象。
   * @param {Cartesian3} second 要比较的第二个Cartesian3对象。
   * @param {Cartesian3} result 用于存储结果的对象。
   * @returns {Cartesian3} 一个包含最大分量的Cartesian3对象。
   */
  Cartesian3.maximumByComponent = function (first, second, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    result.z = Math.max(first.z, second.z);
    return result;
  };

  /**
   * 将一个值限制在两个值之间。
   * @param {Cartesian3} cartesian 要限制的值。
   * @param {Cartesian3} min 最小值。
   * @param {Cartesian3} max 最大值。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 限制在 min <= value <= max 之间的值。
   */
  Cartesian3.clamp = function (value, min, max, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('value', value);
    Check.typeOf.object('min', min);
    Check.typeOf.object('max', max);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    var x = CesiumMath.clamp(value.x, min.x, max.x);
    var y = CesiumMath.clamp(value.y, min.y, max.y);
    var z = CesiumMath.clamp(value.z, min.z, max.z);
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 计算给定 Cartesian 的平方大小。
   * @param {Cartesian3} cartesian 要计算平方大小的 Cartesian 实例。
   * @returns {Number} 平方大小。
   */
  Cartesian3.magnitudeSquared = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    //>>includeEnd('debug');

    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
  };

  /**
   * 计算Cartesian的模（长度）。
   * @param {Cartesian3} cartesian 要计算模的Cartesian实例。
   * @returns {Number} 模
   */
  Cartesian3.magnitude = function (cartesian) {
    return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
  };
  var distanceScratch$1 = new Cartesian3();

  /**
   * 计算两点之间的距离。
   * @param {Cartesian3} left 第一个点。
   * @param {Cartesian3} right 第二个点。
   * @returns {Number} 两点之间的距离
   *
   * @example
   * // Returns 1.0
   * const d = Earth.Cartesian3.distance(new Earth.Cartesian3(1.0, 0.0, 0.0), new Earth.Cartesian3(2.0, 0.0, 0.0));
   */
  Cartesian3.distance = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    //>>includeEnd('debug');

    Cartesian3.subtract(left, right, distanceScratch$1);
    return Cartesian3.magnitude(distanceScratch$1);
  };

  /**
   * 计算两点之间的平方距离。使用此函数比使用{@link Cartesian3.distance}比较距离更高效。
   * @param {Cartesian3} left 计算距离的第一个点。
   * @param {Cartesian3} right 计算距离的第二个点。
   * @returns {Number} 两点之间的距离
   *
   * @example
   * // Returns 4.0, not 2.0
   * const d = Earth.Cartesian3.distanceSquared(new Earth.Cartesian3(1.0, 0.0, 0.0), new Earth.Cartesian3(3.0, 0.0, 0.0));
   */
  Cartesian3.distanceSquared = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    //>>includeEnd('debug');

    Cartesian3.subtract(left, right, distanceScratch$1);
    return Cartesian3.magnitudeSquared(distanceScratch$1);
  };

  /**
   * 计算所提供Cartesian的归一化形式。
   * @param {Cartesian3} cartesian 要归一化的Cartesian。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   */
  Cartesian3.normalize = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    var magnitude = Cartesian3.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    result.z = cartesian.z / magnitude;

    //>>includeStart('debug', pragmas.debug);
    if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {
      throw new DeveloperError$1('normalized result is not a number');
    }
    //>>includeEnd('debug');

    return result;
  };

  /**
   * 计算两个Cartesian的点乘积（标量乘积）。
   * @param {Cartesian3} left 第一个Cartesian。
   * @param {Cartesian3} right 第二个Cartesian。
   * @returns {Number} 点乘积。
   */
  Cartesian3.dot = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    //>>includeEnd('debug');

    return left.x * right.x + left.y * right.y + left.z * right.z;
  };

  /**
   * 计算两个Cartesian3对象的分量积（componentwise product）。
   * @param {Cartesian3} left 第一个Cartesian3对象。
   * @param {Cartesian3} right 第二个Cartesian3对象。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   */
  Cartesian3.multiplyComponents = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = left.x * right.x;
    result.y = left.y * right.y;
    result.z = left.z * right.z;
    return result;
  };

  /**
   * 计算两个Cartesian的分量商。
   * @param {Cartesian3} left 第一个Cartesian。
   * @param {Cartesian3} right 第二个Cartesian。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的result参数。
   */
  Cartesian3.divideComponents = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = left.x / right.x;
    result.y = left.y / right.y;
    result.z = left.z / right.z;
    return result;
  };

  /**
   * 计算两个Cartesian的分量和。
   * @param {Cartesian3} left 第一个Cartesian。
   * @param {Cartesian3} right 第二个Cartesian。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   */
  Cartesian3.add = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    return result;
  };

  /**
   * 计算两个 Cartesian3 各个分量的差。
   * @param {Cartesian3} left 第一个 Cartesian3。
   * @param {Cartesian3} right 第二个 Cartesian3。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的 result 参数。
   */
  Cartesian3.subtract = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    return result;
  };

  /**
   * 按照提供的标量对提供的Cartesian进行逐分量乘法运算。
   * @param {Cartesian3} cartesian 要缩放的Cartesian。
   * @param {Number} scalar 用于乘法运算的标量。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   */
  Cartesian3.multiplyByScalar = function (cartesian, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    result.z = cartesian.z * scalar;
    return result;
  };

  /**
   * 对提供的Cartesian进行逐分量除以提供的标量。
   * @param {Cartesian3} cartesian 要被除的Cartesian。
   * @param {Number} scalar 除数标量。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   */
  Cartesian3.divideByScalar = function (cartesian, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    result.z = cartesian.z / scalar;
    return result;
  };

  /**
   * 取反给定的三维笛卡尔坐标。
   * @param {Cartesian3} cartesian 要取反的三维笛卡尔坐标。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   */
  Cartesian3.negate = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = -cartesian.x;
    result.y = -cartesian.y;
    result.z = -cartesian.z;
    return result;
  };

  /**
   * 计算所提供的 Cartesian 的绝对值。
   * @param {Cartesian3} cartesian 要计算其绝对值的 Cartesian。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的 result 参数。
   */
  Cartesian3.abs = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    result.z = Math.abs(cartesian.z);
    return result;
  };
  var lerpScratch$1 = new Cartesian3();
  /**
   * 使用提供的 Cartesians 计算 t 处的线性插值或外推。
   * @param {Cartesian3} start t = 0.0 时的值。
   * @param {Cartesian3} end t = 1.0 时的值。
   * @param {Number} t 要进行插值的点。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的 result 参数。
   */
  Cartesian3.lerp = function (start, end, t, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('start', start);
    Check.typeOf.object('end', end);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    Cartesian3.multiplyByScalar(end, t, lerpScratch$1);
    result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
    return Cartesian3.add(lerpScratch$1, result, result);
  };
  var angleBetweenScratch = new Cartesian3();
  var angleBetweenScratch2 = new Cartesian3();
  /**
   * 返回两个提供的 Cartesians 之间的夹角，单位为弧度。
   * @param {Cartesian3} left 第一个 Cartesian。
   * @param {Cartesian3} right 第二个 Cartesian。
   * @returns {Number} 两个 Cartesians 之间的夹角。
   */
  Cartesian3.angleBetween = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    //>>includeEnd('debug');

    Cartesian3.normalize(left, angleBetweenScratch);
    Cartesian3.normalize(right, angleBetweenScratch2);
    var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
    var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));
    return Math.atan2(sine, cosine);
  };
  var mostOrthogonalAxisScratch$1 = new Cartesian3();
  /**
   * 返回与所提供的Cartesian最正交的轴。
   * @param {Cartesian3} cartesian 寻找最正交轴的Cartesian。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 最正交的轴。
   */
  Cartesian3.mostOrthogonalAxis = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch$1);
    Cartesian3.abs(f, f);
    if (f.x <= f.y) {
      if (f.x <= f.z) {
        result = Cartesian3.clone(Cartesian3.UNIT_X, result);
      } else {
        result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
      }
    } else if (f.y <= f.z) {
      result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
    } else {
      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
    }
    return result;
  };

  /**
   * 将向量a投影到向量b上
   * @param {Cartesian3} a 需要被投影的向量
   * @param {Cartesian3} b 被投影的向量
   * @param {Cartesian3} result 存储结果的对象
   * @returns {Cartesian3} 经过修改的结果参数
   */
  Cartesian3.projectVector = function (a, b, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('a', a);
    Check.defined('b', b);
    Check.defined('result', result);
    //>>includeEnd('debug');

    var scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);
    return Cartesian3.multiplyByScalar(b, scalar, result);
  };

  /**
   * 逐个比较给定的Cartesian，如果它们相等则返回true，否则返回false。
   * @param {Cartesian3} left <code>optional</code> 第一个Cartesian。
   * @param {Cartesian3} right <code>optional</code> 第二个Cartesian。
   * @returns {Boolean} 如果left和right相等，则返回true，否则返回false。
   */
  Cartesian3.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left.x === right.x && left.y === right.y && left.z === right.z;
  };

  /**
   * @private
   */
  Cartesian3.equalsArray = function (cartesian, array, offset) {
    return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];
  };

  /**
   * 按分量比较提供的两个Cartesian，如果它们通过绝对或相对容差测试，则返回 true，否则返回 false。
   * @param {Cartesian3} left <code>optional</code> 第一个 Cartesian。
   * @param {Cartesian3} right <code>optional</code> 第二个 Cartesian。
   * @param {Number} relativeEpsilon=0 <code>optional</code> 用于相等测试的相对 epsilon 容差。
   * @param {Number} absoluteEpsilon=relativeEpsilon <code>optional</code> 用于相等测试的绝对 epsilon 容差。
   * @returns {Boolean} 如果 left 和 right 在提供的 epsilon 范围内，则返回 true，否则返回 false。
   */
  Cartesian3.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    return left === right || defined$1(left) && defined$1(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon);
  };

  /**
   * 计算两个Cartesian的叉乘（外积）。
   * @param {Cartesian3} left 第一个Cartesian。
   * @param {Cartesian3} right 第二个Cartesian。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 叉积。
   */
  Cartesian3.cross = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    var leftX = left.x;
    var leftY = left.y;
    var leftZ = left.z;
    var rightX = right.x;
    var rightY = right.y;
    var rightZ = right.z;
    var x = leftY * rightZ - leftZ * rightY;
    var y = leftZ * rightX - leftX * rightZ;
    var z = leftX * rightY - leftY * rightX;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 计算左右两个Cartesian的中点
   * @param {Cartesian3} left 第一个Cartesian
   * @param {Cartesian3} right 第二个Cartesian
   * @param {Cartesian3} result 存储结果的对象
   * @returns {Cartesian3} 中点
   */
  Cartesian3.midpoint = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.x = (left.x + right.x) * 0.5;
    result.y = (left.y + right.y) * 0.5;
    result.z = (left.z + right.z) * 0.5;
    return result;
  };

  /**
   * 根据以度为单位给定的经纬度值返回一个Cartesian3位置。
   * @param {Number} longitude 经度，以度为单位
   * @param {Number} latitude 纬度，以度为单位
   * @param {Number} height=0.0 <code>optional</code> 椭球体上的高度，以米为单位。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 该位置所在的椭球体。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 位置
   *
   * @example
   * const position = Earth.Cartesian3.fromDegrees(-115.0, 37.0);
   */
  Cartesian3.fromDegrees = function (longitude, latitude, height, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number('longitude', longitude);
    Check.typeOf.number('latitude', latitude);
    //>>includeEnd('debug');

    longitude = CesiumMath.toRadians(longitude);
    latitude = CesiumMath.toRadians(latitude);
    return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);
  };
  new Cartesian3();
  new Cartesian3();
  new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6378137.0 * 6378137.0
  // 6356752.3142451793 * 6356752.3142451793
  );

  /**
   * 根据给定的经纬度值（弧度制）返回一个Cartesian3类型的位置。
   * @param {Number} longitude 经度，以弧度为单位。
   * @param {Number} latitude 纬度，以弧度为单位。
   * @param {Number} height=0.0 <code>optional</code> 椭球体上方的高度，以米为单位。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 该位置所在的椭球体。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 位置。
   *
   * @example
   * const position = Earth.Cartesian3.fromRadians(-2.007, 0.645);
   */
  Cartesian3.fromRadians = function (longitude, latitude, height, ellipsoid, result) {
    var radius = defined$1(ellipsoid) ? ellipsoid._radii.x : Ellipsoid$1.WGS84._radii.x;
    height = defaultValue$1(height, 0.0);
    //pie生成cartesian3
    var res = PIEVector3.sphericalToCartesian(longitude, latitude, radius + height);
    if (!defined$1(result)) {
      result = new Cartesian3();
    }
    result.x = res.x;
    result.y = res.y;
    result.z = res.z;
    return result;
    // //>>includeStart('debug', pragmas.debug);
    // Check.typeOf.number('longitude', longitude);
    // Check.typeOf.number('latitude', latitude);
    // //>>includeEnd('debug');
    // height = defaultValue(height, 0.0);
    // const radiiSquared = defined(ellipsoid)
    //   ? ellipsoid.radiiSquared
    //   : wgs84RadiiSquared;
    // const cosLatitude = Math.cos(latitude);
    // scratchN.x = cosLatitude * Math.cos(longitude);
    // scratchN.y = cosLatitude * Math.sin(longitude);
    // scratchN.z = Math.sin(latitude);
    // scratchN = Cartesian3.normalize(scratchN, scratchN);
    // Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
    // const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
    // scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
    // scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);
    // if (!defined(result)) {
    //   result = new Cartesian3();
    // }
    // return Cartesian3.add(scratchK, scratchN, result);
  };

  /**
   * 给定以度为单位的经度和纬度值的数组，返回一个Cartesian3位置数组。
   * @param {Number[]} coordinates 一系列以经度和纬度为值的数组。值交替出现 [经度，纬度，经度，纬度...]。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 坐标所在的椭球体。
   * @param {Cartesian3[]} result <code>optional</code> 存储结果的Cartesian3对象数组。
   * @returns {Cartesian3[]} 位置数组。
   *
   * @example
   * const positions = Earth.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);
   */
  Cartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
      throw new DeveloperError$1('the number of coordinates must be a multiple of 2 and at least 2');
    }
    //>>includeEnd('debug');

    var length = coordinates.length;
    if (!defined$1(result)) {
      result = new Array(length / 2);
    } else {
      result.length = length / 2;
    }
    for (var i = 0; i < length; i += 2) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var index = i / 2;
      result[index] = Cartesian3.fromDegrees(longitude, latitude, 0, ellipsoid, result[index]);
    }
    return result;
  };

  /**
   * 返回一个由以弧度表示的经纬度数组生成的由Cartesian3位置数组。
   * @param {Number[]} coordinates 经纬度值的列表。值交替排列 [longitude, latitude, longitude, latitude...]。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 该坐标所在的椭球体。
   * @param {Cartesian3[]} result <code>optional</code> 用于存储结果的Cartesian3对象数组。
   * @returns {Cartesian3[]} 位置数组。
   *
   * @example
   * const positions = Earth.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);
   */
  Cartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
      throw new DeveloperError$1('the number of coordinates must be a multiple of 2 and at least 2');
    }
    //>>includeEnd('debug');

    var length = coordinates.length;
    if (!defined$1(result)) {
      result = new Array(length / 2);
    } else {
      result.length = length / 2;
    }
    for (var i = 0; i < length; i += 2) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var index = i / 2;
      result[index] = Cartesian3.fromRadians(longitude, latitude, 0, ellipsoid, result[index]);
    }
    return result;
  };

  /**
   * 给定经度、纬度和高度的数组，返回一组Cartesian3位置，其中经度和纬度以度为单位。
   * @param {Number[]} coordinates 经度、纬度和高度值的列表，值交替出现 [经度, 纬度, 高度, 经度, 纬度, 高度, ...]。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 该位置所在的椭球体。
   * @param {Cartesian3[]} result <code>optional</code> 用于存储结果的Cartesian3对象数组。
   * @returns {Cartesian3[]} 位置数组。
   *
   * @example
   * const positions = Earth.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);
   */
  Cartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
      throw new DeveloperError$1('the number of coordinates must be a multiple of 3 and at least 3');
    }
    //>>includeEnd('debug');

    var length = coordinates.length;
    if (!defined$1(result)) {
      result = new Array(length / 3);
    } else {
      result.length = length / 3;
    }
    for (var i = 0; i < length; i += 3) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var height = coordinates[i + 2];
      var index = i / 3;
      result[index] = Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result[index]);
    }
    return result;
  };

  /**
   * 返回一个由经度、纬度和高度组成的数组的 Cartesian3 位置数组，其中经度和纬度以弧度为单位。
   * @param {Number[]} coordinates 经度、纬度和高度的值数组，依次为 [经度, 纬度, 高度, 经度, 纬度, 高度, ...]。
   * @param {Ellipsoid} ellipsoid=Ellipsoid.WGS84 <code>optional</code> 该位置所在的椭球体。
   * @param {Cartesian3[]} result <code>optional</code> 用于存储结果的 Cartesian3 对象数组。
   * @returns {Cartesian3[]} 位置数组。
   *
   * @example
   * const positions = Earth.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);
   */
  Cartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
      throw new DeveloperError$1('the number of coordinates must be a multiple of 3 and at least 3');
    }
    //>>includeEnd('debug');

    var length = coordinates.length;
    if (!defined$1(result)) {
      result = new Array(length / 3);
    } else {
      result.length = length / 3;
    }
    for (var i = 0; i < length; i += 3) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var height = coordinates[i + 2];
      var index = i / 3;
      result[index] = Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result[index]);
    }
    return result;
  };

  /*
   * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
   *
   * @type {Cartesian3}
   * @constant
   */
  Cartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));

  /*
   * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).
   *
   * @type {Cartesian3}
   * @constant
   */
  Cartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));

  /*
   * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
   *
   * @type {Cartesian3}
   * @constant
   */
  Cartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));

  /*
   * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
   *
   * @type {Cartesian3}
   * @constant
   */
  Cartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));

  /*
   * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
   *
   * @type {Cartesian3}
   * @constant
   */
  Cartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));

  /**
   * 复制此 Cartesian3 实例。
   * @param {Cartesian3} result <code>optional</code> 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数或新的 Cartesian3 实例（如果没有提供参数）。
   */
  Cartesian3.prototype.clone = function (result) {
    return Cartesian3.clone(this, result);
  };

  /**
   * 对比该 Cartesian3 实例与提供的 Cartesian3 实例的每个分量，如果它们相等则返回 true，否则返回 false。
   * @param {Cartesian3} right <code>optional</code> 右侧 Cartesian3。
   * @returns {Boolean} 如果它们相等则返回 true，否则返回 false。
   */
  Cartesian3.prototype.equals = function (right) {
    return Cartesian3.equals(this, right);
  };

  /**
   * 逐个分量比较此Cartesian和提供的Cartesian，并在绝对或相对容差测试通过时返回true，否则返回false。
   * @param {Cartesian3} right <code>optional</code> 右侧的Cartesian。
   * @param {Number} relativeEpsilon=0 <code>optional</code> 用于相等测试的相对epsilon容差。
   * @param {Number} absoluteEpsilon=relativeEpsilon <code>optional</code> 用于相等测试的绝对epsilon容差。
   * @returns {Boolean} 如果它们在提供的容差范围内则为true，否则为false。
   */
  Cartesian3.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {
    return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };

  /**
   * 以 '(x, y, z)' 的格式创建表示此 Cartesian 的字符串。
   * @returns {String} 表示此 Cartesian 的字符串，格式为 '(x, y, z)'。
   */
  Cartesian3.prototype.toString = function () {
    return "(".concat(this.x, ", ").concat(this.y, ", ").concat(this.z, ")");
  };

  /**
   * 降Cartesion3转为three的Vector3
   * @returns Vector3
   */
  Cartesian3.prototype.toThreeVector3 = function () {
    return new Vector3(this.x, this.y, this.z);
  };

  /**
   * A collection of key-value pairs that is stored as a hash for easy
   * lookup but also provides an array for fast iteration.
   * @alias AssociativeArray
   * @constructor
   */
  function AssociativeArray() {
    this._array = [];
    this._hash = {};
  }
  Object.defineProperties(AssociativeArray.prototype, {
    /**
     * Gets the number of items in the collection.
     * @memberof AssociativeArray.prototype
     *
     * @type {Number}
     */
    length: {
      get: function get() {
        return this._array.length;
      }
    },
    /**
     * Gets an unordered array of all values in the collection.
     * This is a live array that will automatically reflect the values in the collection,
     * it should not be modified directly.
     * @memberof AssociativeArray.prototype
     *
     * @type {Array}
     */
    values: {
      get: function get() {
        return this._array;
      }
    }
  });

  /**
   * Determines if the provided key is in the array.
   *
   * @param {String|Number} key The key to check.
   * @returns {Boolean} <code>true</code> if the key is in the array, <code>false</code> otherwise.
   */
  AssociativeArray.prototype.contains = function (key) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof key !== "string" && typeof key !== "number") {
      throw new DeveloperError$1("key is required to be a string or number.");
    }
    //>>includeEnd('debug');
    return defined$1(this._hash[key]);
  };

  /**
   * Associates the provided key with the provided value.  If the key already
   * exists, it is overwritten with the new value.
   *
   * @param {String|Number} key A unique identifier.
   * @param {*} value The value to associate with the provided key.
   */
  AssociativeArray.prototype.set = function (key, value) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof key !== "string" && typeof key !== "number") {
      throw new DeveloperError$1("key is required to be a string or number.");
    }
    //>>includeEnd('debug');

    var oldValue = this._hash[key];
    if (value !== oldValue) {
      this.remove(key);
      this._hash[key] = value;
      this._array.push(value);
    }
  };

  /**
   * Retrieves the value associated with the provided key.
   *
   * @param {String|Number} key The key whose value is to be retrieved.
   * @returns {*} The associated value, or undefined if the key does not exist in the collection.
   */
  AssociativeArray.prototype.get = function (key) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof key !== "string" && typeof key !== "number") {
      throw new DeveloperError$1("key is required to be a string or number.");
    }
    //>>includeEnd('debug');
    return this._hash[key];
  };

  /**
   * Removes a key-value pair from the collection.
   *
   * @param {String|Number} key The key to be removed.
   * @returns {Boolean} True if it was removed, false if the key was not in the collection.
   */
  AssociativeArray.prototype.remove = function (key) {
    //>>includeStart('debug', pragmas.debug);
    if (defined$1(key) && typeof key !== "string" && typeof key !== "number") {
      throw new DeveloperError$1("key is required to be a string or number.");
    }
    //>>includeEnd('debug');

    var value = this._hash[key];
    var hasValue = defined$1(value);
    if (hasValue) {
      var array = this._array;
      array.splice(array.indexOf(value), 1);
      delete this._hash[key];
    }
    return hasValue;
  };

  /**
   * Clears the collection.
   */
  AssociativeArray.prototype.removeAll = function () {
    var array = this._array;
    if (array.length > 0) {
      this._hash = {};
      array.length = 0;
    }
  };

  function returnTrue() {
    return true;
  }

  /**
   * Destroys an object.  Each of the object's functions, including functions in its prototype,
   * is replaced with a function that throws a {@link DeveloperError}, except for the object's
   * <code>isDestroyed</code> function, which is set to a function that returns <code>true</code>.
   * The object's properties are removed with <code>delete</code>.
   * <br /><br />
   * This function is used by objects that hold native resources, e.g., WebGL resources, which
   * need to be explicitly released.  Client code calls an object's <code>destroy</code> function,
   * which then releases the native resource and calls <code>destroyObject</code> to put itself
   * in a destroyed state.
   *
   * @function
   *
   * @param {Object} object The object to destroy.
   * @param {String} [message] The message to include in the exception that is thrown if
   *                           a destroyed object's function is called.
   *
   *
   * @example
   * // How a texture would destroy itself.
   * this.destroy = function () {
   *     _gl.deleteTexture(_texture);
   *     return Cesium.destroyObject(this);
   * };
   *
   * @see DeveloperError
   */
  function destroyObject(object, message) {
    message = defaultValue$1(message, "This object was destroyed, i.e., destroy() was called.");
    function throwOnDestroyed() {
      //>>includeStart('debug', pragmas.debug);
      throw new DeveloperError$1(message);
      //>>includeEnd('debug');
    }

    for (var key in object) {
      if (typeof object[key] === "function") {
        object[key] = throwOnDestroyed;
      }
    }
    object.isDestroyed = returnTrue;
    return undefined;
  }

  var _supportsFullscreen;
  var _names = {
    requestFullscreen: undefined,
    exitFullscreen: undefined,
    fullscreenEnabled: undefined,
    fullscreenElement: undefined,
    fullscreenchange: undefined,
    fullscreenerror: undefined
  };

  /**
   * Browser-independent functions for working with the standard fullscreen API.
   *
   * @namespace Fullscreen
   *
   * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
   */
  var Fullscreen = {};
  Object.defineProperties(Fullscreen, {
    /**
     * The element that is currently fullscreen, if any.  To simply check if the
     * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.
     * @memberof Fullscreen
     * @type {Object}
     * @readonly
     */
    element: {
      get: function get() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return document[_names.fullscreenElement];
      }
    },
    /**
     * The name of the event on the document that is fired when fullscreen is
     * entered or exited.  This event name is intended for use with addEventListener.
     * In your event handler, to determine if the browser is in fullscreen mode or not,
     * use {@link Fullscreen#fullscreen}.
     * @memberof Fullscreen
     * @type {String}
     * @readonly
     */
    changeEventName: {
      get: function get() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return _names.fullscreenchange;
      }
    },
    /**
     * The name of the event that is fired when a fullscreen error
     * occurs.  This event name is intended for use with addEventListener.
     * @memberof Fullscreen
     * @type {String}
     * @readonly
     */
    errorEventName: {
      get: function get() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return _names.fullscreenerror;
      }
    },
    /**
     * Determine whether the browser will allow an element to be made fullscreen, or not.
     * For example, by default, iframes cannot go fullscreen unless the containing page
     * adds an "allowfullscreen" attribute (or prefixed equivalent).
     * @memberof Fullscreen
     * @type {Boolean}
     * @readonly
     */
    enabled: {
      get: function get() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return document[_names.fullscreenEnabled];
      }
    },
    /**
     * Determines if the browser is currently in fullscreen mode.
     * @memberof Fullscreen
     * @type {Boolean}
     * @readonly
     */
    fullscreen: {
      get: function get() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return Fullscreen.element !== null;
      }
    }
  });

  /**
   * Detects whether the browser supports the standard fullscreen API.
   *
   * @returns {Boolean} <code>true</code> if the browser supports the standard fullscreen API,
   * <code>false</code> otherwise.
   */
  Fullscreen.supportsFullscreen = function () {
    if (defined$1(_supportsFullscreen)) {
      return _supportsFullscreen;
    }
    _supportsFullscreen = false;
    var body = document.body;
    if (typeof body.requestFullscreen === "function") {
      // go with the unprefixed, standard set of names
      _names.requestFullscreen = "requestFullscreen";
      _names.exitFullscreen = "exitFullscreen";
      _names.fullscreenEnabled = "fullscreenEnabled";
      _names.fullscreenElement = "fullscreenElement";
      _names.fullscreenchange = "fullscreenchange";
      _names.fullscreenerror = "fullscreenerror";
      _supportsFullscreen = true;
      return _supportsFullscreen;
    }

    //check for the correct combination of prefix plus the various names that browsers use
    var prefixes = ["webkit", "moz", "o", "ms", "khtml"];
    var name;
    for (var i = 0, len = prefixes.length; i < len; ++i) {
      var prefix = prefixes[i];

      // casing of Fullscreen differs across browsers
      name = "".concat(prefix, "RequestFullscreen");
      if (typeof body[name] === "function") {
        _names.requestFullscreen = name;
        _supportsFullscreen = true;
      } else {
        name = "".concat(prefix, "RequestFullScreen");
        if (typeof body[name] === "function") {
          _names.requestFullscreen = name;
          _supportsFullscreen = true;
        }
      }

      // disagreement about whether it's "exit" as per spec, or "cancel"
      name = "".concat(prefix, "ExitFullscreen");
      if (typeof document[name] === "function") {
        _names.exitFullscreen = name;
      } else {
        name = "".concat(prefix, "CancelFullScreen");
        if (typeof document[name] === "function") {
          _names.exitFullscreen = name;
        }
      }

      // casing of Fullscreen differs across browsers
      name = "".concat(prefix, "FullscreenEnabled");
      if (document[name] !== undefined) {
        _names.fullscreenEnabled = name;
      } else {
        name = "".concat(prefix, "FullScreenEnabled");
        if (document[name] !== undefined) {
          _names.fullscreenEnabled = name;
        }
      }

      // casing of Fullscreen differs across browsers
      name = "".concat(prefix, "FullscreenElement");
      if (document[name] !== undefined) {
        _names.fullscreenElement = name;
      } else {
        name = "".concat(prefix, "FullScreenElement");
        if (document[name] !== undefined) {
          _names.fullscreenElement = name;
        }
      }

      // thankfully, event names are all lowercase per spec
      name = "".concat(prefix, "fullscreenchange");
      // event names do not have 'on' in the front, but the property on the document does
      if (document["on".concat(name)] !== undefined) {
        //except on IE
        if (prefix === "ms") {
          name = "MSFullscreenChange";
        }
        _names.fullscreenchange = name;
      }
      name = "".concat(prefix, "fullscreenerror");
      if (document["on".concat(name)] !== undefined) {
        //except on IE
        if (prefix === "ms") {
          name = "MSFullscreenError";
        }
        _names.fullscreenerror = name;
      }
    }
    return _supportsFullscreen;
  };

  /**
   * Asynchronously requests the browser to enter fullscreen mode on the given element.
   * If fullscreen mode is not supported by the browser, does nothing.
   *
   * @param {Object} element The HTML element which will be placed into fullscreen mode.
   * @param {Object} [vrDevice] The HMDVRDevice device.
   *
   * @example
   * // Put the entire page into fullscreen.
   * Cesium.Fullscreen.requestFullscreen(document.body)
   *
   * // Place only the Cesium canvas into fullscreen.
   * Cesium.Fullscreen.requestFullscreen(scene.canvas)
   */
  Fullscreen.requestFullscreen = function (element, vrDevice) {
    if (!Fullscreen.supportsFullscreen()) {
      return;
    }
    element[_names.requestFullscreen]({
      vrDisplay: vrDevice
    });
  };

  /**
   * Asynchronously exits fullscreen mode.  If the browser is not currently
   * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
   */
  Fullscreen.exitFullscreen = function () {
    if (!Fullscreen.supportsFullscreen()) {
      return;
    }
    document[_names.exitFullscreen]();
  };

  //For unit tests
  Fullscreen._names = _names;

  var theNavigator;
  if (typeof navigator !== "undefined") {
    theNavigator = navigator;
  } else {
    theNavigator = {};
  }
  function extractVersion(versionString) {
    var parts = versionString.split(".");
    for (var i = 0, len = parts.length; i < len; ++i) {
      parts[i] = parseInt(parts[i], 10);
    }
    return parts;
  }
  var isChromeResult;
  var chromeVersionResult;
  function isChrome() {
    if (!defined$1(isChromeResult)) {
      isChromeResult = false;
      // Edge contains Chrome in the user agent too
      if (!isEdge()) {
        var fields = / Chrome\/([\.0-9]+)/.exec(theNavigator.userAgent);
        if (fields !== null) {
          isChromeResult = true;
          chromeVersionResult = extractVersion(fields[1]);
        }
      }
    }
    return isChromeResult;
  }
  function chromeVersion() {
    return isChrome() && chromeVersionResult;
  }
  var isSafariResult;
  var safariVersionResult;
  function isSafari() {
    if (!defined$1(isSafariResult)) {
      isSafariResult = false;

      // Chrome and Edge contain Safari in the user agent too
      if (!isChrome() && !isEdge() && / Safari\/[\.0-9]+/.test(theNavigator.userAgent)) {
        var fields = / Version\/([\.0-9]+)/.exec(theNavigator.userAgent);
        if (fields !== null) {
          isSafariResult = true;
          safariVersionResult = extractVersion(fields[1]);
        }
      }
    }
    return isSafariResult;
  }
  function safariVersion() {
    return isSafari() && safariVersionResult;
  }
  var isWebkitResult;
  var webkitVersionResult;
  function isWebkit() {
    if (!defined$1(isWebkitResult)) {
      isWebkitResult = false;
      var fields = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(theNavigator.userAgent);
      if (fields !== null) {
        isWebkitResult = true;
        webkitVersionResult = extractVersion(fields[1]);
        webkitVersionResult.isNightly = !!fields[2];
      }
    }
    return isWebkitResult;
  }
  function webkitVersion() {
    return isWebkit() && webkitVersionResult;
  }
  var isInternetExplorerResult;
  var internetExplorerVersionResult;
  function isInternetExplorer() {
    if (!defined$1(isInternetExplorerResult)) {
      isInternetExplorerResult = false;
      var fields;
      if (theNavigator.appName === "Microsoft Internet Explorer") {
        fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
        if (fields !== null) {
          isInternetExplorerResult = true;
          internetExplorerVersionResult = extractVersion(fields[1]);
        }
      } else if (theNavigator.appName === "Netscape") {
        fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
        if (fields !== null) {
          isInternetExplorerResult = true;
          internetExplorerVersionResult = extractVersion(fields[1]);
        }
      }
    }
    return isInternetExplorerResult;
  }
  function internetExplorerVersion() {
    return isInternetExplorer() && internetExplorerVersionResult;
  }
  var isEdgeResult;
  var edgeVersionResult;
  function isEdge() {
    if (!defined$1(isEdgeResult)) {
      isEdgeResult = false;
      var fields = / Edg\/([\.0-9]+)/.exec(theNavigator.userAgent);
      if (fields !== null) {
        isEdgeResult = true;
        edgeVersionResult = extractVersion(fields[1]);
      }
    }
    return isEdgeResult;
  }
  function edgeVersion() {
    return isEdge() && edgeVersionResult;
  }
  var isFirefoxResult;
  var firefoxVersionResult;
  function isFirefox() {
    if (!defined$1(isFirefoxResult)) {
      isFirefoxResult = false;
      var fields = /Firefox\/([\.0-9]+)/.exec(theNavigator.userAgent);
      if (fields !== null) {
        isFirefoxResult = true;
        firefoxVersionResult = extractVersion(fields[1]);
      }
    }
    return isFirefoxResult;
  }
  var isWindowsResult;
  function isWindows() {
    if (!defined$1(isWindowsResult)) {
      isWindowsResult = /Windows/i.test(theNavigator.appVersion);
    }
    return isWindowsResult;
  }
  var isIPadOrIOSResult;
  function isIPadOrIOS() {
    if (!defined$1(isIPadOrIOSResult)) {
      isIPadOrIOSResult = navigator.platform === "iPhone" || navigator.platform === "iPod" || navigator.platform === "iPad";
    }
    return isIPadOrIOSResult;
  }
  function firefoxVersion() {
    return isFirefox() && firefoxVersionResult;
  }
  var hasPointerEvents;
  function supportsPointerEvents() {
    if (!defined$1(hasPointerEvents)) {
      //While navigator.pointerEnabled is deprecated in the W3C specification
      //we still need to use it if it exists in order to support browsers
      //that rely on it, such as the Windows WebBrowser control which defines
      //PointerEvent but sets navigator.pointerEnabled to false.

      //Firefox disabled because of https://github.com/CesiumGS/cesium/issues/6372
      hasPointerEvents = !isFirefox() && typeof PointerEvent !== "undefined" && (!defined$1(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);
    }
    return hasPointerEvents;
  }
  var imageRenderingValueResult;
  var supportsImageRenderingPixelatedResult;
  function supportsImageRenderingPixelated() {
    if (!defined$1(supportsImageRenderingPixelatedResult)) {
      var canvas = document.createElement("canvas");
      canvas.setAttribute("style", "image-rendering: -moz-crisp-edges;" + "image-rendering: pixelated;");
      //canvas.style.imageRendering will be undefined, null or an empty string on unsupported browsers.
      var tmp = canvas.style.imageRendering;
      supportsImageRenderingPixelatedResult = defined$1(tmp) && tmp !== "";
      if (supportsImageRenderingPixelatedResult) {
        imageRenderingValueResult = tmp;
      }
    }
    return supportsImageRenderingPixelatedResult;
  }
  function imageRenderingValue() {
    return supportsImageRenderingPixelated() ? imageRenderingValueResult : undefined;
  }
  function supportsWebP() {
    //>>includeStart('debug', pragmas.debug);
    if (!supportsWebP.initialized) {
      throw new DeveloperError$1("You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP");
    }
    //>>includeEnd('debug');
    return supportsWebP._result;
  }
  supportsWebP._promise = undefined;
  supportsWebP._result = undefined;
  supportsWebP.initialize = function () {
    // From https://developers.google.com/speed/webp/faq#how_can_i_detect_browser_support_for_webp
    if (defined$1(supportsWebP._promise)) {
      return supportsWebP._promise;
    }
    supportsWebP._promise = new Promise(function (resolve) {
      var image = new Image();
      image.onload = function () {
        supportsWebP._result = image.width > 0 && image.height > 0;
        resolve(supportsWebP._result);
      };
      image.onerror = function () {
        supportsWebP._result = false;
        resolve(supportsWebP._result);
      };
      image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
    });
    return supportsWebP._promise;
  };
  Object.defineProperties(supportsWebP, {
    initialized: {
      get: function get() {
        return defined$1(supportsWebP._result);
      }
    }
  });
  var typedArrayTypes = [];
  if (typeof ArrayBuffer !== "undefined") {
    typedArrayTypes.push(Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array);
    if (typeof Uint8ClampedArray !== "undefined") {
      typedArrayTypes.push(Uint8ClampedArray);
    }
    if (typeof Uint8ClampedArray !== "undefined") {
      typedArrayTypes.push(Uint8ClampedArray);
    }
    if (typeof BigInt64Array !== "undefined") {
      // eslint-disable-next-line no-undef
      typedArrayTypes.push(BigInt64Array);
    }
    if (typeof BigUint64Array !== "undefined") {
      // eslint-disable-next-line no-undef
      typedArrayTypes.push(BigUint64Array);
    }
  }

  /**
   * A set of functions to detect whether the current browser supports
   * various features.
   *
   * @namespace FeatureDetection
   */
  var FeatureDetection = {
    isChrome: isChrome,
    chromeVersion: chromeVersion,
    isSafari: isSafari,
    safariVersion: safariVersion,
    isWebkit: isWebkit,
    webkitVersion: webkitVersion,
    isInternetExplorer: isInternetExplorer,
    internetExplorerVersion: internetExplorerVersion,
    isEdge: isEdge,
    edgeVersion: edgeVersion,
    isFirefox: isFirefox,
    firefoxVersion: firefoxVersion,
    isWindows: isWindows,
    isIPadOrIOS: isIPadOrIOS,
    hardwareConcurrency: defaultValue$1(theNavigator.hardwareConcurrency, 3),
    supportsPointerEvents: supportsPointerEvents,
    supportsImageRenderingPixelated: supportsImageRenderingPixelated,
    supportsWebP: supportsWebP,
    imageRenderingValue: imageRenderingValue,
    typedArrayTypes: typedArrayTypes
  };

  /**
   * Detects whether the current browser supports Basis Universal textures and the web assembly modules needed to transcode them.
   *
   * @param {Scene} scene
   * @returns {Boolean} true if the browser supports web assembly modules and the scene supports Basis Universal textures, false if not.
   */
  FeatureDetection.supportsBasis = function (scene) {
    return FeatureDetection.supportsWebAssembly() && scene.context.supportsBasis;
  };

  /**
   * Detects whether the current browser supports the full screen standard.
   *
   * @returns {Boolean} true if the browser supports the full screen standard, false if not.
   *
   * @see Fullscreen
   * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
   */
  FeatureDetection.supportsFullscreen = function () {
    return Fullscreen.supportsFullscreen();
  };

  /**
   * Detects whether the current browser supports typed arrays.
   *
   * @returns {Boolean} true if the browser supports typed arrays, false if not.
   *
   * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}
   */
  FeatureDetection.supportsTypedArrays = function () {
    return typeof ArrayBuffer !== "undefined";
  };

  /**
   * Detects whether the current browser supports BigInt64Array typed arrays.
   *
   * @returns {Boolean} true if the browser supports BigInt64Array typed arrays, false if not.
   *
   * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}
   */
  FeatureDetection.supportsBigInt64Array = function () {
    return typeof BigInt64Array !== "undefined";
  };

  /**
   * Detects whether the current browser supports BigUint64Array typed arrays.
   *
   * @returns {Boolean} true if the browser supports BigUint64Array typed arrays, false if not.
   *
   * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}
   */
  FeatureDetection.supportsBigUint64Array = function () {
    return typeof BigUint64Array !== "undefined";
  };

  /**
   * Detects whether the current browser supports BigInt.
   *
   * @returns {Boolean} true if the browser supports BigInt, false if not.
   *
   * @see {@link https://tc39.es/ecma262/#sec-bigint-objects|BigInt Specification}
   */
  FeatureDetection.supportsBigInt = function () {
    return typeof BigInt !== "undefined";
  };

  /**
   * Detects whether the current browser supports Web Workers.
   *
   * @returns {Boolean} true if the browsers supports Web Workers, false if not.
   *
   * @see {@link http://www.w3.org/TR/workers/}
   */
  FeatureDetection.supportsWebWorkers = function () {
    return typeof Worker !== "undefined";
  };

  /**
   * Detects whether the current browser supports Web Assembly.
   *
   * @returns {Boolean} true if the browsers supports Web Assembly, false if not.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/WebAssembly}
   */
  FeatureDetection.supportsWebAssembly = function () {
    return typeof WebAssembly !== "undefined";
  };

  /**
   * Gets a timestamp that can be used in measuring the time between events.  Timestamps
   * are expressed in milliseconds, but it is not specified what the milliseconds are
   * measured from.  This function uses performance.now() if it is available, or Date.now()
   * otherwise.
   *
   * @function getTimestamp
   *
   * @returns {Number} The timestamp in milliseconds since some unspecified reference time.
   */
  var getTimestamp;
  if (typeof performance !== "undefined" && typeof performance.now === "function" && isFinite(performance.now())) {
    getTimestamp = function getTimestamp() {
      return performance.now();
    };
  } else {
    getTimestamp = function getTimestamp() {
      return Date.now();
    };
  }
  var getTimestamp$1 = getTimestamp;

  /**
   * This enumerated type is for representing keyboard modifiers. These are keys
   * that are held down in addition to other event types.
   *
   * @enum {Number}
   */
  var KeyboardEventModifier = {
    /**
     * Represents the shift key being held down.
     *
     * @type {Number}
     * @constant
     */
    SHIFT: 0,
    /**
     * Represents the control key being held down.
     *
     * @type {Number}
     * @constant
     */
    CTRL: 1,
    /**
     * Represents the alt key being held down.
     *
     * @type {Number}
     * @constant
     */
    ALT: 2
  };
  var KeyboardEventModifier$1 = Object.freeze(KeyboardEventModifier);

  /**
   * This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.
   *
   * @enum {Number}
   */
  var ScreenSpaceEventType = {
    /**
     * Represents a mouse left button down event.
     *
     * @type {Number}
     * @constant
     */
    LEFT_DOWN: 0,
    /**
     * Represents a mouse left button up event.
     *
     * @type {Number}
     * @constant
     */
    LEFT_UP: 1,
    /**
     * Represents a mouse left click event.
     *
     * @type {Number}
     * @constant
     */
    LEFT_CLICK: 2,
    /**
     * Represents a mouse left double click event.
     *
     * @type {Number}
     * @constant
     */
    LEFT_DOUBLE_CLICK: 3,
    /**
     * Represents a mouse left button down event.
     *
     * @type {Number}
     * @constant
     */
    RIGHT_DOWN: 5,
    /**
     * Represents a mouse right button up event.
     *
     * @type {Number}
     * @constant
     */
    RIGHT_UP: 6,
    /**
     * Represents a mouse right click event.
     *
     * @type {Number}
     * @constant
     */
    RIGHT_CLICK: 7,
    /**
     * Represents a mouse middle button down event.
     *
     * @type {Number}
     * @constant
     */
    MIDDLE_DOWN: 10,
    /**
     * Represents a mouse middle button up event.
     *
     * @type {Number}
     * @constant
     */
    MIDDLE_UP: 11,
    /**
     * Represents a mouse middle click event.
     *
     * @type {Number}
     * @constant
     */
    MIDDLE_CLICK: 12,
    /**
     * Represents a mouse move event.
     *
     * @type {Number}
     * @constant
     */
    MOUSE_MOVE: 15,
    /**
     * Represents a mouse wheel event.
     *
     * @type {Number}
     * @constant
     */
    WHEEL: 16,
    /**
     * Represents the start of a two-finger event on a touch surface.
     *
     * @type {Number}
     * @constant
     */
    PINCH_START: 17,
    /**
     * Represents the end of a two-finger event on a touch surface.
     *
     * @type {Number}
     * @constant
     */
    PINCH_END: 18,
    /**
     * Represents a change of a two-finger event on a touch surface.
     *
     * @type {Number}
     * @constant
     */
    PINCH_MOVE: 19
  };
  var ScreenSpaceEventType$1 = Object.freeze(ScreenSpaceEventType);

  function getPosition(screenSpaceEventHandler, event, result) {
    var element = screenSpaceEventHandler._element;
    if (element === document) {
      result.x = event.clientX;
      result.y = event.clientY;
      return result;
    }
    var rect = element.getBoundingClientRect();
    result.x = event.clientX - rect.left;
    result.y = event.clientY - rect.top;
    return result;
  }
  function getInputEventKey(type, modifier) {
    var key = type;
    if (defined$1(modifier)) {
      key += "+".concat(modifier);
    }
    return key;
  }
  function getModifier(event) {
    if (event.shiftKey) {
      return KeyboardEventModifier$1.SHIFT;
    } else if (event.ctrlKey) {
      return KeyboardEventModifier$1.CTRL;
    } else if (event.altKey) {
      return KeyboardEventModifier$1.ALT;
    }
    return undefined;
  }
  var MouseButton = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
  };
  function registerListener(screenSpaceEventHandler, domType, element, callback) {
    function listener(e) {
      callback(screenSpaceEventHandler, e);
    }
    if (FeatureDetection.isInternetExplorer()) {
      element.addEventListener(domType, listener, false);
    } else {
      element.addEventListener(domType, listener, {
        capture: false,
        passive: false
      });
    }
    screenSpaceEventHandler._removalFunctions.push(function () {
      element.removeEventListener(domType, listener, false);
    });
  }
  function registerListeners(screenSpaceEventHandler) {
    var element = screenSpaceEventHandler._element;

    // some listeners may be registered on the document, so we still get events even after
    // leaving the bounds of element.
    // this is affected by the existence of an undocumented disableRootEvents property on element.
    var alternateElement = !defined$1(element.disableRootEvents) ? document : element;
    if (FeatureDetection.supportsPointerEvents()) {
      registerListener(screenSpaceEventHandler, 'pointerdown', element, handlePointerDown);
      registerListener(screenSpaceEventHandler, 'pointerup', element, handlePointerUp);
      registerListener(screenSpaceEventHandler, 'pointermove', element, handlePointerMove);
      registerListener(screenSpaceEventHandler, 'pointercancel', element, handlePointerUp);
    } else {
      registerListener(screenSpaceEventHandler, 'mousedown', element, handleMouseDown);
      registerListener(screenSpaceEventHandler, 'mouseup', alternateElement, handleMouseUp);
      registerListener(screenSpaceEventHandler, 'mousemove', alternateElement, handleMouseMove);
      registerListener(screenSpaceEventHandler, 'touchstart', element, handleTouchStart);
      registerListener(screenSpaceEventHandler, 'touchend', alternateElement, handleTouchEnd);
      registerListener(screenSpaceEventHandler, 'touchmove', alternateElement, handleTouchMove);
      registerListener(screenSpaceEventHandler, 'touchcancel', alternateElement, handleTouchEnd);
    }
    registerListener(screenSpaceEventHandler, 'dblclick', element, handleDblClick);

    // detect available wheel event
    var wheelEvent;
    if ('onmousewheel' in element) {
      // spec event type
      // chrome first
      wheelEvent = 'mousewheel';
    } else if (document.onmousewheel !== undefined) {
      // legacy event type
      wheelEvent = 'mousewheel';
    } else {
      // older Firefox
      wheelEvent = 'DOMMouseScroll';
    }
    registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);
  }
  function unregisterListeners(screenSpaceEventHandler) {
    var removalFunctions = screenSpaceEventHandler._removalFunctions;
    for (var i = 0; i < removalFunctions.length; ++i) {
      removalFunctions[i]();
    }
  }
  var mouseDownEvent = {
    position: new Cartesian2()
  };
  function gotTouchEvent(screenSpaceEventHandler) {
    screenSpaceEventHandler._lastSeenTouchEvent = getTimestamp$1();
  }
  function canProcessMouseEvent(screenSpaceEventHandler) {
    return getTimestamp$1() - screenSpaceEventHandler._lastSeenTouchEvent > ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;
  }
  function checkPixelTolerance(startPosition, endPosition, pixelTolerance) {
    var xDiff = startPosition.x - endPosition.x;
    var yDiff = startPosition.y - endPosition.y;
    var totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    return totalPixels < pixelTolerance;
  }
  function handleMouseDown(screenSpaceEventHandler, event) {
    if (!canProcessMouseEvent(screenSpaceEventHandler)) {
      return;
    }
    var button = event.button;
    screenSpaceEventHandler._buttonDown[button] = true;
    var screenSpaceEventType;
    if (button === MouseButton.LEFT) {
      screenSpaceEventType = ScreenSpaceEventType$1.LEFT_DOWN;
    } else if (button === MouseButton.MIDDLE) {
      screenSpaceEventType = ScreenSpaceEventType$1.MIDDLE_DOWN;
    } else if (button === MouseButton.RIGHT) {
      screenSpaceEventType = ScreenSpaceEventType$1.RIGHT_DOWN;
    } else {
      return;
    }
    var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
    Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);
    Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    if (defined$1(action)) {
      Cartesian2.clone(position, mouseDownEvent.position);
      action(mouseDownEvent);

      // event.preventDefault();
    }
  }

  var mouseUpEvent = {
    position: new Cartesian2()
  };
  var mouseClickEvent = {
    position: new Cartesian2()
  };
  function cancelMouseEvent(screenSpaceEventHandler, screenSpaceEventType, clickScreenSpaceEventType, event) {
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    var clickAction = screenSpaceEventHandler.getInputAction(clickScreenSpaceEventType, modifier);
    if (defined$1(action) || defined$1(clickAction)) {
      var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
      if (defined$1(action)) {
        Cartesian2.clone(position, mouseUpEvent.position);
        action(mouseUpEvent);
      }
      if (defined$1(clickAction)) {
        var startPosition = screenSpaceEventHandler._primaryStartPosition;
        if (checkPixelTolerance(startPosition, position, screenSpaceEventHandler._clickPixelTolerance)) {
          Cartesian2.clone(position, mouseClickEvent.position);
          clickAction(mouseClickEvent);
        }
      }
    }
  }
  function handleMouseUp(screenSpaceEventHandler, event) {
    if (!canProcessMouseEvent(screenSpaceEventHandler)) {
      return;
    }
    var button = event.button;
    if (button !== MouseButton.LEFT && button !== MouseButton.MIDDLE && button !== MouseButton.RIGHT) {
      return;
    }
    if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {
      cancelMouseEvent(screenSpaceEventHandler, ScreenSpaceEventType$1.LEFT_UP, ScreenSpaceEventType$1.LEFT_CLICK, event);
      screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;
    }
    if (screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE]) {
      cancelMouseEvent(screenSpaceEventHandler, ScreenSpaceEventType$1.MIDDLE_UP, ScreenSpaceEventType$1.MIDDLE_CLICK, event);
      screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] = false;
    }
    if (screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {
      cancelMouseEvent(screenSpaceEventHandler, ScreenSpaceEventType$1.RIGHT_UP, ScreenSpaceEventType$1.RIGHT_CLICK, event);
      screenSpaceEventHandler._buttonDown[MouseButton.RIGHT] = false;
    }
  }
  var mouseMoveEvent = {
    startPosition: new Cartesian2(),
    endPosition: new Cartesian2()
  };
  function handleMouseMove(screenSpaceEventHandler, event) {
    if (!canProcessMouseEvent(screenSpaceEventHandler)) {
      return;
    }
    var modifier = getModifier(event);
    var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
    var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
    var action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.MOUSE_MOVE, modifier);
    if (defined$1(action)) {
      Cartesian2.clone(previousPosition, mouseMoveEvent.startPosition);
      Cartesian2.clone(position, mouseMoveEvent.endPosition);
      action(mouseMoveEvent);
    }
    Cartesian2.clone(position, previousPosition);
    if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT] || screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] || screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {
      event.preventDefault();
    }
  }
  var mouseDblClickEvent = {
    position: new Cartesian2()
  };
  function handleDblClick(screenSpaceEventHandler, event) {
    var button = event.button;
    var screenSpaceEventType;
    if (button === MouseButton.LEFT) {
      screenSpaceEventType = ScreenSpaceEventType$1.LEFT_DOUBLE_CLICK;
    } else {
      return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    if (defined$1(action)) {
      getPosition(screenSpaceEventHandler, event, mouseDblClickEvent.position);
      action(mouseDblClickEvent);
    }
  }
  function handleWheel(screenSpaceEventHandler, event) {
    // currently this event exposes the delta value in terms of
    // the obsolete mousewheel event type.  so, for now, we adapt the other
    // values to that scheme.
    var delta;

    // standard wheel event uses deltaY.  sign is opposite wheelDelta.
    // deltaMode indicates what unit it is in.
    if (defined$1(event.deltaY)) {
      var deltaMode = event.deltaMode;
      if (deltaMode === event.DOM_DELTA_PIXEL) {
        delta = -event.deltaY;
      } else if (deltaMode === event.DOM_DELTA_LINE) {
        delta = -event.deltaY * 40;
      } else {
        // DOM_DELTA_PAGE
        delta = -event.deltaY * 120;
      }
    } else if (event.detail > 0) {
      // old Firefox versions use event.detail to count the number of clicks. The sign
      // of the integer is the direction the wheel is scrolled.
      delta = event.detail * -120;
    } else {
      delta = event.wheelDelta;
    }
    if (!defined$1(delta)) {
      return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.WHEEL, modifier);
    if (defined$1(action)) {
      action(delta);
      event.preventDefault();
    }
  }
  function handleTouchStart(screenSpaceEventHandler, event) {
    gotTouchEvent(screenSpaceEventHandler);
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      positions.set(identifier, getPosition(screenSpaceEventHandler, touch, new Cartesian2()));
    }
    fireTouchEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));
    }
  }
  function handleTouchEnd(screenSpaceEventHandler, event) {
    gotTouchEvent(screenSpaceEventHandler);
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      positions.remove(identifier);
    }
    fireTouchEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      previousPositions.remove(identifier);
    }
  }
  var touchStartEvent = {
    position: new Cartesian2()
  };
  var touch2StartEvent = {
    position1: new Cartesian2(),
    position2: new Cartesian2()
  };
  var touchEndEvent = {
    position: new Cartesian2()
  };
  var touchClickEvent = {
    position: new Cartesian2()
  };
  var touchHoldEvent = {
    position: new Cartesian2()
  };
  function fireTouchEvents(screenSpaceEventHandler, event) {
    var modifier = getModifier(event);
    var positions = screenSpaceEventHandler._positions;
    var numberOfTouches = positions.length;
    var action;
    var clickAction;
    var pinching = screenSpaceEventHandler._isPinching;
    if (numberOfTouches !== 1 && screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {
      // transitioning from single touch, trigger UP and might trigger CLICK
      screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;
      if (defined$1(screenSpaceEventHandler._touchHoldTimer)) {
        clearTimeout(screenSpaceEventHandler._touchHoldTimer);
        screenSpaceEventHandler._touchHoldTimer = undefined;
      }
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.LEFT_UP, modifier);
      if (defined$1(action)) {
        Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchEndEvent.position);
        action(touchEndEvent);
      }
      if (numberOfTouches === 0 && !screenSpaceEventHandler._isTouchHolding) {
        // releasing single touch, check for CLICK
        clickAction = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.LEFT_CLICK, modifier);
        if (defined$1(clickAction)) {
          var startPosition = screenSpaceEventHandler._primaryStartPosition;
          var endPosition = screenSpaceEventHandler._previousPositions.values[0];
          if (checkPixelTolerance(startPosition, endPosition, screenSpaceEventHandler._clickPixelTolerance)) {
            Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchClickEvent.position);
            clickAction(touchClickEvent);
          }
        }
      }
      screenSpaceEventHandler._isTouchHolding = false;

      // Otherwise don't trigger CLICK, because we are adding more touches.
    }

    if (numberOfTouches === 0 && pinching) {
      // transitioning from pinch, trigger PINCH_END
      screenSpaceEventHandler._isPinching = false;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.PINCH_END, modifier);
      if (defined$1(action)) {
        action();
      }
    }
    if (numberOfTouches === 1 && !pinching) {
      // transitioning to single touch, trigger DOWN
      var position = positions.values[0];
      Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);
      Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);
      Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);
      screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = true;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.LEFT_DOWN, modifier);
      if (defined$1(action)) {
        Cartesian2.clone(position, touchStartEvent.position);
        action(touchStartEvent);
      }
      screenSpaceEventHandler._touchHoldTimer = setTimeout(function () {
        if (!screenSpaceEventHandler.isDestroyed()) {
          screenSpaceEventHandler._touchHoldTimer = undefined;
          screenSpaceEventHandler._isTouchHolding = true;
          clickAction = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.RIGHT_CLICK, modifier);
          if (defined$1(clickAction)) {
            var _startPosition = screenSpaceEventHandler._primaryStartPosition;
            var _endPosition = screenSpaceEventHandler._previousPositions.values[0];
            if (checkPixelTolerance(_startPosition, _endPosition, screenSpaceEventHandler._holdPixelTolerance)) {
              Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchHoldEvent.position);
              clickAction(touchHoldEvent);
            }
          }
        }
      }, ScreenSpaceEventHandler.touchHoldDelayMilliseconds);
      event.preventDefault();
    }
    if (numberOfTouches === 2 && !pinching) {
      // transitioning to pinch, trigger PINCH_START
      screenSpaceEventHandler._isPinching = true;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.PINCH_START, modifier);
      if (defined$1(action)) {
        Cartesian2.clone(positions.values[0], touch2StartEvent.position1);
        Cartesian2.clone(positions.values[1], touch2StartEvent.position2);
        action(touch2StartEvent);

        // Touch-enabled devices, in particular iOS can have many default behaviours for
        // "pinch" events, which can still be executed unless we prevent them here.
        event.preventDefault();
      }
    }
  }
  function handleTouchMove(screenSpaceEventHandler, event) {
    gotTouchEvent(screenSpaceEventHandler);
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      var position = positions.get(identifier);
      if (defined$1(position)) {
        getPosition(screenSpaceEventHandler, touch, position);
      }
    }
    fireTouchMoveEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));
    }
  }
  var touchMoveEvent = {
    startPosition: new Cartesian2(),
    endPosition: new Cartesian2()
  };
  var touchPinchMovementEvent = {
    distance: {
      startPosition: new Cartesian2(),
      endPosition: new Cartesian2()
    },
    angleAndHeight: {
      startPosition: new Cartesian2(),
      endPosition: new Cartesian2()
    }
  };
  function fireTouchMoveEvents(screenSpaceEventHandler, event) {
    var modifier = getModifier(event);
    var positions = screenSpaceEventHandler._positions;
    var previousPositions = screenSpaceEventHandler._previousPositions;
    var numberOfTouches = positions.length;
    var action;
    if (numberOfTouches === 1 && screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {
      // moving single touch
      var position = positions.values[0];
      Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);
      var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.MOUSE_MOVE, modifier);
      if (defined$1(action)) {
        Cartesian2.clone(previousPosition, touchMoveEvent.startPosition);
        Cartesian2.clone(position, touchMoveEvent.endPosition);
        action(touchMoveEvent);
      }
      Cartesian2.clone(position, previousPosition);
      event.preventDefault();
    } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {
      // moving pinch

      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType$1.PINCH_MOVE, modifier);
      if (defined$1(action)) {
        var position1 = positions.values[0];
        var position2 = positions.values[1];
        var previousPosition1 = previousPositions.values[0];
        var previousPosition2 = previousPositions.values[1];
        var dX = position2.x - position1.x;
        var dY = position2.y - position1.y;
        var dist = Math.sqrt(dX * dX + dY * dY) * 0.25;
        var prevDX = previousPosition2.x - previousPosition1.x;
        var prevDY = previousPosition2.y - previousPosition1.y;
        var prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;
        var cY = (position2.y + position1.y) * 0.125;
        var prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;
        var angle = Math.atan2(dY, dX);
        var prevAngle = Math.atan2(prevDY, prevDX);
        Cartesian2.fromElements(0.0, prevDist, touchPinchMovementEvent.distance.startPosition);
        Cartesian2.fromElements(0.0, dist, touchPinchMovementEvent.distance.endPosition);
        Cartesian2.fromElements(prevAngle, prevCY, touchPinchMovementEvent.angleAndHeight.startPosition);
        Cartesian2.fromElements(angle, cY, touchPinchMovementEvent.angleAndHeight.endPosition);
        action(touchPinchMovementEvent);
      }
    }
  }
  function handlePointerDown(screenSpaceEventHandler, event) {
    event.target.setPointerCapture(event.pointerId);
    if (event.pointerType === 'touch') {
      var positions = screenSpaceEventHandler._positions;
      var identifier = event.pointerId;
      positions.set(identifier, getPosition(screenSpaceEventHandler, event, new Cartesian2()));
      fireTouchEvents(screenSpaceEventHandler, event);
      var previousPositions = screenSpaceEventHandler._previousPositions;
      previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));
    } else {
      handleMouseDown(screenSpaceEventHandler, event);
    }
  }
  function handlePointerUp(screenSpaceEventHandler, event) {
    if (event.pointerType === 'touch') {
      var positions = screenSpaceEventHandler._positions;
      var identifier = event.pointerId;
      positions.remove(identifier);
      fireTouchEvents(screenSpaceEventHandler, event);
      var previousPositions = screenSpaceEventHandler._previousPositions;
      previousPositions.remove(identifier);
    } else {
      handleMouseUp(screenSpaceEventHandler, event);
    }
  }
  function handlePointerMove(screenSpaceEventHandler, event) {
    if (event.pointerType === 'touch') {
      var positions = screenSpaceEventHandler._positions;
      var identifier = event.pointerId;
      var position = positions.get(identifier);
      if (!defined$1(position)) {
        return;
      }
      getPosition(screenSpaceEventHandler, event, position);
      fireTouchMoveEvents(screenSpaceEventHandler, event);
      var previousPositions = screenSpaceEventHandler._previousPositions;
      Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));
    } else {
      handleMouseMove(screenSpaceEventHandler, event);
    }
  }

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   *
   * @class ScreenSpaceEventHandler
   * 处理用户输入事件。可以添加自定义函数，以在用户输入时执行。
   * @param {HTMLCanvasElement} element=document <code>optional</code> 要添加事件的元素。
   *
   * @constructor
   */
  function ScreenSpaceEventHandler(element) {
    this._inputEvents = {};
    this._buttonDown = {
      LEFT: false,
      MIDDLE: false,
      RIGHT: false
    };
    this._isPinching = false;
    this._isTouchHolding = false;
    this._lastSeenTouchEvent = -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;
    this._primaryStartPosition = new Cartesian2();
    this._primaryPosition = new Cartesian2();
    this._primaryPreviousPosition = new Cartesian2();
    this._positions = new AssociativeArray();
    this._previousPositions = new AssociativeArray();
    this._removalFunctions = [];
    this._touchHoldTimer = undefined;

    // TODO: Revisit when doing mobile development. May need to be configurable
    // or determined based on the platform?
    this._clickPixelTolerance = 5;
    this._holdPixelTolerance = 25;
    this._element = defaultValue$1(element, document);
    registerListeners(this);
  }

  /**
   * 设置一个函数，在输入事件发生时执行。
   * @param {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} action 在输入事件发生时要执行的函数。
   * @param {ScreenSpaceEventType} type 输入事件的ScreenSpaceEventType。
   * @param {KeyboardEventModifier} modifier <code>optional</code> 在发生type事件时按住的 KeyboardEventModifier 键
   */
  ScreenSpaceEventHandler.prototype.setInputAction = function (action, type, modifier) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(action)) {
      throw new DeveloperError$1('action is required.');
    }
    if (!defined$1(type)) {
      throw new DeveloperError$1('type is required.');
    }
    //>>includeEnd('debug');

    var key = getInputEventKey(type, modifier);
    this._inputEvents[key] = action;
  };

  /**
   * 返回在输入事件发生时要执行的函数。
   * @param {ScreenSpaceEventType} type 输入事件的 ScreenSpaceEventType。
   * @param {KeyboardEventModifier} modifier <code>optional</code> 在发生<code>type</code>事件时按住的 KeyboardEventModifier 键。
   * @returns {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} 在输入事件发生时要执行的函数。
   */
  ScreenSpaceEventHandler.prototype.getInputAction = function (type, modifier) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(type)) {
      throw new DeveloperError$1('type is required.');
    }
    //>>includeEnd('debug');

    var key = getInputEventKey(type, modifier);
    return this._inputEvents[key];
  };

  /**
   * 删除在输入事件发生时要执行的函数。
   * @param {ScreenSpaceEventType} type 输入事件的 ScreenSpaceEventType。
   * @param {KeyboardEventModifier} modifier <code>optional</code> 在发生type事件时按住的 KeyboardEventModifier 键。
   */
  ScreenSpaceEventHandler.prototype.removeInputAction = function (type, modifier) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(type)) {
      throw new DeveloperError$1('type is required.');
    }
    //>>includeEnd('debug');

    var key = getInputEventKey(type, modifier);
    delete this._inputEvents[key];
  };

  /**
   * 如果此对象被销毁，则返回true；否则返回false。
   * @returns {Boolean} 如果此对象已被销毁，则为true；否则为false。
   */
  ScreenSpaceEventHandler.prototype.isDestroyed = function () {
    return false;
  };

  /**
   * 移除该对象持有的监听器。一旦对象被销毁，它不应该再被使用；调用任何除了 isDestroyed 以外的函数将导致一个 {@link DeveloperError} 异常。因此，按照示例将返回值(undefined)分配给该对象。
   * 
   * @exception {DeveloperError} 该对象已被销毁，即 destroy() 被调用。
   * @example
   * handler = handler && handler.destroy();
   */
  ScreenSpaceEventHandler.prototype.destroy = function () {
    unregisterListeners(this);
    return destroyObject(this);
  };

  /*
   * The amount of time, in milliseconds, that mouse events will be disabled after
   * receiving any touch events, such that any emulated mouse events will be ignored.
   * @type {Number}
   * @default 800
   */
  ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;

  /*
   * The amount of time, in milliseconds, before a touch on the screen becomes a
   * touch and hold.
   * @type {Number}
   * @default 1500
   */
  ScreenSpaceEventHandler.touchHoldDelayMilliseconds = 1500;

  /**
   * Determines visibility based on the distance to the camera.
   *
   * @alias DistanceDisplayCondition
   * @constructor
   *
   * @param {Number} [near=0.0] The smallest distance in the interval where the object is visible.
   * @param {Number} [far=Number.MAX_VALUE] The largest distance in the interval where the object is visible.
   *
   * @example
   * // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.
   * billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(10.0, 20.0);
   */
  function DistanceDisplayCondition(near, far) {
    near = defaultValue$1(near, 0.0);
    this._near = near;
    far = defaultValue$1(far, Number.MAX_VALUE);
    this._far = far;
  }
  Object.defineProperties(DistanceDisplayCondition.prototype, {
    /**
     * The smallest distance in the interval where the object is visible.
     * @memberof DistanceDisplayCondition.prototype
     * @type {Number}
     * @default 0.0
     */
    near: {
      get: function get() {
        return this._near;
      },
      set: function set(value) {
        this._near = value;
      }
    },
    /**
     * The largest distance in the interval where the object is visible.
     * @memberof DistanceDisplayCondition.prototype
     * @type {Number}
     * @default Number.MAX_VALUE
     */
    far: {
      get: function get() {
        return this._far;
      },
      set: function set(value) {
        this._far = value;
      }
    }
  });

  /**
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  DistanceDisplayCondition.packedLength = 2;

  /**
   * Stores the provided instance into the provided array.
   *
   * @param {DistanceDisplayCondition} value The value to pack.
   * @param {Number[]} array The array to pack into.
   * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
   *
   * @returns {Number[]} The array that was packed into
   */
  DistanceDisplayCondition.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(value)) {
      throw new DeveloperError$1("value is required");
    }
    if (!defined$1(array)) {
      throw new DeveloperError$1("array is required");
    }
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value.near;
    array[startingIndex] = value.far;
    return array;
  };

  /**
   * Retrieves an instance from a packed array.
   *
   * @param {Number[]} array The packed array.
   * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
   * @param {DistanceDisplayCondition} [result] The object into which to store the result.
   * @returns {DistanceDisplayCondition} The modified result parameter or a new DistanceDisplayCondition instance if one was not provided.
   */
  DistanceDisplayCondition.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(array)) {
      throw new DeveloperError$1("array is required");
    }
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new DistanceDisplayCondition();
    }
    result.near = array[startingIndex++];
    result.far = array[startingIndex];
    return result;
  };

  /**
   * Determines if two distance display conditions are equal.
   *
   * @param {DistanceDisplayCondition} left A distance display condition.
   * @param {DistanceDisplayCondition} right Another distance display condition.
   * @return {Boolean} Whether the two distance display conditions are equal.
   */
  DistanceDisplayCondition.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left.near === right.near && left.far === right.far;
  };

  /**
   * Duplicates a distance display condition instance.
   *
   * @param {DistanceDisplayCondition} [value] The distance display condition to duplicate.
   * @param {DistanceDisplayCondition} [result] The result onto which to store the result.
   * @return {DistanceDisplayCondition} The duplicated instance.
   */
  DistanceDisplayCondition.clone = function (value, result) {
    if (!defined$1(value)) {
      return undefined;
    }
    if (!defined$1(result)) {
      result = new DistanceDisplayCondition();
    }
    result.near = value.near;
    result.far = value.far;
    return result;
  };

  /**
   * Duplicates this instance.
   *
   * @param {DistanceDisplayCondition} [result] The result onto which to store the result.
   * @return {DistanceDisplayCondition} The duplicated instance.
   */
  DistanceDisplayCondition.prototype.clone = function (result) {
    return DistanceDisplayCondition.clone(this, result);
  };

  /**
   * Determines if this distance display condition is equal to another.
   *
   * @param {DistanceDisplayCondition} other Another distance display condition.
   * @return {Boolean} Whether this distance display condition is equal to the other.
   */
  DistanceDisplayCondition.prototype.equals = function (other) {
    return DistanceDisplayCondition.equals(this, other);
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * 
   * @class Event
   * 一种通用的实用程序类，用于管理特定事件的订阅者。该类通常在容器类中实例化，并公开为属性，供其他人订阅。
   * @constructor
   * @example
   * MyObject.prototype.myListener = function(arg1, arg2) {
   *     this.myArg1Copy = arg1;
   *     this.myArg2Copy = arg2;
   * }
   *
   * const myObjectInstance = new MyObject();
   * const evt = new Earth.Event();
   * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
   * evt.raiseEvent('1', '2');
   * evt.removeEventListener(MyObject.prototype.myListener);
   */
  function Event() {
    this._listeners = [];
    this._scopes = [];
    this._toRemove = [];
    this._insideRaiseEvent = false;
  }
  Object.defineProperties(Event.prototype, {
    /** 
     * 当前订阅事件的侦听器数量。
     * @memberof Event.prototype
     * @type {Number}
     * @readonly
     */
    numberOfListeners: {
      get: function get() {
        return this._listeners.length - this._toRemove.length;
      }
    }
  });

  /**
   * 注册一个回调函数，每当事件被触发时都会执行。可以提供一个可选的作用域作为this指针，在该函数执行时使用。
   * @param {Listener} listener 当事件被触发时需要执行的函数。
   * @param {Object} scope <code>optional</code> 可选的对象作用域，用作this指针，该监听函数将在其中执行。
   * @returns {Event.RemoveCallback} 调用时将删除此事件侦听器的函数
   */
  Event.prototype.addEventListener = function (listener, scope) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.func('listener', listener);
    //>>includeEnd('debug');

    this._listeners.push(listener);
    this._scopes.push(scope);
    var event = this;
    return function () {
      event.removeEventListener(listener, scope);
    };
  };

  /**
   * 注销以前注册的回调函数。
   * @param {Listener} listener 要注销的函数。
   * @param {Object} scope <code>optional</code> 最初传递给 addEventListener 的作用域。
   * @returns {Boolean} 如果已删除侦听器，则返回true；如果未将侦听器和作用域注册到事件中，则返回false。
   */
  Event.prototype.removeEventListener = function (listener, scope) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.func('listener', listener);
    //>>includeEnd('debug');

    var listeners = this._listeners;
    var scopes = this._scopes;
    var index = -1;
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener && scopes[i] === scope) {
        index = i;
        break;
      }
    }
    if (index !== -1) {
      if (this._insideRaiseEvent) {
        //In order to allow removing an event subscription from within
        //a callback, we don't actually remove the items here.  Instead
        //remember the index they are at and undefined their value.
        this._toRemove.push(index);
        listeners[index] = undefined;
        scopes[index] = undefined;
      } else {
        listeners.splice(index, 1);
        scopes.splice(index, 1);
      }
      return true;
    }
    return false;
  };
  function compareNumber(a, b) {
    return b - a;
  }

  /**
   * 通过调用每个已注册的监听器并传递所有提供的参数来触发事件。
   * @param {...Parameters<Listener>} arguments 此方法接受任意数量的参数，并将它们传递给监听函数。
   */
  Event.prototype.raiseEvent = function () {
    this._insideRaiseEvent = true;
    var i;
    var listeners = this._listeners;
    var scopes = this._scopes;
    var length = listeners.length;
    for (i = 0; i < length; i++) {
      var listener = listeners[i];
      if (defined$1(listener)) {
        listeners[i].apply(scopes[i], arguments);
      }
    }

    //Actually remove items removed in removeEventListener.
    var toRemove = this._toRemove;
    length = toRemove.length;
    if (length > 0) {
      toRemove.sort(compareNumber);
      for (i = 0; i < length; i++) {
        var index = toRemove[i];
        listeners.splice(index, 1);
        scopes.splice(index, 1);
      }
      toRemove.length = 0;
    }
    this._insideRaiseEvent = false;
  };

  /**
   * A {@link Property} whose value does not change with respect to simulation time.
   *
   * @alias ConstantProperty
   * @constructor
   *
   * @param {*} [value] The property value.
   *
   * @see ConstantPositionProperty
   */
  function ConstantProperty(value) {
    this._value = undefined;
    this._hasClone = false;
    this._hasEquals = false;
    this._definitionChanged = new Event();
    this.setValue(value);
  }
  Object.defineProperties(ConstantProperty.prototype, {
    /**
     * Gets a value indicating if this property is constant.
     * This property always returns <code>true</code>.
     * @memberof ConstantProperty.prototype
     *
     * @type {Boolean}
     * @readonly
     */
    isConstant: {
      value: true
    },
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value.
     * @memberof ConstantProperty.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    }
  });

  /**
   * Gets the value of the property.
   *
   * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
   * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
   * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
   */
  ConstantProperty.prototype.getValue = function (time, result) {
    return this._hasClone ? this._value.clone(result) : this._value;
  };

  /**
   * Sets the value of the property.
   *
   * @param {*} value The property value.
   */
  ConstantProperty.prototype.setValue = function (value) {
    var oldValue = this._value;
    if (oldValue !== value) {
      var isDefined = defined$1(value);
      var hasClone = isDefined && typeof value.clone === "function";
      var hasEquals = isDefined && typeof value.equals === "function";
      var changed = !hasEquals || !value.equals(oldValue);
      if (changed) {
        this._hasClone = hasClone;
        this._hasEquals = hasEquals;
        this._value = !hasClone ? value : value.clone(this._value);
        this._definitionChanged.raiseEvent(this);
      }
    }
  };

  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {Property} [other] The other property.
   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  ConstantProperty.prototype.equals = function (other) {
    return this === other ||
    //
    other instanceof ConstantProperty && (
    //
    !this._hasEquals && this._value === other._value ||
    //
    this._hasEquals && this._value.equals(other._value));
  };

  /**
   * Gets this property's value.
   *
   * @returns {*} This property's value.
   */
  ConstantProperty.prototype.valueOf = function () {
    return this._value;
  };

  /**
   * Creates a string representing this property's value.
   *
   * @returns {String} A string representing the property's value.
   */
  ConstantProperty.prototype.toString = function () {
    return String(this._value);
  };

  /*
   * @FilePath: createPropertyDescriptor.js
   * @Author: chenqian
   * @Date: 2023-02-08 16:51:37
   * @LastEditors: cheniqan
   * @LastEditTime: 2023-02-09 14:59:13
   * @Descripttion:
   */
  function createProperty(name, privateName, subscriptionName, configurable, createPropertyCallback) {
    return {
      configurable: configurable,
      get: function get() {
        return this[privateName];
      },
      set: function set(value) {
        var oldValue = this[privateName];
        var subscription = this[subscriptionName];
        if (defined$1(subscription)) {
          subscription();
          this[subscriptionName] = undefined;
        }
        var hasValue = value !== undefined;
        if (hasValue && (!defined$1(value) || !defined$1(value.getValue)) && defined$1(createPropertyCallback)) {
          value = createPropertyCallback(value);
        }
        if (oldValue !== value) {
          this[privateName] = value;
          this._definitionChanged.raiseEvent(this, name, value, oldValue);
        }
        if (defined$1(value) && defined$1(value.definitionChanged)) {
          this[subscriptionName] = value.definitionChanged.addEventListener(function () {
            this._definitionChanged.raiseEvent(this, name, value, value);
          }, this);
        }
      }
    };
  }
  function createConstantProperty(value) {
    return new ConstantProperty(value);
  }

  /**
   * Used to consistently define all DataSources graphics objects.
   * This is broken into two functions because the Chrome profiler does a better
   * job of optimizing lookups if it notices that the string is constant throughout the function.
   * @private
   */
  function createPropertyDescriptor(name, configurable, createPropertyCallback) {
    //Safari 8.0.3 has a JavaScript bug that causes it to confuse two variables and treat them as the same.
    //The two extra toString calls work around the issue.
    return createProperty(name, "_".concat(name.toString()), "_".concat(name.toString(), "Subscription"), defaultValue$1(configurable, false), defaultValue$1(createPropertyCallback, createConstantProperty));
  }

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Point
   * 点类
   */
  var Point$2 = /*#__PURE__*/function () {
    /**
     * Point的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Boolean} options.show <code>optional</code> 指定点的可见性。
     * @param {Number} options.pixelSize <code>optional</code> 以像素为单位指定大小。
     * @param {Color} options.color <code>optional</code> 指定颜色。
     * @param {HeightReference} options.heightReference <code>optional</code> 相对高度
     */
    function Point(options) {
      _classCallCheck(this, Point);
      this._definitionChanged = new Event();
      this._show = undefined;
      this._showSubscription = undefined;
      this._pixelSize = undefined;
      this._pixelSizeSubscription = undefined;
      this._heightReference = undefined;
      this._heightReferenceSubscription = undefined;
      this._color = undefined;
      this._colorSubscription = undefined;
      this._outlineColor = undefined;
      this._outlineColorSubscription = undefined;
      this._outlineWidth = undefined;
      this._outlineWidthSubscription = undefined;
      this._distanceDisplayCondition = undefined;
      this._distanceDisplayConditionSubscription = undefined;
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Point} result 用于存储结果的对象。
     * @returns {Point} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Point, [{
      key: "clone",
      value: function clone(result) {
        if (!defined$1(result)) {
          return new Point(this);
        }
        result.show = this.show;
        result.pixelSize = this.pixelSize;
        result.heightReference = this.heightReference;
        result.color = this.color;
        result.outlineColor = this.outlineColor;
        result.outlineWidth = this.outlineWidth;
        result.distanceDisplayCondition = this.distanceDisplayCondition;
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Point} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        //>>includeEnd('debug');
        this.show = defaultValue$1(this.show, source.show);
        this.pixelSize = defaultValue$1(this.pixelSize, source.pixelSize);
        this.heightReference = defaultValue$1(this.heightReference, source.heightReference);
        this.color = defaultValue$1(this.color, source.color);
        this.outlineColor = defaultValue$1(this.outlineColor, source.outlineColor);
        this.outlineWidth = defaultValue$1(this.outlineWidth, source.outlineWidth);
        this.distanceDisplayCondition = defaultValue$1(this.distanceDisplayCondition, source.distanceDisplayCondition);
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return Point;
  }();
  Object.defineProperties(Point$2.prototype, {
    /**
     * 获取每当更改或修改属性或子属性时引发的事件。
     * @memberof Point.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    /**
     * 获取或设置指定点的可见性的布尔属性。
     * @memberof Point.prototype
     * @type {Property|undefined}
     * @default true
     */
    show: createPropertyDescriptor('show'),
    /**
     * 获取或设置数字属性，以像素为单位指定大小。
     * @memberof Point.prototype
     * @type {Property|undefined}
     * @default 1
     */
    pixelSize: createPropertyDescriptor('pixelSize'),
    /**
     * 获取或设置指定 HeightReference 的属性。
     * @memberof Point.prototype
     * @type {Property|undefined}
     * @default HeightReference.NONE
     */
    heightReference: createPropertyDescriptor('heightReference'),
    /**
     * 获取或设置指定该点的 Color 的属性。
     * @memberof Point.prototype
     * @type {Property|undefined}
     * @default Color.WHITE
     */
    color: createPropertyDescriptor('color'),
    /**
     * 获取或设置指定轮廓的 Color 的属性。
     * @memberof Point.prototype
     * @type {Property|undefined}
     * @default Color.BLACK
     */
    outlineColor: createPropertyDescriptor('outlineColor'),
    /**
     * 获取或设置数字属性，该属性指定轮廓宽度（以像素为单位）。
     * @memberof Point.prototype
     * @type {Property|undefined}
     * @default 0
     */
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    /**
     * 获取或设置 DistanceDisplayCondition 属性，该属性指定将在距摄像机的距离处显示此点。
     * @memberof Point.prototype
     * @type {Property|undefined}
     */
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition')
  });

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Polyline
   * 线类
   */
  var Polyline = /*#__PURE__*/function () {
    /**
     * Polyline类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Boolean} options.show <code>optional</code> 指定线的可见性
     * @param {Cartesian3} options.positions 指定折线的顶点位置
     * @param {Number} options.width <code>optional</code> 指定宽度（以像素为单位）的数值属性。
     * @param {Color} options.color <code>optional</code> 指定折线的颜色。
     * @param {Boolean} options.clampToGround <code>optional</code> 指定折线是否贴着地面显示。
     */
    function Polyline(options) {
      _classCallCheck(this, Polyline);
      this._definitionChanged = new Event();
      this._show = defaultValue$1(options.show, true);
      this._showSubscription = undefined;
      this._color = undefined;
      this._material = undefined;
      this._positions = undefined;
      this._positionsSubscription = undefined;
      this._width = undefined;
      this._widthSubscription = undefined;
      this._arcType = undefined;
      this._arcTypeSubscription = undefined;
      this._clampToGround = undefined;
      this._clampToGroundSubscription = undefined;
      this._classificationType = undefined;
      this._classificationTypeSubscription = undefined;
      this._distanceDisplayCondition = undefined;
      this._distanceDisplayConditionSubscription = undefined;
      this._zIndex = undefined;
      this._zIndexSubscription = undefined;
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Polyline} result 用于存储结果的对象。
     * @returns {Polyline} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Polyline, [{
      key: "clone",
      value: function clone(result) {
        if (!defined$1(result)) {
          return new Polyline(this);
        }
        result.show = this.show;
        result.color = this.color;
        result.material = this.material;
        result.positions = this.positions;
        result.width = this.width;
        result.arcType = this.arcType;
        result.clampToGround = this.clampToGround;
        result.classificationType = this.classificationType;
        result.distanceDisplayCondition = this.distanceDisplayCondition;
        result.zIndex = this.zIndex;
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Polyline} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        //>>includeEnd('debug');

        this.show = defaultValue$1(this.show, source.show);
        this.color = defaultValue$1(this.color, source.color);
        this.material = defaultValue$1(this.material, source.material);
        this.positions = defaultValue$1(this.positions, source.positions);
        this.width = defaultValue$1(this.width, source.width);
        this.arcType = defaultValue$1(this.arcType, source.arcType);
        this.clampToGround = defaultValue$1(this.clampToGround, source.clampToGround);
        this.distanceDisplayCondition = defaultValue$1(this.distanceDisplayCondition, source.distanceDisplayCondition);
        this.classificationType = defaultValue$1(this.classificationType, source.classificationType);
        this.zIndex = defaultValue$1(this.zIndex, source.zIndex);
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return Polyline;
  }();
  Object.defineProperties(Polyline.prototype, {
    /**
     * 获取每当更改或修改属性或子属性时引发的事件。
     * @memberof Polyline.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    /**
     * 获取或设置指定多段线可见性的布尔属性。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     * @default true
     */
    show: createPropertyDescriptor('show'),
    id: {
      get: function get() {
        return this._id;
      }
    },
    /**
     * 获取或设置指定多段线颜色的属性。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     * @default true
     */
    color: createPropertyDescriptor('color'),
    material: createPropertyDescriptor('material'),
    /**
     * 获取或设置指定Cartesian3数组的属性定义线条的位置。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     */
    positions: createPropertyDescriptor('positions'),
    /**
     * 获取或设置以像素为单位指定宽度的数字属性。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     * @default 1.0
     */
    width: createPropertyDescriptor('width'),
    /**
     * 获取或设置ArcType属性，该属性指定线段是大圆弧、粗直线还是线性连接。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     * @default ArcType.GEODESIC
     */
    arcType: createPropertyDescriptor('arcType'),
    /**
     * 获取或设置布尔属性，该属性指定多段线是否应固定到地面。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     * @default false
     */
    clampToGround: createPropertyDescriptor('clampToGround'),
    /**
     * 获取或设置DistanceDisplayCondition属性，该属性指定此多段线将显示在距相机的距离处。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     */
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition'),
    /**
     * 获取或设置ClassificationType属性，该属性指定此多段线在地面上是否将对地形、三维平铺或两者进行分类。
     * @memberof Polyline.prototype
     * @type {Property|undefined}
     * @default ClassificationType.BOTH
     */
    classificationType: createPropertyDescriptor('classificationType'),
    /**
     * 获取或设置指定多段线顺序的zIndex属性。
     * @memberof Polyline.prototype
     * @type {ConstantProperty|undefined}
     * @default 0
     */
    zIndex: createPropertyDescriptor('zIndex')
  });

  /**
   * An hierarchy of linear rings which define a polygon and its holes.
   * The holes themselves may also have holes which nest inner polygons.
   * @alias PolygonHierarchy
   * @constructor
   *
   * @param {Cartesian3[]} [positions] A linear ring defining the outer boundary of the polygon or hole.
   * @param {PolygonHierarchy[]} [holes] An array of polygon hierarchies defining holes in the polygon.
   */
  function PolygonHierarchy(positions, holes) {
    /**
     * A linear ring defining the outer boundary of the polygon or hole.
     * @type {Cartesian3[]}
     */
    this.positions = defined$1(positions) ? positions : [];

    /**
     * An array of polygon hierarchies defining holes in the polygon.
     * @type {PolygonHierarchy[]}
     */
    this.holes = defined$1(holes) ? holes : [];
  }

  function createPolygonHierarchyProperty(value) {
    if (Array.isArray(value)) {
      // convert array of positions to PolygonHierarchy object
      value = new PolygonHierarchy(value);
    }
    return new ConstantProperty(value);
  }

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Polygon
   * 面类
   */
  var Polygon = /*#__PURE__*/function () {
    /**
     * Polygon类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Number} options.extrudedHeight <code>optional</code> 指定面的可见性。
     * @param {Boolean} options.show <code>optional</code> 指定面的拉伸高度，即在地球表面以上的高度。
     * @param {Cartesian3} options.hierarchy <code>optional</code> 指定面的层次结构的数组。
     * @param {Material} options.material <code>optional</code> 指定面的的材质，可以是颜色、图片、纹理等。
     * @param {HeightReference} options.heightReference <code>optional</code> 指定面相对于哪个参考高度进行定位。
     * @param {Boolean} options.outline <code>optional</code> 指定是否显示面的轮廓线。
     * @param {Color} options.outlineColor <code>optional</code> 指定面的轮廓线的颜色。
     */
    function Polygon(options) {
      _classCallCheck(this, Polygon);
      this._definitionChanged = new Event();
      this._show = defaultValue$1(options.show, true);
      this._showSubscription = undefined;
      this._color = undefined;
      this._hierarchy = undefined;
      this._hierarchySubscription = undefined;
      this._height = undefined;
      this._heightSubscription = undefined;
      this._heightReference = undefined;
      this._heightReferenceSubscription = undefined;
      this._fill = undefined;
      this._fillSubscription = undefined;
      this._outline = undefined;
      this._outlineSubscription = undefined;
      this._outlineColor = undefined;
      this._outlineColorSubscription = undefined;
      this._outlineWidth = undefined;
      this._outlineWidthSubscription = undefined;
      this._perPositionHeight = undefined;
      this._perPositionHeightSubscription = undefined;
      this._extrudedHeight = undefined;
      this._material = undefined;
      this._arcType = undefined;
      this._arcTypeSubscription = undefined;
      this._distanceDisplayCondition = undefined;
      this._distanceDisplayConditionSubscription = undefined;
      this._classificationType = undefined;
      this._classificationTypeSubscription = undefined;
      this._zIndex = undefined;
      this._zIndexSubscription = undefined;
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Polygon} result 用于存储结果的对象。
     * @returns {Polygon} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Polygon, [{
      key: "clone",
      value: function clone(result) {
        if (!defined$1(result)) {
          return new Polygon(this);
        }
        result.show = this.show;
        result.color = this.color;
        result.hierarchy = this.hierarchy;
        result.height = this.height;
        result.heightReference = this.heightReference;
        result.extrudedHeight = this.extrudedHeight;
        result.material = this.material;
        result.fill = this.fill;
        result.outline = this.outline;
        result.outlineColor = this.outlineColor;
        result.outlineWidth = this.outlineWidth;
        result.perPositionHeight = this.perPositionHeight;
        result.arcType = this.arcType;
        result.distanceDisplayCondition = this.distanceDisplayCondition;
        result.classificationType = this.classificationType;
        result.zIndex = this.zIndex;
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Polygon} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this.show = defaultValue$1(this.show, source.show);
        this.color = defaultValue$1(this.color, source.color);
        this.hierarchy = defaultValue$1(this.hierarchy, source.hierarchy);
        this.height = defaultValue$1(this.height, source.height);
        this.extrudedHeight = defaultValue$1(this.extrudedHeight, source.extrudedHeight);
        this.material = defaultValue$1(this.material, source.material);
        this.heightReference = defaultValue$1(this.heightReference, source.heightReference);
        this.fill = defaultValue$1(this.fill, source.fill);
        this.outline = defaultValue$1(this.outline, source.outline);
        this.outlineColor = defaultValue$1(this.outlineColor, source.outlineColor);
        this.outlineWidth = defaultValue$1(this.outlineWidth, source.outlineWidth);
        this.perPositionHeight = defaultValue$1(this.perPositionHeight, source.perPositionHeight);
        this.arcType = defaultValue$1(this.arcType, source.arcType);
        this.distanceDisplayCondition = defaultValue$1(this.distanceDisplayCondition, source.distanceDisplayCondition);
        this.classificationType = defaultValue$1(this.classificationType, source.classificationType);
        this.zIndex = defaultValue$1(this.zIndex, source.zIndex);
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return Polygon;
  }();
  Object.defineProperties(Polygon.prototype, {
    /**
     * 获取每当更改或修改属性或子属性时引发的事件。
     * @memberof Polygon.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    /**
     * 获取或设置指定多边形可见性的布尔属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default true
     */
    show: createPropertyDescriptor('show'),
    /**
     * 获取或设置指定多边形颜色的属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default true
     */
    color: createPropertyDescriptor('color'),
    /**
     * 获取或设置指定PolygonHierarchy的属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     */
    hierarchy: createPropertyDescriptor('hierarchy', undefined, createPolygonHierarchyProperty),
    /**
     * 获取或设置指定多边形恒定高度的数字属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default 0.0
     */
    height: createPropertyDescriptor('height'),
    extrudedHeight: createPropertyDescriptor('extrudedHeight'),
    material: createPropertyDescriptor('material'),
    /**
     * 获取或设置指定HeightReference的属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default HeightReference.NONE
     */
    heightReference: createPropertyDescriptor('heightReference'),
    /**
     * 获取或设置布尔属性，该属性指定多边形是否用提供的材质填充。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default true
     */
    fill: createPropertyDescriptor('fill'),
    /**
     * 获取或设置属性，该属性指定多边形是否为轮廓。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default false
     */
    outline: createPropertyDescriptor('outline'),
    /**
     * 获取或设置指定轮廓的颜色属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default Color.BLACK
     */
    outlineColor: createPropertyDescriptor('outlineColor'),
    /**
     * 获取或设置指定轮廓宽度的数字属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default 1.0
     */
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    /**
     * 获取或设置布尔值，该布尔值指定是否使用每个位置的高度。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     */
    perPositionHeight: createPropertyDescriptor('perPositionHeight'),
    /**
     * 获取或设置指定多边形边使用的线条类型的ArcType属性。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default ArcType.GEODESIC
     */
    arcType: createPropertyDescriptor('arcType'),
    /**
     * 获取或设置DistanceDisplayCondition属性，该属性指定此多边形将显示在距相机的距离处。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     */
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition'),
    /**
     * 
     * 获取或设置ClassificationType属性，该属性指定此多边形在地面上是否将对地形、3DTiles或两者进行分类。
     * @memberof Polygon.prototype
     * @type {Property|undefined}
     * @default ClassificationType.BOTH
     */
    classificationType: createPropertyDescriptor('classificationType'),
    /**
     * 获取或设置指定地面几何图形顺序的zIndex属性。
     * @memberof Polygon.prototype
     * @type {ConstantProperty|undefined}
     * @default 0
     */
    zIndex: createPropertyDescriptor('zIndex')
  });

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Label
   * 标签类
   */
  var Label = /*#__PURE__*/function () {
    /**
     * Label类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Boolean} options.show=true <code>optional</code> 指定标签的可见性。
     * @param {String} options.text <code>optional</code> 指定标签文本的内容。
     * @param {String} options.font <code>optional</code> 指定标签文本的字体大小和字体类型。
     * @param {Color} options.fillColor <code>optional</code> 指定标签文本的填充颜色。
     * @param {HeightReference} options.heightReference <code>optional</code> 指定标签的高度参考系。
     * @param {VerticalOrigin} options.verticalOrigin <code>optional</code> 指定标签文本垂直对齐的位置。
     * @param {HorizontalOrigin} options.horizontalOrigin <code>optional</code> 指定标签文本水平对齐的位置。
     * @param {PixelOffset} options.pixelOffset <code>optional</code> 指定标签文本相对于其所在点的像素偏移量。
     * @param {ShowBackground} options.showBackground <code>optional</code> 指定是否显示标签文本的背景
     * @param {BackgroundColor} options.backgroundColor <code>optional</code> 指定标签文本的背景颜色。
     */
    function Label(options) {
      _classCallCheck(this, Label);
      this._definitionChanged = new Event();
      this._show = undefined;
      this._text = undefined;
      this._font = undefined;
      this._style = undefined;
      this._showBackground = undefined;
      this._backgroundColor = undefined;
      this._pixelOffset = undefined;
      this._eyeOffset = undefined;
      this._horizontalOrigin = undefined;
      this._verticalOrigin = undefined;
      this._heightReference = undefined;
      this._fillColor = undefined;
      this._outlineColor = undefined;
      this._outlineWidth = undefined;
      this._distanceDisplayCondition = undefined;
      this._scaleByDistance = undefined;
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Label} result 用于存储结果的对象。
     * @returns {Label} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Label, [{
      key: "clone",
      value: function clone(result) {
        if (!defined$1(result)) {
          return new Label(this);
        }
        result.show = this.show;
        result.text = this.text;
        result.font = this.font;
        result.style = this.style;
        result.showBackground = this.showBackground;
        result.backgroundColor = this.backgroundColor;
        result.pixelOffset = this.pixelOffset;
        result.eyeOffset = this.eyeOffset;
        result.horizontalOrigin = this.horizontalOrigin;
        result.verticalOrigin = this.verticalOrigin;
        result.heightReference = this.heightReference;
        result.fillColor = this.fillColor;
        result.outlineColor = this.outlineColor;
        result.outlineWidth = this.outlineWidth;
        result.distanceDisplayCondition = this.distanceDisplayCondition;
        result.scaleByDistance = this.scaleByDistance;
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Label} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined$1(source)) {
          throw new DeveloperError$1("source is required.");
        }
        //>>includeEnd('debug');

        this.show = defaultValue$1(this.show, source.show);
        this.text = defaultValue$1(this.text, source.text);
        this.font = defaultValue$1(this.font, source.font);
        this.style = defaultValue$1(this.style, source.style);
        this.showBackground = defaultValue$1(this.showBackground, source.showBackground);
        this.backgroundColor = defaultValue$1(this.backgroundColor, source.backgroundColor);
        this.pixelOffset = defaultValue$1(this.pixelOffset, source.pixelOffset);
        this.eyeOffset = defaultValue$1(this.eyeOffset, source.eyeOffset);
        this.horizontalOrigin = defaultValue$1(this.horizontalOrigin, source.horizontalOrigin);
        this.verticalOrigin = defaultValue$1(this.verticalOrigin, source.verticalOrigin);
        this.heightReference = defaultValue$1(this.heightReference, source.heightReference);
        this.fillColor = defaultValue$1(this.fillColor, source.fillColor);
        this.outlineColor = defaultValue$1(this.outlineColor, source.outlineColor);
        this.outlineWidth = defaultValue$1(this.outlineWidth, source.outlineWidth);
        this.distanceDisplayCondition = defaultValue$1(this.distanceDisplayCondition, source.distanceDisplayCondition);
        this.scaleByDistance = defaultValue$1(this.scaleByDistance, source.scaleByDistance);
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return Label;
  }();
  Object.defineProperties(Label.prototype, {
    /**
     * 获取每当属性或子属性被更改或修改时触发的事件。
     * @memberof Label.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    /**
     * 获取或设置布尔类型的属性，用于指定标签的可见性。
     * @memberof Label.prototype
     * @type {Property|undefined}
     * @default true
     */
    show: createPropertyDescriptor("show"),
    text: createPropertyDescriptor("text"),
    font: createPropertyDescriptor("font"),
    style: createPropertyDescriptor("style"),
    showBackground: createPropertyDescriptor("showBackground"),
    backgroundColor: createPropertyDescriptor("backgroundColor"),
    pixelOffset: createPropertyDescriptor("pixelOffset"),
    eyeOffset: createPropertyDescriptor("eyeOffset"),
    horizontalOrigin: createPropertyDescriptor("horizontalOrigin"),
    verticalOrigin: createPropertyDescriptor("verticalOrigin"),
    heightReference: createPropertyDescriptor("heightReference"),
    fillColor: createPropertyDescriptor("fillColor"),
    outlineColor: createPropertyDescriptor("outlineColor"),
    outlineWidth: createPropertyDescriptor("outlineWidth"),
    distanceDisplayCondition: createPropertyDescriptor("distanceDisplayCondition"),
    scaleByDistance: createPropertyDescriptor("scaleByDistance")
  });

  var propertyNames$5 = ['show', 'image', 'scale', 'pixelOffset', 'eyeOffset', 'horizontalOrigin', 'verticalOrigin', 'heightReference', 'color', 'rotation', 'width', 'height', 'scaleByDistance', 'distanceDisplayCondition', 'sizeInMeters'];
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Billboard
   * 标牌类
   */
  var Billboard = /*#__PURE__*/function () {
    /**
     * Billboard类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Boolean} options.show=true <code>optional</code> 用于指定标牌的可见性。
     * @param {String} options.image <code>optional</code> 用于指定标牌的URL。
     * @param {HorizontalOrigin} options.horizontalOrigin=HorizontalOrigin.CENTER <code>optional</code> 用于指定HorizontalOrigin。
     * @param {VerticalOrigin} options.verticalOrigin=VerticalOrigin.CENTER <code>optional</code> 用于指定VerticalOrigin。
     * @param {HeightReference} options.heightReference=HeightReference.NONE <code>optional</code> 用于指定高度相对于什么。
     * @param {Number} options.rotation=0 <code>optional</code> 用于指定沿着alignedAxis轴的旋转角度。
     * @param {Number} options.width <code>optional</code> 用于指定标牌的像素宽度，覆盖本机大小。
     * @param {Number} options.height <code>optional</code> 用于指定标牌的像素高度，覆盖本机大小。
     */
    function Billboard(options) {
      var _this = this;
      _classCallCheck(this, Billboard);
      _defineProperty(this, "_id", void 0);
      this._definitionChanged = new Event();
      this._propertyNames = propertyNames$5;
      this._propertyNames.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Billboard} result 用于存储结果的对象。
     * @returns {Billboard} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Billboard, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new Billboard(this);
        }
        this._propertyNames.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Billboard} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this._propertyNames.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return Billboard;
  }();
  Object.defineProperties(Billboard.prototype, {
    /**
     * 获取在属性或子属性被改变或修改时所引发的事件
     * @memberof Point.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    show: createPropertyDescriptor('show'),
    image: createPropertyDescriptor('image'),
    scale: createPropertyDescriptor('scale'),
    pixelOffset: createPropertyDescriptor('pixelOffset'),
    eyeOffset: createPropertyDescriptor('eyeOffset'),
    horizontalOrigin: createPropertyDescriptor('horizontalOrigin'),
    verticalOrigin: createPropertyDescriptor('verticalOrigin'),
    heightReference: createPropertyDescriptor('heightReference'),
    color: createPropertyDescriptor('color'),
    rotation: createPropertyDescriptor('rotation'),
    width: createPropertyDescriptor('width'),
    height: createPropertyDescriptor('height'),
    sizeInMeters: createPropertyDescriptor('sizeInMeters'),
    scaleByDistance: createPropertyDescriptor('scaleByDistance'),
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition')
  });

  var propertyNames$4 = ['show', 'image', 'scale', 'pixelOffset', 'eyeOffset', 'horizontalOrigin', 'verticalOrigin', 'heightReference', 'color', 'rotation', 'width', 'height', 'scaleByDistance', 'distanceDisplayCondition'];
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */
  /**
   * @class OverlayImage
   * 贴地图类
   */
  var OverlayImage = /*#__PURE__*/function () {
    /**
     * OverlayImage类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Boolean} options.show=true <code>optional</code> 用于是否显示叠加图片。
     * @param {String} options.image <code>optional</code> 用于叠加图片的路径。
     * @param {HeightReference} options.heightReference=HeightReference.NONE <code>optional</code> 用于指定叠加图片高度的参考系。
     * @param {Number} options.width <code>optional</code> 用于指定叠加图片的宽度，单位为像素。
     * @param {Number} options.height <code>optional</code> 用于指定叠加图片的高度，单位为像素。
     */
    function OverlayImage(options) {
      var _this = this;
      _classCallCheck(this, OverlayImage);
      _defineProperty(this, "_id", void 0);
      this._definitionChanged = new Event();
      this._propertyNames = propertyNames$4;
      this._propertyNames.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {OverlayImage} result 用于存储结果的对象。
     * @returns {OverlayImage} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(OverlayImage, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new OverlayImage(this);
        }
        this._propertyNames.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {OverlayImage} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this._propertyNames.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return OverlayImage;
  }();
  Object.defineProperties(OverlayImage.prototype, {
    /**
     * 获取每当属性或子属性被更改或修改时触发的事件。
     * @memberof Point.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    show: createPropertyDescriptor('show'),
    image: createPropertyDescriptor('image'),
    scale: createPropertyDescriptor('scale'),
    pixelOffset: createPropertyDescriptor('pixelOffset'),
    eyeOffset: createPropertyDescriptor('eyeOffset'),
    horizontalOrigin: createPropertyDescriptor('horizontalOrigin'),
    verticalOrigin: createPropertyDescriptor('verticalOrigin'),
    heightReference: createPropertyDescriptor('heightReference'),
    color: createPropertyDescriptor('color'),
    rotation: createPropertyDescriptor('rotation'),
    width: createPropertyDescriptor('width'),
    height: createPropertyDescriptor('height'),
    scaleByDistance: createPropertyDescriptor('scaleByDistance'),
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition')
  });

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Rectangle
   * 矩形类
   */
  var Rectangle = /*#__PURE__*/function () {
    /**
     * Rectangle类的构造函数
     * @param {Object} options 
     */
    function Rectangle(options) {
      _classCallCheck(this, Rectangle);
      this._definitionChanged = new Event();
      this._show = true;
      this._showSubscription = undefined;
      this._coordinates = undefined;
      this._coordinatesSubscription = undefined;
      this._height = undefined;
      this._heightSubscription = undefined;
      this._heightReference = undefined;
      this._heightReferenceSubscription = undefined;
      this._rotation = undefined;
      this._rotationSubscription = undefined;
      this._fill = undefined;
      this._fillSubscription = undefined;
      this._color = undefined;
      this._colorSubscription = undefined;
      this._outline = undefined;
      this._outlineSubscription = undefined;
      this._outlineColor = undefined;
      this._outlineColorSubscription = undefined;
      this._outlineWidth = undefined;
      this._outlineWidthSubscription = undefined;
      this._distanceDisplayCondition = undefined;
      this._distancedisplayConditionSubscription = undefined;
      this._classificationType = undefined;
      this._classificationTypeSubscription = undefined;
      this._zIndex = undefined;
      this._zIndexSubscription = undefined;
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Rectangle} result 用于存储结果的对象。
     * @returns {Rectangle} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Rectangle, [{
      key: "clone",
      value: function clone(result) {
        if (!defined$1(result)) {
          return new Rectangle(this);
        }
        result.show = this.show;
        result.coordinates = this.coordinates;
        result.height = this.height;
        result.heightReference = this.heightReference;
        result.rotation = this.rotation;
        result.fill = this.fill;
        result.color = this.color;
        result.outline = this.outline;
        result.outlineColor = this.outlineColor;
        result.outlineWidth = this.outlineWidth;
        result.distanceDisplayCondition = this.distanceDisplayCondition;
        result.classificationType = this.classificationType;
        result.zIndex = this.zIndex;
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Rectangle} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this.show = defaultValue$1(this.show, source.show);
        this.coordinates = defaultValue$1(this.coordinates, source.coordinates);
        this.height = defaultValue$1(this.height, source.height);
        this.heightReference = defaultValue$1(this.heightReference, source.heightReference);
        this.rotation = defaultValue$1(this.rotation, source.rotation);
        this.fill = defaultValue$1(this.fill, source.fill);
        this.color = defaultValue$1(this.color, source.color);
        this.outline = defaultValue$1(this.outline, source.outline);
        this.outlineColor = defaultValue$1(this.outlineColor, source.outlineColor);
        this.outlineWidth = defaultValue$1(this.outlineWidth, source.outlineWidth);
        this.distanceDisplayCondition = defaultValue$1(this.distanceDisplayCondition, source.distanceDisplayCondition);
        this.classificationType = defaultValue$1(this.classificationType, source.classificationType);
        this.zIndex = defaultValue$1(this.zIndex, source.zIndex);
      }
    }]);
    return Rectangle;
  }();
  Object.defineProperties(Rectangle.prototype, {
    /**
     * 获取每当属性或子属性被更改或修改时触发的事件。
     * @memberof Rectangle.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    /**
     * 获取或设置布尔类型的属性，用于指定矩形的可见性。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default true
     */
    show: createPropertyDescriptor('show'),
    /**
     * 获取或设置指定 {@link Rectangle} 的属性。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     */
    coordinates: createPropertyDescriptor('coordinates'),
    /**
     * 获取或设置数值类型的属性，用于指定矩形的高度。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default 0.0
     */
    height: createPropertyDescriptor('height'),
    /**
     * 获取或设置指定 {@link HeightReference} 的属性。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default HeightReference.NONE
     */
    heightReference: createPropertyDescriptor('heightReference'),
    /**
     * 获取或设置数值类型的属性，用于指定矩形相对于正北方向的顺时针旋转角度。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default 0
     */
    rotation: createPropertyDescriptor('rotation'),
    /**
     * 获取或设置布尔类型的属性，用于指定矩形是否填充为所提供的颜色。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default true
     */
    fill: createPropertyDescriptor('fill'),
    color: createPropertyDescriptor('color'),
    /**
     * 获取或设置指定矩形是否应有边框的属性。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default false
     */
    outline: createPropertyDescriptor('outline'),
    /**
     * 获取或设置指定边框颜色的 {@link Color} 类型的属性。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default Color.BLACK
     */
    outlineColor: createPropertyDescriptor('outlineColor'),
    /**
     * 获取或设置数值类型的属性，用于指定边框的宽度。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default 1.0
     */
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    /**
     * 获取或设置 {@link DistanceDisplayCondition} 类型的属性，用于指定相机到该矩形的距离达到多少时显示该矩形。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     */
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition'),
    /**
     * 获取或设置 {@link ClassificationType} 类型的属性，用于指定当矩形在地面上时，该矩形是否对地形和 3D Tiles 进行分类。
     * @memberof Rectangle.prototype
     * @type {Property|undefined}
     * @default ClassificationType.BOTH
     */
    classificationType: createPropertyDescriptor('classificationType'),
    /**
     * 获取或设置 zIndex 属性，用于指定矩形的绘制顺序。只有当矩形为常量且未指定高度或挤出高度时，该属性才会起作用。
     * @memberof Rectangle.prototype
     * @type {ConstantProperty|undefined}
     * @default 0
     */
    zIndex: createPropertyDescriptor('zIndex')
  });

  var propertyNames$3 = ['show', 'plotCode', 'lineColor', 'lineWidth', 'outlineColor', 'outlineWidth', 'fillColor', 'fillMode', 'textColor', 'sizeMode', 'innerText', 'fontSize', 'label', 'labelPos', 'size', 'positions', 'unitLength'];
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */
  /**
   * @class Plot
   * 军标类
   */
  var Plot$1 = /*#__PURE__*/function () {
    /**
     * Plot类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Color} options.lineColor <code>optional</code> 指定绘制线条的颜色。
     * @param {Number} options.lineWidth <code>optional</code> 指定绘制线条的宽度，单位为像素。
     * @param {Number} options.plotCode <code>optional</code> 指定绘制的Plot的编码。
     * @param {SizeMode} options.sizeMode <code>optional</code> 指定Plot大小。
     */
    function Plot(options) {
      var _this = this;
      _classCallCheck(this, Plot);
      _defineProperty(this, "_id", void 0);
      this._definitionChanged = new Event();
      this._propertyNames = propertyNames$3;
      this._propertyNames.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Plot} result 用于存储结果的对象。
     * @returns {Plot} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Plot, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new Plot(this);
        }
        this._propertyNames.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Plot} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this._propertyNames.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return Plot;
  }();
  Object.defineProperties(Plot$1.prototype, {
    /*
     * 获取每当属性或子属性被更改或修改时触发的事件。
     * @memberof Point.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    show: createPropertyDescriptor('show'),
    positions: createPropertyDescriptor('positions'),
    plotCode: createPropertyDescriptor('plotCode'),
    lineColor: createPropertyDescriptor('lineColor'),
    lineWidth: createPropertyDescriptor('lineWidth'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    fillColor: createPropertyDescriptor('fillColor'),
    textColor: createPropertyDescriptor('textColor'),
    sizeMode: createPropertyDescriptor('sizeMode'),
    symbolText: createPropertyDescriptor('symbolText'),
    label: createPropertyDescriptor('label'),
    labelPos: createPropertyDescriptor('labelPos'),
    size: createPropertyDescriptor('size'),
    unitLength: createPropertyDescriptor('unitLength')
  });

  function hue2rgb(m1, m2, h) {
    if (h < 0) {
      h += 1;
    }
    if (h > 1) {
      h -= 1;
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * 6 * h;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  }

  /**
   * A color, specified using red, green, blue, and alpha values,
   * which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
   * @param {Number} [red=1.0] The red component.
   * @param {Number} [green=1.0] The green component.
   * @param {Number} [blue=1.0] The blue component.
   * @param {Number} [alpha=1.0] The alpha component.
   *
   * @constructor
   * @alias Color
   *
   * @see Packable
   */
  function Color$1(red, green, blue, alpha) {
    /**
     * The red component.
     * @type {Number}
     * @default 1.0
     */
    this.red = defaultValue$1(red, 1.0);
    /**
     * The green component.
     * @type {Number}
     * @default 1.0
     */
    this.green = defaultValue$1(green, 1.0);
    /**
     * The blue component.
     * @type {Number}
     * @default 1.0
     */
    this.blue = defaultValue$1(blue, 1.0);
    /**
     * The alpha component.
     * @type {Number}
     * @default 1.0
     */
    this.alpha = defaultValue$1(alpha, 1.0);
  }

  /**
   * Creates a Color instance from a {@link Cartesian4}. <code>x</code>, <code>y</code>, <code>z</code>,
   * and <code>w</code> map to <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>, respectively.
   *
   * @param {Cartesian4} cartesian The source cartesian.
   * @param {Color} [result] The object onto which to store the result.
   * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
   */
  Color$1.fromCartesian4 = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('cartesian', cartesian);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Color$1(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    }
    result.red = cartesian.x;
    result.green = cartesian.y;
    result.blue = cartesian.z;
    result.alpha = cartesian.w;
    return result;
  };

  /**
   * Creates a new Color specified using red, green, blue, and alpha values
   * that are in the range of 0 to 255, converting them internally to a range of 0.0 to 1.0.
   *
   * @param {Number} [red=255] The red component.
   * @param {Number} [green=255] The green component.
   * @param {Number} [blue=255] The blue component.
   * @param {Number} [alpha=255] The alpha component.
   * @param {Color} [result] The object onto which to store the result.
   * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
   */
  Color$1.fromBytes = function (red, green, blue, alpha, result) {
    red = Color$1.byteToFloat(defaultValue$1(red, 255.0));
    green = Color$1.byteToFloat(defaultValue$1(green, 255.0));
    blue = Color$1.byteToFloat(defaultValue$1(blue, 255.0));
    alpha = Color$1.byteToFloat(defaultValue$1(alpha, 255.0));
    if (!defined$1(result)) {
      return new Color$1(red, green, blue, alpha);
    }
    result.red = red;
    result.green = green;
    result.blue = blue;
    result.alpha = alpha;
    return result;
  };

  /**
   * Creates a new Color that has the same red, green, and blue components
   * of the specified color, but with the specified alpha value.
   *
   * @param {Color} color The base color
   * @param {Number} alpha The new alpha component.
   * @param {Color} [result] The object onto which to store the result.
   * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
   *
   * @example const translucentRed = Cesium.Color.fromAlpha(Cesium.Color.RED, 0.9);
   */
  Color$1.fromAlpha = function (color, alpha, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('color', color);
    Check.typeOf.number('alpha', alpha);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Color$1(color.red, color.green, color.blue, alpha);
    }
    result.red = color.red;
    result.green = color.green;
    result.blue = color.blue;
    result.alpha = alpha;
    return result;
  };
  var scratchArrayBuffer;
  var scratchUint32Array;
  var scratchUint8Array;
  if (FeatureDetection.supportsTypedArrays()) {
    scratchArrayBuffer = new ArrayBuffer(4);
    scratchUint32Array = new Uint32Array(scratchArrayBuffer);
    scratchUint8Array = new Uint8Array(scratchArrayBuffer);
  }

  /**
   * Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness
   * of the system.
   *
   * @param {Number} rgba A single numeric unsigned 32-bit RGBA value.
   * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
   * @returns {Color} The color object.
   *
   * @example
   * const color = Cesium.Color.fromRgba(0x67ADDFFF);
   *
   * @see Color#toRgba
   */
  Color$1.fromRgba = function (rgba, result) {
    // scratchUint32Array and scratchUint8Array share an underlying array buffer
    scratchUint32Array[0] = rgba;
    return Color$1.fromBytes(scratchUint8Array[0], scratchUint8Array[1], scratchUint8Array[2], scratchUint8Array[3], result);
  };

  /**
   * Creates a Color instance from hue, saturation, and lightness.
   *
   * @param {Number} [hue=0] The hue angle 0...1
   * @param {Number} [saturation=0] The saturation value 0...1
   * @param {Number} [lightness=0] The lightness value 0...1
   * @param {Number} [alpha=1.0] The alpha component 0...1
   * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
   * @returns {Color} The color object.
   *
   * @see {@link http://www.w3.org/TR/css3-color/#hsl-color|CSS color values}
   */
  Color$1.fromHsl = function (hue, saturation, lightness, alpha, result) {
    hue = defaultValue$1(hue, 0.0) % 1.0;
    saturation = defaultValue$1(saturation, 0.0);
    lightness = defaultValue$1(lightness, 0.0);
    alpha = defaultValue$1(alpha, 1.0);
    var red = lightness;
    var green = lightness;
    var blue = lightness;
    if (saturation !== 0) {
      var m2;
      if (lightness < 0.5) {
        m2 = lightness * (1 + saturation);
      } else {
        m2 = lightness + saturation - lightness * saturation;
      }
      var m1 = 2.0 * lightness - m2;
      red = hue2rgb(m1, m2, hue + 1 / 3);
      green = hue2rgb(m1, m2, hue);
      blue = hue2rgb(m1, m2, hue - 1 / 3);
    }
    if (!defined$1(result)) {
      return new Color$1(red, green, blue, alpha);
    }
    result.red = red;
    result.green = green;
    result.blue = blue;
    result.alpha = alpha;
    return result;
  };

  //#rgba
  var rgbaMatcher = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i;
  //#rrggbbaa
  var rrggbbaaMatcher = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
  //rgb(), rgba(), or rgb%()
  var rgbParenthesesMatcher = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
  //hsl() or hsla()
  var hslParenthesesMatcher = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;

  /**
   * Creates a Color instance from a CSS color value.
   *
   * @param {String} color The CSS color value in #rgb, #rgba, #rrggbb, #rrggbbaa, rgb(), rgba(), hsl(), or hsla() format.
   * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
   * @returns {Color} The color object, or undefined if the string was not a valid CSS color.
   *
   *
   * @example
   * const cesiumBlue = Cesium.Color.fromCssColorString('#67ADDF');
   * const green = Cesium.Color.fromCssColorString('green');
   *
   * @see {@link http://www.w3.org/TR/css3-color|CSS color values}
   */
  Color$1.fromCssColorString = function (color, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.string('color', color);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Color$1();
    }

    // Remove all whitespaces from the color string
    color = color.replace(/\s/g, '');
    var namedColor = Color$1[color.toUpperCase()];
    if (defined$1(namedColor)) {
      Color$1.clone(namedColor, result);
      return result;
    }
    var matches = rgbaMatcher.exec(color);
    if (matches !== null) {
      result.red = parseInt(matches[1], 16) / 15;
      result.green = parseInt(matches[2], 16) / 15.0;
      result.blue = parseInt(matches[3], 16) / 15.0;
      result.alpha = parseInt(defaultValue$1(matches[4], 'f'), 16) / 15.0;
      return result;
    }
    matches = rrggbbaaMatcher.exec(color);
    if (matches !== null) {
      result.red = parseInt(matches[1], 16) / 255.0;
      result.green = parseInt(matches[2], 16) / 255.0;
      result.blue = parseInt(matches[3], 16) / 255.0;
      result.alpha = parseInt(defaultValue$1(matches[4], 'ff'), 16) / 255.0;
      return result;
    }
    matches = rgbParenthesesMatcher.exec(color);
    if (matches !== null) {
      result.red = parseFloat(matches[1]) / ('%' === matches[1].substr(-1) ? 100.0 : 255.0);
      result.green = parseFloat(matches[2]) / ('%' === matches[2].substr(-1) ? 100.0 : 255.0);
      result.blue = parseFloat(matches[3]) / ('%' === matches[3].substr(-1) ? 100.0 : 255.0);
      result.alpha = parseFloat(defaultValue$1(matches[4], '1.0'));
      return result;
    }
    matches = hslParenthesesMatcher.exec(color);
    if (matches !== null) {
      return Color$1.fromHsl(parseFloat(matches[1]) / 360.0, parseFloat(matches[2]) / 100.0, parseFloat(matches[3]) / 100.0, parseFloat(defaultValue$1(matches[4], '1.0')), result);
    }
    result = undefined;
    return result;
  };

  /**
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Color$1.packedLength = 4;

  /**
   * Stores the provided instance into the provided array.
   *
   * @param {Color} value The value to pack.
   * @param {Number[]} array The array to pack into.
   * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
   *
   * @returns {Number[]} The array that was packed into
   */
  Color$1.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value.red;
    array[startingIndex++] = value.green;
    array[startingIndex++] = value.blue;
    array[startingIndex] = value.alpha;
    return array;
  };

  /**
   * Retrieves an instance from a packed array.
   *
   * @param {Number[]} array The packed array.
   * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
   * @param {Color} [result] The object into which to store the result.
   * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
   */
  Color$1.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new Color$1();
    }
    result.red = array[startingIndex++];
    result.green = array[startingIndex++];
    result.blue = array[startingIndex++];
    result.alpha = array[startingIndex];
    return result;
  };

  /**
   * Converts a 'byte' color component in the range of 0 to 255 into
   * a 'float' color component in the range of 0 to 1.0.
   *
   * @param {Number} number The number to be converted.
   * @returns {Number} The converted number.
   */
  Color$1.byteToFloat = function (number) {
    return number / 255.0;
  };

  /**
   * Converts a 'float' color component in the range of 0 to 1.0 into
   * a 'byte' color component in the range of 0 to 255.
   *
   * @param {Number} number The number to be converted.
   * @returns {Number} The converted number.
   */
  Color$1.floatToByte = function (number) {
    return number === 1.0 ? 255.0 : number * 256.0 | 0;
  };

  /**
   * Duplicates a Color.
   *
   * @param {Color} color The Color to duplicate.
   * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
   * @returns {Color} The modified result parameter or a new instance if result was undefined. (Returns undefined if color is undefined)
   */
  Color$1.clone = function (color, result) {
    if (!defined$1(color)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Color$1(color.red, color.green, color.blue, color.alpha);
    }
    result.red = color.red;
    result.green = color.green;
    result.blue = color.blue;
    result.alpha = color.alpha;
    return result;
  };

  /**
   * Returns true if the first Color equals the second color.
   *
   * @param {Color} left The first Color to compare for equality.
   * @param {Color} right The second Color to compare for equality.
   * @returns {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
   */
  Color$1.equals = function (left, right) {
    return left === right ||
    //
    defined$1(left) &&
    //
    defined$1(right) &&
    //
    left.red === right.red &&
    //
    left.green === right.green &&
    //
    left.blue === right.blue &&
    //
    left.alpha === right.alpha;
  };

  /**
   * @private
   */
  Color$1.equalsArray = function (color, array, offset) {
    return color.red === array[offset] && color.green === array[offset + 1] && color.blue === array[offset + 2] && color.alpha === array[offset + 3];
  };

  /**
   * Returns a duplicate of a Color instance.
   *
   * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
   * @returns {Color} The modified result parameter or a new instance if result was undefined.
   */
  Color$1.prototype.clone = function (result) {
    return Color$1.clone(this, result);
  };

  /**
   * Returns true if this Color equals other.
   *
   * @param {Color} other The Color to compare for equality.
   * @returns {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
   */
  Color$1.prototype.equals = function (other) {
    return Color$1.equals(this, other);
  };

  /**
   * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
   *
   * @param {Color} other The Color to compare for equality.
   * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
   * @returns {Boolean} <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.
   */
  Color$1.prototype.equalsEpsilon = function (other, epsilon) {
    return this === other ||
    //
    defined$1(other) &&
    //
    Math.abs(this.red - other.red) <= epsilon &&
    //
    Math.abs(this.green - other.green) <= epsilon &&
    //
    Math.abs(this.blue - other.blue) <= epsilon &&
    //
    Math.abs(this.alpha - other.alpha) <= epsilon;
  };

  /**
   * Creates a string representing this Color in the format '(red, green, blue, alpha)'.
   *
   * @returns {String} A string representing this Color in the format '(red, green, blue, alpha)'.
   */
  Color$1.prototype.toString = function () {
    return "(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ", ").concat(this.alpha, ")");
  };

  /**
   * Creates a string containing the CSS color value for this color.
   *
   * @returns {String} The CSS equivalent of this color.
   *
   * @see {@link http://www.w3.org/TR/css3-color/#rgba-color|CSS RGB or RGBA color values}
   */
  Color$1.prototype.toCssColorString = function () {
    var red = Color$1.floatToByte(this.red);
    var green = Color$1.floatToByte(this.green);
    var blue = Color$1.floatToByte(this.blue);
    if (this.alpha === 1) {
      return "rgb(".concat(red, ",").concat(green, ",").concat(blue, ")");
    }
    return "rgba(".concat(red, ",").concat(green, ",").concat(blue, ",").concat(this.alpha, ")");
  };

  /**
   * Creates a string containing CSS hex string color value for this color.
   *
   * @returns {String} The CSS hex string equivalent of this color.
   */
  Color$1.prototype.toCssHexString = function () {
    var r = Color$1.floatToByte(this.red).toString(16);
    if (r.length < 2) {
      r = "0".concat(r);
    }
    var g = Color$1.floatToByte(this.green).toString(16);
    if (g.length < 2) {
      g = "0".concat(g);
    }
    var b = Color$1.floatToByte(this.blue).toString(16);
    if (b.length < 2) {
      b = "0".concat(b);
    }
    if (this.alpha < 1) {
      var hexAlpha = Color$1.floatToByte(this.alpha).toString(16);
      if (hexAlpha.length < 2) {
        hexAlpha = "0".concat(hexAlpha);
      }
      return "#".concat(r).concat(g).concat(b).concat(hexAlpha);
    }
    return "#".concat(r).concat(g).concat(b);
  };

  /**
   * Converts this color to an array of red, green, blue, and alpha values
   * that are in the range of 0 to 255.
   *
   * @param {Number[]} [result] The array to store the result in, if undefined a new instance will be created.
   * @returns {Number[]} The modified result parameter or a new instance if result was undefined.
   */
  Color$1.prototype.toBytes = function (result) {
    var red = Color$1.floatToByte(this.red);
    var green = Color$1.floatToByte(this.green);
    var blue = Color$1.floatToByte(this.blue);
    var alpha = Color$1.floatToByte(this.alpha);
    if (!defined$1(result)) {
      return [red, green, blue, alpha];
    }
    result[0] = red;
    result[1] = green;
    result[2] = blue;
    result[3] = alpha;
    return result;
  };

  /**
   * Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness
   * of the system.
   *
   * @returns {Number} A single numeric unsigned 32-bit RGBA value.
   *
   *
   * @example
   * const rgba = Cesium.Color.BLUE.toRgba();
   *
   * @see Color.fromRgba
   */
  Color$1.prototype.toRgba = function () {
    // scratchUint32Array and scratchUint8Array share an underlying array buffer
    scratchUint8Array[0] = Color$1.floatToByte(this.red);
    scratchUint8Array[1] = Color$1.floatToByte(this.green);
    scratchUint8Array[2] = Color$1.floatToByte(this.blue);
    scratchUint8Array[3] = Color$1.floatToByte(this.alpha);
    return scratchUint32Array[0];
  };

  /**
   * Brightens this color by the provided magnitude.
   *
   * @param {Number} magnitude A positive number indicating the amount to brighten.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   *
   * @example
   * const brightBlue = Cesium.Color.BLUE.brighten(0.5, new Cesium.Color());
   */
  Color$1.prototype.brighten = function (magnitude, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number('magnitude', magnitude);
    Check.typeOf.number.greaterThanOrEquals('magnitude', magnitude, 0.0);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    magnitude = 1.0 - magnitude;
    result.red = 1.0 - (1.0 - this.red) * magnitude;
    result.green = 1.0 - (1.0 - this.green) * magnitude;
    result.blue = 1.0 - (1.0 - this.blue) * magnitude;
    result.alpha = this.alpha;
    return result;
  };

  /**
   * Darkens this color by the provided magnitude.
   *
   * @param {Number} magnitude A positive number indicating the amount to darken.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   *
   * @example
   * const darkBlue = Cesium.Color.BLUE.darken(0.5, new Cesium.Color());
   */
  Color$1.prototype.darken = function (magnitude, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number('magnitude', magnitude);
    Check.typeOf.number.greaterThanOrEquals('magnitude', magnitude, 0.0);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    magnitude = 1.0 - magnitude;
    result.red = this.red * magnitude;
    result.green = this.green * magnitude;
    result.blue = this.blue * magnitude;
    result.alpha = this.alpha;
    return result;
  };

  /**
   * Creates a new Color that has the same red, green, and blue components
   * as this Color, but with the specified alpha value.
   *
   * @param {Number} alpha The new alpha component.
   * @param {Color} [result] The object onto which to store the result.
   * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
   *
   * @example const translucentRed = Cesium.Color.RED.withAlpha(0.9);
   */
  Color$1.prototype.withAlpha = function (alpha, result) {
    return Color$1.fromAlpha(this, alpha, result);
  };

  /**
   * Computes the componentwise sum of two Colors.
   *
   * @param {Color} left The first Color.
   * @param {Color} right The second Color.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   */
  Color$1.add = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.red = left.red + right.red;
    result.green = left.green + right.green;
    result.blue = left.blue + right.blue;
    result.alpha = left.alpha + right.alpha;
    return result;
  };

  /**
   * Computes the componentwise difference of two Colors.
   *
   * @param {Color} left The first Color.
   * @param {Color} right The second Color.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   */
  Color$1.subtract = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.red = left.red - right.red;
    result.green = left.green - right.green;
    result.blue = left.blue - right.blue;
    result.alpha = left.alpha - right.alpha;
    return result;
  };

  /**
   * Computes the componentwise product of two Colors.
   *
   * @param {Color} left The first Color.
   * @param {Color} right The second Color.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   */
  Color$1.multiply = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.red = left.red * right.red;
    result.green = left.green * right.green;
    result.blue = left.blue * right.blue;
    result.alpha = left.alpha * right.alpha;
    return result;
  };

  /**
   * Computes the componentwise quotient of two Colors.
   *
   * @param {Color} left The first Color.
   * @param {Color} right The second Color.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   */
  Color$1.divide = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.red = left.red / right.red;
    result.green = left.green / right.green;
    result.blue = left.blue / right.blue;
    result.alpha = left.alpha / right.alpha;
    return result;
  };

  /**
   * Computes the componentwise modulus of two Colors.
   *
   * @param {Color} left The first Color.
   * @param {Color} right The second Color.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   */
  Color$1.mod = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.red = left.red % right.red;
    result.green = left.green % right.green;
    result.blue = left.blue % right.blue;
    result.alpha = left.alpha % right.alpha;
    return result;
  };

  /**
   * Multiplies the provided Color componentwise by the provided scalar.
   *
   * @param {Color} color The Color to be scaled.
   * @param {Number} scalar The scalar to multiply with.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   */
  Color$1.multiplyByScalar = function (color, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('color', color);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.red = color.red * scalar;
    result.green = color.green * scalar;
    result.blue = color.blue * scalar;
    result.alpha = color.alpha * scalar;
    return result;
  };

  /**
   * Divides the provided Color componentwise by the provided scalar.
   *
   * @param {Color} color The Color to be divided.
   * @param {Number} scalar The scalar to divide with.
   * @param {Color} result The object onto which to store the result.
   * @returns {Color} The modified result parameter.
   */
  Color$1.divideByScalar = function (color, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('color', color);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    //>>includeEnd('debug');

    result.red = color.red / scalar;
    result.green = color.green / scalar;
    result.blue = color.blue / scalar;
    result.alpha = color.alpha / scalar;
    return result;
  };

  /**
   * An immutable Color instance initialized to CSS color #F0F8FF
   * <span class="colorSwath" style="background: #F0F8FF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.ALICEBLUE = Object.freeze(Color$1.fromCssColorString('#F0F8FF'));

  /**
   * An immutable Color instance initialized to CSS color #FAEBD7
   * <span class="colorSwath" style="background: #FAEBD7;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.ANTIQUEWHITE = Object.freeze(Color$1.fromCssColorString('#FAEBD7'));

  /**
   * An immutable Color instance initialized to CSS color #00FFFF
   * <span class="colorSwath" style="background: #00FFFF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.AQUA = Object.freeze(Color$1.fromCssColorString('#00FFFF'));

  /**
   * An immutable Color instance initialized to CSS color #7FFFD4
   * <span class="colorSwath" style="background: #7FFFD4;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.AQUAMARINE = Object.freeze(Color$1.fromCssColorString('#7FFFD4'));

  /**
   * An immutable Color instance initialized to CSS color #F0FFFF
   * <span class="colorSwath" style="background: #F0FFFF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.AZURE = Object.freeze(Color$1.fromCssColorString('#F0FFFF'));

  /**
   * An immutable Color instance initialized to CSS color #F5F5DC
   * <span class="colorSwath" style="background: #F5F5DC;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BEIGE = Object.freeze(Color$1.fromCssColorString('#F5F5DC'));

  /**
   * An immutable Color instance initialized to CSS color #FFE4C4
   * <span class="colorSwath" style="background: #FFE4C4;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BISQUE = Object.freeze(Color$1.fromCssColorString('#FFE4C4'));

  /**
   * An immutable Color instance initialized to CSS color #000000
   * <span class="colorSwath" style="background: #000000;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BLACK = Object.freeze(Color$1.fromCssColorString('#000000'));

  /**
   * An immutable Color instance initialized to CSS color #FFEBCD
   * <span class="colorSwath" style="background: #FFEBCD;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BLANCHEDALMOND = Object.freeze(Color$1.fromCssColorString('#FFEBCD'));

  /**
   * An immutable Color instance initialized to CSS color #0000FF
   * <span class="colorSwath" style="background: #0000FF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BLUE = Object.freeze(Color$1.fromCssColorString('#0000FF'));

  /**
   * An immutable Color instance initialized to CSS color #8A2BE2
   * <span class="colorSwath" style="background: #8A2BE2;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BLUEVIOLET = Object.freeze(Color$1.fromCssColorString('#8A2BE2'));

  /**
   * An immutable Color instance initialized to CSS color #A52A2A
   * <span class="colorSwath" style="background: #A52A2A;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BROWN = Object.freeze(Color$1.fromCssColorString('#A52A2A'));

  /**
   * An immutable Color instance initialized to CSS color #DEB887
   * <span class="colorSwath" style="background: #DEB887;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.BURLYWOOD = Object.freeze(Color$1.fromCssColorString('#DEB887'));

  /**
   * An immutable Color instance initialized to CSS color #5F9EA0
   * <span class="colorSwath" style="background: #5F9EA0;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CADETBLUE = Object.freeze(Color$1.fromCssColorString('#5F9EA0'));
  /**
   * An immutable Color instance initialized to CSS color #7FFF00
   * <span class="colorSwath" style="background: #7FFF00;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CHARTREUSE = Object.freeze(Color$1.fromCssColorString('#7FFF00'));

  /**
   * An immutable Color instance initialized to CSS color #D2691E
   * <span class="colorSwath" style="background: #D2691E;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CHOCOLATE = Object.freeze(Color$1.fromCssColorString('#D2691E'));

  /**
   * An immutable Color instance initialized to CSS color #FF7F50
   * <span class="colorSwath" style="background: #FF7F50;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CORAL = Object.freeze(Color$1.fromCssColorString('#FF7F50'));

  /**
   * An immutable Color instance initialized to CSS color #6495ED
   * <span class="colorSwath" style="background: #6495ED;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CORNFLOWERBLUE = Object.freeze(Color$1.fromCssColorString('#6495ED'));

  /**
   * An immutable Color instance initialized to CSS color #FFF8DC
   * <span class="colorSwath" style="background: #FFF8DC;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CORNSILK = Object.freeze(Color$1.fromCssColorString('#FFF8DC'));

  /**
   * An immutable Color instance initialized to CSS color #DC143C
   * <span class="colorSwath" style="background: #DC143C;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CRIMSON = Object.freeze(Color$1.fromCssColorString('#DC143C'));

  /**
   * An immutable Color instance initialized to CSS color #00FFFF
   * <span class="colorSwath" style="background: #00FFFF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.CYAN = Object.freeze(Color$1.fromCssColorString('#00FFFF'));

  /**
   * An immutable Color instance initialized to CSS color #00008B
   * <span class="colorSwath" style="background: #00008B;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKBLUE = Object.freeze(Color$1.fromCssColorString('#00008B'));

  /**
   * An immutable Color instance initialized to CSS color #008B8B
   * <span class="colorSwath" style="background: #008B8B;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKCYAN = Object.freeze(Color$1.fromCssColorString('#008B8B'));

  /**
   * An immutable Color instance initialized to CSS color #B8860B
   * <span class="colorSwath" style="background: #B8860B;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKGOLDENROD = Object.freeze(Color$1.fromCssColorString('#B8860B'));

  /**
   * An immutable Color instance initialized to CSS color #A9A9A9
   * <span class="colorSwath" style="background: #A9A9A9;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKGRAY = Object.freeze(Color$1.fromCssColorString('#A9A9A9'));

  /**
   * An immutable Color instance initialized to CSS color #006400
   * <span class="colorSwath" style="background: #006400;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKGREEN = Object.freeze(Color$1.fromCssColorString('#006400'));

  /**
   * An immutable Color instance initialized to CSS color #A9A9A9
   * <span class="colorSwath" style="background: #A9A9A9;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKGREY = Color$1.DARKGRAY;

  /**
   * An immutable Color instance initialized to CSS color #BDB76B
   * <span class="colorSwath" style="background: #BDB76B;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKKHAKI = Object.freeze(Color$1.fromCssColorString('#BDB76B'));

  /**
   * An immutable Color instance initialized to CSS color #8B008B
   * <span class="colorSwath" style="background: #8B008B;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKMAGENTA = Object.freeze(Color$1.fromCssColorString('#8B008B'));

  /**
   * An immutable Color instance initialized to CSS color #556B2F
   * <span class="colorSwath" style="background: #556B2F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKOLIVEGREEN = Object.freeze(Color$1.fromCssColorString('#556B2F'));

  /**
   * An immutable Color instance initialized to CSS color #FF8C00
   * <span class="colorSwath" style="background: #FF8C00;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKORANGE = Object.freeze(Color$1.fromCssColorString('#FF8C00'));

  /**
   * An immutable Color instance initialized to CSS color #9932CC
   * <span class="colorSwath" style="background: #9932CC;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKORCHID = Object.freeze(Color$1.fromCssColorString('#9932CC'));

  /**
   * An immutable Color instance initialized to CSS color #8B0000
   * <span class="colorSwath" style="background: #8B0000;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKRED = Object.freeze(Color$1.fromCssColorString('#8B0000'));

  /**
   * An immutable Color instance initialized to CSS color #E9967A
   * <span class="colorSwath" style="background: #E9967A;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKSALMON = Object.freeze(Color$1.fromCssColorString('#E9967A'));

  /**
   * An immutable Color instance initialized to CSS color #8FBC8F
   * <span class="colorSwath" style="background: #8FBC8F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKSEAGREEN = Object.freeze(Color$1.fromCssColorString('#8FBC8F'));

  /**
   * An immutable Color instance initialized to CSS color #483D8B
   * <span class="colorSwath" style="background: #483D8B;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKSLATEBLUE = Object.freeze(Color$1.fromCssColorString('#483D8B'));

  /**
   * An immutable Color instance initialized to CSS color #2F4F4F
   * <span class="colorSwath" style="background: #2F4F4F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKSLATEGRAY = Object.freeze(Color$1.fromCssColorString('#2F4F4F'));

  /**
   * An immutable Color instance initialized to CSS color #2F4F4F
   * <span class="colorSwath" style="background: #2F4F4F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKSLATEGREY = Color$1.DARKSLATEGRAY;

  /**
   * An immutable Color instance initialized to CSS color #00CED1
   * <span class="colorSwath" style="background: #00CED1;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKTURQUOISE = Object.freeze(Color$1.fromCssColorString('#00CED1'));

  /**
   * An immutable Color instance initialized to CSS color #9400D3
   * <span class="colorSwath" style="background: #9400D3;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DARKVIOLET = Object.freeze(Color$1.fromCssColorString('#9400D3'));

  /**
   * An immutable Color instance initialized to CSS color #FF1493
   * <span class="colorSwath" style="background: #FF1493;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DEEPPINK = Object.freeze(Color$1.fromCssColorString('#FF1493'));

  /**
   * An immutable Color instance initialized to CSS color #00BFFF
   * <span class="colorSwath" style="background: #00BFFF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DEEPSKYBLUE = Object.freeze(Color$1.fromCssColorString('#00BFFF'));

  /**
   * An immutable Color instance initialized to CSS color #696969
   * <span class="colorSwath" style="background: #696969;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DIMGRAY = Object.freeze(Color$1.fromCssColorString('#696969'));

  /**
   * An immutable Color instance initialized to CSS color #696969
   * <span class="colorSwath" style="background: #696969;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DIMGREY = Color$1.DIMGRAY;

  /**
   * An immutable Color instance initialized to CSS color #1E90FF
   * <span class="colorSwath" style="background: #1E90FF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.DODGERBLUE = Object.freeze(Color$1.fromCssColorString('#1E90FF'));

  /**
   * An immutable Color instance initialized to CSS color #B22222
   * <span class="colorSwath" style="background: #B22222;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.FIREBRICK = Object.freeze(Color$1.fromCssColorString('#B22222'));

  /**
   * An immutable Color instance initialized to CSS color #FFFAF0
   * <span class="colorSwath" style="background: #FFFAF0;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.FLORALWHITE = Object.freeze(Color$1.fromCssColorString('#FFFAF0'));

  /**
   * An immutable Color instance initialized to CSS color #228B22
   * <span class="colorSwath" style="background: #228B22;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.FORESTGREEN = Object.freeze(Color$1.fromCssColorString('#228B22'));

  /**
   * An immutable Color instance initialized to CSS color #FF00FF
   * <span class="colorSwath" style="background: #FF00FF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.FUCHSIA = Object.freeze(Color$1.fromCssColorString('#FF00FF'));

  /**
   * An immutable Color instance initialized to CSS color #DCDCDC
   * <span class="colorSwath" style="background: #DCDCDC;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GAINSBORO = Object.freeze(Color$1.fromCssColorString('#DCDCDC'));

  /**
   * An immutable Color instance initialized to CSS color #F8F8FF
   * <span class="colorSwath" style="background: #F8F8FF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GHOSTWHITE = Object.freeze(Color$1.fromCssColorString('#F8F8FF'));

  /**
   * An immutable Color instance initialized to CSS color #FFD700
   * <span class="colorSwath" style="background: #FFD700;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GOLD = Object.freeze(Color$1.fromCssColorString('#FFD700'));

  /**
   * An immutable Color instance initialized to CSS color #DAA520
   * <span class="colorSwath" style="background: #DAA520;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GOLDENROD = Object.freeze(Color$1.fromCssColorString('#DAA520'));

  /**
   * An immutable Color instance initialized to CSS color #808080
   * <span class="colorSwath" style="background: #808080;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GRAY = Object.freeze(Color$1.fromCssColorString('#808080'));

  /**
   * An immutable Color instance initialized to CSS color #008000
   * <span class="colorSwath" style="background: #008000;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GREEN = Object.freeze(Color$1.fromCssColorString('#008000'));

  /**
   * An immutable Color instance initialized to CSS color #ADFF2F
   * <span class="colorSwath" style="background: #ADFF2F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GREENYELLOW = Object.freeze(Color$1.fromCssColorString('#ADFF2F'));

  /**
   * An immutable Color instance initialized to CSS color #808080
   * <span class="colorSwath" style="background: #808080;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.GREY = Color$1.GRAY;

  /**
   * An immutable Color instance initialized to CSS color #F0FFF0
   * <span class="colorSwath" style="background: #F0FFF0;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.HONEYDEW = Object.freeze(Color$1.fromCssColorString('#F0FFF0'));

  /**
   * An immutable Color instance initialized to CSS color #FF69B4
   * <span class="colorSwath" style="background: #FF69B4;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.HOTPINK = Object.freeze(Color$1.fromCssColorString('#FF69B4'));

  /**
   * An immutable Color instance initialized to CSS color #CD5C5C
   * <span class="colorSwath" style="background: #CD5C5C;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.INDIANRED = Object.freeze(Color$1.fromCssColorString('#CD5C5C'));

  /**
   * An immutable Color instance initialized to CSS color #4B0082
   * <span class="colorSwath" style="background: #4B0082;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.INDIGO = Object.freeze(Color$1.fromCssColorString('#4B0082'));

  /**
   * An immutable Color instance initialized to CSS color #FFFFF0
   * <span class="colorSwath" style="background: #FFFFF0;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.IVORY = Object.freeze(Color$1.fromCssColorString('#FFFFF0'));

  /**
   * An immutable Color instance initialized to CSS color #F0E68C
   * <span class="colorSwath" style="background: #F0E68C;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.KHAKI = Object.freeze(Color$1.fromCssColorString('#F0E68C'));

  /**
   * An immutable Color instance initialized to CSS color #E6E6FA
   * <span class="colorSwath" style="background: #E6E6FA;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LAVENDER = Object.freeze(Color$1.fromCssColorString('#E6E6FA'));

  /**
   * An immutable Color instance initialized to CSS color #FFF0F5
   * <span class="colorSwath" style="background: #FFF0F5;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LAVENDAR_BLUSH = Object.freeze(Color$1.fromCssColorString('#FFF0F5'));

  /**
   * An immutable Color instance initialized to CSS color #7CFC00
   * <span class="colorSwath" style="background: #7CFC00;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LAWNGREEN = Object.freeze(Color$1.fromCssColorString('#7CFC00'));

  /**
   * An immutable Color instance initialized to CSS color #FFFACD
   * <span class="colorSwath" style="background: #FFFACD;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LEMONCHIFFON = Object.freeze(Color$1.fromCssColorString('#FFFACD'));

  /**
   * An immutable Color instance initialized to CSS color #ADD8E6
   * <span class="colorSwath" style="background: #ADD8E6;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTBLUE = Object.freeze(Color$1.fromCssColorString('#ADD8E6'));

  /**
   * An immutable Color instance initialized to CSS color #F08080
   * <span class="colorSwath" style="background: #F08080;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTCORAL = Object.freeze(Color$1.fromCssColorString('#F08080'));

  /**
   * An immutable Color instance initialized to CSS color #E0FFFF
   * <span class="colorSwath" style="background: #E0FFFF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTCYAN = Object.freeze(Color$1.fromCssColorString('#E0FFFF'));

  /**
   * An immutable Color instance initialized to CSS color #FAFAD2
   * <span class="colorSwath" style="background: #FAFAD2;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTGOLDENRODYELLOW = Object.freeze(Color$1.fromCssColorString('#FAFAD2'));

  /**
   * An immutable Color instance initialized to CSS color #D3D3D3
   * <span class="colorSwath" style="background: #D3D3D3;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTGRAY = Object.freeze(Color$1.fromCssColorString('#D3D3D3'));

  /**
   * An immutable Color instance initialized to CSS color #90EE90
   * <span class="colorSwath" style="background: #90EE90;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTGREEN = Object.freeze(Color$1.fromCssColorString('#90EE90'));

  /**
   * An immutable Color instance initialized to CSS color #D3D3D3
   * <span class="colorSwath" style="background: #D3D3D3;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTGREY = Color$1.LIGHTGRAY;

  /**
   * An immutable Color instance initialized to CSS color #FFB6C1
   * <span class="colorSwath" style="background: #FFB6C1;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTPINK = Object.freeze(Color$1.fromCssColorString('#FFB6C1'));

  /**
   * An immutable Color instance initialized to CSS color #20B2AA
   * <span class="colorSwath" style="background: #20B2AA;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTSEAGREEN = Object.freeze(Color$1.fromCssColorString('#20B2AA'));

  /**
   * An immutable Color instance initialized to CSS color #87CEFA
   * <span class="colorSwath" style="background: #87CEFA;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTSKYBLUE = Object.freeze(Color$1.fromCssColorString('#87CEFA'));

  /**
   * An immutable Color instance initialized to CSS color #778899
   * <span class="colorSwath" style="background: #778899;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTSLATEGRAY = Object.freeze(Color$1.fromCssColorString('#778899'));

  /**
   * An immutable Color instance initialized to CSS color #778899
   * <span class="colorSwath" style="background: #778899;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTSLATEGREY = Color$1.LIGHTSLATEGRAY;

  /**
   * An immutable Color instance initialized to CSS color #B0C4DE
   * <span class="colorSwath" style="background: #B0C4DE;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTSTEELBLUE = Object.freeze(Color$1.fromCssColorString('#B0C4DE'));

  /**
   * An immutable Color instance initialized to CSS color #FFFFE0
   * <span class="colorSwath" style="background: #FFFFE0;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIGHTYELLOW = Object.freeze(Color$1.fromCssColorString('#FFFFE0'));

  /**
   * An immutable Color instance initialized to CSS color #00FF00
   * <span class="colorSwath" style="background: #00FF00;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIME = Object.freeze(Color$1.fromCssColorString('#00FF00'));

  /**
   * An immutable Color instance initialized to CSS color #32CD32
   * <span class="colorSwath" style="background: #32CD32;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LIMEGREEN = Object.freeze(Color$1.fromCssColorString('#32CD32'));

  /**
   * An immutable Color instance initialized to CSS color #FAF0E6
   * <span class="colorSwath" style="background: #FAF0E6;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.LINEN = Object.freeze(Color$1.fromCssColorString('#FAF0E6'));

  /**
   * An immutable Color instance initialized to CSS color #FF00FF
   * <span class="colorSwath" style="background: #FF00FF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MAGENTA = Object.freeze(Color$1.fromCssColorString('#FF00FF'));

  /**
   * An immutable Color instance initialized to CSS color #800000
   * <span class="colorSwath" style="background: #800000;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MAROON = Object.freeze(Color$1.fromCssColorString('#800000'));

  /**
   * An immutable Color instance initialized to CSS color #66CDAA
   * <span class="colorSwath" style="background: #66CDAA;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMAQUAMARINE = Object.freeze(Color$1.fromCssColorString('#66CDAA'));

  /**
   * An immutable Color instance initialized to CSS color #0000CD
   * <span class="colorSwath" style="background: #0000CD;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMBLUE = Object.freeze(Color$1.fromCssColorString('#0000CD'));

  /**
   * An immutable Color instance initialized to CSS color #BA55D3
   * <span class="colorSwath" style="background: #BA55D3;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMORCHID = Object.freeze(Color$1.fromCssColorString('#BA55D3'));

  /**
   * An immutable Color instance initialized to CSS color #9370DB
   * <span class="colorSwath" style="background: #9370DB;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMPURPLE = Object.freeze(Color$1.fromCssColorString('#9370DB'));

  /**
   * An immutable Color instance initialized to CSS color #3CB371
   * <span class="colorSwath" style="background: #3CB371;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMSEAGREEN = Object.freeze(Color$1.fromCssColorString('#3CB371'));

  /**
   * An immutable Color instance initialized to CSS color #7B68EE
   * <span class="colorSwath" style="background: #7B68EE;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMSLATEBLUE = Object.freeze(Color$1.fromCssColorString('#7B68EE'));

  /**
   * An immutable Color instance initialized to CSS color #00FA9A
   * <span class="colorSwath" style="background: #00FA9A;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMSPRINGGREEN = Object.freeze(Color$1.fromCssColorString('#00FA9A'));

  /**
   * An immutable Color instance initialized to CSS color #48D1CC
   * <span class="colorSwath" style="background: #48D1CC;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMTURQUOISE = Object.freeze(Color$1.fromCssColorString('#48D1CC'));

  /**
   * An immutable Color instance initialized to CSS color #C71585
   * <span class="colorSwath" style="background: #C71585;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MEDIUMVIOLETRED = Object.freeze(Color$1.fromCssColorString('#C71585'));

  /**
   * An immutable Color instance initialized to CSS color #191970
   * <span class="colorSwath" style="background: #191970;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MIDNIGHTBLUE = Object.freeze(Color$1.fromCssColorString('#191970'));

  /**
   * An immutable Color instance initialized to CSS color #F5FFFA
   * <span class="colorSwath" style="background: #F5FFFA;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MINTCREAM = Object.freeze(Color$1.fromCssColorString('#F5FFFA'));

  /**
   * An immutable Color instance initialized to CSS color #FFE4E1
   * <span class="colorSwath" style="background: #FFE4E1;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MISTYROSE = Object.freeze(Color$1.fromCssColorString('#FFE4E1'));

  /**
   * An immutable Color instance initialized to CSS color #FFE4B5
   * <span class="colorSwath" style="background: #FFE4B5;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.MOCCASIN = Object.freeze(Color$1.fromCssColorString('#FFE4B5'));

  /**
   * An immutable Color instance initialized to CSS color #FFDEAD
   * <span class="colorSwath" style="background: #FFDEAD;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.NAVAJOWHITE = Object.freeze(Color$1.fromCssColorString('#FFDEAD'));

  /**
   * An immutable Color instance initialized to CSS color #000080
   * <span class="colorSwath" style="background: #000080;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.NAVY = Object.freeze(Color$1.fromCssColorString('#000080'));

  /**
   * An immutable Color instance initialized to CSS color #FDF5E6
   * <span class="colorSwath" style="background: #FDF5E6;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.OLDLACE = Object.freeze(Color$1.fromCssColorString('#FDF5E6'));

  /**
   * An immutable Color instance initialized to CSS color #808000
   * <span class="colorSwath" style="background: #808000;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.OLIVE = Object.freeze(Color$1.fromCssColorString('#808000'));

  /**
   * An immutable Color instance initialized to CSS color #6B8E23
   * <span class="colorSwath" style="background: #6B8E23;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.OLIVEDRAB = Object.freeze(Color$1.fromCssColorString('#6B8E23'));

  /**
   * An immutable Color instance initialized to CSS color #FFA500
   * <span class="colorSwath" style="background: #FFA500;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.ORANGE = Object.freeze(Color$1.fromCssColorString('#FFA500'));

  /**
   * An immutable Color instance initialized to CSS color #FF4500
   * <span class="colorSwath" style="background: #FF4500;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.ORANGERED = Object.freeze(Color$1.fromCssColorString('#FF4500'));

  /**
   * An immutable Color instance initialized to CSS color #DA70D6
   * <span class="colorSwath" style="background: #DA70D6;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.ORCHID = Object.freeze(Color$1.fromCssColorString('#DA70D6'));

  /**
   * An immutable Color instance initialized to CSS color #EEE8AA
   * <span class="colorSwath" style="background: #EEE8AA;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PALEGOLDENROD = Object.freeze(Color$1.fromCssColorString('#EEE8AA'));

  /**
   * An immutable Color instance initialized to CSS color #98FB98
   * <span class="colorSwath" style="background: #98FB98;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PALEGREEN = Object.freeze(Color$1.fromCssColorString('#98FB98'));

  /**
   * An immutable Color instance initialized to CSS color #AFEEEE
   * <span class="colorSwath" style="background: #AFEEEE;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PALETURQUOISE = Object.freeze(Color$1.fromCssColorString('#AFEEEE'));

  /**
   * An immutable Color instance initialized to CSS color #DB7093
   * <span class="colorSwath" style="background: #DB7093;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PALEVIOLETRED = Object.freeze(Color$1.fromCssColorString('#DB7093'));

  /**
   * An immutable Color instance initialized to CSS color #FFEFD5
   * <span class="colorSwath" style="background: #FFEFD5;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PAPAYAWHIP = Object.freeze(Color$1.fromCssColorString('#FFEFD5'));

  /**
   * An immutable Color instance initialized to CSS color #FFDAB9
   * <span class="colorSwath" style="background: #FFDAB9;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PEACHPUFF = Object.freeze(Color$1.fromCssColorString('#FFDAB9'));

  /**
   * An immutable Color instance initialized to CSS color #CD853F
   * <span class="colorSwath" style="background: #CD853F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PERU = Object.freeze(Color$1.fromCssColorString('#CD853F'));

  /**
   * An immutable Color instance initialized to CSS color #FFC0CB
   * <span class="colorSwath" style="background: #FFC0CB;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PINK = Object.freeze(Color$1.fromCssColorString('#FFC0CB'));

  /**
   * An immutable Color instance initialized to CSS color #DDA0DD
   * <span class="colorSwath" style="background: #DDA0DD;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PLUM = Object.freeze(Color$1.fromCssColorString('#DDA0DD'));

  /**
   * An immutable Color instance initialized to CSS color #B0E0E6
   * <span class="colorSwath" style="background: #B0E0E6;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.POWDERBLUE = Object.freeze(Color$1.fromCssColorString('#B0E0E6'));

  /**
   * An immutable Color instance initialized to CSS color #800080
   * <span class="colorSwath" style="background: #800080;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.PURPLE = Object.freeze(Color$1.fromCssColorString('#800080'));

  /**
   * An immutable Color instance initialized to CSS color #FF0000
   * <span class="colorSwath" style="background: #FF0000;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.RED = Object.freeze(Color$1.fromCssColorString('#FF0000'));

  /**
   * An immutable Color instance initialized to CSS color #BC8F8F
   * <span class="colorSwath" style="background: #BC8F8F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.ROSYBROWN = Object.freeze(Color$1.fromCssColorString('#BC8F8F'));

  /**
   * An immutable Color instance initialized to CSS color #4169E1
   * <span class="colorSwath" style="background: #4169E1;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.ROYALBLUE = Object.freeze(Color$1.fromCssColorString('#4169E1'));

  /**
   * An immutable Color instance initialized to CSS color #8B4513
   * <span class="colorSwath" style="background: #8B4513;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SADDLEBROWN = Object.freeze(Color$1.fromCssColorString('#8B4513'));

  /**
   * An immutable Color instance initialized to CSS color #FA8072
   * <span class="colorSwath" style="background: #FA8072;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SALMON = Object.freeze(Color$1.fromCssColorString('#FA8072'));

  /**
   * An immutable Color instance initialized to CSS color #F4A460
   * <span class="colorSwath" style="background: #F4A460;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SANDYBROWN = Object.freeze(Color$1.fromCssColorString('#F4A460'));

  /**
   * An immutable Color instance initialized to CSS color #2E8B57
   * <span class="colorSwath" style="background: #2E8B57;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SEAGREEN = Object.freeze(Color$1.fromCssColorString('#2E8B57'));

  /**
   * An immutable Color instance initialized to CSS color #FFF5EE
   * <span class="colorSwath" style="background: #FFF5EE;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SEASHELL = Object.freeze(Color$1.fromCssColorString('#FFF5EE'));

  /**
   * An immutable Color instance initialized to CSS color #A0522D
   * <span class="colorSwath" style="background: #A0522D;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SIENNA = Object.freeze(Color$1.fromCssColorString('#A0522D'));

  /**
   * An immutable Color instance initialized to CSS color #C0C0C0
   * <span class="colorSwath" style="background: #C0C0C0;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SILVER = Object.freeze(Color$1.fromCssColorString('#C0C0C0'));

  /**
   * An immutable Color instance initialized to CSS color #87CEEB
   * <span class="colorSwath" style="background: #87CEEB;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SKYBLUE = Object.freeze(Color$1.fromCssColorString('#87CEEB'));

  /**
   * An immutable Color instance initialized to CSS color #6A5ACD
   * <span class="colorSwath" style="background: #6A5ACD;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SLATEBLUE = Object.freeze(Color$1.fromCssColorString('#6A5ACD'));

  /**
   * An immutable Color instance initialized to CSS color #708090
   * <span class="colorSwath" style="background: #708090;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SLATEGRAY = Object.freeze(Color$1.fromCssColorString('#708090'));

  /**
   * An immutable Color instance initialized to CSS color #708090
   * <span class="colorSwath" style="background: #708090;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SLATEGREY = Color$1.SLATEGRAY;

  /**
   * An immutable Color instance initialized to CSS color #FFFAFA
   * <span class="colorSwath" style="background: #FFFAFA;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SNOW = Object.freeze(Color$1.fromCssColorString('#FFFAFA'));

  /**
   * An immutable Color instance initialized to CSS color #00FF7F
   * <span class="colorSwath" style="background: #00FF7F;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.SPRINGGREEN = Object.freeze(Color$1.fromCssColorString('#00FF7F'));

  /**
   * An immutable Color instance initialized to CSS color #4682B4
   * <span class="colorSwath" style="background: #4682B4;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.STEELBLUE = Object.freeze(Color$1.fromCssColorString('#4682B4'));

  /**
   * An immutable Color instance initialized to CSS color #D2B48C
   * <span class="colorSwath" style="background: #D2B48C;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.TAN = Object.freeze(Color$1.fromCssColorString('#D2B48C'));

  /**
   * An immutable Color instance initialized to CSS color #008080
   * <span class="colorSwath" style="background: #008080;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.TEAL = Object.freeze(Color$1.fromCssColorString('#008080'));

  /**
   * An immutable Color instance initialized to CSS color #D8BFD8
   * <span class="colorSwath" style="background: #D8BFD8;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.THISTLE = Object.freeze(Color$1.fromCssColorString('#D8BFD8'));

  /**
   * An immutable Color instance initialized to CSS color #FF6347
   * <span class="colorSwath" style="background: #FF6347;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.TOMATO = Object.freeze(Color$1.fromCssColorString('#FF6347'));

  /**
   * An immutable Color instance initialized to CSS color #40E0D0
   * <span class="colorSwath" style="background: #40E0D0;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.TURQUOISE = Object.freeze(Color$1.fromCssColorString('#40E0D0'));

  /**
   * An immutable Color instance initialized to CSS color #EE82EE
   * <span class="colorSwath" style="background: #EE82EE;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.VIOLET = Object.freeze(Color$1.fromCssColorString('#EE82EE'));

  /**
   * An immutable Color instance initialized to CSS color #F5DEB3
   * <span class="colorSwath" style="background: #F5DEB3;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.WHEAT = Object.freeze(Color$1.fromCssColorString('#F5DEB3'));

  /**
   * An immutable Color instance initialized to CSS color #FFFFFF
   * <span class="colorSwath" style="background: #FFFFFF;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.WHITE = Object.freeze(Color$1.fromCssColorString('#FFFFFF'));

  /**
   * An immutable Color instance initialized to CSS color #F5F5F5
   * <span class="colorSwath" style="background: #F5F5F5;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.WHITESMOKE = Object.freeze(Color$1.fromCssColorString('#F5F5F5'));

  /**
   * An immutable Color instance initialized to CSS color #FFFF00
   * <span class="colorSwath" style="background: #FFFF00;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.YELLOW = Object.freeze(Color$1.fromCssColorString('#FFFF00'));

  /**
   * An immutable Color instance initialized to CSS color #9ACD32
   * <span class="colorSwath" style="background: #9ACD32;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.YELLOWGREEN = Object.freeze(Color$1.fromCssColorString('#9ACD32'));

  /**
   * An immutable Color instance initialized to CSS transparent.
   * <span class="colorSwath" style="background: transparent;"></span>
   *
   * @constant
   * @type {Color}
   */
  Color$1.TRANSPARENT = Object.freeze(new Color$1(0, 0, 0, 0));

  /**
   * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the
   * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
   * the positive x axis.
   * @alias HeadingPitchRoll
   * @constructor
   *
   * @param {Number} [heading=0.0] The heading component in radians.
   * @param {Number} [pitch=0.0] The pitch component in radians.
   * @param {Number} [roll=0.0] The roll component in radians.
   */
  function HeadingPitchRoll(heading, pitch, roll) {
    /**
     * Gets or sets the heading.
     * @type {Number}
     * @default 0.0
     */
    this.heading = defaultValue$1(heading, 0.0);
    /**
     * Gets or sets the pitch.
     * @type {Number}
     * @default 0.0
     */
    this.pitch = defaultValue$1(pitch, 0.0);
    /**
     * Gets or sets the roll.
     * @type {Number}
     * @default 0.0
     */
    this.roll = defaultValue$1(roll, 0.0);
  }

  /**
   * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
   *
   * @param {Quaternion} quaternion The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.
   * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.
   * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
   */
  HeadingPitchRoll.fromQuaternion = function (quaternion, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(quaternion)) {
      throw new DeveloperError$1("quaternion is required");
    }
    //>>includeEnd('debug');
    if (!defined$1(result)) {
      result = new HeadingPitchRoll();
    }
    var test = 2 * (quaternion.w * quaternion.y - quaternion.z * quaternion.x);
    var denominatorRoll = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
    var numeratorRoll = 2 * (quaternion.w * quaternion.x + quaternion.y * quaternion.z);
    var denominatorHeading = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
    var numeratorHeading = 2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);
    result.heading = -Math.atan2(numeratorHeading, denominatorHeading);
    result.roll = Math.atan2(numeratorRoll, denominatorRoll);
    result.pitch = -CesiumMath.asinClamped(test);
    return result;
  };

  /**
   * Returns a new HeadingPitchRoll instance from angles given in degrees.
   *
   * @param {Number} heading the heading in degrees
   * @param {Number} pitch the pitch in degrees
   * @param {Number} roll the heading in degrees
   * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.
   * @returns {HeadingPitchRoll} A new HeadingPitchRoll instance
   */
  HeadingPitchRoll.fromDegrees = function (heading, pitch, roll, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined$1(heading)) {
      throw new DeveloperError$1("heading is required");
    }
    if (!defined$1(pitch)) {
      throw new DeveloperError$1("pitch is required");
    }
    if (!defined$1(roll)) {
      throw new DeveloperError$1("roll is required");
    }
    //>>includeEnd('debug');
    if (!defined$1(result)) {
      result = new HeadingPitchRoll();
    }
    result.heading = heading * CesiumMath.RADIANS_PER_DEGREE;
    result.pitch = pitch * CesiumMath.RADIANS_PER_DEGREE;
    result.roll = roll * CesiumMath.RADIANS_PER_DEGREE;
    return result;
  };

  /**
   * Duplicates a HeadingPitchRoll instance.
   *
   * @param {HeadingPitchRoll} headingPitchRoll The HeadingPitchRoll to duplicate.
   * @param {HeadingPitchRoll} [result] The object onto which to store the result.
   * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)
   */
  HeadingPitchRoll.clone = function (headingPitchRoll, result) {
    if (!defined$1(headingPitchRoll)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new HeadingPitchRoll(headingPitchRoll.heading, headingPitchRoll.pitch, headingPitchRoll.roll);
    }
    result.heading = headingPitchRoll.heading;
    result.pitch = headingPitchRoll.pitch;
    result.roll = headingPitchRoll.roll;
    return result;
  };

  /**
   * Compares the provided HeadingPitchRolls componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.
   * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.
   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  HeadingPitchRoll.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left.heading === right.heading && left.pitch === right.pitch && left.roll === right.roll;
  };

  /**
   * Compares the provided HeadingPitchRolls componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   *
   * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.
   * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.
   * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
   * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
   * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  HeadingPitchRoll.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    return left === right || defined$1(left) && defined$1(right) && CesiumMath.equalsEpsilon(left.heading, right.heading, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.pitch, right.pitch, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.roll, right.roll, relativeEpsilon, absoluteEpsilon);
  };

  /**
   * Duplicates this HeadingPitchRoll instance.
   *
   * @param {HeadingPitchRoll} [result] The object onto which to store the result.
   * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
   */
  HeadingPitchRoll.prototype.clone = function (result) {
    return HeadingPitchRoll.clone(this, result);
  };

  /**
   * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.
   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  HeadingPitchRoll.prototype.equals = function (right) {
    return HeadingPitchRoll.equals(this, right);
  };

  /**
   * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   *
   * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.
   * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
   * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
   * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  HeadingPitchRoll.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {
    return HeadingPitchRoll.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };

  /**
   * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.
   *
   * @returns {String} A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.
   */
  HeadingPitchRoll.prototype.toString = function () {
    return "(".concat(this.heading, ", ").concat(this.pitch, ", ").concat(this.roll, ")");
  };

  /*
   * @FilePath: HeightReference.js
   * @Author: chenqian
   * @Date: 2023-02-11 11:19:39
   * @LastEditors: cheniqan
   * @LastEditTime: 2023-02-14 13:29:13
   * @Descripttion:
   */
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 表示相对于地形的位置
   *
   * @enum {Number}
   */
  var HeightReference = {
    /**
     * 该位置是绝对的。
     * @type {Number}
     * @constant
     */
    NONE: 0,
    /**
     * 该位置固定在地形上。
     * @type {Number}
     * @constant
     */
    CLAMP_TO_GROUND: 1,
    /**
     * 位置高度是指地形上方的高度。
     * @type {Number}
     * @constant
     */
    RELATIVE_TO_GROUND: 2
  };
  var HeightReference$1 = Object.freeze(HeightReference);

  var Primitive = /*#__PURE__*/function (_Mesh) {
    _inherits(Primitive, _Mesh);
    var _super = _createSuper(Primitive);
    function Primitive(_ref) {
      var _this;
      var image = _ref.image,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color,
        _ref$transparent = _ref.transparent,
        transparent = _ref$transparent === void 0 ? true : _ref$transparent,
        rotation = _ref.rotation,
        heightReference = _ref.heightReference,
        _ref$animate = _ref.animate,
        animate = _ref$animate === void 0 ? false : _ref$animate,
        _ref$amplitute = _ref.amplitute,
        amplitute = _ref$amplitute === void 0 ? 0.5 : _ref$amplitute,
        material = _ref.material;
      _classCallCheck(this, Primitive);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_amplitude", void 0);
      _defineProperty(_assertThisInitialized(_this), "_animate", void 0);
      _defineProperty(_assertThisInitialized(_this), "_rotation", void 0);
      _defineProperty(_assertThisInitialized(_this), "_heightReference", void 0);
      _this._animate = animate;
      _this._amplitute = amplitute;
      var texture;
      if (image) {
        texture = new TextureLoader().load(image);
      }
      if (material) {
        _this.material = material;
      } else {
        _this.material = new MeshBasicMaterial$1({
          color: new Color$2(color.red, color.green, color.blue),
          map: image ? texture : null,
          transparent: transparent,
          opacity: color.alpha,
          blending: NormalBlending,
          side: DoubleSide$1
        });
      }
      _this._heightReference = heightReference;
      _this._rotation = rotation;
      _this.setRotation(rotation);
      return _this;
    }
    _createClass(Primitive, [{
      key: "setRotation",
      value: function setRotation(rotation) {
        this._rotation = rotation;
        if (rotation && rotation instanceof HeadingPitchRoll) {
          this.rotation.set(rotation.pitch - Math.PI / 2, rotation.heading, rotation.roll);
        } else {
          this.rotation.set(-Math.PI / 2, 0, 0);
        }
      }
    }, {
      key: "animate",
      set: function set(value) {
        this._animate = value;
      }
    }, {
      key: "amplitute",
      set: function set(value) {
        this._amplitute = value;
      }
    }, {
      key: "heightReference",
      set: function set(value) {
        this._heightReference = value;
      }
    }, {
      key: "update",
      value: function update(frameNumber, terrainHeight, absoluteHeight) {
        this.rotation.set(0, 0, 0);
        var ajustHeight = 0;
        if (this.geometry.boundingBox) {
          ajustHeight = this.geometry.boundingBox.max.z * (this.scale ? this.scale.z : 1);
        }
        if (this._animate) {
          var z = Math.sin(frameNumber * 0.1);
          ajustHeight *= (z + 1.0) * this._amplitute;
        }
        if (this._heightReference === HeightReference$1.CLAMP_TO_GROUND) {
          ajustHeight += terrainHeight - absoluteHeight;
        } else if (this._heightReference === HeightReference$1.RELATIVE_TO_GROUND) {
          ajustHeight += terrainHeight + absoluteHeight;
        }
        this.position.set(0, 0, -ajustHeight);
        this.setRotation(this._rotation);
        if (this.material instanceof ShaderMaterial) {
          this.material.uniforms.frameNumber.value = frameNumber;
        }
      }
    }]);
    return Primitive;
  }(Mesh);

  // const { THREE } = window;

  /**
   * Box
   */
  var BoxPrimitive = /*#__PURE__*/function (_Primitive) {
    _inherits(BoxPrimitive, _Primitive);
    var _super = _createSuper(BoxPrimitive);
    /**
     * 球体半径
     */
    // private _radius: any = 1000;

    /**
     * 是否有弹跳动画
     */
    // private _animate = false;

    /**
     * 弹跳幅度
     */
    // private _amplitude: number;
    function BoxPrimitive(_ref) {
      var _this;
      var image = _ref.image,
        _ref$dimensions = _ref.dimensions,
        dimensions = _ref$dimensions === void 0 ? new Vector3(100, 100, 100) : _ref$dimensions,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color,
        _ref$transparent = _ref.transparent,
        transparent = _ref$transparent === void 0 ? false : _ref$transparent,
        rotation = _ref.rotation,
        _ref$animate = _ref.animate,
        animate = _ref$animate === void 0 ? false : _ref$animate,
        _ref$amplitude = _ref.amplitude,
        amplitude = _ref$amplitude === void 0 ? 0.2 : _ref$amplitude,
        _ref$widthSegments = _ref.widthSegments,
        widthSegments = _ref$widthSegments === void 0 ? 32 : _ref$widthSegments,
        _ref$heightSegments = _ref.heightSegments,
        heightSegments = _ref$heightSegments === void 0 ? 32 : _ref$heightSegments,
        _ref$depthSegments = _ref.depthSegments,
        depthSegments = _ref$depthSegments === void 0 ? 32 : _ref$depthSegments,
        heightReference = _ref.heightReference,
        material = _ref.material;
      _classCallCheck(this, BoxPrimitive);
      _this = _super.call(this, {
        image: image,
        color: color,
        transparent: transparent,
        rotation: rotation,
        heightReference: heightReference,
        animate: animate,
        amplitude: amplitude,
        material: material
      });
      _this.geometry = new BoxGeometry(1, 1, 1, widthSegments, heightSegments, depthSegments);
      _this.scale.set(dimensions.x, dimensions.y, dimensions.z);
      _this.geometry.computeBoundingBox();
      return _this;
    }

    /**
     * 更新
     * @param frameNumber 帧数
     */
    _createClass(BoxPrimitive, [{
      key: "update",
      value: function update(frameNumber, terrainHeight, absoluteHeight) {
        _get(_getPrototypeOf(BoxPrimitive.prototype), "update", this).call(this, frameNumber, terrainHeight, absoluteHeight);
      }
    }]);
    return BoxPrimitive;
  }(Primitive);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class BaseGraphic
   * 基础几何
   */
  var BaseGraphic = /*#__PURE__*/function () {
    /**
     * BaseGraphic类的构造函数
     * @param {Object} options 对象
     * @param {Array} properties 对象的属性值
     */
    function BaseGraphic(options, properties) {
      var _this = this;
      _classCallCheck(this, BaseGraphic);
      _defineProperty(this, "_propertyList", ['show', 'heightReference', 'material', 'color', 'image', 'transparent', 'animate', 'amplitute']);
      this._definitionChanged = new Event();
      this._properties = new Set([].concat(_toConsumableArray(this._propertyList), _toConsumableArray(properties)));
      this._properties.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Plot} result 用于存储结果的对象。
     * @returns {Plot} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(BaseGraphic, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new Plot(this);
        }
        this._properties.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Plot} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this._properties.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
      /**
       * 获取对象属性值
       * @returns {Array}
       */
    }, {
      key: "properties",
      get: function get() {
        return this._properties;
      }
      /**
       * 获取实例化对象
       * @returns {BaseGraphic}
       */
    }, {
      key: "value",
      get: function get() {
        return this;
      }
      /**
       * 获取每当更改或修改属性或子属性时引发的事件
       * @returns {Event}
       */
    }, {
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }
    }, {
      key: "id",
      get: function get() {
        return this._id;
      }
      /**
       * 获取材质
       * @returns {Event}
       */
    }, {
      key: "material",
      get: function get() {
        return this._material;
      }
      /**
       * 设置材质
       * @param {Material} value
       */,
      set: function set(value) {
        this._material = value;
      }
    }]);
    return BaseGraphic;
  }();
  Object.defineProperties(BaseGraphic.prototype, {
    show: createPropertyDescriptor('show'),
    heightReference: createPropertyDescriptor('heightReference'),
    color: createPropertyDescriptor('color'),
    image: createPropertyDescriptor('image'),
    transparent: createPropertyDescriptor('transparent'),
    animate: createPropertyDescriptor('animate'),
    amplitute: createPropertyDescriptor('amplitute')
  });
  var addGraphic = function addGraphic(entity, key, Type, primitiveName) {
    //获取entity属性
    var attr = entity[key];
    var properties = attr.properties;
    var options = new Object();
    properties.forEach(function (item) {
      if (item == 'material') {
        options[item] = attr[item];
      } else {
        var _attr$item;
        options[item] = (_attr$item = attr[item]) === null || _attr$item === void 0 ? void 0 : _attr$item.getValue();
      }
    });
    var primitive = new Type(options);
    //设置相机
    entity.primitiveInstance[primitiveName] = primitive;
    attr._id = primitive.id;
    return primitive;
  };
  var updateGraphic = function updateGraphic(name, result, primitive) {
    switch (name) {
      case 'color':
        primitive.material.color.fromArray([result.red, result.green, result.blue]);
        primitive.material.opacity = result.alpha;
        break;
      case 'image':
        primitive.material.map = new TextureLoader().load(result);
        break;
      case 'show':
        primitive.visible = result;
        break;
      case 'material':
        primitive.material = result;
        break;
      case 'amplitute':
        primitive.amplitute = result;
        break;
      case 'aniamte':
        primitive.animate = result;
        break;
      case 'transparent':
        primitive.material.transparent = result;
    }
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Box
   * 盒类
   * @extends BaseGraphic
   */
  var Box = /*#__PURE__*/function (_BaseGraphic) {
    _inherits(Box, _BaseGraphic);
    var _super = _createSuper(Box);
    /**
     * Box类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Boolean} options.show=true <code>optional</code> 指定盒子是否可见。
     * @param {Cartesian3} options.dimensions <code>optional</code> 指定盒子的长度、宽度和高度。
     * @param {HeightReference} options.heightReference=HeightReference.NONE <code>optional</code> 指定实体位置相对于什么高度参考系。
     * @param {String} options.image <code>optional</code> 指定盒子的URL。
     * @param {Color} options.color <code>optional</code> 指定用于填充盒子的材料，材质暂只支持颜色。
     */
    function Box(options) {
      _classCallCheck(this, Box);
      return _super.call(this, options, Box.propertyList);
    }
    return _createClass(Box);
  }(BaseGraphic);
  _defineProperty(Box, "propertyList", ['dimensions', 'fill', 'outline', 'outlineColor', 'outlineWidth', 'distanceDisplayCondition']);
  Object.defineProperties(Box.prototype, {
    /**
     * 这是一种事件，每当属性或子属性被更改或修改时会被触发。
     * @memberof Box.prototype
     *
     * @type {Event}
     * @readonly
     */

    dimensions: createPropertyDescriptor('dimensions'),
    fill: createPropertyDescriptor('fill'),
    outline: createPropertyDescriptor('outline'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition')
  });
  var addBox = function addBox(globe, layer, entity, threeEarth) {
    // const primitiveInstance = entity.primitiveInstance
    // const box = entity.box

    // const boxPrimitive = new BoxPrimitive({
    //   image: box.image,
    //   // radius = 10000,
    //   width: box.dimensions ? box.dimensions._value.x : 1,
    //   height: box.dimensions ? box.dimensions._value.y : 1,
    //   depth: box.dimensions ? box.dimensions._value.z : 1,
    //   color: box.color ? box.color._value : null,
    //   heightReference: box.heightReference?._value,
    //   transparent: true,
    //   material: box.material
    // })

    // //设置相机
    // primitiveInstance.boxPrimitive = boxPrimitive
    // entity.box._id = boxPrimitive.id;
    addGraphic(entity, 'box', BoxPrimitive, 'boxPrimitive');
  };
  var updateBox = function updateBox(globe, layer, _ref) {
    var scope = _ref.scope,
      name = _ref.name,
      value = _ref.value;
      _ref.oldValue;
    layer.children.forEach(function (item) {
      var boxPrimitive = item.boxPrimitive;
      if (boxPrimitive.id === scope.id) {
        var result = value._value;
        switch (name) {
          case 'dimensions':
            boxPrimitive.scale.set(result.x, result.y, result.z);
            break;
          default:
            updateGraphic(name, result, boxPrimitive);
            break;
        }
      }
    });
  };

  /**
   * 球体
   */
  var EllipsoidPrimitive = /*#__PURE__*/function (_Primitive) {
    _inherits(EllipsoidPrimitive, _Primitive);
    var _super = _createSuper(EllipsoidPrimitive);
    /**
     * 球体半径
     */

    function EllipsoidPrimitive(_ref) {
      var _this;
      var image = _ref.image,
        _ref$radii = _ref.radii,
        radii = _ref$radii === void 0 ? new Vector3(1, 1, 1) : _ref$radii,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color,
        _ref$transparent = _ref.transparent,
        transparent = _ref$transparent === void 0 ? false : _ref$transparent,
        _ref$animate = _ref.animate,
        animate = _ref$animate === void 0 ? false : _ref$animate,
        _ref$amplitude = _ref.amplitude,
        amplitude = _ref$amplitude === void 0 ? 0.2 : _ref$amplitude,
        _ref$widthSegments = _ref.widthSegments,
        widthSegments = _ref$widthSegments === void 0 ? 32 : _ref$widthSegments,
        _ref$heightSegments = _ref.heightSegments,
        heightSegments = _ref$heightSegments === void 0 ? 16 : _ref$heightSegments,
        rotation = _ref.rotation,
        heightReference = _ref.heightReference,
        material = _ref.material;
      _classCallCheck(this, EllipsoidPrimitive);
      _this = _super.call(this, {
        image: image,
        color: color,
        transparent: transparent,
        rotation: rotation,
        heightReference: heightReference,
        animate: animate,
        amplitude: amplitude,
        material: material
      });
      _defineProperty(_assertThisInitialized(_this), "_radius", 1000);
      _this.geometry = new SphereGeometry(1, widthSegments, heightSegments);
      _this.scale.set(radii.x, radii.y, radii.z);
      _this.geometry.computeBoundingBox();
      return _this;
    }

    /**
     * 更新
     * @param frameNumber 帧数
     */
    _createClass(EllipsoidPrimitive, [{
      key: "update",
      value: function update(frameNumber, terrainHeight, absoluteHeight) {
        _get(_getPrototypeOf(EllipsoidPrimitive.prototype), "update", this).call(this, frameNumber, terrainHeight, absoluteHeight);
      }
    }]);
    return EllipsoidPrimitive;
  }(Primitive);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Ellipsoid
   * 椭球类
   * @extends BaseGraphic
   */
  var Ellipsoid = /*#__PURE__*/function (_BaseGraphic) {
    _inherits(Ellipsoid, _BaseGraphic);
    var _super = _createSuper(Ellipsoid);
    /**
    * Ellipsoid类的构造函数
    * @param {Object} options 具有以下属性的对象:
    * @param {Boolean} options.show=true <code>optional</code> 指定椭球的可见性。
    * @param {Cartesian3} options.radii <code>optional</code> 指定椭球的半径。
    * @param {Color} options.color <code>optional</code> 指定椭球体的颜色和透明度。
    * @param {Boolean} options.animate <code>optional</code> 指定是否要添加动画效果。
    * @param {Material} options.material <code>optional</code> 指定椭球体表面的材质属性。
    */
    function Ellipsoid(options) {
      _classCallCheck(this, Ellipsoid);
      return _super.call(this, options, Ellipsoid.propertyList);
    }
    return _createClass(Ellipsoid);
  }(BaseGraphic);
  _defineProperty(Ellipsoid, "propertyList", ['radii', 'innerRadii', 'minimumCone', 'maximumCone', 'fill', 'outline', 'outlineColor', 'outlineWidth', 'distanceDisplayCondition']);
  Object.defineProperties(Ellipsoid.prototype, {
    radii: createPropertyDescriptor('radii'),
    innerRadii: createPropertyDescriptor('innerRadii'),
    minimumCone: createPropertyDescriptor('minimumCone'),
    maximumCone: createPropertyDescriptor('maximumCone'),
    fill: createPropertyDescriptor('fill'),
    outline: createPropertyDescriptor('outline'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition')
  });
  var addEllipsoid = function addEllipsoid(globe, layer, entity, threeEarth) {
    // const primitiveInstance = entity.primitiveInstance
    // const ellipsoid = entity.ellipsoid

    // const ellipsoidPrimitive = new EllipsoidPrimitive({
    //   image: ellipsoid.image?._value,
    //   radius: ellipsoid.radii?._value,
    //   color: ellipsoid.color?._value,
    //   transparent: ellipsoid.transparent?._value,
    //   heightReference: ellipsoid.heightReference?._value,
    //   animate: ellipsoid.animate?._value,
    //   amplitude: ellipsoid.amplitude?._value,
    //   material: ellipsoid.material
    // })
    // //设置相机
    // primitiveInstance.spherePrimitive = ellipsoidPrimitive
    // entity.ellipsoid._id = ellipsoidPrimitive.id;
    addGraphic(entity, 'ellipsoid', EllipsoidPrimitive, 'ellipsoidPrimitive');
  };
  var updateEllipsoid = function updateEllipsoid(globe, layer, _ref) {
    var scope = _ref.scope,
      name = _ref.name,
      value = _ref.value,
      oldValue = _ref.oldValue;
    layer.children.forEach(function (item) {
      var ellipsoidPrimitive = item.ellipsoidPrimitive;
      if (ellipsoidPrimitive.id === scope.id) {
        var result = value._value;
        switch (name) {
          case 'radii':
            var x = value._value.x / oldValue._value.x;
            var y = value._value.y / oldValue._value.y;
            var z = value._value.z / oldValue._value.z;
            ellipsoidPrimitive.scale.set(x, y, z);
            break;
          default:
            updateGraphic(name, result, ellipsoidPrimitive);
            break;
        }
      }
    });
  };

  var propertyNames$2 = ['show', 'radius', 'data', 'colorRange'];
  var HeatMap = /*#__PURE__*/function () {
    function HeatMap(options) {
      var _this = this;
      _classCallCheck(this, HeatMap);
      _defineProperty(this, "_id", void 0);
      this._definitionChanged = new Event();
      this._propertyNames = propertyNames$2;
      this._propertyNames.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    _createClass(HeatMap, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new HeatMap(this);
        }
        this._propertyNames.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this._propertyNames.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return HeatMap;
  }();
  Object.defineProperties(HeatMap.prototype, {
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     * @memberof Point.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    show: createPropertyDescriptor('show'),
    radius: createPropertyDescriptor('radius'),
    data: createPropertyDescriptor('data'),
    colorRange: createPropertyDescriptor('colorRange')
  });

  var propertyNames$1 = ['show', 'radius', 'data', 'color'];
  var DensityMap = /*#__PURE__*/function () {
    function DensityMap(options) {
      var _this = this;
      _classCallCheck(this, DensityMap);
      _defineProperty(this, "_id", void 0);
      this._definitionChanged = new Event();
      this._propertyNames = propertyNames$1;
      this._propertyNames.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this._show = defaultValue$1(options.show, true);
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    _createClass(DensityMap, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new DensityMap(this);
        }
        this._propertyNames.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this._propertyNames.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return DensityMap;
  }();
  Object.defineProperties(DensityMap.prototype, {
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     * @memberof Point.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    show: createPropertyDescriptor('show'),
    radius: createPropertyDescriptor('radius'),
    data: createPropertyDescriptor('data'),
    color: createPropertyDescriptor('color')
  });

  /**
   * 平面圆
   */
  var CirclePrimitive = /*#__PURE__*/function (_Primitive) {
    _inherits(CirclePrimitive, _Primitive);
    var _super = _createSuper(CirclePrimitive);
    /**
     * 圆的半径,默认为100
     */

    /**
     * 偏移高度，默认值为0
     */

    function CirclePrimitive(_ref) {
      var _this;
      var image = _ref.image,
        _ref$radius = _ref.radius,
        radius = _ref$radius === void 0 ? 100 : _ref$radius,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color,
        transparent = _ref.transparent,
        material = _ref.material,
        animate = _ref.animate,
        amplitude = _ref.amplitude,
        heightReference = _ref.heightReference;
        _ref.offsetHeight;
      _classCallCheck(this, CirclePrimitive);
      _this = _super.call(this, {
        image: image,
        color: color,
        transparent: transparent,
        rotation: new HeadingPitchRoll(0, Math.PI / 2, 0),
        heightReference: heightReference,
        animate: animate,
        amplitude: amplitude,
        material: material
      });
      _defineProperty(_assertThisInitialized(_this), "_radius", 100);
      _defineProperty(_assertThisInitialized(_this), "_offsetHeight", void 0);
      _this.geometry = new CircleGeometry(1, 64);
      _this.scale.set(radius, radius, radius);
      _this.geometry.computeBoundingBox();
      _this._definitionChanged = new Event();
      return _this;
    }
    _createClass(CirclePrimitive, [{
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }

      /**
       * 更新
       * @param frameNumber 帧数
       * @param globe PIEGlobe对象
       */
    }, {
      key: "update",
      value: function update(frameNumber, terrainHeight, absoluteHeight) {
        _get(_getPrototypeOf(CirclePrimitive.prototype), "update", this).call(this, frameNumber, terrainHeight, absoluteHeight);
      }
    }]);
    return CirclePrimitive;
  }(Primitive);

  /**
   * 锥体
   */
  var ConePrimitive = /*#__PURE__*/function (_Primitive) {
    _inherits(ConePrimitive, _Primitive);
    var _super = _createSuper(ConePrimitive);
    function ConePrimitive(_ref) {
      var _this;
      var image = _ref.image,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color,
        _ref$transparent = _ref.transparent,
        transparent = _ref$transparent === void 0 ? false : _ref$transparent,
        _ref$radius = _ref.radius,
        radius = _ref$radius === void 0 ? 10000 : _ref$radius,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? 20000 : _ref$height,
        _ref$radialSegments = _ref.radialSegments,
        radialSegments = _ref$radialSegments === void 0 ? 32 : _ref$radialSegments,
        heightReference = _ref.heightReference,
        rotation = _ref.rotation,
        _ref$animate = _ref.animate,
        animate = _ref$animate === void 0 ? false : _ref$animate,
        _ref$amplitude = _ref.amplitude,
        amplitude = _ref$amplitude === void 0 ? 0.2 : _ref$amplitude,
        material = _ref.material;
      _classCallCheck(this, ConePrimitive);
      _this = _super.call(this, {
        image: image,
        color: color,
        transparent: transparent,
        rotation: rotation,
        heightReference: heightReference,
        animate: animate,
        amplitude: amplitude,
        material: material
      });
      _defineProperty(_assertThisInitialized(_this), "_definitionChanged", void 0);
      _this.geometry = new ConeGeometry(radius, height, radialSegments);
      _this.geometry.computeBoundingBox();
      _this._definitionChanged = new Event();
      return _this;
    }
    _createClass(ConePrimitive, [{
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }
    }, {
      key: "update",
      value: function update(frameNumber, terrainHeight, absoluteHeight) {
        _get(_getPrototypeOf(ConePrimitive.prototype), "update", this).call(this, frameNumber, terrainHeight, absoluteHeight);
      }
    }]);
    return ConePrimitive;
  }(Primitive);

  /**
   * 平面图形
   */
  var PlanePrimitive = /*#__PURE__*/function (_Primitive) {
    _inherits(PlanePrimitive, _Primitive);
    var _super = _createSuper(PlanePrimitive);
    function PlanePrimitive(_ref) {
      var _this;
      var image = _ref.image,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color,
        _ref$width = _ref.width,
        width = _ref$width === void 0 ? 60 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? 100 : _ref$height,
        rotation = _ref.rotation,
        _ref$transparent = _ref.transparent,
        transparent = _ref$transparent === void 0 ? true : _ref$transparent,
        material = _ref.material,
        heightReference = _ref.heightReference,
        animate = _ref.animate,
        amplitude = _ref.amplitude;
      _classCallCheck(this, PlanePrimitive);
      _this = _super.call(this, {
        image: image,
        color: color,
        transparent: transparent,
        rotation: rotation,
        heightReference: heightReference,
        animate: animate,
        amplitude: amplitude,
        material: material
      });
      _this.geometry = new PlaneGeometry(1, 1);
      _this.scale.set(width, height, 1);
      _this._definitionChanged = new Event();
      return _this;
    }
    _createClass(PlanePrimitive, [{
      key: "createCanvas",
      value: function createCanvas() {
        var canvas = document.createElement('canvas');
        canvas.width = 1000;
        canvas.height = 600;
        canvas.style.backgroundColor = 'red';
        var ctx = canvas.getContext('2d');
        ctx.font = '160pt Arial';
        ctx.fillStyle = 'orange';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('踏得网', canvas.width / 2, canvas.height / 2);
        return canvas;
      }
    }, {
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }
    }, {
      key: "update",
      value: function update(frameNumber, terrainHeight, absoluteHeight) {
        _get(_getPrototypeOf(PlanePrimitive.prototype), "update", this).call(this, frameNumber, terrainHeight, absoluteHeight);
      }
    }]);
    return PlanePrimitive;
  }(Primitive);

  function convert(points, that) {
    var left = 1000;
    var top = -1000;
    var right = -1000;
    var bottom = 1000;
    for (var i = 0; i < points.length; i += 3) {
      if (points[i] < left) {
        left = points[i];
      }
      if (points[i] > right) {
        right = points[i];
      }
      if (points[i + 1] > top) {
        top = points[i + 1];
      }
      if (points[i + 1] < bottom) {
        bottom = points[i + 1];
      }
    }
    var centerX = 0,
      centerY = 0,
      centerZ = 0;
    points.forEach(function (item) {
      centerX += item.x;
      centerY += item.y;
      centerZ += item.z;
    });
    centerX = centerX / points.length;
    centerY = centerY / points.length;
    centerZ = centerZ / points.length;

    // var centerX = (left + right) / 2;
    // var centerY = (top + bottom) / 2;
    // var centerZ = 0;
    // var worldCenter = PIEVector3.sphericalToCartesian(centerX * DTOR, centerY * DTOR, Radius + centerZ);
    var worldCenter = Cartesian3.fromElements(centerX, centerY, centerZ);
    that.worldCenter = worldCenter;
    var rotationX = new Matrix4$1();
    var cartoGraphic = Cartographic.fromCartesian(worldCenter);
    // rotationX.makeRotationX(-centerY * DTOR);
    rotationX.makeRotationX(-cartoGraphic.latitude);
    var rotationY = new Matrix4$1();
    // rotationY.makeRotationY(centerX * DTOR);
    rotationY.makeRotationY(cartoGraphic.longitude);
    var rotationXY = new Matrix4$1();
    rotationXY.multiplyMatrices(rotationY, rotationX);
    rotationXY.invert();
    var positions = [];
    points.forEach(function (item) {
      var localPosition = new Vector3(item.x - worldCenter.x, item.y - worldCenter.y, item.z - worldCenter.z);
      localPosition.applyMatrix4(rotationXY);
      positions.push(localPosition);
    });
    // for (var i = 0; i < points.length; i += 3) {
    //   var worldPosition = PIEVector3.sphericalToCartesian(points[i] * DTOR, points[i + 1] * DTOR, Radius + points[i + 2]);
    //   var localPosition = new Vector3(worldPosition.x - worldCenter.x, worldPosition.y - worldCenter.y, worldPosition.z - worldCenter.z);
    //   localPosition.applyMatrix4(rotationXY);
    //   positions.push(localPosition);
    // }

    return {
      positions: positions,
      center: {
        x: centerX,
        y: centerY,
        z: centerZ
      }
    };
  }
  var PolygonPrimitive$1 = /*#__PURE__*/function (_Mesh) {
    _inherits(PolygonPrimitive, _Mesh);
    var _super = _createSuper(PolygonPrimitive);
    function PolygonPrimitive(_ref) {
      var _this;
      var image = _ref.image,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color,
        _ref$positions = _ref.positions,
        positions = _ref$positions === void 0 ? [] : _ref$positions,
        _ref$extrudedHeight = _ref.extrudedHeight,
        extrudedHeight = _ref$extrudedHeight === void 0 ? 1 : _ref$extrudedHeight,
        _ref$transparent = _ref.transparent,
        transparent = _ref$transparent === void 0 ? true : _ref$transparent,
        material = _ref.material;
      _classCallCheck(this, PolygonPrimitive);
      _this = _super.call(this);
      _this.DTOR = 3.141592653 / 180.0;
      _this.Radius = 6378137;
      var that = _assertThisInitialized(_this);
      // var points = [116.39, 39.9, 0, 116.39 + 1, 39.9, 0, 116.39 + 0.5, 39.9 - 0.5, 0, 116.39, 39.9, 0];
      var polygon = convert(positions, that);
      // var polygonWorldMatrix = camera.computeWorldMatrix(polygon.center.x, polygon.center.y, polygon.center.z);
      // var polygonMaterial = new MeshLambertMaterial({
      //   color: 0xff0000,
      //   side: THREE.DoubleSide,
      //   transparent: true,
      //   opacity: 1
      // });
      var shape = new Shape(polygon.positions);
      _this.geometry = new ExtrudeGeometry([shape], {
        depth: 1,
        bevelEnabled: false
      });
      var texture;
      if (image) {
        texture = new TextureLoader().load(image);
      }
      if (material) {
        _this.material = material;
      } else {
        _this.material = new MeshBasicMaterial$1({
          // color: new Color(color.red, color.green, color.blue),
          color: new Color$2(color.red, color.green, color.blue),
          // opacity: opacity,
          map: image ? texture : null,
          opacity: color.alpha,
          transparent: transparent,
          blending: NormalBlending
        });
      }

      // var shape = new Shape(positions);
      // this.geometry = new ExtrudeBufferGeometry(shape, extrudeSettings);
      _this.scale.setZ(extrudedHeight);
      return _this;
    }

    /**
     * 更新
     * @param frameNumber 帧数
     */
    _createClass(PolygonPrimitive, [{
      key: "update",
      value: function update(frameNumber) {
        // const z = Math.sin(frameNumber * 0.1);
        // if (this._animate) {
        //   this.position.set(0, 0, this._radius * (z + 1.0) * this._amplitude);
        // }
      }
    }]);
    return PolygonPrimitive;
  }(Mesh);

  /**
   * 实体，适用于点坐标类型
   */
  var PrimitiveInstance = /*#__PURE__*/function (_Group) {
    _inherits(PrimitiveInstance, _Group);
    var _super = _createSuper(PrimitiveInstance);
    /**
     * 球参数
     */

    /**
     * 球实体
     */

    /**
     * 长方体参数
     */

    /**
     * 长方体实体
     */

    /**
     * 锥体参数
     */

    /**
     * 锥体实体
     */

    /**
     * 圆参数
     */

    /**
     * 圆实体
     */

    /**
     * 平板参数
     */

    /**
     * 平板实体
     */

    /**
     * 模型
     */

    //上方向
    function PrimitiveInstance(position) {
      var _this;
      _classCallCheck(this, PrimitiveInstance);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_sphereParams", void 0);
      _defineProperty(_assertThisInitialized(_this), "_spherePrimitive", void 0);
      _defineProperty(_assertThisInitialized(_this), "_boxParams", void 0);
      _defineProperty(_assertThisInitialized(_this), "_boxPrimitive", void 0);
      _defineProperty(_assertThisInitialized(_this), "_coneParams", void 0);
      _defineProperty(_assertThisInitialized(_this), "_conePrimitive", void 0);
      _defineProperty(_assertThisInitialized(_this), "_circleParams", void 0);
      _defineProperty(_assertThisInitialized(_this), "_circlePrimitive", void 0);
      _defineProperty(_assertThisInitialized(_this), "_panelParams", void 0);
      _defineProperty(_assertThisInitialized(_this), "_PlanePrimitive", void 0);
      _defineProperty(_assertThisInitialized(_this), "_polygonParams", void 0);
      _defineProperty(_assertThisInitialized(_this), "_polygonPrimitive", void 0);
      _defineProperty(_assertThisInitialized(_this), "_model", void 0);
      _defineProperty(_assertThisInitialized(_this), "_weatherSystem", void 0);
      _defineProperty(_assertThisInitialized(_this), "_volumeCloud", void 0);
      _defineProperty(_assertThisInitialized(_this), "_changePosition", void 0);
      _this._dirToUp = new Vector3();
      if (position) {
        _this.changePosition(position);
      }
      _this._terrainHeight = 0;
      _this._definitionChanged = new Event();
      return _this;
    }

    /**
     * 修改位置
     * @param position 位置坐标
     */
    _createClass(PrimitiveInstance, [{
      key: "changePosition",
      value: function changePosition(position) {
        this.position.set(position.x, position.y, position.z);
        this._height = this.getAbsoluteHeight();
        this._changePosition = true;
      }
    }, {
      key: "getAbsoluteHeight",
      value: function getAbsoluteHeight() {
        var cartographic = Cartographic.fromCartesian(this.position);

        //
        var height = cartographic.height;
        return height;
      }
    }, {
      key: "threeEarth",
      set: function set(value) {
        this._threeEarth = value;
      }
    }, {
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }

      /**
       *
       * @returns 获取球体
       */
    }, {
      key: "ellipsoidPrimitive",
      get: function get() {
        return this._spherePrimitive;
      },
      set: function set(value) {
        this._spherePrimitive = value;
        this.add(this._spherePrimitive);
      }
      /**
       *
       * @returns 获取长方体
       */
    }, {
      key: "boxPrimitive",
      get: function get() {
        return this._boxPrimitive;
      },
      set: function set(value) {
        this._boxPrimitive = value;
        this.add(value);
      }

      /**
       *
       * @returns 获取锥体
       */
    }, {
      key: "conePrimitive",
      get: function get() {
        return this._conePrimitive;
      }

      /**
       *
       * @returns 获取平面
       */,
      set: function set(value) {
        this._conePrimitive = value;
        this.add(value);
      }
    }, {
      key: "planePrimitive",
      get: function get() {
        return this._planePrimitive;
      }

      /**
       *
       * @returns 获取圆
       */,
      set: function set(value) {
        this._planePrimitive = value;
        this.add(value);
      }
    }, {
      key: "circlePrimitive",
      get: function get() {
        return this._circlePrimitive;
      },
      set: function set(value) {
        this._circlePrimitive = value;
        this.add(value);
      }
    }, {
      key: "polygonPrimitive",
      get: function get() {
        return this._polygonPrimitive;
      },
      set: function set(value) {
        this._polygonPrimitive = value;
        this.parent.add(value);
      }
    }, {
      key: "model",
      set: function set(value) {
        this._model = value;
        this.add(value);
      }
    }, {
      key: "weatherSystem",
      set: function set(value) {
        this._weatherSystem = value;
        this.add(value);
      }
    }, {
      key: "volumeCloud",
      get: function get() {
        return this._volumeCloud;
      }

      /**
       * 创建实体
       */,
      set: function set(value) {
        this._volumeCloud = value;
        this.add(value);
      }
    }, {
      key: "create",
      value: function create() {
        if (this._sphereParams) {
          this._spherePrimitive = new EllipsoidPrimitive(this._sphereParams);
          this.add(this._spherePrimitive);
        }
        if (this._boxParams) {
          this._boxPrimitive = new BoxPrimitive(this._boxParams);
          this.add(this._boxPrimitive);
        }
        if (this._coneParams) {
          this._conePrimitive = new ConePrimitive(this._coneParams);
          this.add(this._conePrimitive);
        }
        if (this._circleParams) {
          this._circlePrimitive = new CirclePrimitive(this._circleParams);
          this.add(this._circlePrimitive);
        }
        if (this._planeParams) {
          this._planePrimitive = new PlanePrimitive(this._planeParams);
          this.add(this._planePrimitive);
        }
        if (this._polygonParams) {
          this._polygonPrimitive = new PolygonPrimitive$1(this._polygonParams);
          var worldCenter = this._polygonPrimitive.worldCenter;
          var cartographic = Cartographic.fromCartesian(worldCenter);
          this._worldMatrix = this._threeEarth.computeWorldMatrix(cartographic.longitude / Math.PI * 180, cartographic.latitude / Math.PI * 180, cartographic.height);
          this._polygonPrimitive.applyMatrix(this._worldMatrix);
          this.add(this._polygonPrimitive);
        }
        if (this._model) {
          this.add(this._model);
        }
      }

      /**
       * 更新实体
       * @param frameNumber 帧数
       * @param globe PIEGlobe实例
       */
    }, {
      key: "update",
      value: function update(frameState) {
        var worldCamera = frameState.threeEarth.worldCamera;
        //计算朝向
        var refCenter = worldCamera.getReferenceCenter();
        this.lookAt(-refCenter.x, -refCenter.y, -refCenter.z);
        var frameNumber = frameState.frameNumber;
        if (frameNumber % 60 == 0 && this._changePosition) {
          this._terrainHeight = worldCamera.getHPElevationEx(PIESceneMode.Sphere, [this.position.x, this.position.y, this.position.z]);
          this._changePosition = false;
        }
        var globe = frameState.threeEarth.globeControl.getGlobe();
        if (this._weatherSystem) {
          //更新天气系统
          this._weatherSystem.update(frameState);
        }
        if (this._spherePrimitive) {
          this._spherePrimitive.update(frameNumber, this._terrainHeight, this._height);
        }
        if (this._boxPrimitive) {
          this._boxPrimitive.update(frameNumber, this._terrainHeight, this._height);
        }
        if (this._conePrimitive) {
          this._conePrimitive.update(frameNumber, this._terrainHeight, this._height);
        }
        if (this._circlePrimitive) {
          this._circlePrimitive.update(frameNumber, this._terrainHeight, this._height);
        }
        if (this._planePrimitive) {
          this._planePrimitive.update(frameNumber, this._terrainHeight, this._height);
        }
        if (this._polygonPrimitive) {
          this._polygonPrimitive.update(frameNumber, globe, this._terrainHeight, this._height);
        }
        if (this._volumeCloud) {
          this._volumeCloud.update(frameState);
        }
      }

      /**
       * 添加边框
       */
    }, {
      key: "addBorder",
      value: function addBorder(primitive, color, opacity, linewidth) {
        if (primitive === this._boxPrimitive || primitive === this._polygonPrimitive || primitive === this._conePrimitive) {
          var cubeGeometry = primitive.geometry;
          var cubeEdges = new EdgesGeometry(cubeGeometry, 1);
          var edgesMtl = new LineBasicMaterial({
            color: color,
            linewidth: linewidth,
            opacity: opacity,
            transparent: true
          });
          var cubeLine = new LineSegments(cubeEdges, edgesMtl);
          primitive.add(cubeLine);
        }
      }
    }]);
    return PrimitiveInstance;
  }(Group$1);

  // o object_name | g group_name
  var _object_pattern = /^[og]\s*(.+)?/;
  // mtllib file_reference
  var _material_library_pattern = /^mtllib /;
  // usemtl material_name
  var _material_use_pattern = /^usemtl /;
  // usemap map_name
  var _map_use_pattern = /^usemap /;
  var _face_vertex_data_separator_pattern = /\s+/;
  var _vA = new Vector3();
  var _vB = new Vector3();
  var _vC = new Vector3();
  var _ab = new Vector3();
  var _cb = new Vector3();
  var _color = new Color$2();
  function ParserState() {
    var state = {
      objects: [],
      object: {},
      vertices: [],
      normals: [],
      colors: [],
      uvs: [],
      materials: {},
      materialLibraries: [],
      startObject: function startObject(name, fromDeclaration) {
        // If the current object (initial from reset) is not from a g/o declaration in the parsed
        // file. We need to use it for the first parsed g/o to keep things in sync.
        if (this.object && this.object.fromDeclaration === false) {
          this.object.name = name;
          this.object.fromDeclaration = fromDeclaration !== false;
          return;
        }
        var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;
        if (this.object && typeof this.object._finalize === 'function') {
          this.object._finalize(true);
        }
        this.object = {
          name: name || '',
          fromDeclaration: fromDeclaration !== false,
          geometry: {
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            hasUVIndices: false
          },
          materials: [],
          smooth: true,
          startMaterial: function startMaterial(name, libraries) {
            var previous = this._finalize(false);

            // New usemtl declaration overwrites an inherited material, except if faces were declared
            // after the material, then it must be preserved for proper MultiMaterial continuation.
            if (previous && (previous.inherited || previous.groupCount <= 0)) {
              this.materials.splice(previous.index, 1);
            }
            var material = {
              index: this.materials.length,
              name: name || '',
              mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
              smooth: previous !== undefined ? previous.smooth : this.smooth,
              groupStart: previous !== undefined ? previous.groupEnd : 0,
              groupEnd: -1,
              groupCount: -1,
              inherited: false,
              clone: function clone(index) {
                var cloned = {
                  index: typeof index === 'number' ? index : this.index,
                  name: this.name,
                  mtllib: this.mtllib,
                  smooth: this.smooth,
                  groupStart: 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: false
                };
                cloned.clone = this.clone.bind(cloned);
                return cloned;
              }
            };
            this.materials.push(material);
            return material;
          },
          currentMaterial: function currentMaterial() {
            if (this.materials.length > 0) {
              return this.materials[this.materials.length - 1];
            }
            return undefined;
          },
          _finalize: function _finalize(end) {
            var lastMultiMaterial = this.currentMaterial();
            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
              lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
              lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
              lastMultiMaterial.inherited = false;
            }

            // Ignore objects tail materials if no face declarations followed them before a new o/g started.
            if (end && this.materials.length > 1) {
              for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                if (this.materials[mi].groupCount <= 0) {
                  this.materials.splice(mi, 1);
                }
              }
            }

            // Guarantee at least one empty material, this makes the creation later more straight forward.
            if (end && this.materials.length === 0) {
              this.materials.push({
                name: '',
                smooth: this.smooth
              });
            }
            return lastMultiMaterial;
          }
        };

        // Inherit previous objects material.
        // Spec tells us that a declared material must be set to all objects until a new material is declared.
        // If a usemtl declaration is encountered while this new object is being parsed, it will
        // overwrite the inherited material. Exception being that there was already face declarations
        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

        if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
          var declared = previousMaterial.clone(0);
          declared.inherited = true;
          this.object.materials.push(declared);
        }
        this.objects.push(this.object);
      },
      finalize: function finalize() {
        if (this.object && typeof this.object._finalize === 'function') {
          this.object._finalize(true);
        }
      },
      parseVertexIndex: function parseVertexIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
      },
      parseNormalIndex: function parseNormalIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 3) * 3;
      },
      parseUVIndex: function parseUVIndex(value, len) {
        var index = parseInt(value, 10);
        return (index >= 0 ? index - 1 : index + len / 2) * 2;
      },
      addVertex: function addVertex(a, b, c) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
        dst.push(src[b + 0], src[b + 1], src[b + 2]);
        dst.push(src[c + 0], src[c + 1], src[c + 2]);
      },
      addVertexPoint: function addVertexPoint(a) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
      },
      addVertexLine: function addVertexLine(a) {
        var src = this.vertices;
        var dst = this.object.geometry.vertices;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
      },
      addNormal: function addNormal(a, b, c) {
        var src = this.normals;
        var dst = this.object.geometry.normals;
        dst.push(src[a + 0], src[a + 1], src[a + 2]);
        dst.push(src[b + 0], src[b + 1], src[b + 2]);
        dst.push(src[c + 0], src[c + 1], src[c + 2]);
      },
      addFaceNormal: function addFaceNormal(a, b, c) {
        var src = this.vertices;
        var dst = this.object.geometry.normals;
        _vA.fromArray(src, a);
        _vB.fromArray(src, b);
        _vC.fromArray(src, c);
        _cb.subVectors(_vC, _vB);
        _ab.subVectors(_vA, _vB);
        _cb.cross(_ab);
        _cb.normalize();
        dst.push(_cb.x, _cb.y, _cb.z);
        dst.push(_cb.x, _cb.y, _cb.z);
        dst.push(_cb.x, _cb.y, _cb.z);
      },
      addColor: function addColor(a, b, c) {
        var src = this.colors;
        var dst = this.object.geometry.colors;
        if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);
        if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);
        if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);
      },
      addUV: function addUV(a, b, c) {
        var src = this.uvs;
        var dst = this.object.geometry.uvs;
        dst.push(src[a + 0], src[a + 1]);
        dst.push(src[b + 0], src[b + 1]);
        dst.push(src[c + 0], src[c + 1]);
      },
      addDefaultUV: function addDefaultUV() {
        var dst = this.object.geometry.uvs;
        dst.push(0, 0);
        dst.push(0, 0);
        dst.push(0, 0);
      },
      addUVLine: function addUVLine(a) {
        var src = this.uvs;
        var dst = this.object.geometry.uvs;
        dst.push(src[a + 0], src[a + 1]);
      },
      addFace: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {
        var vLen = this.vertices.length;
        var ia = this.parseVertexIndex(a, vLen);
        var ib = this.parseVertexIndex(b, vLen);
        var ic = this.parseVertexIndex(c, vLen);
        this.addVertex(ia, ib, ic);
        this.addColor(ia, ib, ic);

        // normals

        if (na !== undefined && na !== '') {
          var nLen = this.normals.length;
          ia = this.parseNormalIndex(na, nLen);
          ib = this.parseNormalIndex(nb, nLen);
          ic = this.parseNormalIndex(nc, nLen);
          this.addNormal(ia, ib, ic);
        } else {
          this.addFaceNormal(ia, ib, ic);
        }

        // uvs

        if (ua !== undefined && ua !== '') {
          var uvLen = this.uvs.length;
          ia = this.parseUVIndex(ua, uvLen);
          ib = this.parseUVIndex(ub, uvLen);
          ic = this.parseUVIndex(uc, uvLen);
          this.addUV(ia, ib, ic);
          this.object.geometry.hasUVIndices = true;
        } else {
          // add placeholder values (for inconsistent face definitions)

          this.addDefaultUV();
        }
      },
      addPointGeometry: function addPointGeometry(vertices) {
        this.object.geometry.type = 'Points';
        var vLen = this.vertices.length;
        for (var vi = 0, l = vertices.length; vi < l; vi++) {
          var index = this.parseVertexIndex(vertices[vi], vLen);
          this.addVertexPoint(index);
          this.addColor(index);
        }
      },
      addLineGeometry: function addLineGeometry(vertices, uvs) {
        this.object.geometry.type = 'Line';
        var vLen = this.vertices.length;
        var uvLen = this.uvs.length;
        for (var vi = 0, l = vertices.length; vi < l; vi++) {
          this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
        }
        for (var uvi = 0, _l = uvs.length; uvi < _l; uvi++) {
          this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
        }
      }
    };
    state.startObject('', false);
    return state;
  }

  //
  var OBJLoader = /*#__PURE__*/function (_Loader) {
    _inherits(OBJLoader, _Loader);
    var _super = _createSuper(OBJLoader);
    function OBJLoader(manager) {
      var _this;
      _classCallCheck(this, OBJLoader);
      _this = _super.call(this, manager);
      _this.materials = null;
      return _this;
    }
    _createClass(OBJLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (text) {
          try {
            onLoad(scope.parse(text));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "setMaterials",
      value: function setMaterials(materials) {
        this.materials = materials;
        return this;
      }
    }, {
      key: "parse",
      value: function parse(text) {
        var state = new ParserState();
        if (text.indexOf('\r\n') !== -1) {
          // This is faster than String.split with regex that splits on both
          text = text.replace(/\r\n/g, '\n');
        }
        if (text.indexOf('\\\n') !== -1) {
          // join lines separated by a line continuation character (\)
          text = text.replace(/\\\n/g, '');
        }
        var lines = text.split('\n');
        var result = [];
        for (var i = 0, l = lines.length; i < l; i++) {
          var line = lines[i].trimStart();
          if (line.length === 0) continue;
          var lineFirstChar = line.charAt(0);

          // @todo invoke passed in handler if any
          if (lineFirstChar === '#') continue;
          if (lineFirstChar === 'v') {
            var data = line.split(_face_vertex_data_separator_pattern);
            switch (data[0]) {
              case 'v':
                state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                if (data.length >= 7) {
                  _color.setRGB(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6])).convertSRGBToLinear();
                  state.colors.push(_color.r, _color.g, _color.b);
                } else {
                  // if no colors are defined, add placeholders so color and vertex indices match

                  state.colors.push(undefined, undefined, undefined);
                }
                break;
              case 'vn':
                state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                break;
              case 'vt':
                state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                break;
            }
          } else if (lineFirstChar === 'f') {
            var lineData = line.slice(1).trim();
            var vertexData = lineData.split(_face_vertex_data_separator_pattern);
            var faceVertices = [];

            // Parse the face vertex data into an easy to work with format

            for (var j = 0, jl = vertexData.length; j < jl; j++) {
              var vertex = vertexData[j];
              if (vertex.length > 0) {
                var vertexParts = vertex.split('/');
                faceVertices.push(vertexParts);
              }
            }

            // Draw an edge between the first vertex and all subsequent vertices to form an n-gon

            var v1 = faceVertices[0];
            for (var _j = 1, _jl = faceVertices.length - 1; _j < _jl; _j++) {
              var v2 = faceVertices[_j];
              var v3 = faceVertices[_j + 1];
              state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
            }
          } else if (lineFirstChar === 'l') {
            var lineParts = line.substring(1).trim().split(' ');
            var lineVertices = [];
            var lineUVs = [];
            if (line.indexOf('/') === -1) {
              lineVertices = lineParts;
            } else {
              for (var li = 0, llen = lineParts.length; li < llen; li++) {
                var parts = lineParts[li].split('/');
                if (parts[0] !== '') lineVertices.push(parts[0]);
                if (parts[1] !== '') lineUVs.push(parts[1]);
              }
            }
            state.addLineGeometry(lineVertices, lineUVs);
          } else if (lineFirstChar === 'p') {
            var _lineData = line.slice(1).trim();
            var pointData = _lineData.split(' ');
            state.addPointGeometry(pointData);
          } else if ((result = _object_pattern.exec(line)) !== null) {
            // o object_name
            // or
            // g group_name

            // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
            // let name = result[ 0 ].slice( 1 ).trim();
            var name = (' ' + result[0].slice(1).trim()).slice(1);
            state.startObject(name);
          } else if (_material_use_pattern.test(line)) {
            // material

            state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
          } else if (_material_library_pattern.test(line)) {
            // mtl file

            state.materialLibraries.push(line.substring(7).trim());
          } else if (_map_use_pattern.test(line)) {
            // the line is parsed but ignored since the loader assumes textures are defined MTL files
            // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

            console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
          } else if (lineFirstChar === 's') {
            result = line.split(' ');

            // smooth shading

            // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
            // but does not define a usemtl for each face set.
            // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
            // This requires some care to not create extra material on each smooth value for "normal" obj files.
            // where explicit usemtl defines geometry groups.
            // Example asset: examples/models/obj/cerberus/Cerberus.obj

            /*
                 * http://paulbourke.net/dataformats/obj/
                 *
                 * From chapter "Grouping" Syntax explanation "s group_number":
                 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
                 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
                 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
                 * than 0."
                 */
            if (result.length > 1) {
              var value = result[1].trim().toLowerCase();
              state.object.smooth = value !== '0' && value !== 'off';
            } else {
              // ZBrush can produce "s" lines #11707
              state.object.smooth = true;
            }
            var material = state.object.currentMaterial();
            if (material) material.smooth = state.object.smooth;
          } else {
            // Handle null terminated files without exception
            if (line === '\0') continue;
            console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
          }
        }
        state.finalize();
        var container = new Group$1();
        container.materialLibraries = [].concat(state.materialLibraries);
        var hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
        if (hasPrimitives === true) {
          for (var _i = 0, _l2 = state.objects.length; _i < _l2; _i++) {
            var object = state.objects[_i];
            var geometry = object.geometry;
            var materials = object.materials;
            var isLine = geometry.type === 'Line';
            var isPoints = geometry.type === 'Points';
            var hasVertexColors = false;

            // Skip o/g line declarations that did not follow with any faces
            if (geometry.vertices.length === 0) continue;
            var buffergeometry = new BufferGeometry();
            buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3));
            if (geometry.normals.length > 0) {
              buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3));
            }
            if (geometry.colors.length > 0) {
              hasVertexColors = true;
              buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3));
            }
            if (geometry.hasUVIndices === true) {
              buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2));
            }

            // Create materials

            var createdMaterials = [];
            for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
              var sourceMaterial = materials[mi];
              var materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
              var _material = state.materials[materialHash];
              if (this.materials !== null) {
                _material = this.materials.create(sourceMaterial.name);

                // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
                if (isLine && _material && !(_material instanceof LineBasicMaterial)) {
                  var materialLine = new LineBasicMaterial();
                  Material$1.prototype.copy.call(materialLine, _material);
                  materialLine.color.copy(_material.color);
                  _material = materialLine;
                } else if (isPoints && _material && !(_material instanceof PointsMaterial)) {
                  var materialPoints = new PointsMaterial({
                    size: 10,
                    sizeAttenuation: false
                  });
                  Material$1.prototype.copy.call(materialPoints, _material);
                  materialPoints.color.copy(_material.color);
                  materialPoints.map = _material.map;
                  _material = materialPoints;
                }
              }
              if (_material === undefined) {
                if (isLine) {
                  _material = new LineBasicMaterial();
                } else if (isPoints) {
                  _material = new PointsMaterial({
                    size: 1,
                    sizeAttenuation: false
                  });
                } else {
                  _material = new MeshPhongMaterial();
                }
                _material.name = sourceMaterial.name;
                _material.flatShading = sourceMaterial.smooth ? false : true;
                _material.vertexColors = hasVertexColors;
                state.materials[materialHash] = _material;
              }
              createdMaterials.push(_material);
            }

            // Create mesh

            var mesh = void 0;
            if (createdMaterials.length > 1) {
              for (var _mi = 0, _miLen = materials.length; _mi < _miLen; _mi++) {
                var _sourceMaterial = materials[_mi];
                buffergeometry.addGroup(_sourceMaterial.groupStart, _sourceMaterial.groupCount, _mi);
              }
              if (isLine) {
                mesh = new LineSegments(buffergeometry, createdMaterials);
              } else if (isPoints) {
                mesh = new Points(buffergeometry, createdMaterials);
              } else {
                mesh = new Mesh(buffergeometry, createdMaterials);
              }
            } else {
              if (isLine) {
                mesh = new LineSegments(buffergeometry, createdMaterials[0]);
              } else if (isPoints) {
                mesh = new Points(buffergeometry, createdMaterials[0]);
              } else {
                mesh = new Mesh(buffergeometry, createdMaterials[0]);
              }
            }
            mesh.name = object.name;
            container.add(mesh);
          }
        } else {
          // if there is only the default parser state object with no geometry data, interpret data as point cloud

          if (state.vertices.length > 0) {
            var _material2 = new PointsMaterial({
              size: 1,
              sizeAttenuation: false
            });
            var _buffergeometry = new BufferGeometry();
            _buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3));
            if (state.colors.length > 0 && state.colors[0] !== undefined) {
              _buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3));
              _material2.vertexColors = true;
            }
            var points = new Points(_buffergeometry, _material2);
            container.add(points);
          }
        }
        return container;
      }
    }]);
    return OBJLoader;
  }(Loader);

  var GLTFLoader = /*#__PURE__*/function (_Loader) {
    _inherits(GLTFLoader, _Loader);
    var _super = _createSuper(GLTFLoader);
    function GLTFLoader(manager) {
      var _this;
      _classCallCheck(this, GLTFLoader);
      _this = _super.call(this, manager);
      _this.dracoLoader = null;
      _this.ktx2Loader = null;
      _this.meshoptDecoder = null;
      _this.pluginCallbacks = [];
      _this.register(function (parser) {
        return new GLTFMaterialsClearcoatExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFTextureBasisUExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFTextureWebPExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFMaterialsTransmissionExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFMaterialsVolumeExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFMaterialsIorExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFMaterialsSpecularExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFLightsExtension(parser);
      });
      _this.register(function (parser) {
        return new GLTFMeshoptCompression(parser);
      });
      return _this;
    }
    _createClass(GLTFLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var resourcePath;
        if (this.resourcePath !== '') {
          resourcePath = this.resourcePath;
        } else if (this.path !== '') {
          resourcePath = this.path;
        } else {
          resourcePath = LoaderUtils.extractUrlBase(url);
        }

        // Tells the LoadingManager to track an extra item, which resolves after
        // the model is fully loaded. This means the count of items loaded will
        // be incorrect, but ensures manager.onLoad() does not fire early.
        this.manager.itemStart(url);
        var _onError = function _onError(e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        };
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (data) {
          try {
            scope.parse(data, resourcePath, function (gltf) {
              onLoad(gltf);
              scope.manager.itemEnd(url);
            }, _onError);
          } catch (e) {
            _onError(e);
          }
        }, onProgress, _onError);
      }
    }, {
      key: "setDRACOLoader",
      value: function setDRACOLoader(dracoLoader) {
        this.dracoLoader = dracoLoader;
        return this;
      }
    }, {
      key: "setDDSLoader",
      value: function setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
      }
    }, {
      key: "setKTX2Loader",
      value: function setKTX2Loader(ktx2Loader) {
        this.ktx2Loader = ktx2Loader;
        return this;
      }
    }, {
      key: "setMeshoptDecoder",
      value: function setMeshoptDecoder(meshoptDecoder) {
        this.meshoptDecoder = meshoptDecoder;
        return this;
      }
    }, {
      key: "register",
      value: function register(callback) {
        if (this.pluginCallbacks.indexOf(callback) === -1) {
          this.pluginCallbacks.push(callback);
        }
        return this;
      }
    }, {
      key: "unregister",
      value: function unregister(callback) {
        if (this.pluginCallbacks.indexOf(callback) !== -1) {
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
        }
        return this;
      }
    }, {
      key: "parse",
      value: function parse(data, path, onLoad, onError) {
        var content;
        var extensions = {};
        var plugins = {};
        if (typeof data === 'string') {
          content = data;
        } else {
          var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
          if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
            try {
              extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
            } catch (error) {
              if (onError) onError(error);
              return;
            }
            content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
          } else {
            content = LoaderUtils.decodeText(new Uint8Array(data));
          }
        }
        var json = JSON.parse(content);
        if (json.asset === undefined || json.asset.version[0] < 2) {
          if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
          return;
        }
        var parser = new GLTFParser(json, {
          path: path || this.resourcePath || '',
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder
        });
        parser.fileLoader.setRequestHeader(this.requestHeader);
        for (var i = 0; i < this.pluginCallbacks.length; i++) {
          var plugin = this.pluginCallbacks[i](parser);
          plugins[plugin.name] = plugin;

          // Workaround to avoid determining as unknown extension
          // in addUnknownExtensionsToUserData().
          // Remove this workaround if we move all the existing
          // extension handlers to plugin system
          extensions[plugin.name] = true;
        }
        if (json.extensionsUsed) {
          for (var _i = 0; _i < json.extensionsUsed.length; ++_i) {
            var extensionName = json.extensionsUsed[_i];
            var extensionsRequired = json.extensionsRequired || [];
            switch (extensionName) {
              case EXTENSIONS.KHR_MATERIALS_UNLIT:
                extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                break;
              case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                break;
              case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                break;
              case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                extensions[extensionName] = new GLTFTextureTransformExtension();
                break;
              case EXTENSIONS.KHR_MESH_QUANTIZATION:
                extensions[extensionName] = new GLTFMeshQuantizationExtension();
                break;
              default:
                if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {
                  console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                }
            }
          }
        }
        parser.setExtensions(extensions);
        parser.setPlugins(plugins);
        parser.parse(onLoad, onError);
      }
    }]);
    return GLTFLoader;
  }(Loader);
  /* GLTFREGISTRY */
  function GLTFRegistry() {
    var objects = {};
    return {
      get: function get(key) {
        return objects[key];
      },
      add: function add(key, object) {
        objects[key] = object;
      },
      remove: function remove(key) {
        delete objects[key];
      },
      removeAll: function removeAll() {
        objects = {};
      }
    };
  }

  /*********************************/
  /********** EXTENSIONS ***********/
  /*********************************/

  var EXTENSIONS = {
    KHR_BINARY_GLTF: 'KHR_binary_glTF',
    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
    KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
    KHR_MATERIALS_IOR: 'KHR_materials_ior',
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
    KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
    KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
    KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
    KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
    KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
    EXT_TEXTURE_WEBP: 'EXT_texture_webp',
    EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
  };

  /**
   * Punctual Lights Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
   */
  var GLTFLightsExtension = /*#__PURE__*/function () {
    function GLTFLightsExtension(parser) {
      _classCallCheck(this, GLTFLightsExtension);
      this.parser = parser;
      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

      // Object3D instance caches
      this.cache = {
        refs: {},
        uses: {}
      };
    }
    _createClass(GLTFLightsExtension, [{
      key: "_markDefs",
      value: function _markDefs() {
        var parser = this.parser;
        var nodeDefs = this.parser.json.nodes || [];
        for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
          var nodeDef = nodeDefs[nodeIndex];
          if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {
            parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
          }
        }
      }
    }, {
      key: "_loadLight",
      value: function _loadLight(lightIndex) {
        var parser = this.parser;
        var cacheKey = 'light:' + lightIndex;
        var dependency = parser.cache.get(cacheKey);
        if (dependency) return dependency;
        var json = parser.json;
        var extensions = json.extensions && json.extensions[this.name] || {};
        var lightDefs = extensions.lights || [];
        var lightDef = lightDefs[lightIndex];
        var lightNode;
        var color = new Color$2(0xffffff);
        if (lightDef.color !== undefined) color.fromArray(lightDef.color);
        var range = lightDef.range !== undefined ? lightDef.range : 0;
        switch (lightDef.type) {
          case 'directional':
            lightNode = new DirectionalLight(color);
            lightNode.target.position.set(0, 0, -1);
            lightNode.add(lightNode.target);
            break;
          case 'point':
            lightNode = new PointLight(color);
            lightNode.distance = range;
            break;
          case 'spot':
            lightNode = new SpotLight(color);
            lightNode.distance = range;
            // Handle spotlight properties.
            lightDef.spot = lightDef.spot || {};
            lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
            lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
            lightNode.angle = lightDef.spot.outerConeAngle;
            lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
            lightNode.target.position.set(0, 0, -1);
            lightNode.add(lightNode.target);
            break;
          default:
            throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);
        }

        // Some lights (e.g. spot) default to a position other than the origin. Reset the position
        // here, because node-level parsing will only override position if explicitly specified.
        lightNode.position.set(0, 0, 0);
        lightNode.decay = 2;
        if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
        lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);
        dependency = Promise.resolve(lightNode);
        parser.cache.add(cacheKey, dependency);
        return dependency;
      }
    }, {
      key: "createNodeAttachment",
      value: function createNodeAttachment(nodeIndex) {
        var self = this;
        var parser = this.parser;
        var json = parser.json;
        var nodeDef = json.nodes[nodeIndex];
        var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
        var lightIndex = lightDef.light;
        if (lightIndex === undefined) return null;
        return this._loadLight(lightIndex).then(function (light) {
          return parser._getNodeRef(self.cache, lightIndex, light);
        });
      }
    }]);
    return GLTFLightsExtension;
  }();
  /**
   * Unlit Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
   */
  var GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {
    function GLTFMaterialsUnlitExtension() {
      _classCallCheck(this, GLTFMaterialsUnlitExtension);
      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }
    _createClass(GLTFMaterialsUnlitExtension, [{
      key: "getMaterialType",
      value: function getMaterialType() {
        return MeshBasicMaterial$1;
      }
    }, {
      key: "extendParams",
      value: function extendParams(materialParams, materialDef, parser) {
        var pending = [];
        materialParams.color = new Color$2(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;
        var metallicRoughness = materialDef.pbrMetallicRoughness;
        if (metallicRoughness) {
          if (Array.isArray(metallicRoughness.baseColorFactor)) {
            var array = metallicRoughness.baseColorFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }
          if (metallicRoughness.baseColorTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
          }
        }
        return Promise.all(pending);
      }
    }]);
    return GLTFMaterialsUnlitExtension;
  }();
  /**
   * Clearcoat Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
   */
  var GLTFMaterialsClearcoatExtension = /*#__PURE__*/function () {
    function GLTFMaterialsClearcoatExtension(parser) {
      _classCallCheck(this, GLTFMaterialsClearcoatExtension);
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }
    _createClass(GLTFMaterialsClearcoatExtension, [{
      key: "getMaterialType",
      value: function getMaterialType(materialIndex) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return MeshPhysicalMaterial;
      }
    }, {
      key: "extendMaterialParams",
      value: function extendMaterialParams(materialIndex, materialParams) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
          return Promise.resolve();
        }
        var pending = [];
        var extension = materialDef.extensions[this.name];
        if (extension.clearcoatFactor !== undefined) {
          materialParams.clearcoat = extension.clearcoatFactor;
        }
        if (extension.clearcoatTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));
        }
        if (extension.clearcoatRoughnessFactor !== undefined) {
          materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
        }
        if (extension.clearcoatRoughnessTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));
        }
        if (extension.clearcoatNormalTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));
          if (extension.clearcoatNormalTexture.scale !== undefined) {
            var scale = extension.clearcoatNormalTexture.scale;
            materialParams.clearcoatNormalScale = new Vector2(scale, scale);
          }
        }
        return Promise.all(pending);
      }
    }]);
    return GLTFMaterialsClearcoatExtension;
  }();
  /**
   * Transmission Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
   * Draft: https://github.com/KhronosGroup/glTF/pull/1698
   */
  var GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {
    function GLTFMaterialsTransmissionExtension(parser) {
      _classCallCheck(this, GLTFMaterialsTransmissionExtension);
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }
    _createClass(GLTFMaterialsTransmissionExtension, [{
      key: "getMaterialType",
      value: function getMaterialType(materialIndex) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return MeshPhysicalMaterial;
      }
    }, {
      key: "extendMaterialParams",
      value: function extendMaterialParams(materialIndex, materialParams) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
          return Promise.resolve();
        }
        var pending = [];
        var extension = materialDef.extensions[this.name];
        if (extension.transmissionFactor !== undefined) {
          materialParams.transmission = extension.transmissionFactor;
        }
        if (extension.transmissionTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));
        }
        return Promise.all(pending);
      }
    }]);
    return GLTFMaterialsTransmissionExtension;
  }();
  /**
   * Materials Volume Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
   */
  var GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {
    function GLTFMaterialsVolumeExtension(parser) {
      _classCallCheck(this, GLTFMaterialsVolumeExtension);
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
    }
    _createClass(GLTFMaterialsVolumeExtension, [{
      key: "getMaterialType",
      value: function getMaterialType(materialIndex) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return MeshPhysicalMaterial;
      }
    }, {
      key: "extendMaterialParams",
      value: function extendMaterialParams(materialIndex, materialParams) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
          return Promise.resolve();
        }
        var pending = [];
        var extension = materialDef.extensions[this.name];
        materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;
        if (extension.thicknessTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));
        }
        materialParams.attenuationDistance = extension.attenuationDistance || 0;
        var colorArray = extension.attenuationColor || [1, 1, 1];
        materialParams.attenuationTint = new Color$2(colorArray[0], colorArray[1], colorArray[2]);
        return Promise.all(pending);
      }
    }]);
    return GLTFMaterialsVolumeExtension;
  }();
  /**
   * Materials ior Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
   */
  var GLTFMaterialsIorExtension = /*#__PURE__*/function () {
    function GLTFMaterialsIorExtension(parser) {
      _classCallCheck(this, GLTFMaterialsIorExtension);
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_IOR;
    }
    _createClass(GLTFMaterialsIorExtension, [{
      key: "getMaterialType",
      value: function getMaterialType(materialIndex) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return MeshPhysicalMaterial;
      }
    }, {
      key: "extendMaterialParams",
      value: function extendMaterialParams(materialIndex, materialParams) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
          return Promise.resolve();
        }
        var extension = materialDef.extensions[this.name];
        materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;
        return Promise.resolve();
      }
    }]);
    return GLTFMaterialsIorExtension;
  }();
  /**
   * Materials specular Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
   */
  var GLTFMaterialsSpecularExtension = /*#__PURE__*/function () {
    function GLTFMaterialsSpecularExtension(parser) {
      _classCallCheck(this, GLTFMaterialsSpecularExtension);
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
    }
    _createClass(GLTFMaterialsSpecularExtension, [{
      key: "getMaterialType",
      value: function getMaterialType(materialIndex) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return MeshPhysicalMaterial;
      }
    }, {
      key: "extendMaterialParams",
      value: function extendMaterialParams(materialIndex, materialParams) {
        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
          return Promise.resolve();
        }
        var pending = [];
        var extension = materialDef.extensions[this.name];
        materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;
        if (extension.specularTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));
        }
        var colorArray = extension.specularColorFactor || [1, 1, 1];
        materialParams.specularTint = new Color$2(colorArray[0], colorArray[1], colorArray[2]);
        if (extension.specularColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {
            texture.encoding = sRGBEncoding;
          }));
        }
        return Promise.all(pending);
      }
    }]);
    return GLTFMaterialsSpecularExtension;
  }();
  /**
   * BasisU Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
   */
  var GLTFTextureBasisUExtension = /*#__PURE__*/function () {
    function GLTFTextureBasisUExtension(parser) {
      _classCallCheck(this, GLTFTextureBasisUExtension);
      this.parser = parser;
      this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }
    _createClass(GLTFTextureBasisUExtension, [{
      key: "loadTexture",
      value: function loadTexture(textureIndex) {
        var parser = this.parser;
        var json = parser.json;
        var textureDef = json.textures[textureIndex];
        if (!textureDef.extensions || !textureDef.extensions[this.name]) {
          return null;
        }
        var extension = textureDef.extensions[this.name];
        var source = json.images[extension.source];
        var loader = parser.options.ktx2Loader;
        if (!loader) {
          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
            throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
          } else {
            // Assumes that the extension is optional and that a fallback texture is present
            return null;
          }
        }
        return parser.loadTextureImage(textureIndex, source, loader);
      }
    }]);
    return GLTFTextureBasisUExtension;
  }();
  /**
   * WebP Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
   */
  var GLTFTextureWebPExtension = /*#__PURE__*/function () {
    function GLTFTextureWebPExtension(parser) {
      _classCallCheck(this, GLTFTextureWebPExtension);
      this.parser = parser;
      this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
      this.isSupported = null;
    }
    _createClass(GLTFTextureWebPExtension, [{
      key: "loadTexture",
      value: function loadTexture(textureIndex) {
        var name = this.name;
        var parser = this.parser;
        var json = parser.json;
        var textureDef = json.textures[textureIndex];
        if (!textureDef.extensions || !textureDef.extensions[name]) {
          return null;
        }
        var extension = textureDef.extensions[name];
        var source = json.images[extension.source];
        var loader = parser.textureLoader;
        if (source.uri) {
          var handler = parser.options.manager.getHandler(source.uri);
          if (handler !== null) loader = handler;
        }
        return this.detectSupport().then(function (isSupported) {
          if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);
          if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
            throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
          }

          // Fall back to PNG or JPEG.
          return parser.loadTexture(textureIndex);
        });
      }
    }, {
      key: "detectSupport",
      value: function detectSupport() {
        if (!this.isSupported) {
          this.isSupported = new Promise(function (resolve) {
            var image = new Image();

            // Lossy test image. Support for lossy images doesn't guarantee support for all
            // WebP images, unfortunately.
            image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
            image.onload = image.onerror = function () {
              resolve(image.height === 1);
            };
          });
        }
        return this.isSupported;
      }
    }]);
    return GLTFTextureWebPExtension;
  }();
  /**
   * meshopt BufferView Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
   */
  var GLTFMeshoptCompression = /*#__PURE__*/function () {
    function GLTFMeshoptCompression(parser) {
      _classCallCheck(this, GLTFMeshoptCompression);
      this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
      this.parser = parser;
    }
    _createClass(GLTFMeshoptCompression, [{
      key: "loadBufferView",
      value: function loadBufferView(index) {
        var json = this.parser.json;
        var bufferView = json.bufferViews[index];
        if (bufferView.extensions && bufferView.extensions[this.name]) {
          var extensionDef = bufferView.extensions[this.name];
          var buffer = this.parser.getDependency('buffer', extensionDef.buffer);
          var decoder = this.parser.options.meshoptDecoder;
          if (!decoder || !decoder.supported) {
            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
              throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
            } else {
              // Assumes that the extension is optional and that fallback buffer data is present
              return null;
            }
          }
          return Promise.all([buffer, decoder.ready]).then(function (res) {
            var byteOffset = extensionDef.byteOffset || 0;
            var byteLength = extensionDef.byteLength || 0;
            var count = extensionDef.count;
            var stride = extensionDef.byteStride;
            var result = new ArrayBuffer(count * stride);
            var source = new Uint8Array(res[0], byteOffset, byteLength);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        } else {
          return null;
        }
      }
    }]);
    return GLTFMeshoptCompression;
  }();
  /* BINARY EXTENSION */
  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 0x4E4F534A,
    BIN: 0x004E4942
  };
  var GLTFBinaryExtension = /*#__PURE__*/_createClass(function GLTFBinaryExtension(data) {
    _classCallCheck(this, GLTFBinaryExtension);
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
    } else if (this.header.version < 2.0) {
      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
    }
    var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    var chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      var chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      var chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }

      // Clients must ignore chunks with unknown types.

      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error('THREE.GLTFLoader: JSON content not found.');
    }
  });
  /**
   * DRACO Mesh Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
   */
  var GLTFDracoMeshCompressionExtension = /*#__PURE__*/function () {
    function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
      _classCallCheck(this, GLTFDracoMeshCompressionExtension);
      if (!dracoLoader) {
        throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
      }
      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
      this.json = json;
      this.dracoLoader = dracoLoader;
      this.dracoLoader.preload();
    }
    _createClass(GLTFDracoMeshCompressionExtension, [{
      key: "decodePrimitive",
      value: function decodePrimitive(primitive, parser) {
        var json = this.json;
        var dracoLoader = this.dracoLoader;
        var bufferViewIndex = primitive.extensions[this.name].bufferView;
        var gltfAttributeMap = primitive.extensions[this.name].attributes;
        var threeAttributeMap = {};
        var attributeNormalizedMap = {};
        var attributeTypeMap = {};
        for (var attributeName in gltfAttributeMap) {
          var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
          threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
        }
        for (var _attributeName in primitive.attributes) {
          var _threeAttributeName = ATTRIBUTES[_attributeName] || _attributeName.toLowerCase();
          if (gltfAttributeMap[_attributeName] !== undefined) {
            var accessorDef = json.accessors[primitive.attributes[_attributeName]];
            var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            attributeTypeMap[_threeAttributeName] = componentType;
            attributeNormalizedMap[_threeAttributeName] = accessorDef.normalized === true;
          }
        }
        return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
          return new Promise(function (resolve) {
            dracoLoader.decodeDracoFile(bufferView, function (geometry) {
              for (var _attributeName2 in geometry.attributes) {
                var attribute = geometry.attributes[_attributeName2];
                var normalized = attributeNormalizedMap[_attributeName2];
                if (normalized !== undefined) attribute.normalized = normalized;
              }
              resolve(geometry);
            }, threeAttributeMap, attributeTypeMap);
          });
        });
      }
    }]);
    return GLTFDracoMeshCompressionExtension;
  }();
  /**
   * Texture Transform Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
   */
  var GLTFTextureTransformExtension = /*#__PURE__*/function () {
    function GLTFTextureTransformExtension() {
      _classCallCheck(this, GLTFTextureTransformExtension);
      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }
    _createClass(GLTFTextureTransformExtension, [{
      key: "extendTexture",
      value: function extendTexture(texture, transform) {
        if (transform.texCoord !== undefined) {
          console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
        }
        if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {
          // See https://github.com/mrdoob/three.js/issues/21819.
          return texture;
        }
        texture = texture.clone();
        if (transform.offset !== undefined) {
          texture.offset.fromArray(transform.offset);
        }
        if (transform.rotation !== undefined) {
          texture.rotation = transform.rotation;
        }
        if (transform.scale !== undefined) {
          texture.repeat.fromArray(transform.scale);
        }
        texture.needsUpdate = true;
        return texture;
      }
    }]);
    return GLTFTextureTransformExtension;
  }();
  /**
   * Specular-Glossiness Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
   */
  /**
   * A sub class of StandardMaterial with some of the functionality
   * changed via the `onBeforeCompile` callback
   * @pailhead
   */
  var GLTFMeshStandardSGMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {
    _inherits(GLTFMeshStandardSGMaterial, _MeshStandardMaterial);
    var _super2 = _createSuper(GLTFMeshStandardSGMaterial);
    function GLTFMeshStandardSGMaterial(params) {
      var _this2;
      _classCallCheck(this, GLTFMeshStandardSGMaterial);
      _this2 = _super2.call(this);
      _this2.isGLTFSpecularGlossinessMaterial = true;

      //various chunks that need replacing
      var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
      var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
      var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
      var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
      var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\n');
      var uniforms = {
        specular: {
          value: new Color$2().setHex(0xffffff)
        },
        glossiness: {
          value: 1
        },
        specularMap: {
          value: null
        },
        glossinessMap: {
          value: null
        }
      };
      _this2._extraUniforms = uniforms;
      _this2.onBeforeCompile = function (shader) {
        for (var uniformName in uniforms) {
          shader.uniforms[uniformName] = uniforms[uniformName];
        }
        shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
      };
      Object.defineProperties(_assertThisInitialized(_this2), {
        specular: {
          get: function get() {
            return uniforms.specular.value;
          },
          set: function set(v) {
            uniforms.specular.value = v;
          }
        },
        specularMap: {
          get: function get() {
            return uniforms.specularMap.value;
          },
          set: function set(v) {
            uniforms.specularMap.value = v;
            if (v) {
              this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps
            } else {
              delete this.defines.USE_SPECULARMAP;
            }
          }
        },
        glossiness: {
          get: function get() {
            return uniforms.glossiness.value;
          },
          set: function set(v) {
            uniforms.glossiness.value = v;
          }
        },
        glossinessMap: {
          get: function get() {
            return uniforms.glossinessMap.value;
          },
          set: function set(v) {
            uniforms.glossinessMap.value = v;
            if (v) {
              this.defines.USE_GLOSSINESSMAP = '';
              this.defines.USE_UV = '';
            } else {
              delete this.defines.USE_GLOSSINESSMAP;
              delete this.defines.USE_UV;
            }
          }
        }
      });
      delete _this2.metalness;
      delete _this2.roughness;
      delete _this2.metalnessMap;
      delete _this2.roughnessMap;
      _this2.setValues(params);
      return _this2;
    }
    _createClass(GLTFMeshStandardSGMaterial, [{
      key: "copy",
      value: function copy(source) {
        _get(_getPrototypeOf(GLTFMeshStandardSGMaterial.prototype), "copy", this).call(this, source);
        this.specularMap = source.specularMap;
        this.specular.copy(source.specular);
        this.glossinessMap = source.glossinessMap;
        this.glossiness = source.glossiness;
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;
        return this;
      }
    }]);
    return GLTFMeshStandardSGMaterial;
  }(MeshStandardMaterial);
  var GLTFMaterialsPbrSpecularGlossinessExtension = /*#__PURE__*/function () {
    function GLTFMaterialsPbrSpecularGlossinessExtension() {
      _classCallCheck(this, GLTFMaterialsPbrSpecularGlossinessExtension);
      this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
      this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];
    }
    _createClass(GLTFMaterialsPbrSpecularGlossinessExtension, [{
      key: "getMaterialType",
      value: function getMaterialType() {
        return GLTFMeshStandardSGMaterial;
      }
    }, {
      key: "extendParams",
      value: function extendParams(materialParams, materialDef, parser) {
        var pbrSpecularGlossiness = materialDef.extensions[this.name];
        materialParams.color = new Color$2(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;
        var pending = [];
        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
          var array = pbrSpecularGlossiness.diffuseFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }
        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
        }
        materialParams.emissive = new Color$2(0.0, 0.0, 0.0);
        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
        materialParams.specular = new Color$2(1.0, 1.0, 1.0);
        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
        }
        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
          pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
          pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
        }
        return Promise.all(pending);
      }
    }, {
      key: "createMaterial",
      value: function createMaterial(materialParams) {
        var material = new GLTFMeshStandardSGMaterial(materialParams);
        material.fog = true;
        material.color = materialParams.color;
        material.map = materialParams.map === undefined ? null : materialParams.map;
        material.lightMap = null;
        material.lightMapIntensity = 1.0;
        material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
        material.aoMapIntensity = 1.0;
        material.emissive = materialParams.emissive;
        material.emissiveIntensity = 1.0;
        material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
        material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
        material.bumpScale = 1;
        material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
        material.normalMapType = TangentSpaceNormalMap;
        if (materialParams.normalScale) material.normalScale = materialParams.normalScale;
        material.displacementMap = null;
        material.displacementScale = 1;
        material.displacementBias = 0;
        material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
        material.specular = materialParams.specular;
        material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
        material.glossiness = materialParams.glossiness;
        material.alphaMap = null;
        material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
        material.envMapIntensity = 1.0;
        material.refractionRatio = 0.98;
        return material;
      }
    }]);
    return GLTFMaterialsPbrSpecularGlossinessExtension;
  }();
  /**
   * Mesh Quantization Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
   */
  var GLTFMeshQuantizationExtension = /*#__PURE__*/_createClass(function GLTFMeshQuantizationExtension() {
    _classCallCheck(this, GLTFMeshQuantizationExtension);
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  });
  /*********************************/
  /********** INTERPOLATION ********/
  /*********************************/
  // Spline Interpolation
  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
  var GLTFCubicSplineInterpolant = /*#__PURE__*/function (_Interpolant) {
    _inherits(GLTFCubicSplineInterpolant, _Interpolant);
    var _super3 = _createSuper(GLTFCubicSplineInterpolant);
    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      _classCallCheck(this, GLTFCubicSplineInterpolant);
      return _super3.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    _createClass(GLTFCubicSplineInterpolant, [{
      key: "copySampleValue_",
      value: function copySampleValue_(index) {
        // Copies a sample value to the result buffer. See description of glTF
        // CUBICSPLINE values layout in interpolate_() function below.

        var result = this.resultBuffer,
          values = this.sampleValues,
          valueSize = this.valueSize,
          offset = index * valueSize * 3 + valueSize;
        for (var i = 0; i !== valueSize; i++) {
          result[i] = values[offset + i];
        }
        return result;
      }
    }]);
    return GLTFCubicSplineInterpolant;
  }(Interpolant);
  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
    var result = this.resultBuffer;
    var values = this.sampleValues;
    var stride = this.valueSize;
    var stride2 = stride * 2;
    var stride3 = stride * 3;
    var td = t1 - t0;
    var p = (t - t0) / td;
    var pp = p * p;
    var ppp = pp * p;
    var offset1 = i1 * stride3;
    var offset0 = offset1 - stride3;
    var s2 = -2 * ppp + 3 * pp;
    var s3 = ppp - pp;
    var s0 = 1 - s2;
    var s1 = s3 - pp + p;

    // Layout of keyframe output values for CUBICSPLINE animations:
    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
    for (var i = 0; i !== stride; i++) {
      var p0 = values[offset0 + i + stride]; // splineVertex_k
      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
      var p1 = values[offset1 + i + stride]; // splineVertex_k+1
      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  };
  var _q = new Quaternion();
  var GLTFCubicSplineQuaternionInterpolant = /*#__PURE__*/function (_GLTFCubicSplineInter) {
    _inherits(GLTFCubicSplineQuaternionInterpolant, _GLTFCubicSplineInter);
    var _super4 = _createSuper(GLTFCubicSplineQuaternionInterpolant);
    function GLTFCubicSplineQuaternionInterpolant() {
      _classCallCheck(this, GLTFCubicSplineQuaternionInterpolant);
      return _super4.apply(this, arguments);
    }
    _createClass(GLTFCubicSplineQuaternionInterpolant, [{
      key: "interpolate_",
      value: function interpolate_(i1, t0, t, t1) {
        var result = _get(_getPrototypeOf(GLTFCubicSplineQuaternionInterpolant.prototype), "interpolate_", this).call(this, i1, t0, t, t1);
        _q.fromArray(result).normalize().toArray(result);
        return result;
      }
    }]);
    return GLTFCubicSplineQuaternionInterpolant;
  }(GLTFCubicSplineInterpolant);
  /*********************************/
  /********** INTERNALS ************/
  /*********************************/
  /* CONSTANTS */
  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping
  };
  var WEBGL_TYPE_SIZES = {
    'SCALAR': 1,
    'VEC2': 2,
    'VEC3': 3,
    'VEC4': 4,
    'MAT2': 4,
    'MAT3': 9,
    'MAT4': 16
  };
  var ATTRIBUTES = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv2',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex'
  };
  var PATH_PROPERTIES = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  };
  var INTERPOLATION = {
    CUBICSPLINE: undefined,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: 'OPAQUE',
    MASK: 'MASK',
    BLEND: 'BLEND'
  };

  /* UTILITY FUNCTIONS */

  function resolveURL(url, path) {
    // Invalid URL
    if (typeof url !== 'string' || url === '') return '';

    // Host Relative URL
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
    }

    // Absolute URL http://,https://,//
    if (/^(https?:)?\/\//i.test(url)) return url;

    // Data URI
    if (/^data:.*,.*$/i.test(url)) return url;

    // Blob URL
    if (/^blob:.*$/i.test(url)) return url;

    // Relative URL
    return path + url;
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   */
  function createDefaultMaterial(cache) {
    if (cache['DefaultMaterial'] === undefined) {
      cache['DefaultMaterial'] = new MeshStandardMaterial({
        color: 0xFFFFFF,
        emissive: 0x000000,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }
    return cache['DefaultMaterial'];
  }
  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    // Add unknown glTF extensions to an object's userData.

    for (var name in objectDef.extensions) {
      if (knownExtensions[name] === undefined) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }

  /**
   * @param {Object3D|Material|BufferGeometry} object
   * @param {GLTF.definition} gltfDef
   */
  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== undefined) {
      if (_typeof(gltfDef.extras) === 'object') {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
      }
    }
  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   *
   * @param {BufferGeometry} geometry
   * @param {Array<GLTF.Target>} targets
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */
  function addMorphTargets(geometry, targets, parser) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;
    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      if (target.POSITION !== undefined) hasMorphPosition = true;
      if (target.NORMAL !== undefined) hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal) break;
    }
    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
    var pendingPositionAccessors = [];
    var pendingNormalAccessors = [];
    for (var _i2 = 0, _il = targets.length; _i2 < _il; _i2++) {
      var _target = targets[_i2];
      if (hasMorphPosition) {
        var pendingAccessor = _target.POSITION !== undefined ? parser.getDependency('accessor', _target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }
      if (hasMorphNormal) {
        var _pendingAccessor = _target.NORMAL !== undefined ? parser.getDependency('accessor', _target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(_pendingAccessor);
      }
    }
    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
      var morphPositions = accessors[0];
      var morphNormals = accessors[1];
      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }

  /**
   * @param {Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   */
  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== undefined) {
      for (var i = 0, il = meshDef.weights.length; i < il; i++) {
        mesh.morphTargetInfluences[i] = meshDef.weights[i];
      }
    }

    // .extras has user-defined data, so check that .extras.targetNames is an array.
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      var targetNames = meshDef.extras.targetNames;
      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};
        for (var _i3 = 0, _il2 = targetNames.length; _i3 < _il2; _i3++) {
          mesh.morphTargetDictionary[targetNames[_i3]] = _i3;
        }
      } else {
        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
      }
    }
  }
  function createPrimitiveKey(primitiveDef) {
    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    var geometryKey;
    if (dracoExtension) {
      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
    }
    return geometryKey;
  }
  function createAttributesKey(attributes) {
    var attributesKey = '';
    var keys = Object.keys(attributes).sort();
    for (var i = 0, il = keys.length; i < il; i++) {
      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
    }
    return attributesKey;
  }
  function getNormalizedComponentScale(constructor) {
    // Reference:
    // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

    switch (constructor) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
    }
  }

  /* GLTF PARSER */
  var GLTFParser = /*#__PURE__*/function () {
    function GLTFParser() {
      var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, GLTFParser);
      this.json = json;
      this.extensions = {};
      this.plugins = {};
      this.options = options;

      // loader object cache
      this.cache = new GLTFRegistry();

      // associations between Three.js objects and glTF elements
      this.associations = new Map();

      // BufferGeometry caching
      this.primitiveCache = {};

      // Object3D instance caches
      this.meshCache = {
        refs: {},
        uses: {}
      };
      this.cameraCache = {
        refs: {},
        uses: {}
      };
      this.lightCache = {
        refs: {},
        uses: {}
      };
      this.textureCache = {};

      // Track node names, to ensure no duplicates
      this.nodeNamesUsed = {};

      // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
      // expensive work of uploading a texture to the GPU off the main thread.
      if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {
        this.textureLoader = new ImageBitmapLoader(this.options.manager);
      } else {
        this.textureLoader = new TextureLoader(this.options.manager);
      }
      this.textureLoader.setCrossOrigin(this.options.crossOrigin);
      this.textureLoader.setRequestHeader(this.options.requestHeader);
      this.fileLoader = new FileLoader(this.options.manager);
      this.fileLoader.setResponseType('arraybuffer');
      if (this.options.crossOrigin === 'use-credentials') {
        this.fileLoader.setWithCredentials(true);
      }
    }
    _createClass(GLTFParser, [{
      key: "setExtensions",
      value: function setExtensions(extensions) {
        this.extensions = extensions;
      }
    }, {
      key: "setPlugins",
      value: function setPlugins(plugins) {
        this.plugins = plugins;
      }
    }, {
      key: "parse",
      value: function parse(onLoad, onError) {
        var parser = this;
        var json = this.json;
        var extensions = this.extensions;

        // Clear the loader cache
        this.cache.removeAll();

        // Mark the special nodes/meshes in json for efficient parse
        this._invokeAll(function (ext) {
          return ext._markDefs && ext._markDefs();
        });
        Promise.all(this._invokeAll(function (ext) {
          return ext.beforeRoot && ext.beforeRoot();
        })).then(function () {
          return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);
        }).then(function (dependencies) {
          var result = {
            scene: dependencies[0][json.scene || 0],
            scenes: dependencies[0],
            animations: dependencies[1],
            cameras: dependencies[2],
            asset: json.asset,
            parser: parser,
            userData: {}
          };
          addUnknownExtensionsToUserData(extensions, result, json);
          assignExtrasToUserData(result, json);
          Promise.all(parser._invokeAll(function (ext) {
            return ext.afterRoot && ext.afterRoot(result);
          })).then(function () {
            onLoad(result);
          });
        })["catch"](onError);
      }

      /**
       * Marks the special nodes/meshes in json for efficient parse.
       */
    }, {
      key: "_markDefs",
      value: function _markDefs() {
        var nodeDefs = this.json.nodes || [];
        var skinDefs = this.json.skins || [];
        var meshDefs = this.json.meshes || [];

        // Nothing in the node definition indicates whether it is a Bone or an
        // Object3D. Use the skins' joint references to mark bones.
        for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
          var joints = skinDefs[skinIndex].joints;
          for (var i = 0, il = joints.length; i < il; i++) {
            nodeDefs[joints[i]].isBone = true;
          }
        }

        // Iterate over all nodes, marking references to shared resources,
        // as well as skeleton joints.
        for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
          var nodeDef = nodeDefs[nodeIndex];
          if (nodeDef.mesh !== undefined) {
            this._addNodeRef(this.meshCache, nodeDef.mesh);

            // Nothing in the mesh definition indicates whether it is
            // a SkinnedMesh or Mesh. Use the node's mesh reference
            // to mark SkinnedMesh if node has skin.
            if (nodeDef.skin !== undefined) {
              meshDefs[nodeDef.mesh].isSkinnedMesh = true;
            }
          }
          if (nodeDef.camera !== undefined) {
            this._addNodeRef(this.cameraCache, nodeDef.camera);
          }
        }
      }

      /**
       * Counts references to shared node / Object3D resources. These resources
       * can be reused, or "instantiated", at multiple nodes in the scene
       * hierarchy. Mesh, Camera, and Light instances are instantiated and must
       * be marked. Non-scenegraph resources (like Materials, Geometries, and
       * Textures) can be reused directly and are not marked here.
       *
       * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
       */
    }, {
      key: "_addNodeRef",
      value: function _addNodeRef(cache, index) {
        if (index === undefined) return;
        if (cache.refs[index] === undefined) {
          cache.refs[index] = cache.uses[index] = 0;
        }
        cache.refs[index]++;
      }

      /** Returns a reference to a shared resource, cloning it if necessary. */
    }, {
      key: "_getNodeRef",
      value: function _getNodeRef(cache, index, object) {
        var _this3 = this;
        if (cache.refs[index] <= 1) return object;
        var ref = object.clone();

        // Propagates mappings to the cloned object, prevents mappings on the
        // original object from being lost.
        var updateMappings = function updateMappings(original, clone) {
          var mappings = _this3.associations.get(original);
          if (mappings != null) {
            _this3.associations.set(clone, mappings);
          }
          var _iterator = _createForOfIteratorHelper(original.children.entries()),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                i = _step$value[0],
                child = _step$value[1];
              updateMappings(child, clone.children[i]);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        };
        updateMappings(object, ref);
        ref.name += '_instance_' + cache.uses[index]++;
        return ref;
      }
    }, {
      key: "_invokeOne",
      value: function _invokeOne(func) {
        var extensions = Object.values(this.plugins);
        extensions.push(this);
        for (var i = 0; i < extensions.length; i++) {
          var result = func(extensions[i]);
          if (result) return result;
        }
        return null;
      }
    }, {
      key: "_invokeAll",
      value: function _invokeAll(func) {
        var extensions = Object.values(this.plugins);
        extensions.unshift(this);
        var pending = [];
        for (var i = 0; i < extensions.length; i++) {
          var result = func(extensions[i]);
          if (result) pending.push(result);
        }
        return pending;
      }

      /**
       * Requests the specified dependency asynchronously, with caching.
       * @param {string} type
       * @param {number} index
       * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
       */
    }, {
      key: "getDependency",
      value: function getDependency(type, index) {
        var cacheKey = type + ':' + index;
        var dependency = this.cache.get(cacheKey);
        if (!dependency) {
          switch (type) {
            case 'scene':
              dependency = this.loadScene(index);
              break;
            case 'node':
              dependency = this.loadNode(index);
              break;
            case 'mesh':
              dependency = this._invokeOne(function (ext) {
                return ext.loadMesh && ext.loadMesh(index);
              });
              break;
            case 'accessor':
              dependency = this.loadAccessor(index);
              break;
            case 'bufferView':
              dependency = this._invokeOne(function (ext) {
                return ext.loadBufferView && ext.loadBufferView(index);
              });
              break;
            case 'buffer':
              dependency = this.loadBuffer(index);
              break;
            case 'material':
              dependency = this._invokeOne(function (ext) {
                return ext.loadMaterial && ext.loadMaterial(index);
              });
              break;
            case 'texture':
              dependency = this._invokeOne(function (ext) {
                return ext.loadTexture && ext.loadTexture(index);
              });
              break;
            case 'skin':
              dependency = this.loadSkin(index);
              break;
            case 'animation':
              dependency = this.loadAnimation(index);
              break;
            case 'camera':
              dependency = this.loadCamera(index);
              break;
            default:
              throw new Error('Unknown type: ' + type);
          }
          this.cache.add(cacheKey, dependency);
        }
        return dependency;
      }

      /**
       * Requests all dependencies of the specified type asynchronously, with caching.
       * @param {string} type
       * @return {Promise<Array<Object>>}
       */
    }, {
      key: "getDependencies",
      value: function getDependencies(type) {
        var dependencies = this.cache.get(type);
        if (!dependencies) {
          var parser = this;
          var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
          dependencies = Promise.all(defs.map(function (def, index) {
            return parser.getDependency(type, index);
          }));
          this.cache.add(type, dependencies);
        }
        return dependencies;
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
       * @param {number} bufferIndex
       * @return {Promise<ArrayBuffer>}
       */
    }, {
      key: "loadBuffer",
      value: function loadBuffer(bufferIndex) {
        var bufferDef = this.json.buffers[bufferIndex];
        var loader = this.fileLoader;
        if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
          throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
        }

        // If present, GLB container is required to be the first buffer.
        if (bufferDef.uri === undefined && bufferIndex === 0) {
          return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        }
        var options = this.options;
        return new Promise(function (resolve, reject) {
          loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
            reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
          });
        });
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
       * @param {number} bufferViewIndex
       * @return {Promise<ArrayBuffer>}
       */
    }, {
      key: "loadBufferView",
      value: function loadBufferView(bufferViewIndex) {
        var bufferViewDef = this.json.bufferViews[bufferViewIndex];
        return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
          var byteLength = bufferViewDef.byteLength || 0;
          var byteOffset = bufferViewDef.byteOffset || 0;
          return buffer.slice(byteOffset, byteOffset + byteLength);
        });
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
       * @param {number} accessorIndex
       * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
       */
    }, {
      key: "loadAccessor",
      value: function loadAccessor(accessorIndex) {
        var parser = this;
        var json = this.json;
        var accessorDef = this.json.accessors[accessorIndex];
        if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
          // Ignore empty accessors, which may be used to declare runtime
          // information about attributes coming from another source (e.g. Draco
          // compression extension).
          return Promise.resolve(null);
        }
        var pendingBufferViews = [];
        if (accessorDef.bufferView !== undefined) {
          pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
        } else {
          pendingBufferViews.push(null);
        }
        if (accessorDef.sparse !== undefined) {
          pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
          pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
        }
        return Promise.all(pendingBufferViews).then(function (bufferViews) {
          var bufferView = bufferViews[0];
          var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
          var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

          // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
          var elementBytes = TypedArray.BYTES_PER_ELEMENT;
          var itemBytes = elementBytes * itemSize;
          var byteOffset = accessorDef.byteOffset || 0;
          var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
          var normalized = accessorDef.normalized === true;
          var array, bufferAttribute;

          // The buffer is not interleaved if the stride is the item size in bytes.
          if (byteStride && byteStride !== itemBytes) {
            // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
            // This makes sure that IBA.count reflects accessor.count properly
            var ibSlice = Math.floor(byteOffset / byteStride);
            var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
            var ib = parser.cache.get(ibCacheKey);
            if (!ib) {
              array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);

              // Integer parameters to IB/IBA are in array elements, not bytes.
              ib = new InterleavedBuffer(array, byteStride / elementBytes);
              parser.cache.add(ibCacheKey, ib);
            }
            bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
          } else {
            if (bufferView === null) {
              array = new TypedArray(accessorDef.count * itemSize);
            } else {
              array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
            }
            bufferAttribute = new BufferAttribute(array, itemSize, normalized);
          }

          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
          if (accessorDef.sparse !== undefined) {
            var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
            var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
            var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
            var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
            var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
            var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
            if (bufferView !== null) {
              // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
              bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
            }
            for (var i = 0, il = sparseIndices.length; i < il; i++) {
              var index = sparseIndices[i];
              bufferAttribute.setX(index, sparseValues[i * itemSize]);
              if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
              if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
              if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
              if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
            }
          }
          return bufferAttribute;
        });
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
       * @param {number} textureIndex
       * @return {Promise<THREE.Texture>}
       */
    }, {
      key: "loadTexture",
      value: function loadTexture(textureIndex) {
        var json = this.json;
        var options = this.options;
        var textureDef = json.textures[textureIndex];
        var source = json.images[textureDef.source];
        var loader = this.textureLoader;
        if (source.uri) {
          var handler = options.manager.getHandler(source.uri);
          if (handler !== null) loader = handler;
        }
        return this.loadTextureImage(textureIndex, source, loader);
      }
    }, {
      key: "loadTextureImage",
      value: function loadTextureImage(textureIndex, source, loader) {
        var parser = this;
        var json = this.json;
        var options = this.options;
        var textureDef = json.textures[textureIndex];
        var cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;
        if (this.textureCache[cacheKey]) {
          // See https://github.com/mrdoob/three.js/issues/21559.
          return this.textureCache[cacheKey];
        }
        var URL = self.URL || self.webkitURL;
        var sourceURI = source.uri || '';
        var isObjectURL = false;
        if (source.bufferView !== undefined) {
          // Load binary image data from bufferView, if provided.

          sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
            isObjectURL = true;
            var blob = new Blob([bufferView], {
              type: source.mimeType
            });
            sourceURI = URL.createObjectURL(blob);
            return sourceURI;
          });
        } else if (source.uri === undefined) {
          throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');
        }
        var promise = Promise.resolve(sourceURI).then(function (sourceURI) {
          return new Promise(function (resolve, reject) {
            var onLoad = resolve;
            if (loader.isImageBitmapLoader === true) {
              onLoad = function onLoad(imageBitmap) {
                var texture = new Texture(imageBitmap);
                texture.needsUpdate = true;
                resolve(texture);
              };
            }
            loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);
          });
        }).then(function (texture) {
          // Clean up resources and configure Texture.

          if (isObjectURL === true) {
            URL.revokeObjectURL(sourceURI);
          }
          texture.flipY = false;
          if (textureDef.name) texture.name = textureDef.name;
          var samplers = json.samplers || {};
          var sampler = samplers[textureDef.sampler] || {};
          texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
          texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
          texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
          texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
          parser.associations.set(texture, {
            textures: textureIndex
          });
          return texture;
        })["catch"](function () {
          console.error('THREE.GLTFLoader: Couldn\'t load texture', sourceURI);
          return null;
        });
        this.textureCache[cacheKey] = promise;
        return promise;
      }

      /**
       * Asynchronously assigns a texture to the given material parameters.
       * @param {Object} materialParams
       * @param {string} mapName
       * @param {Object} mapDef
       * @return {Promise<Texture>}
       */
    }, {
      key: "assignTexture",
      value: function assignTexture(materialParams, mapName, mapDef) {
        var parser = this;
        return this.getDependency('texture', mapDef.index).then(function (texture) {
          // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
          // However, we will copy UV set 0 to UV set 1 on demand for aoMap
          if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
            console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
          }
          if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
            var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;
            if (transform) {
              var gltfReference = parser.associations.get(texture);
              texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
              parser.associations.set(texture, gltfReference);
            }
          }
          materialParams[mapName] = texture;
          return texture;
        });
      }

      /**
       * Assigns final material to a Mesh, Line, or Points instance. The instance
       * already has a material (generated from the glTF material options alone)
       * but reuse of the same glTF material may require multiple threejs materials
       * to accommodate different primitive types, defines, etc. New materials will
       * be created if necessary, and reused from a cache.
       * @param  {Object3D} mesh Mesh, Line, or Points instance.
       */
    }, {
      key: "assignFinalMaterial",
      value: function assignFinalMaterial(mesh) {
        var geometry = mesh.geometry;
        var material = mesh.material;
        var useDerivativeTangents = geometry.attributes.tangent === undefined;
        var useVertexColors = geometry.attributes.color !== undefined;
        var useFlatShading = geometry.attributes.normal === undefined;
        if (mesh.isPoints) {
          var cacheKey = 'PointsMaterial:' + material.uuid;
          var pointsMaterial = this.cache.get(cacheKey);
          if (!pointsMaterial) {
            pointsMaterial = new PointsMaterial();
            Material$1.prototype.copy.call(pointsMaterial, material);
            pointsMaterial.color.copy(material.color);
            pointsMaterial.map = material.map;
            pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

            this.cache.add(cacheKey, pointsMaterial);
          }
          material = pointsMaterial;
        } else if (mesh.isLine) {
          var _cacheKey = 'LineBasicMaterial:' + material.uuid;
          var lineMaterial = this.cache.get(_cacheKey);
          if (!lineMaterial) {
            lineMaterial = new LineBasicMaterial();
            Material$1.prototype.copy.call(lineMaterial, material);
            lineMaterial.color.copy(material.color);
            this.cache.add(_cacheKey, lineMaterial);
          }
          material = lineMaterial;
        }

        // Clone the material if it will be modified
        if (useDerivativeTangents || useVertexColors || useFlatShading) {
          var _cacheKey2 = 'ClonedMaterial:' + material.uuid + ':';
          if (material.isGLTFSpecularGlossinessMaterial) _cacheKey2 += 'specular-glossiness:';
          if (useDerivativeTangents) _cacheKey2 += 'derivative-tangents:';
          if (useVertexColors) _cacheKey2 += 'vertex-colors:';
          if (useFlatShading) _cacheKey2 += 'flat-shading:';
          var cachedMaterial = this.cache.get(_cacheKey2);
          if (!cachedMaterial) {
            cachedMaterial = material.clone();
            if (useVertexColors) cachedMaterial.vertexColors = true;
            if (useFlatShading) cachedMaterial.flatShading = true;
            if (useDerivativeTangents) {
              // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
              if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
              if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
            }
            this.cache.add(_cacheKey2, cachedMaterial);
            this.associations.set(cachedMaterial, this.associations.get(material));
          }
          material = cachedMaterial;
        }

        // workarounds for mesh and geometry

        if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
          geometry.setAttribute('uv2', geometry.attributes.uv);
        }
        mesh.material = material;
      }
    }, {
      key: "getMaterialType",
      value: function getMaterialType( /* materialIndex */
      ) {
        return MeshStandardMaterial;
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
       * @param {number} materialIndex
       * @return {Promise<Material>}
       */
    }, {
      key: "loadMaterial",
      value: function loadMaterial(materialIndex) {
        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        var materialDef = json.materials[materialIndex];
        var materialType;
        var materialParams = {};
        var materialExtensions = materialDef.extensions || {};
        var pending = [];
        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
          var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
          materialType = sgExtension.getMaterialType();
          pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
        } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
          var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
          materialType = kmuExtension.getMaterialType();
          pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
        } else {
          // Specification:
          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

          var metallicRoughness = materialDef.pbrMetallicRoughness || {};
          materialParams.color = new Color$2(1.0, 1.0, 1.0);
          materialParams.opacity = 1.0;
          if (Array.isArray(metallicRoughness.baseColorFactor)) {
            var array = metallicRoughness.baseColorFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }
          if (metallicRoughness.baseColorTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
          }
          materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
          materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;
          if (metallicRoughness.metallicRoughnessTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
            pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
          }
          materialType = this._invokeOne(function (ext) {
            return ext.getMaterialType && ext.getMaterialType(materialIndex);
          });
          pending.push(Promise.all(this._invokeAll(function (ext) {
            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
          })));
        }
        if (materialDef.doubleSided === true) {
          materialParams.side = DoubleSide$1;
        }
        var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
        if (alphaMode === ALPHA_MODES.BLEND) {
          materialParams.transparent = true;

          // See: https://github.com/mrdoob/three.js/issues/17706
          materialParams.depthWrite = false;
        } else {
          materialParams.format = RGBFormat;
          materialParams.transparent = false;
          if (alphaMode === ALPHA_MODES.MASK) {
            materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
          }
        }
        if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial$1) {
          pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
          materialParams.normalScale = new Vector2(1, 1);
          if (materialDef.normalTexture.scale !== undefined) {
            var scale = materialDef.normalTexture.scale;
            materialParams.normalScale.set(scale, scale);
          }
        }
        if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial$1) {
          pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));
          if (materialDef.occlusionTexture.strength !== undefined) {
            materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
          }
        }
        if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial$1) {
          materialParams.emissive = new Color$2().fromArray(materialDef.emissiveFactor);
        }
        if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial$1) {
          pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
        }
        return Promise.all(pending).then(function () {
          var material;
          if (materialType === GLTFMeshStandardSGMaterial) {
            material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
          } else {
            material = new materialType(materialParams);
          }
          if (materialDef.name) material.name = materialDef.name;

          // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
          if (material.map) material.map.encoding = sRGBEncoding;
          if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;
          assignExtrasToUserData(material, materialDef);
          parser.associations.set(material, {
            materials: materialIndex
          });
          if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
          return material;
        });
      }

      /** When Object3D instances are targeted by animation, they need unique names. */
    }, {
      key: "createUniqueName",
      value: function createUniqueName(originalName) {
        var sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');
        var name = sanitizedName;
        for (var i = 1; this.nodeNamesUsed[name]; ++i) {
          name = sanitizedName + '_' + i;
        }
        this.nodeNamesUsed[name] = true;
        return name;
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
       *
       * Creates BufferGeometries from primitives.
       *
       * @param {Array<GLTF.Primitive>} primitives
       * @return {Promise<Array<BufferGeometry>>}
       */
    }, {
      key: "loadGeometries",
      value: function loadGeometries(primitives) {
        var parser = this;
        var extensions = this.extensions;
        var cache = this.primitiveCache;
        function createDracoPrimitive(primitive) {
          return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
            return addPrimitiveAttributes(geometry, primitive, parser);
          });
        }
        var pending = [];
        for (var i = 0, il = primitives.length; i < il; i++) {
          var primitive = primitives[i];
          var cacheKey = createPrimitiveKey(primitive);

          // See if we've already created this geometry
          var cached = cache[cacheKey];
          if (cached) {
            // Use the cached geometry if it exists
            pending.push(cached.promise);
          } else {
            var geometryPromise = void 0;
            if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
              // Use DRACO geometry if available
              geometryPromise = createDracoPrimitive(primitive);
            } else {
              // Otherwise create a new geometry
              geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
            }

            // Cache this geometry
            cache[cacheKey] = {
              primitive: primitive,
              promise: geometryPromise
            };
            pending.push(geometryPromise);
          }
        }
        return Promise.all(pending);
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
       * @param {number} meshIndex
       * @return {Promise<Group|Mesh|SkinnedMesh>}
       */
    }, {
      key: "loadMesh",
      value: function loadMesh(meshIndex) {
        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        var meshDef = json.meshes[meshIndex];
        var primitives = meshDef.primitives;
        var pending = [];
        for (var i = 0, il = primitives.length; i < il; i++) {
          var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
          pending.push(material);
        }
        pending.push(parser.loadGeometries(primitives));
        return Promise.all(pending).then(function (results) {
          var materials = results.slice(0, results.length - 1);
          var geometries = results[results.length - 1];
          var meshes = [];
          for (var _i4 = 0, _il3 = geometries.length; _i4 < _il3; _i4++) {
            var geometry = geometries[_i4];
            var primitive = primitives[_i4];

            // 1. create Mesh

            var mesh = void 0;
            var _material = materials[_i4];
            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
              // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
              mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, _material) : new Mesh(geometry, _material);
              if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
                // we normalize floating point skin weight array to fix malformed assets (see #15319)
                // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
                mesh.normalizeSkinWeights();
              }
              if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
              } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
              }
            } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
              mesh = new LineSegments(geometry, _material);
            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
              mesh = new Line(geometry, _material);
            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
              mesh = new LineLoop(geometry, _material);
            } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
              mesh = new Points(geometry, _material);
            } else {
              throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
            }
            if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
              updateMorphTargets(mesh, meshDef);
            }
            mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);
            assignExtrasToUserData(mesh, meshDef);
            if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
            parser.assignFinalMaterial(mesh);
            meshes.push(mesh);
          }
          for (var _i5 = 0, _il4 = meshes.length; _i5 < _il4; _i5++) {
            parser.associations.set(meshes[_i5], {
              meshes: meshIndex,
              primitives: _i5
            });
          }
          if (meshes.length === 1) {
            return meshes[0];
          }
          var group = new Group$1();
          parser.associations.set(group, {
            meshes: meshIndex
          });
          for (var _i6 = 0, _il5 = meshes.length; _i6 < _il5; _i6++) {
            group.add(meshes[_i6]);
          }
          return group;
        });
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
       * @param {number} cameraIndex
       * @return {Promise<THREE.Camera>}
       */
    }, {
      key: "loadCamera",
      value: function loadCamera(cameraIndex) {
        var camera;
        var cameraDef = this.json.cameras[cameraIndex];
        var params = cameraDef[cameraDef.type];
        if (!params) {
          console.warn('THREE.GLTFLoader: Missing camera parameters.');
          return;
        }
        if (cameraDef.type === 'perspective') {
          camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
        } else if (cameraDef.type === 'orthographic') {
          camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
        }
        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
        assignExtrasToUserData(camera, cameraDef);
        return Promise.resolve(camera);
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
       * @param {number} skinIndex
       * @return {Promise<Object>}
       */
    }, {
      key: "loadSkin",
      value: function loadSkin(skinIndex) {
        var skinDef = this.json.skins[skinIndex];
        var skinEntry = {
          joints: skinDef.joints
        };
        if (skinDef.inverseBindMatrices === undefined) {
          return Promise.resolve(skinEntry);
        }
        return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
          skinEntry.inverseBindMatrices = accessor;
          return skinEntry;
        });
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
       * @param {number} animationIndex
       * @return {Promise<AnimationClip>}
       */
    }, {
      key: "loadAnimation",
      value: function loadAnimation(animationIndex) {
        var json = this.json;
        var animationDef = json.animations[animationIndex];
        var pendingNodes = [];
        var pendingInputAccessors = [];
        var pendingOutputAccessors = [];
        var pendingSamplers = [];
        var pendingTargets = [];
        for (var i = 0, il = animationDef.channels.length; i < il; i++) {
          var channel = animationDef.channels[i];
          var sampler = animationDef.samplers[channel.sampler];
          var target = channel.target;
          var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
          var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
          var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
          pendingNodes.push(this.getDependency('node', name));
          pendingInputAccessors.push(this.getDependency('accessor', input));
          pendingOutputAccessors.push(this.getDependency('accessor', output));
          pendingSamplers.push(sampler);
          pendingTargets.push(target);
        }
        return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
          var nodes = dependencies[0];
          var inputAccessors = dependencies[1];
          var outputAccessors = dependencies[2];
          var samplers = dependencies[3];
          var targets = dependencies[4];
          var tracks = [];
          var _loop = function _loop() {
            var node = nodes[_i7];
            var inputAccessor = inputAccessors[_i7];
            var outputAccessor = outputAccessors[_i7];
            var sampler = samplers[_i7];
            var target = targets[_i7];
            if (node === undefined) return "continue";
            node.updateMatrix();
            node.matrixAutoUpdate = true;
            var TypedKeyframeTrack;
            switch (PATH_PROPERTIES[target.path]) {
              case PATH_PROPERTIES.weights:
                TypedKeyframeTrack = NumberKeyframeTrack;
                break;
              case PATH_PROPERTIES.rotation:
                TypedKeyframeTrack = QuaternionKeyframeTrack;
                break;
              case PATH_PROPERTIES.position:
              case PATH_PROPERTIES.scale:
              default:
                TypedKeyframeTrack = VectorKeyframeTrack;
                break;
            }
            var targetName = node.name ? node.name : node.uuid;
            var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
            var targetNames = [];
            if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
              // Node may be a Group (glTF mesh with several primitives) or a Mesh.
              node.traverse(function (object) {
                if (object.isMesh === true && object.morphTargetInfluences) {
                  targetNames.push(object.name ? object.name : object.uuid);
                }
              });
            } else {
              targetNames.push(targetName);
            }
            var outputArray = outputAccessor.array;
            if (outputAccessor.normalized) {
              var scale = getNormalizedComponentScale(outputArray.constructor);
              var scaled = new Float32Array(outputArray.length);
              for (var j = 0, jl = outputArray.length; j < jl; j++) {
                scaled[j] = outputArray[j] * scale;
              }
              outputArray = scaled;
            }
            for (var _j = 0, _jl = targetNames.length; _j < _jl; _j++) {
              var track = new TypedKeyframeTrack(targetNames[_j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);

              // Override interpolation with custom factory method.
              if (sampler.interpolation === 'CUBICSPLINE') {
                track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                  // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                  // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                  // must be divided by three to get the interpolant's sampleSize argument.

                  var interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                  return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
                };

                // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
                track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
              }
              tracks.push(track);
            }
          };
          for (var _i7 = 0, _il6 = nodes.length; _i7 < _il6; _i7++) {
            var _ret = _loop();
            if (_ret === "continue") continue;
          }
          var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
          return new AnimationClip(name, undefined, tracks);
        });
      }
    }, {
      key: "createNodeMesh",
      value: function createNodeMesh(nodeIndex) {
        var json = this.json;
        var parser = this;
        var nodeDef = json.nodes[nodeIndex];
        if (nodeDef.mesh === undefined) return null;
        return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
          var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);

          // if weights are provided on the node, override weights on the mesh.
          if (nodeDef.weights !== undefined) {
            node.traverse(function (o) {
              if (!o.isMesh) return;
              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
                o.morphTargetInfluences[i] = nodeDef.weights[i];
              }
            });
          }
          return node;
        });
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
       * @param {number} nodeIndex
       * @return {Promise<Object3D>}
       */
    }, {
      key: "loadNode",
      value: function loadNode(nodeIndex) {
        var json = this.json;
        var extensions = this.extensions;
        var parser = this;
        var nodeDef = json.nodes[nodeIndex];

        // reserve node's name before its dependencies, so the root has the intended name.
        var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';
        return function () {
          var pending = [];
          var meshPromise = parser._invokeOne(function (ext) {
            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
          });
          if (meshPromise) {
            pending.push(meshPromise);
          }
          if (nodeDef.camera !== undefined) {
            pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {
              return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
            }));
          }
          parser._invokeAll(function (ext) {
            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
          }).forEach(function (promise) {
            pending.push(promise);
          });
          return Promise.all(pending);
        }().then(function (objects) {
          var node;

          // .isBone isn't in glTF spec. See ._markDefs
          if (nodeDef.isBone === true) {
            node = new Bone();
          } else if (objects.length > 1) {
            node = new Group$1();
          } else if (objects.length === 1) {
            node = objects[0];
          } else {
            node = new Object3D$1();
          }
          if (node !== objects[0]) {
            for (var i = 0, il = objects.length; i < il; i++) {
              node.add(objects[i]);
            }
          }
          if (nodeDef.name) {
            node.userData.name = nodeDef.name;
            node.name = nodeName;
          }
          assignExtrasToUserData(node, nodeDef);
          if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
          if (nodeDef.matrix !== undefined) {
            var matrix = new Matrix4$1();
            matrix.fromArray(nodeDef.matrix);
            node.applyMatrix4(matrix);
          } else {
            if (nodeDef.translation !== undefined) {
              node.position.fromArray(nodeDef.translation);
            }
            if (nodeDef.rotation !== undefined) {
              node.quaternion.fromArray(nodeDef.rotation);
            }
            if (nodeDef.scale !== undefined) {
              node.scale.fromArray(nodeDef.scale);
            }
          }
          if (!parser.associations.has(node)) {
            parser.associations.set(node, {});
          }
          parser.associations.get(node).nodes = nodeIndex;
          return node;
        });
      }

      /**
       * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
       * @param {number} sceneIndex
       * @return {Promise<Group>}
       */
    }, {
      key: "loadScene",
      value: function loadScene(sceneIndex) {
        var json = this.json;
        var extensions = this.extensions;
        var sceneDef = this.json.scenes[sceneIndex];
        var parser = this;

        // Loader returns Group, not Scene.
        // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
        var scene = new Group$1();
        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
        assignExtrasToUserData(scene, sceneDef);
        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
        var nodeIds = sceneDef.nodes || [];
        var pending = [];
        for (var i = 0, il = nodeIds.length; i < il; i++) {
          pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));
        }
        return Promise.all(pending).then(function () {
          // Removes dangling associations, associations that reference a node that
          // didn't make it into the scene.
          var reduceAssociations = function reduceAssociations(node) {
            var reducedAssociations = new Map();
            var _iterator2 = _createForOfIteratorHelper(parser.associations),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _step2$value = _slicedToArray(_step2.value, 2),
                  key = _step2$value[0],
                  value = _step2$value[1];
                if (key instanceof Material$1 || key instanceof Texture) {
                  reducedAssociations.set(key, value);
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            node.traverse(function (node) {
              var mappings = parser.associations.get(node);
              if (mappings != null) {
                reducedAssociations.set(node, mappings);
              }
            });
            return reducedAssociations;
          };
          parser.associations = reduceAssociations(scene);
          return scene;
        });
      }
    }]);
    return GLTFParser;
  }();
  function buildNodeHierarchy(nodeId, parentObject, json, parser) {
    var nodeDef = json.nodes[nodeId];
    return parser.getDependency('node', nodeId).then(function (node) {
      if (nodeDef.skin === undefined) return node;

      // build skeleton here as well

      var skinEntry;
      return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
        skinEntry = skin;
        var pendingJoints = [];
        for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
          pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
        }
        return Promise.all(pendingJoints);
      }).then(function (jointNodes) {
        node.traverse(function (mesh) {
          if (!mesh.isMesh) return;
          var bones = [];
          var boneInverses = [];
          for (var j = 0, jl = jointNodes.length; j < jl; j++) {
            var jointNode = jointNodes[j];
            if (jointNode) {
              bones.push(jointNode);
              var mat = new Matrix4$1();
              if (skinEntry.inverseBindMatrices !== undefined) {
                mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
              }
              boneInverses.push(mat);
            } else {
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
            }
          }
          mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
        });
        return node;
      });
    }).then(function (node) {
      // build node hierachy

      parentObject.add(node);
      var pending = [];
      if (nodeDef.children) {
        var children = nodeDef.children;
        for (var i = 0, il = children.length; i < il; i++) {
          var child = children[i];
          pending.push(buildNodeHierarchy(child, node, json, parser));
        }
      }
      return Promise.all(pending);
    });
  }

  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   */
  function computeBounds(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var box = new Box3();
    if (attributes.POSITION !== undefined) {
      var accessor = parser.json.accessors[attributes.POSITION];
      var min = accessor.min;
      var max = accessor.max;

      // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

      if (min !== undefined && max !== undefined) {
        box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
        if (accessor.normalized) {
          var boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
          box.min.multiplyScalar(boxScale);
          box.max.multiplyScalar(boxScale);
        }
      } else {
        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
        return;
      }
    } else {
      return;
    }
    var targets = primitiveDef.targets;
    if (targets !== undefined) {
      var maxDisplacement = new Vector3();
      var vector = new Vector3();
      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];
        if (target.POSITION !== undefined) {
          var _accessor = parser.json.accessors[target.POSITION];
          var _min = _accessor.min;
          var _max = _accessor.max;

          // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

          if (_min !== undefined && _max !== undefined) {
            // we need to get max of absolute components because target weight is [-1,1]
            vector.setX(Math.max(Math.abs(_min[0]), Math.abs(_max[0])));
            vector.setY(Math.max(Math.abs(_min[1]), Math.abs(_max[1])));
            vector.setZ(Math.max(Math.abs(_min[2]), Math.abs(_max[2])));
            if (_accessor.normalized) {
              var _boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[_accessor.componentType]);
              vector.multiplyScalar(_boxScale);
            }

            // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
            // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
            // are used to implement key-frame animations and as such only two are active at a time - this results in very large
            // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
            maxDisplacement.max(vector);
          } else {
            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
          }
        }
      }

      // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
      box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    var sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }

  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */
  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }
    for (var gltfAttributeName in attributes) {
      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();

      // Skip attributes already provided by e.g. Draco extension.
      if (threeAttributeName in geometry.attributes) continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== undefined && !geometry.index) {
      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
        geometry.setIndex(accessor);
      });
      pending.push(accessor);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function () {
      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }

  /**
   * @param {BufferGeometry} geometry
   * @param {Number} drawMode
   * @return {BufferGeometry}
   */
  function toTrianglesDrawMode(geometry, drawMode) {
    var index = geometry.getIndex();

    // generate index if not present

    if (index === null) {
      var indices = [];
      var position = geometry.getAttribute('position');
      if (position !== undefined) {
        for (var i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
        return geometry;
      }
    }

    //

    var numberOfTriangles = index.count - 2;
    var newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      // gl.TRIANGLE_FAN

      for (var _i8 = 1; _i8 <= numberOfTriangles; _i8++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(_i8));
        newIndices.push(index.getX(_i8 + 1));
      }
    } else {
      // gl.TRIANGLE_STRIP

      for (var _i9 = 0; _i9 < numberOfTriangles; _i9++) {
        if (_i9 % 2 === 0) {
          newIndices.push(index.getX(_i9));
          newIndices.push(index.getX(_i9 + 1));
          newIndices.push(index.getX(_i9 + 2));
        } else {
          newIndices.push(index.getX(_i9 + 2));
          newIndices.push(index.getX(_i9 + 1));
          newIndices.push(index.getX(_i9));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
    }

    // build final geometry

    var newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }

  /*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.6.9
  */

  // DEFLATE is a complex format; to read this code, you should probably check the RFC first:
  // https://tools.ietf.org/html/rfc1951
  // You may also wish to take a look at the guide I made about this program:
  // https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
  // Some of the following code is similar to that of UZIP.js:
  // https://github.com/photopea/UZIP.js
  // However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
  // Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
  // is better for memory in most engines (I *think*).
  var ch2 = {};
  var durl = function durl(c) {
    return URL.createObjectURL(new Blob([c], {
      type: 'text/javascript'
    }));
  };
  var cwk = function cwk(u) {
    return new Worker(u);
  };
  try {
    URL.revokeObjectURL(durl(''));
  } catch (e) {
    // We're in Deno or a very old browser
    durl = function durl(c) {
      return 'data:application/javascript;charset=UTF-8,' + encodeURI(c);
    };
    // If Deno, this is necessary; if not, this changes nothing
    cwk = function cwk(u) {
      return new Worker(u, {
        type: 'module'
      });
    };
  }
  var wk = function wk(c, id, msg, transfer, cb) {
    var w = cwk(ch2[id] || (ch2[id] = durl(c)));
    w.onerror = function (e) {
      return cb(e.error, null);
    };
    w.onmessage = function (e) {
      return cb(null, e.data);
    };
    w.postMessage(msg, transfer);
    return w;
  };

  // aliases for shorter compressed code (most minifers don't do this)
  var u8 = Uint8Array,
    u16 = Uint16Array,
    u32 = Uint32Array;
  // fixed length extra bits
  var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */0, 0, /* impossible */0]);
  // fixed distance extra bits
  // see fleb note
  var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */0, 0]);
  // code length index map
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  // get base, reverse index map from extra bits
  var freb = function freb(eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new u32(b[30]);
    for (var i = 1; i < 30; ++i) {
      for (var j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return [b, r];
  };
  var _a = freb(fleb, 2),
    fl = _a[0],
    revfl = _a[1];
  // we can ignore the fact that the other numbers are wrong; they never happen anyway
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0),
    fd = _b[0],
    revfd = _b[1];
  // map of value to reverse (assuming 16 bits)
  var rev = new u16(32768);
  for (var i$1 = 0; i$1 < 32768; ++i$1) {
    // reverse table algorithm from SO
    var x = (i$1 & 0xAAAA) >>> 1 | (i$1 & 0x5555) << 1;
    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;
    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;
    rev[i$1] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;
  }
  // create huffman tree from u8 "map": index -> code length for code index
  // mb (max bits) must be at most 15
  // TODO: optimize/split up?
  var hMap = function hMap(cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i) ++l[cd[i] - 1];
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 0; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
      // u16 "map": index -> number of actual bits, symbol for code
      co = new u16(1 << mb);
      // bits to remove for reverser
      var rvb = 15 - mb;
      for (i = 0; i < s; ++i) {
        // ignore 0 lengths
        if (cd[i]) {
          // num encoding both symbol and bits read
          var sv = i << 4 | cd[i];
          // free bits
          var r_1 = mb - cd[i];
          // start value
          var v = le[cd[i] - 1]++ << r_1;
          // m is end value
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            // every 16 bit value starting with the code yields the same result
            co[rev[v] >>> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
        }
      }
    }
    return co;
  };
  // fixed length tree
  var flt = new u8(288);
  for (var i$1 = 0; i$1 < 144; ++i$1) flt[i$1] = 8;
  for (var i$1 = 144; i$1 < 256; ++i$1) flt[i$1] = 9;
  for (var i$1 = 256; i$1 < 280; ++i$1) flt[i$1] = 7;
  for (var i$1 = 280; i$1 < 288; ++i$1) flt[i$1] = 8;
  // fixed distance tree
  var fdt = new u8(32);
  for (var i$1 = 0; i$1 < 32; ++i$1) fdt[i$1] = 5;
  // fixed length map
  var flm = /*#__PURE__*/hMap(flt, 9, 0),
    flrm = /*#__PURE__*/hMap(flt, 9, 1);
  // fixed distance map
  var fdm = /*#__PURE__*/hMap(fdt, 5, 0),
    fdrm = /*#__PURE__*/hMap(fdt, 5, 1);
  // find max of array
  var max = function max(a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
      if (a[i] > m) m = a[i];
    }
    return m;
  };
  // read d, starting at bit p and mask with m
  var bits = function bits(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  // read d, starting at bit p continuing for at least 16 bits
  var bits16 = function bits16(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  // get end of byte
  var shft = function shft(p) {
    return (p / 8 | 0) + (p & 7 && 1);
  };
  // typed array slice - allows garbage collector to free original reference,
  // while being more compatible than .slice
  var slc = function slc(v, s, e) {
    if (s == null || s < 0) s = 0;
    if (e == null || e > v.length) e = v.length;
    // can't use .constructor in case user-supplied
    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
  };
  // expands raw DEFLATE data
  var inflt = function inflt(dat, buf, st) {
    // source length
    var sl = dat.length;
    if (!sl || st && !st.l && sl < 5) return buf || new u8(0);
    // have to estimate size
    var noBuf = !buf || st;
    // no state
    var noSt = !st || st.i;
    if (!st) st = {};
    // Assumes roughly 33% compression ratio average
    if (!buf) buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function cbuf(l) {
      var bl = buf.length;
      // need to increase size to fit
      if (l > bl) {
        // Double or set to necessary, whichever is greater
        var nbuf = new u8(Math.max(bl * 2, l));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    //  last chunk         bitpos           bytes
    var _final = st.f || 0,
      pos = st.p || 0,
      bt = st.b || 0,
      lm = st.l,
      dm = st.d,
      lbt = st.m,
      dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
      if (!lm) {
        // BFINAL - this is only 1 when last chunk is next
        st.f = _final = bits(dat, pos, 1);
        // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          // go to end of byte boundary
          var s = shft(pos) + 4,
            l = dat[s - 4] | dat[s - 3] << 8,
            t = s + l;
          if (t > sl) {
            if (noSt) throw 'unexpected EOF';
            break;
          }
          // ensure size
          if (noBuf) cbuf(bt + l);
          // Copy over uncompressed data
          buf.set(dat.subarray(s, t), bt);
          // Get new bitpos, update byte count
          st.b = bt += l, st.p = pos = t * 8;
          continue;
        } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {
          //  literal                            lengths
          var hLit = bits(dat, pos, 31) + 257,
            hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          // length+distance tree
          var ldt = new u8(tl);
          // code length tree
          var clt = new u8(19);
          for (var i = 0; i < hcLen; ++i) {
            // use index map to get real code
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }
          pos += hcLen * 3;
          // code lengths bits
          var clb = max(clt),
            clbmsk = (1 << clb) - 1;
          // code lengths map
          var clm = hMap(clt, clb, 1);
          for (var i = 0; i < tl;) {
            var r = clm[bits(dat, pos, clbmsk)];
            // bits read
            pos += r & 15;
            // symbol
            var s = r >>> 4;
            // code length to copy
            if (s < 16) {
              ldt[i++] = s;
            } else {
              //  copy   count
              var c = 0,
                n = 0;
              if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--) ldt[i++] = c;
            }
          }
          //    length tree                 distance tree
          var lt = ldt.subarray(0, hLit),
            dt = ldt.subarray(hLit);
          // max length bits
          lbt = max(lt);
          // max dist bits
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else throw 'invalid block type';
        if (pos > tbts) {
          if (noSt) throw 'unexpected EOF';
          break;
        }
      }
      // Make sure the buffer can hold this + the largest possible addition
      // Maximum chunk size (practically, theoretically infinite) is 2^17;
      if (noBuf) cbuf(bt + 131072);
      var lms = (1 << lbt) - 1,
        dms = (1 << dbt) - 1;
      var lpos = pos;
      for (;; lpos = pos) {
        // bits read, code
        var c = lm[bits16(dat, pos) & lms],
          sym = c >>> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt) throw 'unexpected EOF';
          break;
        }
        if (!c) throw 'invalid length/literal';
        if (sym < 256) buf[bt++] = sym;else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          // no extra bits needed if less
          if (sym > 264) {
            // index
            var i = sym - 257,
              b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          }
          // dist
          var d = dm[bits16(dat, pos) & dms],
            dsym = d >>> 4;
          if (!d) throw 'invalid distance';
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt) throw 'unexpected EOF';
            break;
          }
          if (noBuf) cbuf(bt + 131072);
          var end = bt + add;
          for (; bt < end; bt += 4) {
            buf[bt] = buf[bt - dt];
            buf[bt + 1] = buf[bt + 1 - dt];
            buf[bt + 2] = buf[bt + 2 - dt];
            buf[bt + 3] = buf[bt + 3 - dt];
          }
          bt = end;
        }
      }
      st.l = lm, st.p = lpos, st.b = bt;
      if (lm) _final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!_final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
  };
  // starting at p, write the minimum number of bits that can hold v to d
  var wbits = function wbits(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >>> 8;
  };
  // starting at p, write the minimum number of bits (>8) that can hold v to d
  var wbits16 = function wbits16(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >>> 8;
    d[o + 2] |= v >>> 16;
  };
  // creates code lengths from a frequency table
  var hTree = function hTree(d, mb) {
    // Need extra info to make a tree
    var t = [];
    for (var i = 0; i < d.length; ++i) {
      if (d[i]) t.push({
        s: i,
        f: d[i]
      });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s) return [et, 0];
    if (s == 1) {
      var v = new u8(t[0].s + 1);
      v[t[0].s] = 1;
      return [v, 1];
    }
    t.sort(function (a, b) {
      return a.f - b.f;
    });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({
      s: -1,
      f: 25001
    });
    var l = t[0],
      r = t[1],
      i0 = 0,
      i1 = 1,
      i2 = 2;
    t[0] = {
      s: -1,
      f: l.f + r.f,
      l: l,
      r: r
    };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while (i1 != s - 1) {
      l = t[t[i0].f < t[i2].f ? i0++ : i2++];
      r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
      t[i1++] = {
        s: -1,
        f: l.f + r.f,
        l: l,
        r: r
      };
    }
    var maxSym = t2[0].s;
    for (var i = 1; i < s; ++i) {
      if (t2[i].s > maxSym) maxSym = t2[i].s;
    }
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
      // more algorithms from UZIP.js
      // TODO: find out how this code works (debt)
      //  ind    debt
      var i = 0,
        dt = 0;
      //    left            cost
      var lft = mbt - mb,
        cst = 1 << lft;
      t2.sort(function (a, b) {
        return tr[b.s] - tr[a.s] || a.f - b.f;
      });
      for (; i < s; ++i) {
        var i2_1 = t2[i].s;
        if (tr[i2_1] > mb) {
          dt += cst - (1 << mbt - tr[i2_1]);
          tr[i2_1] = mb;
        } else break;
      }
      dt >>>= lft;
      while (dt > 0) {
        var i2_2 = t2[i].s;
        if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;else ++i;
      }
      for (; i >= 0 && dt; --i) {
        var i2_3 = t2[i].s;
        if (tr[i2_3] == mb) {
          --tr[i2_3];
          ++dt;
        }
      }
      mbt = mb;
    }
    return [new u8(tr), mbt];
  };
  // get the max length and assign length codes
  var ln = function ln(n, l, d) {
    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
  };
  // length codes generation
  var lc = function lc(c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while (s && !c[--s]);
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0,
      cln = c[0],
      cls = 1;
    var w = function w(v) {
      cl[cli++] = v;
    };
    for (var i = 1; i <= s; ++i) {
      if (c[i] == cln && i != s) ++cls;else {
        if (!cln && cls > 2) {
          for (; cls > 138; cls -= 138) w(32754);
          if (cls > 2) {
            w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
            cls = 0;
          }
        } else if (cls > 3) {
          w(cln), --cls;
          for (; cls > 6; cls -= 6) w(8304);
          if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
        }
        while (cls--) w(cln);
        cls = 1;
        cln = c[i];
      }
    }
    return [cl.subarray(0, cli), s];
  };
  // calculate the length of output from tree, code lengths
  var clen = function clen(cf, cl) {
    var l = 0;
    for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];
    return l;
  };
  // writes a fixed block
  // returns the new bit pos
  var wfblk = function wfblk(out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >>> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
  };
  // writes a block
  var wblk = function wblk(dat, out, _final2, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, _final2);
    ++lf[256];
    var _a = hTree(lf, 15),
      dlt = _a[0],
      mlb = _a[1];
    var _b = hTree(df, 15),
      ddt = _b[0],
      mdb = _b[1];
    var _c = lc(dlt),
      lclt = _c[0],
      nlc = _c[1];
    var _d = lc(ddt),
      lcdt = _d[0],
      ndc = _d[1];
    var lcfreq = new u16(19);
    for (var i = 0; i < lclt.length; ++i) lcfreq[lclt[i] & 31]++;
    for (var i = 0; i < lcdt.length; ++i) lcfreq[lcdt[i] & 31]++;
    var _e = hTree(lcfreq, 7),
      lct = _e[0],
      mlcb = _e[1];
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
    if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
      lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
      var llm = hMap(lct, mlcb, 0);
      wbits(out, p, nlc - 257);
      wbits(out, p + 5, ndc - 1);
      wbits(out, p + 10, nlcc - 4);
      p += 14;
      for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);
      p += 3 * nlcc;
      var lcts = [lclt, lcdt];
      for (var it = 0; it < 2; ++it) {
        var clct = lcts[it];
        for (var i = 0; i < clct.length; ++i) {
          var len = clct[i] & 31;
          wbits(out, p, llm[len]), p += lct[len];
          if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;
        }
      }
    } else {
      lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i = 0; i < li; ++i) {
      if (syms[i] > 255) {
        var len = syms[i] >>> 18 & 31;
        wbits16(out, p, lm[len + 257]), p += ll[len + 257];
        if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];
        var dst = syms[i] & 31;
        wbits16(out, p, dm[dst]), p += dl[dst];
        if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];
      } else {
        wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
      }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
  };
  // deflate options (nice << 13) | chain
  var deo = /*#__PURE__*/new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  // empty
  var et = /*#__PURE__*/new u8(0);
  // compresses data into a raw DEFLATE buffer
  var dflt = function dflt(dat, lvl, plvl, pre, post, lst) {
    var s = dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var pos = 0;
    if (!lvl || s < 8) {
      for (var i = 0; i <= s; i += 65535) {
        // end
        var e = i + 65535;
        if (e < s) {
          // write full block
          pos = wfblk(w, pos, dat.subarray(i, e));
        } else {
          // write final block
          w[i] = lst;
          pos = wfblk(w, pos, dat.subarray(i, s));
        }
      }
    } else {
      var opt = deo[lvl - 1];
      var n = opt >>> 13,
        c = opt & 8191;
      var msk_1 = (1 << plvl) - 1;
      //    prev 2-byte val map    curr 2-byte val map
      var prev = new u16(32768),
        head = new u16(msk_1 + 1);
      var bs1_1 = Math.ceil(plvl / 3),
        bs2_1 = 2 * bs1_1;
      var hsh = function hsh(i) {
        return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
      };
      // 24576 is an arbitrary number of maximum symbols per block
      // 424 buffer for last block
      var syms = new u32(25000);
      // length/literal freq   distance freq
      var lf = new u16(288),
        df = new u16(32);
      //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
      var lc_1 = 0,
        eb = 0,
        i = 0,
        li = 0,
        wi = 0,
        bs = 0;
      for (; i < s; ++i) {
        // hash value
        // deopt when i > s - 3 - at end, deopt acceptable
        var hv = hsh(i);
        // index mod 32768    previous index mod
        var imod = i & 32767,
          pimod = head[hv];
        prev[imod] = pimod;
        head[hv] = imod;
        // We always should modify head and prev, but only add symbols if
        // this data is not yet processed ("wait" for wait index)
        if (wi <= i) {
          // bytes remaining
          var rem = s - i;
          if ((lc_1 > 7000 || li > 24576) && rem > 423) {
            pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
            li = lc_1 = eb = 0, bs = i;
            for (var j = 0; j < 286; ++j) lf[j] = 0;
            for (var j = 0; j < 30; ++j) df[j] = 0;
          }
          //  len    dist   chain
          var l = 2,
            d = 0,
            ch_1 = c,
            dif = imod - pimod & 32767;
          if (rem > 2 && hv == hsh(i - dif)) {
            var maxn = Math.min(n, rem) - 1;
            var maxd = Math.min(32767, i);
            // max possible length
            // not capped at dif because decompressors implement "rolling" index population
            var ml = Math.min(258, rem);
            while (dif <= maxd && --ch_1 && imod != pimod) {
              if (dat[i + l] == dat[i + l - dif]) {
                var nl = 0;
                for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
                if (nl > l) {
                  l = nl, d = dif;
                  // break out early when we reach "nice" (we are satisfied enough)
                  if (nl > maxn) break;
                  // now, find the rarest 2-byte sequence within this
                  // length of literals and search for that instead.
                  // Much faster than just using the start
                  var mmd = Math.min(dif, nl - 2);
                  var md = 0;
                  for (var j = 0; j < mmd; ++j) {
                    var ti = i - dif + j + 32768 & 32767;
                    var pti = prev[ti];
                    var cd = ti - pti + 32768 & 32767;
                    if (cd > md) md = cd, pimod = ti;
                  }
                }
              }
              // check the previous match
              imod = pimod, pimod = prev[imod];
              dif += imod - pimod + 32768 & 32767;
            }
          }
          // d will be nonzero only when a match was found
          if (d) {
            // store both dist and len data in one Uint32
            // Make sure this is recognized as a len/dist with 28th bit (2^28)
            syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
            var lin = revfl[l] & 31,
              din = revfd[d] & 31;
            eb += fleb[lin] + fdeb[din];
            ++lf[257 + lin];
            ++df[din];
            wi = i + l;
            ++lc_1;
          } else {
            syms[li++] = dat[i];
            ++lf[dat[i]];
          }
        }
      }
      pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
      // this is the easiest way to avoid needing to maintain state
      if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);
    }
    return slc(o, 0, pre + shft(pos) + post);
  };
  // CRC32 table
  var crct = /*#__PURE__*/function () {
    var t = new u32(256);
    for (var i = 0; i < 256; ++i) {
      var c = i,
        k = 9;
      while (--k) c = (c & 1 && 0xEDB88320) ^ c >>> 1;
      t[i] = c;
    }
    return t;
  }();
  // CRC32
  var crc = function crc() {
    var c = -1;
    return {
      p: function p(d) {
        // closures have awful performance
        var cr = c;
        for (var i = 0; i < d.length; ++i) cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
        c = cr;
      },
      d: function d() {
        return ~c;
      }
    };
  };
  // Alder32
  var adler = function adler() {
    var a = 1,
      b = 0;
    return {
      p: function p(d) {
        // closures have awful performance
        var n = a,
          m = b;
        var l = d.length;
        for (var i = 0; i != l;) {
          var e = Math.min(i + 2655, l);
          for (; i < e; ++i) m += n += d[i];
          n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
        }
        a = n, b = m;
      },
      d: function d() {
        a %= 65521, b %= 65521;
        return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;
      }
    };
  };
  // deflate with opts
  var dopt = function dopt(dat, opt, pre, post, st) {
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
  };
  // Walmart object spread
  var mrg = function mrg(a, b) {
    var o = {};
    for (var k in a) o[k] = a[k];
    for (var k in b) o[k] = b[k];
    return o;
  };
  // worker clone
  // This is possibly the craziest part of the entire codebase, despite how simple it may seem.
  // The only parameter to this function is a closure that returns an array of variables outside of the function scope.
  // We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
  // We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
  // The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
  // This took me three weeks to figure out how to do.
  var wcln = function wcln(fn, fnStr, td) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');
    for (var i = 0; i < dt.length; ++i) {
      var v = dt[i],
        k = ks[i];
      if (typeof v == 'function') {
        fnStr += ';' + k + '=';
        var st_1 = v.toString();
        if (v.prototype) {
          // for global objects
          if (st_1.indexOf('[native code]') != -1) {
            var spInd = st_1.indexOf(' ', 8) + 1;
            fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
          } else {
            fnStr += st_1;
            for (var t in v.prototype) fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
          }
        } else fnStr += st_1;
      } else td[k] = v;
    }
    return [fnStr, td];
  };
  var ch = [];
  // clone bufs
  var cbfs = function cbfs(v) {
    var tl = [];
    for (var k in v) {
      if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    }
    return tl;
  };
  // use a worker to execute code
  var wrkr = function wrkr(fns, init, id, cb) {
    var _a;
    if (!ch[id]) {
      var fnStr = '',
        td_1 = {},
        m = fns.length - 1;
      for (var i = 0; i < m; ++i) _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];
      ch[id] = wcln(fns[m], fnStr, td_1);
    }
    var td = mrg({}, ch[id][1]);
    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
  };
  // base async inflate fn
  var bInflt = function bInflt() {
    return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8];
  };
  var bDflt = function bDflt() {
    return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
  };
  // gzip extra
  var gze = function gze() {
    return [gzh, gzhl, wbytes, crc, crct];
  };
  // gunzip extra
  var guze = function guze() {
    return [gzs, gzl];
  };
  // zlib extra
  var zle = function zle() {
    return [zlh, wbytes, adler];
  };
  // unzlib extra
  var zule = function zule() {
    return [zlv];
  };
  // post buf
  var pbf = function pbf(msg) {
    return postMessage(msg, [msg.buffer]);
  };
  // get u8
  var gu8 = function gu8(o) {
    return o && o.size && new u8(o.size);
  };
  // async helper
  var cbify = function cbify(dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function (err, dat) {
      w.terminate();
      cb(err, dat);
    });
    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
    return function () {
      w.terminate();
    };
  };
  // auto stream
  var astrm = function astrm(strm) {
    strm.ondata = function (dat, _final3) {
      return postMessage([dat, _final3], [dat.buffer]);
    };
    return function (ev) {
      return strm.push(ev.data[0], ev.data[1]);
    };
  };
  // async stream attach
  var astrmify = function astrmify(fns, strm, opts, init, id) {
    var t;
    var w = wrkr(fns, init, id, function (err, dat) {
      if (err) w.terminate(), strm.ondata.call(strm, err);else {
        if (dat[1]) w.terminate();
        strm.ondata.call(strm, err, dat[0], dat[1]);
      }
    });
    w.postMessage(opts);
    strm.push = function (d, f) {
      if (t) throw 'stream finished';
      if (!strm.ondata) throw 'no stream handler';
      w.postMessage([d, t = f], [d.buffer]);
    };
    strm.terminate = function () {
      w.terminate();
    };
  };
  // read 2 bytes
  var b2 = function b2(d, b) {
    return d[b] | d[b + 1] << 8;
  };
  // read 4 bytes
  var b4 = function b4(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
  };
  var b8 = function b8(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
  };
  // write bytes
  var wbytes = function wbytes(d, b, v) {
    for (; v; ++b) d[b] = v, v >>>= 8;
  };
  // gzip header
  var gzh = function gzh(c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix
    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));
    if (fn) {
      c[3] = 8;
      for (var i = 0; i <= fn.length; ++i) c[i + 10] = fn.charCodeAt(i);
    }
  };
  // gzip footer: -8 to -4 = CRC, -4 to -0 is length
  // gzip start
  var gzs = function gzs(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw 'invalid gzip data';
    var flg = d[3];
    var st = 10;
    if (flg & 4) st += d[10] | (d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);
    return st + (flg & 2);
  };
  // gzip length
  var gzl = function gzl(d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
  };
  // gzip header length
  var gzhl = function gzhl(o) {
    return 10 + (o.filename && o.filename.length + 1 || 0);
  };
  // zlib header
  var zlh = function zlh(c, o) {
    var lv = o.level,
      fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);
  };
  // zlib valid
  var zlv = function zlv(d) {
    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';
    if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
  };
  function AsyncCmpStrm(opts, cb) {
    if (!cb && typeof opts == 'function') cb = opts, opts = {};
    this.ondata = cb;
    return opts;
  }
  // zlib footer: -4 to -0 is Adler32
  /**
   * Streaming DEFLATE compression
   */
  var Deflate = /*#__PURE__*/function () {
    function Deflate(opts, cb) {
      if (!cb && typeof opts == 'function') cb = opts, opts = {};
      this.ondata = cb;
      this.o = opts || {};
    }
    Deflate.prototype.p = function (c, f) {
      this.ondata(dopt(c, this.o, 0, 0, !f), f);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Deflate.prototype.push = function (chunk, _final4) {
      if (this.d) throw 'stream finished';
      if (!this.ondata) throw 'no stream handler';
      this.d = _final4;
      this.p(chunk, _final4 || false);
    };
    return Deflate;
  }();
  /**
   * Asynchronous streaming DEFLATE compression
   */
  var AsyncDeflate = /*#__PURE__*/function () {
    function AsyncDeflate(opts, cb) {
      astrmify([bDflt, function () {
        return [astrm, Deflate];
      }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
        var strm = new Deflate(ev.data);
        onmessage = astrm(strm);
      }, 6);
    }
    return AsyncDeflate;
  }();
  function deflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [bDflt], function (ev) {
      return pbf(deflateSync(ev.data[0], ev.data[1]));
    }, 0, cb);
  }
  /**
   * Compresses data with DEFLATE without any wrapper
   * @param data The data to compress
   * @param opts The compression options
   * @returns The deflated version of the data
   */
  function deflateSync(data, opts) {
    return dopt(data, opts || {}, 0, 0);
  }
  /**
   * Streaming DEFLATE decompression
   */
  var Inflate = /*#__PURE__*/function () {
    /**
     * Creates an inflation stream
     * @param cb The callback to call whenever data is inflated
     */
    function Inflate(cb) {
      this.s = {};
      this.p = new u8(0);
      this.ondata = cb;
    }
    Inflate.prototype.e = function (c) {
      if (this.d) throw 'stream finished';
      if (!this.ondata) throw 'no stream handler';
      var l = this.p.length;
      var n = new u8(l + c.length);
      n.set(this.p), n.set(c, l), this.p = n;
    };
    Inflate.prototype.c = function (_final5) {
      this.d = this.s.i = _final5 || false;
      var bts = this.s.b;
      var dt = inflt(this.p, this.o, this.s);
      this.ondata(slc(dt, bts, this.s.b), this.d);
      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    };
    /**
     * Pushes a chunk to be inflated
     * @param chunk The chunk to push
     * @param final Whether this is the final chunk
     */
    Inflate.prototype.push = function (chunk, _final6) {
      this.e(chunk), this.c(_final6);
    };
    return Inflate;
  }();
  /**
   * Asynchronous streaming DEFLATE decompression
   */
  var AsyncInflate = /*#__PURE__*/function () {
    /**
     * Creates an asynchronous inflation stream
     * @param cb The callback to call whenever data is deflated
     */
    function AsyncInflate(cb) {
      this.ondata = cb;
      astrmify([bInflt, function () {
        return [astrm, Inflate];
      }], this, 0, function () {
        var strm = new Inflate();
        onmessage = astrm(strm);
      }, 7);
    }
    return AsyncInflate;
  }();
  function inflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [bInflt], function (ev) {
      return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));
    }, 1, cb);
  }
  /**
   * Expands DEFLATE data with no wrapper
   * @param data The data to decompress
   * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
   * @returns The decompressed version of the data
   */
  function inflateSync(data, out) {
    return inflt(data, out);
  }
  // before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
  /**
   * Streaming GZIP compression
   */
  var Gzip = /*#__PURE__*/function () {
    function Gzip(opts, cb) {
      this.c = crc();
      this.l = 0;
      this.v = 1;
      Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Gzip.prototype.push = function (chunk, _final7) {
      Deflate.prototype.push.call(this, chunk, _final7);
    };
    Gzip.prototype.p = function (c, f) {
      this.c.p(c);
      this.l += c.length;
      var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
      if (this.v) gzh(raw, this.o), this.v = 0;
      if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
      this.ondata(raw, f);
    };
    return Gzip;
  }();
  /**
   * Asynchronous streaming GZIP compression
   */
  var AsyncGzip = /*#__PURE__*/function () {
    function AsyncGzip(opts, cb) {
      astrmify([bDflt, gze, function () {
        return [astrm, Deflate, Gzip];
      }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
        var strm = new Gzip(ev.data);
        onmessage = astrm(strm);
      }, 8);
    }
    return AsyncGzip;
  }();
  function gzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [bDflt, gze, function () {
      return [gzipSync];
    }], function (ev) {
      return pbf(gzipSync(ev.data[0], ev.data[1]));
    }, 2, cb);
  }
  /**
   * Compresses data with GZIP
   * @param data The data to compress
   * @param opts The compression options
   * @returns The gzipped version of the data
   */
  function gzipSync(data, opts) {
    if (!opts) opts = {};
    var c = crc(),
      l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8),
      s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
  }
  /**
   * Streaming GZIP decompression
   */
  var Gunzip = /*#__PURE__*/function () {
    /**
     * Creates a GUNZIP stream
     * @param cb The callback to call whenever data is inflated
     */
    function Gunzip(cb) {
      this.v = 1;
      Inflate.call(this, cb);
    }
    /**
     * Pushes a chunk to be GUNZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Gunzip.prototype.push = function (chunk, _final8) {
      Inflate.prototype.e.call(this, chunk);
      if (this.v) {
        var s = this.p.length > 3 ? gzs(this.p) : 4;
        if (s >= this.p.length && !_final8) return;
        this.p = this.p.subarray(s), this.v = 0;
      }
      if (_final8) {
        if (this.p.length < 8) throw 'invalid gzip stream';
        this.p = this.p.subarray(0, -8);
      }
      // necessary to prevent TS from using the closure value
      // This allows for workerization to function correctly
      Inflate.prototype.c.call(this, _final8);
    };
    return Gunzip;
  }();
  /**
   * Asynchronous streaming GZIP decompression
   */
  var AsyncGunzip = /*#__PURE__*/function () {
    /**
     * Creates an asynchronous GUNZIP stream
     * @param cb The callback to call whenever data is deflated
     */
    function AsyncGunzip(cb) {
      this.ondata = cb;
      astrmify([bInflt, guze, function () {
        return [astrm, Inflate, Gunzip];
      }], this, 0, function () {
        var strm = new Gunzip();
        onmessage = astrm(strm);
      }, 9);
    }
    return AsyncGunzip;
  }();
  function gunzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [bInflt, guze, function () {
      return [gunzipSync];
    }], function (ev) {
      return pbf(gunzipSync(ev.data[0]));
    }, 3, cb);
  }
  /**
   * Expands GZIP data
   * @param data The data to decompress
   * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.
   * @returns The decompressed version of the data
   */
  function gunzipSync(data, out) {
    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
  }
  /**
   * Streaming Zlib compression
   */
  var Zlib = /*#__PURE__*/function () {
    function Zlib(opts, cb) {
      this.c = adler();
      this.v = 1;
      Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be zlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Zlib.prototype.push = function (chunk, _final9) {
      Deflate.prototype.push.call(this, chunk, _final9);
    };
    Zlib.prototype.p = function (c, f) {
      this.c.p(c);
      var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
      if (this.v) zlh(raw, this.o), this.v = 0;
      if (f) wbytes(raw, raw.length - 4, this.c.d());
      this.ondata(raw, f);
    };
    return Zlib;
  }();
  /**
   * Asynchronous streaming Zlib compression
   */
  var AsyncZlib = /*#__PURE__*/function () {
    function AsyncZlib(opts, cb) {
      astrmify([bDflt, zle, function () {
        return [astrm, Deflate, Zlib];
      }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
        var strm = new Zlib(ev.data);
        onmessage = astrm(strm);
      }, 10);
    }
    return AsyncZlib;
  }();
  function zlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [bDflt, zle, function () {
      return [zlibSync];
    }], function (ev) {
      return pbf(zlibSync(ev.data[0], ev.data[1]));
    }, 4, cb);
  }
  /**
   * Compress data with Zlib
   * @param data The data to compress
   * @param opts The compression options
   * @returns The zlib-compressed version of the data
   */
  function zlibSync(data, opts) {
    if (!opts) opts = {};
    var a = adler();
    a.p(data);
    var d = dopt(data, opts, 2, 4);
    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
  }
  /**
   * Streaming Zlib decompression
   */
  var Unzlib = /*#__PURE__*/function () {
    /**
     * Creates a Zlib decompression stream
     * @param cb The callback to call whenever data is inflated
     */
    function Unzlib(cb) {
      this.v = 1;
      Inflate.call(this, cb);
    }
    /**
     * Pushes a chunk to be unzlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Unzlib.prototype.push = function (chunk, _final10) {
      Inflate.prototype.e.call(this, chunk);
      if (this.v) {
        if (this.p.length < 2 && !_final10) return;
        this.p = this.p.subarray(2), this.v = 0;
      }
      if (_final10) {
        if (this.p.length < 4) throw 'invalid zlib stream';
        this.p = this.p.subarray(0, -4);
      }
      // necessary to prevent TS from using the closure value
      // This allows for workerization to function correctly
      Inflate.prototype.c.call(this, _final10);
    };
    return Unzlib;
  }();
  /**
   * Asynchronous streaming Zlib decompression
   */
  var AsyncUnzlib = /*#__PURE__*/function () {
    /**
     * Creates an asynchronous Zlib decompression stream
     * @param cb The callback to call whenever data is deflated
     */
    function AsyncUnzlib(cb) {
      this.ondata = cb;
      astrmify([bInflt, zule, function () {
        return [astrm, Inflate, Unzlib];
      }], this, 0, function () {
        var strm = new Unzlib();
        onmessage = astrm(strm);
      }, 11);
    }
    return AsyncUnzlib;
  }();
  function unzlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [bInflt, zule, function () {
      return [unzlibSync];
    }], function (ev) {
      return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));
    }, 5, cb);
  }
  /**
   * Expands Zlib data
   * @param data The data to decompress
   * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
   * @returns The decompressed version of the data
   */
  function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
  }
  /**
   * Streaming GZIP, Zlib, or raw DEFLATE decompression
   */
  var Decompress = /*#__PURE__*/function () {
    /**
     * Creates a decompression stream
     * @param cb The callback to call whenever data is decompressed
     */
    function Decompress(cb) {
      this.G = Gunzip;
      this.I = Inflate;
      this.Z = Unzlib;
      this.ondata = cb;
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Decompress.prototype.push = function (chunk, _final11) {
      if (!this.ondata) throw 'no stream handler';
      if (!this.s) {
        if (this.p && this.p.length) {
          var n = new u8(this.p.length + chunk.length);
          n.set(this.p), n.set(chunk, this.p.length);
        } else this.p = chunk;
        if (this.p.length > 2) {
          var _this_1 = this;
          var cb = function cb() {
            _this_1.ondata.apply(_this_1, arguments);
          };
          this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
          this.s.push(this.p, _final11);
          this.p = null;
        }
      } else this.s.push(chunk, _final11);
    };
    return Decompress;
  }();
  /**
   * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
   */
  var AsyncDecompress = /*#__PURE__*/function () {
    /**
    * Creates an asynchronous decompression stream
    * @param cb The callback to call whenever data is decompressed
    */
    function AsyncDecompress(cb) {
      this.G = AsyncGunzip;
      this.I = AsyncInflate;
      this.Z = AsyncUnzlib;
      this.ondata = cb;
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    AsyncDecompress.prototype.push = function (chunk, _final12) {
      Decompress.prototype.push.call(this, chunk, _final12);
    };
    return AsyncDecompress;
  }();
  function decompress(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
  }
  /**
   * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
   * @param data The data to decompress
   * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
   * @returns The decompressed version of the data
   */
  function decompressSync(data, out) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);
  }
  // flatten a directory structure
  var fltn = function fltn(d, p, t, o) {
    for (var k in d) {
      var val = d[k],
        n = p + k;
      if (val instanceof u8) t[n] = [val, o];else if (Array.isArray(val)) t[n] = [val[0], mrg(o, val[1])];else fltn(val, n + '/', t, o);
    }
  };
  // text encoder
  var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/new TextEncoder();
  // text decoder
  var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/new TextDecoder();
  // text decoder stream
  var tds = 0;
  try {
    td.decode(et, {
      stream: true
    });
    tds = 1;
  } catch (e) {}
  // decode UTF8
  var dutf8 = function dutf8(d) {
    for (var r = '', i = 0;;) {
      var c = d[i++];
      var eb = (c > 127) + (c > 223) + (c > 239);
      if (i + eb > d.length) return [r, slc(d, i - 1)];
      if (!eb) r += String.fromCharCode(c);else if (eb == 3) {
        c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
      } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
    }
  };
  /**
   * Streaming UTF-8 decoding
   */
  var DecodeUTF8 = /*#__PURE__*/function () {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is decoded
     */
    function DecodeUTF8(cb) {
      this.ondata = cb;
      if (tds) this.t = new TextDecoder();else this.p = et;
    }
    /**
     * Pushes a chunk to be decoded from UTF-8 binary
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    DecodeUTF8.prototype.push = function (chunk, _final13) {
      if (!this.ondata) throw 'no callback';
      _final13 = !!_final13;
      if (this.t) {
        this.ondata(this.t.decode(chunk, {
          stream: true
        }), _final13);
        if (_final13) {
          if (this.t.decode().length) throw 'invalid utf-8 data';
          this.t = null;
        }
        return;
      }
      if (!this.p) throw 'stream finished';
      var dat = new u8(this.p.length + chunk.length);
      dat.set(this.p);
      dat.set(chunk, this.p.length);
      var _a = dutf8(dat),
        ch = _a[0],
        np = _a[1];
      if (_final13) {
        if (np.length) throw 'invalid utf-8 data';
        this.p = null;
      } else this.p = np;
      this.ondata(ch, _final13);
    };
    return DecodeUTF8;
  }();
  /**
   * Streaming UTF-8 encoding
   */
  var EncodeUTF8 = /*#__PURE__*/function () {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is encoded
     */
    function EncodeUTF8(cb) {
      this.ondata = cb;
    }
    /**
     * Pushes a chunk to be encoded to UTF-8
     * @param chunk The string data to push
     * @param final Whether this is the last chunk
     */
    EncodeUTF8.prototype.push = function (chunk, _final14) {
      if (!this.ondata) throw 'no callback';
      if (this.d) throw 'stream finished';
      this.ondata(strToU8(chunk), this.d = _final14 || false);
    };
    return EncodeUTF8;
  }();
  /**
   * Converts a string into a Uint8Array for use with compression/decompression methods
   * @param str The string to encode
   * @param latin1 Whether or not to interpret the data as Latin-1. This should
   *               not need to be true unless decoding a binary string.
   * @returns The string encoded in UTF-8/Latin-1 binary
   */
  function strToU8(str, latin1) {
    if (latin1) {
      var ar_1 = new u8(str.length);
      for (var i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);
      return ar_1;
    }
    if (te) return te.encode(str);
    var l = str.length;
    var ar = new u8(str.length + (str.length >> 1));
    var ai = 0;
    var w = function w(v) {
      ar[ai++] = v;
    };
    for (var i = 0; i < l; ++i) {
      if (ai + 5 > ar.length) {
        var n = new u8(ai + 8 + (l - i << 1));
        n.set(ar);
        ar = n;
      }
      var c = str.charCodeAt(i);
      if (c < 128 || latin1) w(c);else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
    }
    return slc(ar, 0, ai);
  }
  /**
   * Converts a Uint8Array to a string
   * @param dat The data to decode to string
   * @param latin1 Whether or not to interpret the data as Latin-1. This should
   *               not need to be true unless encoding to binary string.
   * @returns The original UTF-8/Latin-1 string
   */
  function strFromU8(dat, latin1) {
    if (latin1) {
      var r = '';
      for (var i = 0; i < dat.length; i += 16384) r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
      return r;
    } else if (td) return td.decode(dat);else {
      var _a = dutf8(dat),
        out = _a[0],
        ext = _a[1];
      if (ext.length) throw 'invalid utf-8 data';
      return out;
    }
  }
  // deflate bit flag
  var dbf = function dbf(l) {
    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
  };
  // skip local zip header
  var slzh = function slzh(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
  };
  // read zip header
  var zh = function zh(d, b, z) {
    var fnl = b2(d, b + 28),
      fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)),
      es = b + 46 + fnl,
      bs = b4(d, b + 20);
    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)],
      sc = _a[0],
      su = _a[1],
      off = _a[2];
    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
  };
  // read zip64 extra field
  var z64e = function z64e(d, b) {
    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2));
    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
  };
  // extra field length
  var exfl = function exfl(ex) {
    var le = 0;
    if (ex) {
      for (var k in ex) {
        var l = ex[k].length;
        if (l > 65535) throw 'extra field too long';
        le += l + 4;
      }
    }
    return le;
  };
  // write zip header
  var wzh = function wzh(d, b, f, fn, u, c, ce, co) {
    var fl = fn.length,
      ex = f.extra,
      col = co && co.length;
    var exl = exfl(ex);
    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
    if (ce != null) d[b++] = 20, d[b++] = f.os;
    d[b] = 20, b += 2; // spec compliance? what's that?
    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;
    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
    var dt = new Date(f.mtime == null ? Date.now() : f.mtime),
      y = dt.getFullYear() - 1980;
    if (y < 0 || y > 119) throw 'date not in range 1980-2099';
    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;
    if (c != null) {
      wbytes(d, b, f.crc);
      wbytes(d, b + 4, c);
      wbytes(d, b + 8, f.size);
    }
    wbytes(d, b + 12, fl);
    wbytes(d, b + 14, exl), b += 16;
    if (ce != null) {
      wbytes(d, b, col);
      wbytes(d, b + 6, f.attrs);
      wbytes(d, b + 10, ce), b += 14;
    }
    d.set(fn, b);
    b += fl;
    if (exl) {
      for (var k in ex) {
        var exf = ex[k],
          l = exf.length;
        wbytes(d, b, +k);
        wbytes(d, b + 2, l);
        d.set(exf, b + 4), b += 4 + l;
      }
    }
    if (col) d.set(co, b), b += col;
    return b;
  };
  // write zip footer (end of central directory)
  var wzf = function wzf(o, b, c, d, e) {
    wbytes(o, b, 0x6054B50); // skip disk
    wbytes(o, b + 8, c);
    wbytes(o, b + 10, c);
    wbytes(o, b + 12, d);
    wbytes(o, b + 16, e);
  };
  /**
   * A pass-through stream to keep data uncompressed in a ZIP archive.
   */
  var ZipPassThrough = /*#__PURE__*/function () {
    /**
     * Creates a pass-through stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     */
    function ZipPassThrough(filename) {
      this.filename = filename;
      this.c = crc();
      this.size = 0;
      this.compression = 0;
    }
    /**
     * Processes a chunk and pushes to the output stream. You can override this
     * method in a subclass for custom behavior, but by default this passes
     * the data through. You must call this.ondata(err, chunk, final) at some
     * point in this method.
     * @param chunk The chunk to process
     * @param final Whether this is the last chunk
     */
    ZipPassThrough.prototype.process = function (chunk, _final15) {
      this.ondata(null, chunk, _final15);
    };
    /**
     * Pushes a chunk to be added. If you are subclassing this with a custom
     * compression algorithm, note that you must push data from the source
     * file only, pre-compression.
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    ZipPassThrough.prototype.push = function (chunk, _final16) {
      if (!this.ondata) throw 'no callback - add to ZIP archive before pushing';
      this.c.p(chunk);
      this.size += chunk.length;
      if (_final16) this.crc = this.c.d();
      this.process(chunk, _final16 || false);
    };
    return ZipPassThrough;
  }();
  // I don't extend because TypeScript extension adds 1kB of runtime bloat
  /**
   * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
   * for better performance
   */
  var ZipDeflate = /*#__PURE__*/function () {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */
    function ZipDeflate(filename, opts) {
      var _this_1 = this;
      if (!opts) opts = {};
      ZipPassThrough.call(this, filename);
      this.d = new Deflate(opts, function (dat, _final17) {
        _this_1.ondata(null, dat, _final17);
      });
      this.compression = 8;
      this.flag = dbf(opts.level);
    }
    ZipDeflate.prototype.process = function (chunk, _final18) {
      try {
        this.d.push(chunk, _final18);
      } catch (e) {
        this.ondata(e, null, _final18);
      }
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    ZipDeflate.prototype.push = function (chunk, _final19) {
      ZipPassThrough.prototype.push.call(this, chunk, _final19);
    };
    return ZipDeflate;
  }();
  /**
   * Asynchronous streaming DEFLATE compression for ZIP archives
   */
  var AsyncZipDeflate = /*#__PURE__*/function () {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */
    function AsyncZipDeflate(filename, opts) {
      var _this_1 = this;
      if (!opts) opts = {};
      ZipPassThrough.call(this, filename);
      this.d = new AsyncDeflate(opts, function (err, dat, _final20) {
        _this_1.ondata(err, dat, _final20);
      });
      this.compression = 8;
      this.flag = dbf(opts.level);
      this.terminate = this.d.terminate;
    }
    AsyncZipDeflate.prototype.process = function (chunk, _final21) {
      this.d.push(chunk, _final21);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    AsyncZipDeflate.prototype.push = function (chunk, _final22) {
      ZipPassThrough.prototype.push.call(this, chunk, _final22);
    };
    return AsyncZipDeflate;
  }();
  // TODO: Better tree shaking
  /**
   * A zippable archive to which files can incrementally be added
   */
  var Zip = /*#__PURE__*/function () {
    /**
     * Creates an empty ZIP archive to which files can be added
     * @param cb The callback to call whenever data for the generated ZIP archive
     *           is available
     */
    function Zip(cb) {
      this.ondata = cb;
      this.u = [];
      this.d = 1;
    }
    /**
     * Adds a file to the ZIP archive
     * @param file The file stream to add
     */
    Zip.prototype.add = function (file) {
      var _this_1 = this;
      if (this.d & 2) throw 'stream finished';
      var f = strToU8(file.filename),
        fl = f.length;
      var com = file.comment,
        o = com && strToU8(com);
      var u = fl != file.filename.length || o && com.length != o.length;
      var hl = fl + exfl(file.extra) + 30;
      if (fl > 65535) throw 'filename too long';
      var header = new u8(hl);
      wzh(header, 0, file, f, u);
      var chks = [header];
      var pAll = function pAll() {
        for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
          var chk = chks_1[_i];
          _this_1.ondata(null, chk, false);
        }
        chks = [];
      };
      var tr = this.d;
      this.d = 0;
      var ind = this.u.length;
      var uf = mrg(file, {
        f: f,
        u: u,
        o: o,
        t: function t() {
          if (file.terminate) file.terminate();
        },
        r: function r() {
          pAll();
          if (tr) {
            var nxt = _this_1.u[ind + 1];
            if (nxt) nxt.r();else _this_1.d = 1;
          }
          tr = 1;
        }
      });
      var cl = 0;
      file.ondata = function (err, dat, _final23) {
        if (err) {
          _this_1.ondata(err, dat, _final23);
          _this_1.terminate();
        } else {
          cl += dat.length;
          chks.push(dat);
          if (_final23) {
            var dd = new u8(16);
            wbytes(dd, 0, 0x8074B50);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl);
            wbytes(dd, 12, file.size);
            chks.push(dd);
            uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
            if (tr) uf.r();
            tr = 1;
          } else if (tr) pAll();
        }
      };
      this.u.push(uf);
    };
    /**
     * Ends the process of adding files and prepares to emit the final chunks.
     * This *must* be called after adding all desired files for the resulting
     * ZIP file to work properly.
     */
    Zip.prototype.end = function () {
      var _this_1 = this;
      if (this.d & 2) {
        if (this.d & 1) throw 'stream finishing';
        throw 'stream finished';
      }
      if (this.d) this.e();else this.u.push({
        r: function r() {
          if (!(_this_1.d & 1)) return;
          _this_1.u.splice(-1, 1);
          _this_1.e();
        },
        t: function t() {}
      });
      this.d = 3;
    };
    Zip.prototype.e = function () {
      var bt = 0,
        l = 0,
        tl = 0;
      for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
        var f = _a[_i];
        tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
      }
      var out = new u8(tl + 22);
      for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
        var f = _c[_b];
        wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
        bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
      }
      wzf(out, bt, this.u.length, tl, l);
      this.ondata(null, out, true);
      this.d = 2;
    };
    /**
     * A method to terminate any internal workers used by the stream. Subsequent
     * calls to add() will fail.
     */
    Zip.prototype.terminate = function () {
      for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
        var f = _a[_i];
        f.t();
      }
      this.d = 2;
    };
    return Zip;
  }();
  function zip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    var r = {};
    fltn(data, '', r, opts);
    var k = Object.keys(r);
    var lft = k.length,
      o = 0,
      tot = 0;
    var slft = lft,
      files = new Array(lft);
    var term = [];
    var tAll = function tAll() {
      for (var i = 0; i < term.length; ++i) term[i]();
    };
    var cbf = function cbf() {
      var out = new u8(tot + 22),
        oe = o,
        cdl = tot - o;
      tot = 0;
      for (var i = 0; i < slft; ++i) {
        var f = files[i];
        try {
          var l = f.c.length;
          wzh(out, tot, f, f.f, f.u, l);
          var badd = 30 + f.f.length + exfl(f.extra);
          var loc = tot + badd;
          out.set(f.c, loc);
          wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
        } catch (e) {
          return cb(e, null);
        }
      }
      wzf(out, o, files.length, cdl, oe);
      cb(null, out);
    };
    if (!lft) cbf();
    var _loop_1 = function _loop_1(i) {
      var fn = k[i];
      var _a = r[fn],
        file = _a[0],
        p = _a[1];
      var c = crc(),
        size = file.length;
      c.p(file);
      var f = strToU8(fn),
        s = f.length;
      var com = p.comment,
        m = com && strToU8(com),
        ms = m && m.length;
      var exl = exfl(p.extra);
      var compression = p.level == 0 ? 0 : 8;
      var cbl = function cbl(e, d) {
        if (e) {
          tAll();
          cb(e, null);
        } else {
          var l = d.length;
          files[i] = mrg(p, {
            size: size,
            crc: c.d(),
            c: d,
            f: f,
            m: m,
            u: s != fn.length || m && com.length != ms,
            compression: compression
          });
          o += 30 + s + exl + l;
          tot += 76 + 2 * (s + exl) + (ms || 0) + l;
          if (! --lft) cbf();
        }
      };
      if (s > 65535) cbl('filename too long', null);
      if (!compression) cbl(null, file);else if (size < 160000) {
        try {
          cbl(null, deflateSync(file, p));
        } catch (e) {
          cbl(e, null);
        }
      } else term.push(deflate(file, p, cbl));
    };
    // Cannot use lft because it can decrease
    for (var i = 0; i < slft; ++i) {
      _loop_1(i);
    }
    return tAll;
  }
  /**
   * Synchronously creates a ZIP file. Prefer using `zip` for better performance
   * with more than one file.
   * @param data The directory structure for the ZIP archive
   * @param opts The main options, merged with per-file options
   * @returns The generated ZIP archive
   */
  function zipSync(data, opts) {
    if (!opts) opts = {};
    var r = {};
    var files = [];
    fltn(data, '', r, opts);
    var o = 0;
    var tot = 0;
    for (var fn in r) {
      var _a = r[fn],
        file = _a[0],
        p = _a[1];
      var compression = p.level == 0 ? 0 : 8;
      var f = strToU8(fn),
        s = f.length;
      var com = p.comment,
        m = com && strToU8(com),
        ms = m && m.length;
      var exl = exfl(p.extra);
      if (s > 65535) throw 'filename too long';
      var d = compression ? deflateSync(file, p) : file,
        l = d.length;
      var c = crc();
      c.p(file);
      files.push(mrg(p, {
        size: file.length,
        crc: c.d(),
        c: d,
        f: f,
        m: m,
        u: s != fn.length || m && com.length != ms,
        o: o,
        compression: compression
      }));
      o += 30 + s + exl + l;
      tot += 76 + 2 * (s + exl) + (ms || 0) + l;
    }
    var out = new u8(tot + 22),
      oe = o,
      cdl = tot - o;
    for (var i = 0; i < files.length; ++i) {
      var f = files[i];
      wzh(out, f.o, f, f.f, f.u, f.c.length);
      var badd = 30 + f.f.length + exfl(f.extra);
      out.set(f.c, f.o + badd);
      wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
    }
    wzf(out, o, files.length, cdl, oe);
    return out;
  }
  /**
   * Streaming pass-through decompression for ZIP archives
   */
  var UnzipPassThrough = /*#__PURE__*/function () {
    function UnzipPassThrough() {}
    UnzipPassThrough.prototype.push = function (data, _final24) {
      this.ondata(null, data, _final24);
    };
    UnzipPassThrough.compression = 0;
    return UnzipPassThrough;
  }();
  /**
   * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
   * better performance.
   */
  var UnzipInflate = /*#__PURE__*/function () {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */
    function UnzipInflate() {
      var _this_1 = this;
      this.i = new Inflate(function (dat, _final25) {
        _this_1.ondata(null, dat, _final25);
      });
    }
    UnzipInflate.prototype.push = function (data, _final26) {
      try {
        this.i.push(data, _final26);
      } catch (e) {
        this.ondata(e, data, _final26);
      }
    };
    UnzipInflate.compression = 8;
    return UnzipInflate;
  }();
  /**
   * Asynchronous streaming DEFLATE decompression for ZIP archives
   */
  var AsyncUnzipInflate = /*#__PURE__*/function () {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */
    function AsyncUnzipInflate(_, sz) {
      var _this_1 = this;
      if (sz < 320000) {
        this.i = new Inflate(function (dat, _final27) {
          _this_1.ondata(null, dat, _final27);
        });
      } else {
        this.i = new AsyncInflate(function (err, dat, _final28) {
          _this_1.ondata(err, dat, _final28);
        });
        this.terminate = this.i.terminate;
      }
    }
    AsyncUnzipInflate.prototype.push = function (data, _final29) {
      if (this.i.terminate) data = slc(data, 0);
      this.i.push(data, _final29);
    };
    AsyncUnzipInflate.compression = 8;
    return AsyncUnzipInflate;
  }();
  /**
   * A ZIP archive decompression stream that emits files as they are discovered
   */
  var Unzip = /*#__PURE__*/function () {
    /**
     * Creates a ZIP decompression stream
     * @param cb The callback to call whenever a file in the ZIP archive is found
     */
    function Unzip(cb) {
      this.onfile = cb;
      this.k = [];
      this.o = {
        0: UnzipPassThrough
      };
      this.p = et;
    }
    /**
     * Pushes a chunk to be unzipped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Unzip.prototype.push = function (chunk, _final30) {
      var _this_1 = this;
      if (!this.onfile) throw 'no callback';
      if (!this.p) throw 'stream finished';
      if (this.c > 0) {
        var len = Math.min(this.c, chunk.length);
        var toAdd = chunk.subarray(0, len);
        this.c -= len;
        if (this.d) this.d.push(toAdd, !this.c);else this.k[0].push(toAdd);
        chunk = chunk.subarray(len);
        if (chunk.length) return this.push(chunk, _final30);
      } else {
        var f = 0,
          i = 0,
          is = void 0,
          buf = void 0;
        if (!this.p.length) buf = chunk;else if (!chunk.length) buf = this.p;else {
          buf = new u8(this.p.length + chunk.length);
          buf.set(this.p), buf.set(chunk, this.p.length);
        }
        var l = buf.length,
          oc = this.c,
          add = oc && this.d;
        var _loop_2 = function _loop_2() {
          var _a;
          var sig = b4(buf, i);
          if (sig == 0x4034B50) {
            f = 1, is = i;
            this_1.d = null;
            this_1.c = 0;
            var bf = b2(buf, i + 6),
              cmp_1 = b2(buf, i + 8),
              u = bf & 2048,
              dd = bf & 8,
              fnl = b2(buf, i + 26),
              es = b2(buf, i + 28);
            if (l > i + 30 + fnl + es) {
              var chks_2 = [];
              this_1.k.unshift(chks_2);
              f = 2;
              var sc_1 = b4(buf, i + 18),
                su_1 = b4(buf, i + 22);
              var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
              if (sc_1 == 4294967295) {
                _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
              } else if (dd) sc_1 = -1;
              i += es;
              this_1.c = sc_1;
              var d_1;
              var file_1 = {
                name: fn_1,
                compression: cmp_1,
                start: function start() {
                  if (!file_1.ondata) throw 'no callback';
                  if (!sc_1) file_1.ondata(null, et, true);else {
                    var ctr = _this_1.o[cmp_1];
                    if (!ctr) throw 'unknown compression type ' + cmp_1;
                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                    d_1.ondata = function (err, dat, _final31) {
                      file_1.ondata(err, dat, _final31);
                    };
                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
                      var dat = chks_3[_i];
                      d_1.push(dat, false);
                    }
                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;else d_1.push(et, true);
                  }
                },
                terminate: function terminate() {
                  if (d_1 && d_1.terminate) d_1.terminate();
                }
              };
              if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
              this_1.onfile(file_1);
            }
            return "break";
          } else if (oc) {
            if (sig == 0x8074B50) {
              is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
              return "break";
            } else if (sig == 0x2014B50) {
              is = i -= 4, f = 3, this_1.c = 0;
              return "break";
            }
          }
        };
        var this_1 = this;
        for (; i < l - 4; ++i) {
          var state_1 = _loop_2();
          if (state_1 === "break") break;
        }
        this.p = et;
        if (oc < 0) {
          var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
          if (add) add.push(dat, !!f);else this.k[+(f == 2)].push(dat);
        }
        if (f & 2) return this.push(buf.subarray(i), _final30);
        this.p = buf.subarray(i);
      }
      if (_final30) {
        if (this.c) throw 'invalid zip file';
        this.p = null;
      }
    };
    /**
     * Registers a decoder with the stream, allowing for files compressed with
     * the compression type provided to be expanded correctly
     * @param decoder The decoder constructor
     */
    Unzip.prototype.register = function (decoder) {
      this.o[decoder.compression] = decoder;
    };
    return Unzip;
  }();
  /**
   * Asynchronously decompresses a ZIP archive
   * @param data The raw compressed ZIP file
   * @param cb The callback to call with the decompressed files
   * @returns A function that can be used to immediately terminate the unzipping
   */
  function unzip(data, cb) {
    if (typeof cb != 'function') throw 'no callback';
    var term = [];
    var tAll = function tAll() {
      for (var i = 0; i < term.length; ++i) term[i]();
    };
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 0x6054B50; --e) {
      if (!e || data.length - e > 65558) {
        cb('invalid zip file', null);
        return;
      }
    }
    var lft = b2(data, e + 8);
    if (!lft) cb(null, {});
    var c = lft;
    var o = b4(data, e + 16);
    var z = o == 4294967295;
    if (z) {
      e = b4(data, e - 12);
      if (b4(data, e) != 0x6064B50) {
        cb('invalid zip file', null);
        return;
      }
      c = lft = b4(data, e + 32);
      o = b4(data, e + 48);
    }
    var _loop_3 = function _loop_3(i) {
      var _a = zh(data, o, z),
        c_1 = _a[0],
        sc = _a[1],
        su = _a[2],
        fn = _a[3],
        no = _a[4],
        off = _a[5],
        b = slzh(data, off);
      o = no;
      var cbl = function cbl(e, d) {
        if (e) {
          tAll();
          cb(e, null);
        } else {
          files[fn] = d;
          if (! --lft) cb(null, files);
        }
      };
      if (!c_1) cbl(null, slc(data, b, b + sc));else if (c_1 == 8) {
        var infl = data.subarray(b, b + sc);
        if (sc < 320000) {
          try {
            cbl(null, inflateSync(infl, new u8(su)));
          } catch (e) {
            cbl(e, null);
          }
        } else term.push(inflate(infl, {
          size: su
        }, cbl));
      } else cbl('unknown compression type ' + c_1, null);
    };
    for (var i = 0; i < c; ++i) {
      _loop_3();
    }
    return tAll;
  }
  /**
   * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
   * performance with more than one file.
   * @param data The raw compressed ZIP file
   * @returns The decompressed files
   */
  function unzipSync(data) {
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 0x6054B50; --e) {
      if (!e || data.length - e > 65558) throw 'invalid zip file';
    }
    var c = b2(data, e + 8);
    if (!c) return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295;
    if (z) {
      e = b4(data, e - 12);
      if (b4(data, e) != 0x6064B50) throw 'invalid zip file';
      c = b4(data, e + 32);
      o = b4(data, e + 48);
    }
    for (var i = 0; i < c; ++i) {
      var _a = zh(data, o, z),
        c_2 = _a[0],
        sc = _a[1],
        su = _a[2],
        fn = _a[3],
        no = _a[4],
        off = _a[5],
        b = slzh(data, off);
      o = no;
      if (!c_2) files[fn] = slc(data, b, b + sc);else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));else throw 'unknown compression type ' + c_2;
    }
    return files;
  }

  var fflate = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Deflate: Deflate,
    AsyncDeflate: AsyncDeflate,
    deflate: deflate,
    deflateSync: deflateSync,
    Inflate: Inflate,
    AsyncInflate: AsyncInflate,
    inflate: inflate,
    inflateSync: inflateSync,
    Gzip: Gzip,
    AsyncGzip: AsyncGzip,
    gzip: gzip,
    gzipSync: gzipSync,
    Gunzip: Gunzip,
    AsyncGunzip: AsyncGunzip,
    gunzip: gunzip,
    gunzipSync: gunzipSync,
    Zlib: Zlib,
    AsyncZlib: AsyncZlib,
    zlib: zlib,
    zlibSync: zlibSync,
    Unzlib: Unzlib,
    AsyncUnzlib: AsyncUnzlib,
    unzlib: unzlib,
    unzlibSync: unzlibSync,
    compress: gzip,
    AsyncCompress: AsyncGzip,
    compressSync: gzipSync,
    Compress: Gzip,
    Decompress: Decompress,
    AsyncDecompress: AsyncDecompress,
    decompress: decompress,
    decompressSync: decompressSync,
    DecodeUTF8: DecodeUTF8,
    EncodeUTF8: EncodeUTF8,
    strToU8: strToU8,
    strFromU8: strFromU8,
    ZipPassThrough: ZipPassThrough,
    ZipDeflate: ZipDeflate,
    AsyncZipDeflate: AsyncZipDeflate,
    Zip: Zip,
    zip: zip,
    zipSync: zipSync,
    UnzipPassThrough: UnzipPassThrough,
    UnzipInflate: UnzipInflate,
    AsyncUnzipInflate: AsyncUnzipInflate,
    Unzip: Unzip,
    unzip: unzip,
    unzipSync: unzipSync
  });

  /**
   * NURBS utils
   *
   * See NURBSCurve and NURBSSurface.
   **/

  /**************************************************************
   *	NURBS Utils
   **************************************************************/

  /*
  Finds knot vector span.

  p : degree
  u : parametric value
  U : knot vector

  returns the span
  */
  function findSpan(p, u, U) {
    var n = U.length - p - 1;
    if (u >= U[n]) {
      return n - 1;
    }
    if (u <= U[p]) {
      return p;
    }
    var low = p;
    var high = n;
    var mid = Math.floor((low + high) / 2);
    while (u < U[mid] || u >= U[mid + 1]) {
      if (u < U[mid]) {
        high = mid;
      } else {
        low = mid;
      }
      mid = Math.floor((low + high) / 2);
    }
    return mid;
  }

  /*
  Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

  span : span in which u lies
  u    : parametric point
  p    : degree
  U    : knot vector

  returns array[p+1] with basis functions values.
  */
  function calcBasisFunctions(span, u, p, U) {
    var N = [];
    var left = [];
    var right = [];
    N[0] = 1.0;
    for (var j = 1; j <= p; ++j) {
      left[j] = u - U[span + 1 - j];
      right[j] = U[span + j] - u;
      var saved = 0.0;
      for (var r = 0; r < j; ++r) {
        var rv = right[r + 1];
        var lv = left[j - r];
        var temp = N[r] / (rv + lv);
        N[r] = saved + rv * temp;
        saved = lv * temp;
      }
      N[j] = saved;
    }
    return N;
  }

  /*
  Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

  p : degree of B-Spline
  U : knot vector
  P : control points (x, y, z, w)
  u : parametric point

  returns point for given u
  */
  function calcBSplinePoint(p, U, P, u) {
    var span = findSpan(p, u, U);
    var N = calcBasisFunctions(span, u, p, U);
    var C = new Vector4(0, 0, 0, 0);
    for (var j = 0; j <= p; ++j) {
      var point = P[span - p + j];
      var Nj = N[j];
      var wNj = point.w * Nj;
      C.x += point.x * wNj;
      C.y += point.y * wNj;
      C.z += point.z * wNj;
      C.w += point.w * Nj;
    }
    return C;
  }

  /*
  Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

  span : span in which u lies
  u    : parametric point
  p    : degree
  n    : number of derivatives to calculate
  U    : knot vector

  returns array[n+1][p+1] with basis functions derivatives
  */
  function calcBasisFunctionDerivatives(span, u, p, n, U) {
    var zeroArr = [];
    for (var i = 0; i <= p; ++i) zeroArr[i] = 0.0;
    var ders = [];
    for (var _i = 0; _i <= n; ++_i) ders[_i] = zeroArr.slice(0);
    var ndu = [];
    for (var _i2 = 0; _i2 <= p; ++_i2) ndu[_i2] = zeroArr.slice(0);
    ndu[0][0] = 1.0;
    var left = zeroArr.slice(0);
    var right = zeroArr.slice(0);
    for (var j = 1; j <= p; ++j) {
      left[j] = u - U[span + 1 - j];
      right[j] = U[span + j] - u;
      var saved = 0.0;
      for (var _r = 0; _r < j; ++_r) {
        var rv = right[_r + 1];
        var lv = left[j - _r];
        ndu[j][_r] = rv + lv;
        var temp = ndu[_r][j - 1] / ndu[j][_r];
        ndu[_r][j] = saved + rv * temp;
        saved = lv * temp;
      }
      ndu[j][j] = saved;
    }
    for (var _j = 0; _j <= p; ++_j) {
      ders[0][_j] = ndu[_j][p];
    }
    for (var _r2 = 0; _r2 <= p; ++_r2) {
      var s1 = 0;
      var s2 = 1;
      var a = [];
      for (var _i3 = 0; _i3 <= p; ++_i3) {
        a[_i3] = zeroArr.slice(0);
      }
      a[0][0] = 1.0;
      for (var k = 1; k <= n; ++k) {
        var d = 0.0;
        var rk = _r2 - k;
        var pk = p - k;
        if (_r2 >= k) {
          a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
          d = a[s2][0] * ndu[rk][pk];
        }
        var j1 = rk >= -1 ? 1 : -rk;
        var j2 = _r2 - 1 <= pk ? k - 1 : p - _r2;
        for (var _j2 = j1; _j2 <= j2; ++_j2) {
          a[s2][_j2] = (a[s1][_j2] - a[s1][_j2 - 1]) / ndu[pk + 1][rk + _j2];
          d += a[s2][_j2] * ndu[rk + _j2][pk];
        }
        if (_r2 <= pk) {
          a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][_r2];
          d += a[s2][k] * ndu[_r2][pk];
        }
        ders[k][_r2] = d;
        var _j3 = s1;
        s1 = s2;
        s2 = _j3;
      }
    }
    var r = p;
    for (var _k = 1; _k <= n; ++_k) {
      for (var _j4 = 0; _j4 <= p; ++_j4) {
        ders[_k][_j4] *= r;
      }
      r *= p - _k;
    }
    return ders;
  }

  /*
      Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

      p  : degree
      U  : knot vector
      P  : control points
      u  : Parametric points
      nd : number of derivatives

      returns array[d+1] with derivatives
      */
  function calcBSplineDerivatives(p, U, P, u, nd) {
    var du = nd < p ? nd : p;
    var CK = [];
    var span = findSpan(p, u, U);
    var nders = calcBasisFunctionDerivatives(span, u, p, du, U);
    var Pw = [];
    for (var i = 0; i < P.length; ++i) {
      var point = P[i].clone();
      var w = point.w;
      point.x *= w;
      point.y *= w;
      point.z *= w;
      Pw[i] = point;
    }
    for (var k = 0; k <= du; ++k) {
      var _point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
      for (var j = 1; j <= p; ++j) {
        _point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
      }
      CK[k] = _point;
    }
    for (var _k2 = du + 1; _k2 <= nd + 1; ++_k2) {
      CK[_k2] = new Vector4(0, 0, 0);
    }
    return CK;
  }

  /*
  Calculate "K over I"

  returns k!/(i!(k-i)!)
  */
  function calcKoverI(k, i) {
    var nom = 1;
    for (var j = 2; j <= k; ++j) {
      nom *= j;
    }
    var denom = 1;
    for (var _j5 = 2; _j5 <= i; ++_j5) {
      denom *= _j5;
    }
    for (var _j6 = 2; _j6 <= k - i; ++_j6) {
      denom *= _j6;
    }
    return nom / denom;
  }

  /*
  Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

  Pders : result of function calcBSplineDerivatives

  returns array with derivatives for rational curve.
  */
  function calcRationalCurveDerivatives(Pders) {
    var nd = Pders.length;
    var Aders = [];
    var wders = [];
    for (var i = 0; i < nd; ++i) {
      var point = Pders[i];
      Aders[i] = new Vector3(point.x, point.y, point.z);
      wders[i] = point.w;
    }
    var CK = [];
    for (var k = 0; k < nd; ++k) {
      var v = Aders[k].clone();
      for (var _i4 = 1; _i4 <= k; ++_i4) {
        v.sub(CK[k - _i4].clone().multiplyScalar(calcKoverI(k, _i4) * wders[_i4]));
      }
      CK[k] = v.divideScalar(wders[0]);
    }
    return CK;
  }

  /*
  Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

  p  : degree
  U  : knot vector
  P  : control points in homogeneous space
  u  : parametric points
  nd : number of derivatives

  returns array with derivatives.
  */
  function calcNURBSDerivatives(p, U, P, u, nd) {
    var Pders = calcBSplineDerivatives(p, U, P, u, nd);
    return calcRationalCurveDerivatives(Pders);
  }

  /**
   * NURBS curve object
   *
   * Derives from Curve, overriding getPoint and getTangent.
   *
   * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.
   *
   **/
  var NURBSCurve = /*#__PURE__*/function (_Curve) {
    _inherits(NURBSCurve, _Curve);
    var _super = _createSuper(NURBSCurve);
    function NURBSCurve(degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */) {
      var _this;
      _classCallCheck(this, NURBSCurve);
      _this = _super.call(this);
      _this.degree = degree;
      _this.knots = knots;
      _this.controlPoints = [];
      // Used by periodic NURBS to remove hidden spans
      _this.startKnot = startKnot || 0;
      _this.endKnot = endKnot || _this.knots.length - 1;
      for (var i = 0; i < controlPoints.length; ++i) {
        // ensure Vector4 for control points
        var point = controlPoints[i];
        _this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);
      }
      return _this;
    }
    _createClass(NURBSCurve, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
        var point = optionalTarget;
        var u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u

        // following results in (wx, wy, wz, w) homogeneous point
        var hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
        if (hpoint.w !== 1.0) {
          // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
          hpoint.divideScalar(hpoint.w);
        }
        return point.set(hpoint.x, hpoint.y, hpoint.z);
      }
    }, {
      key: "getTangent",
      value: function getTangent(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
        var tangent = optionalTarget;
        var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
        var ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
        tangent.copy(ders[1]).normalize();
        return tangent;
      }
    }]);
    return NURBSCurve;
  }(Curve);

  /**
   * Loader loads FBX file and generates Group representing FBX scene.
   * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
   * Versions lower than this may load but will probably have errors
   *
   * Needs Support:
   *  Morph normals / blend shape normals
   *
   * FBX format references:
   * 	https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
   *
   * Binary format specification:
   *	https://code.blender.org/2013/08/fbx-binary-file-format-specification/
   */

  var fbxTree;
  var connections;
  var sceneGraph;
  var FBXLoader = /*#__PURE__*/function (_Loader) {
    _inherits(FBXLoader, _Loader);
    var _super = _createSuper(FBXLoader);
    function FBXLoader(manager) {
      _classCallCheck(this, FBXLoader);
      return _super.call(this, manager);
    }
    _createClass(FBXLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;
        var loader = new FileLoader(this.manager);
        loader.setPath(scope.path);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function (buffer) {
          try {
            onLoad(scope.parse(buffer, path));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "parse",
      value: function parse(FBXBuffer, path) {
        if (isFbxFormatBinary(FBXBuffer)) {
          fbxTree = new BinaryParser().parse(FBXBuffer);
        } else {
          var FBXText = convertArrayBufferToString(FBXBuffer);
          if (!isFbxFormatASCII(FBXText)) {
            throw new Error('THREE.FBXLoader: Unknown format.');
          }
          if (getFbxVersion(FBXText) < 7000) {
            throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));
          }
          fbxTree = new TextParser().parse(FBXText);
        }

        // console.log( fbxTree );

        var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
      }
    }]);
    return FBXLoader;
  }(Loader); // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
  var FBXTreeParser = /*#__PURE__*/function () {
    function FBXTreeParser(textureLoader, manager) {
      _classCallCheck(this, FBXTreeParser);
      this.textureLoader = textureLoader;
      this.manager = manager;
    }
    _createClass(FBXTreeParser, [{
      key: "parse",
      value: function parse() {
        connections = this.parseConnections();
        var images = this.parseImages();
        var textures = this.parseTextures(images);
        var materials = this.parseMaterials(textures);
        var deformers = this.parseDeformers();
        var geometryMap = new GeometryParser().parse(deformers);
        this.parseScene(deformers, geometryMap, materials);
        return sceneGraph;
      }

      // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
      // and details the connection type
    }, {
      key: "parseConnections",
      value: function parseConnections() {
        var connectionMap = new Map();
        if ('Connections' in fbxTree) {
          var rawConnections = fbxTree.Connections.connections;
          rawConnections.forEach(function (rawConnection) {
            var fromID = rawConnection[0];
            var toID = rawConnection[1];
            var relationship = rawConnection[2];
            if (!connectionMap.has(fromID)) {
              connectionMap.set(fromID, {
                parents: [],
                children: []
              });
            }
            var parentRelationship = {
              ID: toID,
              relationship: relationship
            };
            connectionMap.get(fromID).parents.push(parentRelationship);
            if (!connectionMap.has(toID)) {
              connectionMap.set(toID, {
                parents: [],
                children: []
              });
            }
            var childRelationship = {
              ID: fromID,
              relationship: relationship
            };
            connectionMap.get(toID).children.push(childRelationship);
          });
        }
        return connectionMap;
      }

      // Parse FBXTree.Objects.Video for embedded image data
      // These images are connected to textures in FBXTree.Objects.Textures
      // via FBXTree.Connections.
    }, {
      key: "parseImages",
      value: function parseImages() {
        var images = {};
        var blobs = {};
        if ('Video' in fbxTree.Objects) {
          var videoNodes = fbxTree.Objects.Video;
          for (var nodeID in videoNodes) {
            var videoNode = videoNodes[nodeID];
            var id = parseInt(nodeID);
            images[id] = videoNode.RelativeFilename || videoNode.Filename;

            // raw image data is in videoNode.Content
            if ('Content' in videoNode) {
              var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
              var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';
              if (arrayBufferContent || base64Content) {
                var image = this.parseImage(videoNodes[nodeID]);
                blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
              }
            }
          }
        }
        for (var _id in images) {
          var filename = images[_id];
          if (blobs[filename] !== undefined) images[_id] = blobs[filename];else images[_id] = images[_id].split('\\').pop();
        }
        return images;
      }

      // Parse embedded image data in FBXTree.Video.Content
    }, {
      key: "parseImage",
      value: function parseImage(videoNode) {
        var content = videoNode.Content;
        var fileName = videoNode.RelativeFilename || videoNode.Filename;
        var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();
        var type;
        switch (extension) {
          case 'bmp':
            type = 'image/bmp';
            break;
          case 'jpg':
          case 'jpeg':
            type = 'image/jpeg';
            break;
          case 'png':
            type = 'image/png';
            break;
          case 'tif':
            type = 'image/tiff';
            break;
          case 'tga':
            if (this.manager.getHandler('.tga') === null) {
              console.warn('FBXLoader: TGA loader not found, skipping ', fileName);
            }
            type = 'image/tga';
            break;
          default:
            console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
            return;
        }
        if (typeof content === 'string') {
          // ASCII format

          return 'data:' + type + ';base64,' + content;
        } else {
          // Binary Format

          var array = new Uint8Array(content);
          return window.URL.createObjectURL(new Blob([array], {
            type: type
          }));
        }
      }

      // Parse nodes in FBXTree.Objects.Texture
      // These contain details such as UV scaling, cropping, rotation etc and are connected
      // to images in FBXTree.Objects.Video
    }, {
      key: "parseTextures",
      value: function parseTextures(images) {
        var textureMap = new Map();
        if ('Texture' in fbxTree.Objects) {
          var textureNodes = fbxTree.Objects.Texture;
          for (var nodeID in textureNodes) {
            var texture = this.parseTexture(textureNodes[nodeID], images);
            textureMap.set(parseInt(nodeID), texture);
          }
        }
        return textureMap;
      }

      // Parse individual node in FBXTree.Objects.Texture
    }, {
      key: "parseTexture",
      value: function parseTexture(textureNode, images) {
        var texture = this.loadTexture(textureNode, images);
        texture.ID = textureNode.id;
        texture.name = textureNode.attrName;
        var wrapModeU = textureNode.WrapModeU;
        var wrapModeV = textureNode.WrapModeV;
        var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
        var valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

        // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
        // 0: repeat(default), 1: clamp

        texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        if ('Scaling' in textureNode) {
          var values = textureNode.Scaling.value;
          texture.repeat.x = values[0];
          texture.repeat.y = values[1];
        }
        if ('Translation' in textureNode) {
          var _values = textureNode.Translation.value;
          texture.offset.x = _values[0];
          texture.offset.y = _values[1];
        }
        return texture;
      }

      // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
    }, {
      key: "loadTexture",
      value: function loadTexture(textureNode, images) {
        var fileName;
        var currentPath = this.textureLoader.path;
        var children = connections.get(textureNode.id).children;
        if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {
          fileName = images[children[0].ID];
          if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {
            this.textureLoader.setPath(undefined);
          }
        }
        var texture;
        var extension = textureNode.FileName.slice(-3).toLowerCase();
        if (extension === 'tga') {
          var loader = this.manager.getHandler('.tga');
          if (loader === null) {
            console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename);
            texture = new Texture();
          } else {
            loader.setPath(this.textureLoader.path);
            texture = loader.load(fileName);
          }
        } else if (extension === 'psd') {
          console.warn('FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename);
          texture = new Texture();
        } else {
          texture = this.textureLoader.load(fileName);
        }
        this.textureLoader.setPath(currentPath);
        return texture;
      }

      // Parse nodes in FBXTree.Objects.Material
    }, {
      key: "parseMaterials",
      value: function parseMaterials(textureMap) {
        var materialMap = new Map();
        if ('Material' in fbxTree.Objects) {
          var materialNodes = fbxTree.Objects.Material;
          for (var nodeID in materialNodes) {
            var material = this.parseMaterial(materialNodes[nodeID], textureMap);
            if (material !== null) materialMap.set(parseInt(nodeID), material);
          }
        }
        return materialMap;
      }

      // Parse single node in FBXTree.Objects.Material
      // Materials are connected to texture maps in FBXTree.Objects.Textures
      // FBX format currently only supports Lambert and Phong shading models
    }, {
      key: "parseMaterial",
      value: function parseMaterial(materialNode, textureMap) {
        var ID = materialNode.id;
        var name = materialNode.attrName;
        var type = materialNode.ShadingModel;

        // Case where FBX wraps shading model in property object.
        if (_typeof(type) === 'object') {
          type = type.value;
        }

        // Ignore unused materials which don't have any connections.
        if (!connections.has(ID)) return null;
        var parameters = this.parseParameters(materialNode, textureMap, ID);
        var material;
        switch (type.toLowerCase()) {
          case 'phong':
            material = new MeshPhongMaterial();
            break;
          case 'lambert':
            material = new MeshLambertMaterial();
            break;
          default:
            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
            material = new MeshPhongMaterial();
            break;
        }
        material.setValues(parameters);
        material.name = name;
        return material;
      }

      // Parse FBX material and return parameters suitable for a three.js material
      // Also parse the texture map and return any textures associated with the material
    }, {
      key: "parseParameters",
      value: function parseParameters(materialNode, textureMap, ID) {
        var parameters = {};
        if (materialNode.BumpFactor) {
          parameters.bumpScale = materialNode.BumpFactor.value;
        }
        if (materialNode.Diffuse) {
          parameters.color = new Color$2().fromArray(materialNode.Diffuse.value);
        } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')) {
          // The blender exporter exports diffuse here instead of in materialNode.Diffuse
          parameters.color = new Color$2().fromArray(materialNode.DiffuseColor.value);
        }
        if (materialNode.DisplacementFactor) {
          parameters.displacementScale = materialNode.DisplacementFactor.value;
        }
        if (materialNode.Emissive) {
          parameters.emissive = new Color$2().fromArray(materialNode.Emissive.value);
        } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')) {
          // The blender exporter exports emissive color here instead of in materialNode.Emissive
          parameters.emissive = new Color$2().fromArray(materialNode.EmissiveColor.value);
        }
        if (materialNode.EmissiveFactor) {
          parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
        }
        if (materialNode.Opacity) {
          parameters.opacity = parseFloat(materialNode.Opacity.value);
        }
        if (parameters.opacity < 1.0) {
          parameters.transparent = true;
        }
        if (materialNode.ReflectionFactor) {
          parameters.reflectivity = materialNode.ReflectionFactor.value;
        }
        if (materialNode.Shininess) {
          parameters.shininess = materialNode.Shininess.value;
        }
        if (materialNode.Specular) {
          parameters.specular = new Color$2().fromArray(materialNode.Specular.value);
        } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {
          // The blender exporter exports specular color here instead of in materialNode.Specular
          parameters.specular = new Color$2().fromArray(materialNode.SpecularColor.value);
        }
        var scope = this;
        connections.get(ID).children.forEach(function (child) {
          var type = child.relationship;
          switch (type) {
            case 'Bump':
              parameters.bumpMap = scope.getTexture(textureMap, child.ID);
              break;
            case 'Maya|TEX_ao_map':
              parameters.aoMap = scope.getTexture(textureMap, child.ID);
              break;
            case 'DiffuseColor':
            case 'Maya|TEX_color_map':
              parameters.map = scope.getTexture(textureMap, child.ID);
              if (parameters.map !== undefined) {
                parameters.map.encoding = sRGBEncoding;
              }
              break;
            case 'DisplacementColor':
              parameters.displacementMap = scope.getTexture(textureMap, child.ID);
              break;
            case 'EmissiveColor':
              parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
              if (parameters.emissiveMap !== undefined) {
                parameters.emissiveMap.encoding = sRGBEncoding;
              }
              break;
            case 'NormalMap':
            case 'Maya|TEX_normal_map':
              parameters.normalMap = scope.getTexture(textureMap, child.ID);
              break;
            case 'ReflectionColor':
              parameters.envMap = scope.getTexture(textureMap, child.ID);
              if (parameters.envMap !== undefined) {
                parameters.envMap.mapping = EquirectangularReflectionMapping;
                parameters.envMap.encoding = sRGBEncoding;
              }
              break;
            case 'SpecularColor':
              parameters.specularMap = scope.getTexture(textureMap, child.ID);
              if (parameters.specularMap !== undefined) {
                parameters.specularMap.encoding = sRGBEncoding;
              }
              break;
            case 'TransparentColor':
            case 'TransparencyFactor':
              parameters.alphaMap = scope.getTexture(textureMap, child.ID);
              parameters.transparent = true;
              break;
            case 'AmbientColor':
            case 'ShininessExponent': // AKA glossiness map
            case 'SpecularFactor': // AKA specularLevel
            case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
            default:
              console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);
              break;
          }
        });
        return parameters;
      }

      // get a texture from the textureMap for use by a material.
    }, {
      key: "getTexture",
      value: function getTexture(textureMap, id) {
        // if the texture is a layered texture, just use the first layer and issue a warning
        if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
          console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');
          id = connections.get(id).children[0].ID;
        }
        return textureMap.get(id);
      }

      // Parse nodes in FBXTree.Objects.Deformer
      // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
      // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
    }, {
      key: "parseDeformers",
      value: function parseDeformers() {
        var skeletons = {};
        var morphTargets = {};
        if ('Deformer' in fbxTree.Objects) {
          var DeformerNodes = fbxTree.Objects.Deformer;
          for (var nodeID in DeformerNodes) {
            var deformerNode = DeformerNodes[nodeID];
            var relationships = connections.get(parseInt(nodeID));
            if (deformerNode.attrType === 'Skin') {
              var skeleton = this.parseSkeleton(relationships, DeformerNodes);
              skeleton.ID = nodeID;
              if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');
              skeleton.geometryID = relationships.parents[0].ID;
              skeletons[nodeID] = skeleton;
            } else if (deformerNode.attrType === 'BlendShape') {
              var morphTarget = {
                id: nodeID
              };
              morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
              morphTarget.id = nodeID;
              if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');
              morphTargets[nodeID] = morphTarget;
            }
          }
        }
        return {
          skeletons: skeletons,
          morphTargets: morphTargets
        };
      }

      // Parse single nodes in FBXTree.Objects.Deformer
      // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
      // Each skin node represents a skeleton and each cluster node represents a bone
    }, {
      key: "parseSkeleton",
      value: function parseSkeleton(relationships, deformerNodes) {
        var rawBones = [];
        relationships.children.forEach(function (child) {
          var boneNode = deformerNodes[child.ID];
          if (boneNode.attrType !== 'Cluster') return;
          var rawBone = {
            ID: child.ID,
            indices: [],
            weights: [],
            transformLink: new Matrix4$1().fromArray(boneNode.TransformLink.a)
            // transform: new Matrix4().fromArray( boneNode.Transform.a ),
            // linkMode: boneNode.Mode,
          };

          if ('Indexes' in boneNode) {
            rawBone.indices = boneNode.Indexes.a;
            rawBone.weights = boneNode.Weights.a;
          }
          rawBones.push(rawBone);
        });
        return {
          rawBones: rawBones,
          bones: []
        };
      }

      // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
    }, {
      key: "parseMorphTargets",
      value: function parseMorphTargets(relationships, deformerNodes) {
        var rawMorphTargets = [];
        for (var i = 0; i < relationships.children.length; i++) {
          var child = relationships.children[i];
          var morphTargetNode = deformerNodes[child.ID];
          var rawMorphTarget = {
            name: morphTargetNode.attrName,
            initialWeight: morphTargetNode.DeformPercent,
            id: morphTargetNode.id,
            fullWeights: morphTargetNode.FullWeights.a
          };
          if (morphTargetNode.attrType !== 'BlendShapeChannel') return;
          rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {
            return child.relationship === undefined;
          })[0].ID;
          rawMorphTargets.push(rawMorphTarget);
        }
        return rawMorphTargets;
      }

      // create the main Group() to be returned by the loader
    }, {
      key: "parseScene",
      value: function parseScene(deformers, geometryMap, materialMap) {
        sceneGraph = new Group$1();
        var modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
        var modelNodes = fbxTree.Objects.Model;
        var scope = this;
        modelMap.forEach(function (model) {
          var modelNode = modelNodes[model.ID];
          scope.setLookAtProperties(model, modelNode);
          var parentConnections = connections.get(model.ID).parents;
          parentConnections.forEach(function (connection) {
            var parent = modelMap.get(connection.ID);
            if (parent !== undefined) parent.add(model);
          });
          if (model.parent === null) {
            sceneGraph.add(model);
          }
        });
        this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
        this.createAmbientLight();
        sceneGraph.traverse(function (node) {
          if (node.userData.transformData) {
            if (node.parent) {
              node.userData.transformData.parentMatrix = node.parent.matrix;
              node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
            }
            var transform = generateTransform(node.userData.transformData);
            node.applyMatrix4(transform);
            node.updateWorldMatrix();
          }
        });
        var animations = new AnimationParser().parse();

        // if all the models where already combined in a single group, just return that
        if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
          sceneGraph.children[0].animations = animations;
          sceneGraph = sceneGraph.children[0];
        }
        sceneGraph.animations = animations;
      }

      // parse nodes in FBXTree.Objects.Model
    }, {
      key: "parseModels",
      value: function parseModels(skeletons, geometryMap, materialMap) {
        var modelMap = new Map();
        var modelNodes = fbxTree.Objects.Model;
        for (var nodeID in modelNodes) {
          var id = parseInt(nodeID);
          var node = modelNodes[nodeID];
          var relationships = connections.get(id);
          var model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
          if (!model) {
            switch (node.attrType) {
              case 'Camera':
                model = this.createCamera(relationships);
                break;
              case 'Light':
                model = this.createLight(relationships);
                break;
              case 'Mesh':
                model = this.createMesh(relationships, geometryMap, materialMap);
                break;
              case 'NurbsCurve':
                model = this.createCurve(relationships, geometryMap);
                break;
              case 'LimbNode':
              case 'Root':
                model = new Bone();
                break;
              case 'Null':
              default:
                model = new Group$1();
                break;
            }
            model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : '';
            model.ID = id;
          }
          this.getTransformData(model, node);
          modelMap.set(id, model);
        }
        return modelMap;
      }
    }, {
      key: "buildSkeleton",
      value: function buildSkeleton(relationships, skeletons, id, name) {
        var bone = null;
        relationships.parents.forEach(function (parent) {
          var _loop = function _loop() {
            var skeleton = skeletons[ID];
            skeleton.rawBones.forEach(function (rawBone, i) {
              if (rawBone.ID === parent.ID) {
                var subBone = bone;
                bone = new Bone();
                bone.matrixWorld.copy(rawBone.transformLink);

                // set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

                bone.name = name ? PropertyBinding.sanitizeNodeName(name) : '';
                bone.ID = id;
                skeleton.bones[i] = bone;

                // In cases where a bone is shared between multiple meshes
                // duplicate the bone here and and it as a child of the first bone
                if (subBone !== null) {
                  bone.add(subBone);
                }
              }
            });
          };
          for (var ID in skeletons) {
            _loop();
          }
        });
        return bone;
      }

      // create a PerspectiveCamera or OrthographicCamera
    }, {
      key: "createCamera",
      value: function createCamera(relationships) {
        var model;
        var cameraAttribute;
        relationships.children.forEach(function (child) {
          var attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== undefined) {
            cameraAttribute = attr;
          }
        });
        if (cameraAttribute === undefined) {
          model = new Object3D$1();
        } else {
          var type = 0;
          if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {
            type = 1;
          }
          var nearClippingPlane = 1;
          if (cameraAttribute.NearPlane !== undefined) {
            nearClippingPlane = cameraAttribute.NearPlane.value / 1000;
          }
          var farClippingPlane = 1000;
          if (cameraAttribute.FarPlane !== undefined) {
            farClippingPlane = cameraAttribute.FarPlane.value / 1000;
          }
          var width = window.innerWidth;
          var height = window.innerHeight;
          if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {
            width = cameraAttribute.AspectWidth.value;
            height = cameraAttribute.AspectHeight.value;
          }
          var aspect = width / height;
          var fov = 45;
          if (cameraAttribute.FieldOfView !== undefined) {
            fov = cameraAttribute.FieldOfView.value;
          }
          var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
          switch (type) {
            case 0:
              // Perspective
              model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
              if (focalLength !== null) model.setFocalLength(focalLength);
              break;
            case 1:
              // Orthographic
              model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
              break;
            default:
              console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');
              model = new Object3D$1();
              break;
          }
        }
        return model;
      }

      // Create a DirectionalLight, PointLight or SpotLight
    }, {
      key: "createLight",
      value: function createLight(relationships) {
        var model;
        var lightAttribute;
        relationships.children.forEach(function (child) {
          var attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== undefined) {
            lightAttribute = attr;
          }
        });
        if (lightAttribute === undefined) {
          model = new Object3D$1();
        } else {
          var type;

          // LightType can be undefined for Point lights
          if (lightAttribute.LightType === undefined) {
            type = 0;
          } else {
            type = lightAttribute.LightType.value;
          }
          var color = 0xffffff;
          if (lightAttribute.Color !== undefined) {
            color = new Color$2().fromArray(lightAttribute.Color.value);
          }
          var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;

          // light disabled
          if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {
            intensity = 0;
          }
          var distance = 0;
          if (lightAttribute.FarAttenuationEnd !== undefined) {
            if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {
              distance = 0;
            } else {
              distance = lightAttribute.FarAttenuationEnd.value;
            }
          }

          // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
          var decay = 1;
          switch (type) {
            case 0:
              // Point
              model = new PointLight(color, intensity, distance, decay);
              break;
            case 1:
              // Directional
              model = new DirectionalLight(color, intensity);
              break;
            case 2:
              // Spot
              var angle = Math.PI / 3;
              if (lightAttribute.InnerAngle !== undefined) {
                angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
              }
              var penumbra = 0;
              if (lightAttribute.OuterAngle !== undefined) {
                // TODO: this is not correct - FBX calculates outer and inner angle in degrees
                // with OuterAngle > InnerAngle && OuterAngle <= Math.PI
                // while three.js uses a penumbra between (0, 1) to attenuate the inner angle
                penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
                penumbra = Math.max(penumbra, 1);
              }
              model = new SpotLight(color, intensity, distance, angle, penumbra, decay);
              break;
            default:
              console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.');
              model = new PointLight(color, intensity);
              break;
          }
          if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {
            model.castShadow = true;
          }
        }
        return model;
      }
    }, {
      key: "createMesh",
      value: function createMesh(relationships, geometryMap, materialMap) {
        var model;
        var geometry = null;
        var material = null;
        var materials = [];

        // get geometry and materials(s) from connections
        relationships.children.forEach(function (child) {
          if (geometryMap.has(child.ID)) {
            geometry = geometryMap.get(child.ID);
          }
          if (materialMap.has(child.ID)) {
            materials.push(materialMap.get(child.ID));
          }
        });
        if (materials.length > 1) {
          material = materials;
        } else if (materials.length > 0) {
          material = materials[0];
        } else {
          material = new MeshPhongMaterial({
            color: 0xcccccc
          });
          materials.push(material);
        }
        if ('color' in geometry.attributes) {
          materials.forEach(function (material) {
            material.vertexColors = true;
          });
        }
        if (geometry.FBX_Deformer) {
          model = new SkinnedMesh(geometry, material);
          model.normalizeSkinWeights();
        } else {
          model = new Mesh(geometry, material);
        }
        return model;
      }
    }, {
      key: "createCurve",
      value: function createCurve(relationships, geometryMap) {
        var geometry = relationships.children.reduce(function (geo, child) {
          if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);
          return geo;
        }, null);

        // FBX does not list materials for Nurbs lines, so we'll just put our own in here.
        var material = new LineBasicMaterial({
          color: 0x3300ff,
          linewidth: 1
        });
        return new Line(geometry, material);
      }

      // parse the model node for transform data
    }, {
      key: "getTransformData",
      value: function getTransformData(model, modelNode) {
        var transformData = {};
        if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';
        if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
        if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;
        if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
        if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;
        if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
        if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
        if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
        if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
        if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;
        model.userData.transformData = transformData;
      }
    }, {
      key: "setLookAtProperties",
      value: function setLookAtProperties(model, modelNode) {
        if ('LookAtProperty' in modelNode) {
          var children = connections.get(model.ID).children;
          children.forEach(function (child) {
            if (child.relationship === 'LookAtProperty') {
              var lookAtTarget = fbxTree.Objects.Model[child.ID];
              if ('Lcl_Translation' in lookAtTarget) {
                var pos = lookAtTarget.Lcl_Translation.value;

                // DirectionalLight, SpotLight
                if (model.target !== undefined) {
                  model.target.position.fromArray(pos);
                  sceneGraph.add(model.target);
                } else {
                  // Cameras and other Object3Ds

                  model.lookAt(new Vector3().fromArray(pos));
                }
              }
            }
          });
        }
      }
    }, {
      key: "bindSkeleton",
      value: function bindSkeleton(skeletons, geometryMap, modelMap) {
        var bindMatrices = this.parsePoseNodes();
        var _loop2 = function _loop2() {
          var skeleton = skeletons[ID];
          var parents = connections.get(parseInt(skeleton.ID)).parents;
          parents.forEach(function (parent) {
            if (geometryMap.has(parent.ID)) {
              var geoID = parent.ID;
              var geoRelationships = connections.get(geoID);
              geoRelationships.parents.forEach(function (geoConnParent) {
                if (modelMap.has(geoConnParent.ID)) {
                  var model = modelMap.get(geoConnParent.ID);
                  model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
                }
              });
            }
          });
        };
        for (var ID in skeletons) {
          _loop2();
        }
      }
    }, {
      key: "parsePoseNodes",
      value: function parsePoseNodes() {
        var bindMatrices = {};
        if ('Pose' in fbxTree.Objects) {
          var BindPoseNode = fbxTree.Objects.Pose;
          for (var nodeID in BindPoseNode) {
            if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {
              var poseNodes = BindPoseNode[nodeID].PoseNode;
              if (Array.isArray(poseNodes)) {
                poseNodes.forEach(function (poseNode) {
                  bindMatrices[poseNode.Node] = new Matrix4$1().fromArray(poseNode.Matrix.a);
                });
              } else {
                bindMatrices[poseNodes.Node] = new Matrix4$1().fromArray(poseNodes.Matrix.a);
              }
            }
          }
        }
        return bindMatrices;
      }

      // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
    }, {
      key: "createAmbientLight",
      value: function createAmbientLight() {
        if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {
          var ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
          var r = ambientColor[0];
          var g = ambientColor[1];
          var b = ambientColor[2];
          if (r !== 0 || g !== 0 || b !== 0) {
            var color = new Color$2(r, g, b);
            sceneGraph.add(new AmbientLight(color, 1));
          }
        }
      }
    }]);
    return FBXTreeParser;
  }(); // parse Geometry data from FBXTree and return map of BufferGeometries
  var GeometryParser = /*#__PURE__*/function () {
    function GeometryParser() {
      _classCallCheck(this, GeometryParser);
    }
    _createClass(GeometryParser, [{
      key: "parse",
      value:
      // Parse nodes in FBXTree.Objects.Geometry
      function parse(deformers) {
        var geometryMap = new Map();
        if ('Geometry' in fbxTree.Objects) {
          var geoNodes = fbxTree.Objects.Geometry;
          for (var nodeID in geoNodes) {
            var relationships = connections.get(parseInt(nodeID));
            var geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
            geometryMap.set(parseInt(nodeID), geo);
          }
        }
        return geometryMap;
      }

      // Parse single node in FBXTree.Objects.Geometry
    }, {
      key: "parseGeometry",
      value: function parseGeometry(relationships, geoNode, deformers) {
        switch (geoNode.attrType) {
          case 'Mesh':
            return this.parseMeshGeometry(relationships, geoNode, deformers);
          case 'NurbsCurve':
            return this.parseNurbsGeometry(geoNode);
        }
      }

      // Parse single node mesh geometry in FBXTree.Objects.Geometry
    }, {
      key: "parseMeshGeometry",
      value: function parseMeshGeometry(relationships, geoNode, deformers) {
        var skeletons = deformers.skeletons;
        var morphTargets = [];
        var modelNodes = relationships.parents.map(function (parent) {
          return fbxTree.Objects.Model[parent.ID];
        });

        // don't create geometry if it is not associated with any models
        if (modelNodes.length === 0) return;
        var skeleton = relationships.children.reduce(function (skeleton, child) {
          if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];
          return skeleton;
        }, null);
        relationships.children.forEach(function (child) {
          if (deformers.morphTargets[child.ID] !== undefined) {
            morphTargets.push(deformers.morphTargets[child.ID]);
          }
        });

        // Assume one model and get the preRotation from that
        // if there is more than one model associated with the geometry this may cause problems
        var modelNode = modelNodes[0];
        var transformData = {};
        if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value;
        if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value;
        if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value;
        var transform = generateTransform(transformData);
        return this.genGeometry(geoNode, skeleton, morphTargets, transform);
      }

      // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
    }, {
      key: "genGeometry",
      value: function genGeometry(geoNode, skeleton, morphTargets, preTransform) {
        var geo = new BufferGeometry();
        if (geoNode.attrName) geo.name = geoNode.attrName;
        var geoInfo = this.parseGeoNode(geoNode, skeleton);
        var buffers = this.genBuffers(geoInfo);
        var positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
        positionAttribute.applyMatrix4(preTransform);
        geo.setAttribute('position', positionAttribute);
        if (buffers.colors.length > 0) {
          geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3));
        }
        if (skeleton) {
          geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4));
          geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4));

          // used later to bind the skeleton to the model
          geo.FBX_Deformer = skeleton;
        }
        if (buffers.normal.length > 0) {
          var normalMatrix = new Matrix3$1().getNormalMatrix(preTransform);
          var normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
          normalAttribute.applyNormalMatrix(normalMatrix);
          geo.setAttribute('normal', normalAttribute);
        }
        buffers.uvs.forEach(function (uvBuffer, i) {
          // subsequent uv buffers are called 'uv1', 'uv2', ...
          var name = 'uv' + (i + 1).toString();

          // the first uv buffer is just called 'uv'
          if (i === 0) {
            name = 'uv';
          }
          geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));
        });
        if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
          // Convert the material indices of each vertex into rendering groups on the geometry.
          var prevMaterialIndex = buffers.materialIndex[0];
          var startIndex = 0;
          buffers.materialIndex.forEach(function (currentIndex, i) {
            if (currentIndex !== prevMaterialIndex) {
              geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
              prevMaterialIndex = currentIndex;
              startIndex = i;
            }
          });

          // the loop above doesn't add the last group, do that here.
          if (geo.groups.length > 0) {
            var lastGroup = geo.groups[geo.groups.length - 1];
            var lastIndex = lastGroup.start + lastGroup.count;
            if (lastIndex !== buffers.materialIndex.length) {
              geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
            }
          }

          // case where there are multiple materials but the whole geometry is only
          // using one of them
          if (geo.groups.length === 0) {
            geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
          }
        }
        this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
        return geo;
      }
    }, {
      key: "parseGeoNode",
      value: function parseGeoNode(geoNode, skeleton) {
        var geoInfo = {};
        geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];
        geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];
        if (geoNode.LayerElementColor) {
          geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
        }
        if (geoNode.LayerElementMaterial) {
          geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
        }
        if (geoNode.LayerElementNormal) {
          geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
        }
        if (geoNode.LayerElementUV) {
          geoInfo.uv = [];
          var i = 0;
          while (geoNode.LayerElementUV[i]) {
            if (geoNode.LayerElementUV[i].UV) {
              geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
            }
            i++;
          }
        }
        geoInfo.weightTable = {};
        if (skeleton !== null) {
          geoInfo.skeleton = skeleton;
          skeleton.rawBones.forEach(function (rawBone, i) {
            // loop over the bone's vertex indices and weights
            rawBone.indices.forEach(function (index, j) {
              if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];
              geoInfo.weightTable[index].push({
                id: i,
                weight: rawBone.weights[j]
              });
            });
          });
        }
        return geoInfo;
      }
    }, {
      key: "genBuffers",
      value: function genBuffers(geoInfo) {
        var buffers = {
          vertex: [],
          normal: [],
          colors: [],
          uvs: [],
          materialIndex: [],
          vertexWeights: [],
          weightsIndices: []
        };
        var polygonIndex = 0;
        var faceLength = 0;
        var displayedWeightsWarning = false;

        // these will hold data for a single face
        var facePositionIndexes = [];
        var faceNormals = [];
        var faceColors = [];
        var faceUVs = [];
        var faceWeights = [];
        var faceWeightIndices = [];
        var scope = this;
        geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {
          var materialIndex;
          var endOfFace = false;

          // Face index and vertex index arrays are combined in a single array
          // A cube with quad faces looks like this:
          // PolygonVertexIndex: *24 {
          //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
          //  }
          // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
          // to find index of last vertex bit shift the index: ^ - 1
          if (vertexIndex < 0) {
            vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1
            endOfFace = true;
          }
          var weightIndices = [];
          var weights = [];
          facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
          if (geoInfo.color) {
            var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
            faceColors.push(data[0], data[1], data[2]);
          }
          if (geoInfo.skeleton) {
            if (geoInfo.weightTable[vertexIndex] !== undefined) {
              geoInfo.weightTable[vertexIndex].forEach(function (wt) {
                weights.push(wt.weight);
                weightIndices.push(wt.id);
              });
            }
            if (weights.length > 4) {
              if (!displayedWeightsWarning) {
                console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');
                displayedWeightsWarning = true;
              }
              var wIndex = [0, 0, 0, 0];
              var Weight = [0, 0, 0, 0];
              weights.forEach(function (weight, weightIndex) {
                var currentWeight = weight;
                var currentIndex = weightIndices[weightIndex];
                Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {
                  if (currentWeight > comparedWeight) {
                    comparedWeightArray[comparedWeightIndex] = currentWeight;
                    currentWeight = comparedWeight;
                    var tmp = wIndex[comparedWeightIndex];
                    wIndex[comparedWeightIndex] = currentIndex;
                    currentIndex = tmp;
                  }
                });
              });
              weightIndices = wIndex;
              weights = Weight;
            }

            // if the weight array is shorter than 4 pad with 0s
            while (weights.length < 4) {
              weights.push(0);
              weightIndices.push(0);
            }
            for (var i = 0; i < 4; ++i) {
              faceWeights.push(weights[i]);
              faceWeightIndices.push(weightIndices[i]);
            }
          }
          if (geoInfo.normal) {
            var _data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
            faceNormals.push(_data[0], _data[1], _data[2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
            materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function (uv, i) {
              var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
              if (faceUVs[i] === undefined) {
                faceUVs[i] = [];
              }
              faceUVs[i].push(data[0]);
              faceUVs[i].push(data[1]);
            });
          }
          faceLength++;
          if (endOfFace) {
            scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
            polygonIndex++;
            faceLength = 0;

            // reset arrays for the next face
            facePositionIndexes = [];
            faceNormals = [];
            faceColors = [];
            faceUVs = [];
            faceWeights = [];
            faceWeightIndices = [];
          }
        });
        return buffers;
      }

      // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
    }, {
      key: "genFace",
      value: function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
        var _loop3 = function _loop3(i) {
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);
          if (geoInfo.skeleton) {
            buffers.vertexWeights.push(faceWeights[0]);
            buffers.vertexWeights.push(faceWeights[1]);
            buffers.vertexWeights.push(faceWeights[2]);
            buffers.vertexWeights.push(faceWeights[3]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);
            buffers.vertexWeights.push(faceWeights[i * 4]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[0]);
            buffers.weightsIndices.push(faceWeightIndices[1]);
            buffers.weightsIndices.push(faceWeightIndices[2]);
            buffers.weightsIndices.push(faceWeightIndices[3]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);
          }
          if (geoInfo.color) {
            buffers.colors.push(faceColors[0]);
            buffers.colors.push(faceColors[1]);
            buffers.colors.push(faceColors[2]);
            buffers.colors.push(faceColors[(i - 1) * 3]);
            buffers.colors.push(faceColors[(i - 1) * 3 + 1]);
            buffers.colors.push(faceColors[(i - 1) * 3 + 2]);
            buffers.colors.push(faceColors[i * 3]);
            buffers.colors.push(faceColors[i * 3 + 1]);
            buffers.colors.push(faceColors[i * 3 + 2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
          }
          if (geoInfo.normal) {
            buffers.normal.push(faceNormals[0]);
            buffers.normal.push(faceNormals[1]);
            buffers.normal.push(faceNormals[2]);
            buffers.normal.push(faceNormals[(i - 1) * 3]);
            buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);
            buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);
            buffers.normal.push(faceNormals[i * 3]);
            buffers.normal.push(faceNormals[i * 3 + 1]);
            buffers.normal.push(faceNormals[i * 3 + 2]);
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function (uv, j) {
              if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];
              buffers.uvs[j].push(faceUVs[j][0]);
              buffers.uvs[j].push(faceUVs[j][1]);
              buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);
              buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);
              buffers.uvs[j].push(faceUVs[j][i * 2]);
              buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);
            });
          }
        };
        for (var i = 2; i < faceLength; i++) {
          _loop3(i);
        }
      }
    }, {
      key: "addMorphTargets",
      value: function addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
        if (morphTargets.length === 0) return;
        parentGeo.morphTargetsRelative = true;
        parentGeo.morphAttributes.position = [];
        // parentGeo.morphAttributes.normal = []; // not implemented

        var scope = this;
        morphTargets.forEach(function (morphTarget) {
          morphTarget.rawTargets.forEach(function (rawTarget) {
            var morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
            if (morphGeoNode !== undefined) {
              scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
            }
          });
        });
      }

      // a morph geometry node is similar to a standard  node, and the node is also contained
      // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
      // and a special attribute Index defining which vertices of the original geometry are affected
      // Normal and position attributes only have data for the vertices that are affected by the morph
    }, {
      key: "genMorphGeometry",
      value: function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
        var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];
        var morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];
        var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];
        var length = parentGeo.attributes.position.count * 3;
        var morphPositions = new Float32Array(length);
        for (var i = 0; i < indices.length; i++) {
          var morphIndex = indices[i] * 3;
          morphPositions[morphIndex] = morphPositionsSparse[i * 3];
          morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
          morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
        }

        // TODO: add morph normal support
        var morphGeoInfo = {
          vertexIndices: vertexIndices,
          vertexPositions: morphPositions
        };
        var morphBuffers = this.genBuffers(morphGeoInfo);
        var positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
        positionAttribute.name = name || morphGeoNode.attrName;
        positionAttribute.applyMatrix4(preTransform);
        parentGeo.morphAttributes.position.push(positionAttribute);
      }

      // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
    }, {
      key: "parseNormals",
      value: function parseNormals(NormalNode) {
        var mappingType = NormalNode.MappingInformationType;
        var referenceType = NormalNode.ReferenceInformationType;
        var buffer = NormalNode.Normals.a;
        var indexBuffer = [];
        if (referenceType === 'IndexToDirect') {
          if ('NormalIndex' in NormalNode) {
            indexBuffer = NormalNode.NormalIndex.a;
          } else if ('NormalsIndex' in NormalNode) {
            indexBuffer = NormalNode.NormalsIndex.a;
          }
        }
        return {
          dataSize: 3,
          buffer: buffer,
          indices: indexBuffer,
          mappingType: mappingType,
          referenceType: referenceType
        };
      }

      // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
    }, {
      key: "parseUVs",
      value: function parseUVs(UVNode) {
        var mappingType = UVNode.MappingInformationType;
        var referenceType = UVNode.ReferenceInformationType;
        var buffer = UVNode.UV.a;
        var indexBuffer = [];
        if (referenceType === 'IndexToDirect') {
          indexBuffer = UVNode.UVIndex.a;
        }
        return {
          dataSize: 2,
          buffer: buffer,
          indices: indexBuffer,
          mappingType: mappingType,
          referenceType: referenceType
        };
      }

      // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
    }, {
      key: "parseVertexColors",
      value: function parseVertexColors(ColorNode) {
        var mappingType = ColorNode.MappingInformationType;
        var referenceType = ColorNode.ReferenceInformationType;
        var buffer = ColorNode.Colors.a;
        var indexBuffer = [];
        if (referenceType === 'IndexToDirect') {
          indexBuffer = ColorNode.ColorIndex.a;
        }
        return {
          dataSize: 4,
          buffer: buffer,
          indices: indexBuffer,
          mappingType: mappingType,
          referenceType: referenceType
        };
      }

      // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
    }, {
      key: "parseMaterialIndices",
      value: function parseMaterialIndices(MaterialNode) {
        var mappingType = MaterialNode.MappingInformationType;
        var referenceType = MaterialNode.ReferenceInformationType;
        if (mappingType === 'NoMappingInformation') {
          return {
            dataSize: 1,
            buffer: [0],
            indices: [0],
            mappingType: 'AllSame',
            referenceType: referenceType
          };
        }
        var materialIndexBuffer = MaterialNode.Materials.a;

        // Since materials are stored as indices, there's a bit of a mismatch between FBX and what
        // we expect.So we create an intermediate buffer that points to the index in the buffer,
        // for conforming with the other functions we've written for other data.
        var materialIndices = [];
        for (var i = 0; i < materialIndexBuffer.length; ++i) {
          materialIndices.push(i);
        }
        return {
          dataSize: 1,
          buffer: materialIndexBuffer,
          indices: materialIndices,
          mappingType: mappingType,
          referenceType: referenceType
        };
      }

      // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
    }, {
      key: "parseNurbsGeometry",
      value: function parseNurbsGeometry(geoNode) {
        if (NURBSCurve === undefined) {
          console.error('THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');
          return new BufferGeometry();
        }
        var order = parseInt(geoNode.Order);
        if (isNaN(order)) {
          console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);
          return new BufferGeometry();
        }
        var degree = order - 1;
        var knots = geoNode.KnotVector.a;
        var controlPoints = [];
        var pointsValues = geoNode.Points.a;
        for (var i = 0, l = pointsValues.length; i < l; i += 4) {
          controlPoints.push(new Vector4().fromArray(pointsValues, i));
        }
        var startKnot, endKnot;
        if (geoNode.Form === 'Closed') {
          controlPoints.push(controlPoints[0]);
        } else if (geoNode.Form === 'Periodic') {
          startKnot = degree;
          endKnot = knots.length - 1 - startKnot;
          for (var _i = 0; _i < degree; ++_i) {
            controlPoints.push(controlPoints[_i]);
          }
        }
        var curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
        var points = curve.getPoints(controlPoints.length * 12);
        return new BufferGeometry().setFromPoints(points);
      }
    }]);
    return GeometryParser;
  }(); // parse animation data from FBXTree
  var AnimationParser = /*#__PURE__*/function () {
    function AnimationParser() {
      _classCallCheck(this, AnimationParser);
    }
    _createClass(AnimationParser, [{
      key: "parse",
      value:
      // take raw animation clips and turn them into three.js animation clips
      function parse() {
        var animationClips = [];
        var rawClips = this.parseClips();
        if (rawClips !== undefined) {
          for (var key in rawClips) {
            var rawClip = rawClips[key];
            var clip = this.addClip(rawClip);
            animationClips.push(clip);
          }
        }
        return animationClips;
      }
    }, {
      key: "parseClips",
      value: function parseClips() {
        // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
        // if this is undefined we can safely assume there are no animations
        if (fbxTree.Objects.AnimationCurve === undefined) return undefined;
        var curveNodesMap = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(curveNodesMap);
        var layersMap = this.parseAnimationLayers(curveNodesMap);
        var rawClips = this.parseAnimStacks(layersMap);
        return rawClips;
      }

      // parse nodes in FBXTree.Objects.AnimationCurveNode
      // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
      // and is referenced by an AnimationLayer
    }, {
      key: "parseAnimationCurveNodes",
      value: function parseAnimationCurveNodes() {
        var rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
        var curveNodesMap = new Map();
        for (var nodeID in rawCurveNodes) {
          var rawCurveNode = rawCurveNodes[nodeID];
          if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
            var curveNode = {
              id: rawCurveNode.id,
              attr: rawCurveNode.attrName,
              curves: {}
            };
            curveNodesMap.set(curveNode.id, curveNode);
          }
        }
        return curveNodesMap;
      }

      // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
      // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
      // axis ( e.g. times and values of x rotation)
    }, {
      key: "parseAnimationCurves",
      value: function parseAnimationCurves(curveNodesMap) {
        var rawCurves = fbxTree.Objects.AnimationCurve;

        // TODO: Many values are identical up to roundoff error, but won't be optimised
        // e.g. position times: [0, 0.4, 0. 8]
        // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
        // clearly, this should be optimised to
        // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
        // this shows up in nearly every FBX file, and generally time array is length > 100

        for (var nodeID in rawCurves) {
          var animationCurve = {
            id: rawCurves[nodeID].id,
            times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
            values: rawCurves[nodeID].KeyValueFloat.a
          };
          var relationships = connections.get(animationCurve.id);
          if (relationships !== undefined) {
            var animationCurveID = relationships.parents[0].ID;
            var animationCurveRelationship = relationships.parents[0].relationship;
            if (animationCurveRelationship.match(/X/)) {
              curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;
            } else if (animationCurveRelationship.match(/Y/)) {
              curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;
            } else if (animationCurveRelationship.match(/Z/)) {
              curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;
            } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
              curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve;
            }
          }
        }
      }

      // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
      // to various AnimationCurveNodes and is referenced by an AnimationStack node
      // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
    }, {
      key: "parseAnimationLayers",
      value: function parseAnimationLayers(curveNodesMap) {
        var rawLayers = fbxTree.Objects.AnimationLayer;
        var layersMap = new Map();
        var _loop4 = function _loop4() {
          var layerCurveNodes = [];
          var connection = connections.get(parseInt(nodeID));
          if (connection !== undefined) {
            // all the animationCurveNodes used in the layer
            var children = connection.children;
            children.forEach(function (child, i) {
              if (curveNodesMap.has(child.ID)) {
                var curveNode = curveNodesMap.get(child.ID);

                // check that the curves are defined for at least one axis, otherwise ignore the curveNode
                if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {
                  if (layerCurveNodes[i] === undefined) {
                    var modelID = connections.get(child.ID).parents.filter(function (parent) {
                      return parent.relationship !== undefined;
                    })[0].ID;
                    if (modelID !== undefined) {
                      var rawModel = fbxTree.Objects.Model[modelID.toString()];
                      if (rawModel === undefined) {
                        console.warn('THREE.FBXLoader: Encountered a unused curve.', child);
                        return;
                      }
                      var node = {
                        modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',
                        ID: rawModel.id,
                        initialPosition: [0, 0, 0],
                        initialRotation: [0, 0, 0],
                        initialScale: [1, 1, 1]
                      };
                      sceneGraph.traverse(function (child) {
                        if (child.ID === rawModel.id) {
                          node.transform = child.matrix;
                          if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;
                        }
                      });
                      if (!node.transform) node.transform = new Matrix4$1();

                      // if the animated model is pre rotated, we'll have to apply the pre rotations to every
                      // animation value as well
                      if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value;
                      if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value;
                      layerCurveNodes[i] = node;
                    }
                  }
                  if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;
                } else if (curveNode.curves.morph !== undefined) {
                  if (layerCurveNodes[i] === undefined) {
                    var deformerID = connections.get(child.ID).parents.filter(function (parent) {
                      return parent.relationship !== undefined;
                    })[0].ID;
                    var morpherID = connections.get(deformerID).parents[0].ID;
                    var geoID = connections.get(morpherID).parents[0].ID;

                    // assuming geometry is not used in more than one model
                    var _modelID = connections.get(geoID).parents[0].ID;
                    var _rawModel = fbxTree.Objects.Model[_modelID];
                    var _node = {
                      modelName: _rawModel.attrName ? PropertyBinding.sanitizeNodeName(_rawModel.attrName) : '',
                      morphName: fbxTree.Objects.Deformer[deformerID].attrName
                    };
                    layerCurveNodes[i] = _node;
                  }
                  layerCurveNodes[i][curveNode.attr] = curveNode;
                }
              }
            });
            layersMap.set(parseInt(nodeID), layerCurveNodes);
          }
        };
        for (var nodeID in rawLayers) {
          _loop4();
        }
        return layersMap;
      }

      // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
      // hierarchy. Each Stack node will be used to create a AnimationClip
    }, {
      key: "parseAnimStacks",
      value: function parseAnimStacks(layersMap) {
        var rawStacks = fbxTree.Objects.AnimationStack;

        // connect the stacks (clips) up to the layers
        var rawClips = {};
        for (var nodeID in rawStacks) {
          var children = connections.get(parseInt(nodeID)).children;
          if (children.length > 1) {
            // it seems like stacks will always be associated with a single layer. But just in case there are files
            // where there are multiple layers per stack, we'll display a warning
            console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');
          }
          var layer = layersMap.get(children[0].ID);
          rawClips[nodeID] = {
            name: rawStacks[nodeID].attrName,
            layer: layer
          };
        }
        return rawClips;
      }
    }, {
      key: "addClip",
      value: function addClip(rawClip) {
        var tracks = [];
        var scope = this;
        rawClip.layer.forEach(function (rawTracks) {
          tracks = tracks.concat(scope.generateTracks(rawTracks));
        });
        return new AnimationClip(rawClip.name, -1, tracks);
      }
    }, {
      key: "generateTracks",
      value: function generateTracks(rawTracks) {
        var tracks = [];
        var initialPosition = new Vector3();
        var initialRotation = new Quaternion();
        var initialScale = new Vector3();
        if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
        initialPosition = initialPosition.toArray();
        initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
        initialScale = initialScale.toArray();
        if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {
          var positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position');
          if (positionTrack !== undefined) tracks.push(positionTrack);
        }
        if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {
          var rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
          if (rotationTrack !== undefined) tracks.push(rotationTrack);
        }
        if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {
          var scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale');
          if (scaleTrack !== undefined) tracks.push(scaleTrack);
        }
        if (rawTracks.DeformPercent !== undefined) {
          var morphTrack = this.generateMorphTrack(rawTracks);
          if (morphTrack !== undefined) tracks.push(morphTrack);
        }
        return tracks;
      }
    }, {
      key: "generateVectorTrack",
      value: function generateVectorTrack(modelName, curves, initialValue, type) {
        var times = this.getTimesForAllAxes(curves);
        var values = this.getKeyframeTrackValues(times, curves, initialValue);
        return new VectorKeyframeTrack(modelName + '.' + type, times, values);
      }
    }, {
      key: "generateRotationTrack",
      value: function generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
        if (curves.x !== undefined) {
          this.interpolateRotations(curves.x);
          curves.x.values = curves.x.values.map(MathUtils.degToRad);
        }
        if (curves.y !== undefined) {
          this.interpolateRotations(curves.y);
          curves.y.values = curves.y.values.map(MathUtils.degToRad);
        }
        if (curves.z !== undefined) {
          this.interpolateRotations(curves.z);
          curves.z.values = curves.z.values.map(MathUtils.degToRad);
        }
        var times = this.getTimesForAllAxes(curves);
        var values = this.getKeyframeTrackValues(times, curves, initialValue);
        if (preRotation !== undefined) {
          preRotation = preRotation.map(MathUtils.degToRad);
          preRotation.push(eulerOrder);
          preRotation = new Euler().fromArray(preRotation);
          preRotation = new Quaternion().setFromEuler(preRotation);
        }
        if (postRotation !== undefined) {
          postRotation = postRotation.map(MathUtils.degToRad);
          postRotation.push(eulerOrder);
          postRotation = new Euler().fromArray(postRotation);
          postRotation = new Quaternion().setFromEuler(postRotation).invert();
        }
        var quaternion = new Quaternion();
        var euler = new Euler();
        var quaternionValues = [];
        for (var i = 0; i < values.length; i += 3) {
          euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
          quaternion.setFromEuler(euler);
          if (preRotation !== undefined) quaternion.premultiply(preRotation);
          if (postRotation !== undefined) quaternion.multiply(postRotation);
          quaternion.toArray(quaternionValues, i / 3 * 4);
        }
        return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);
      }
    }, {
      key: "generateMorphTrack",
      value: function generateMorphTrack(rawTracks) {
        var curves = rawTracks.DeformPercent.curves.morph;
        var values = curves.values.map(function (val) {
          return val / 100;
        });
        var morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
        return new NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values);
      }

      // For all animated objects, times are defined separately for each axis
      // Here we'll combine the times into one sorted array without duplicates
    }, {
      key: "getTimesForAllAxes",
      value: function getTimesForAllAxes(curves) {
        var times = [];

        // first join together the times for each axis, if defined
        if (curves.x !== undefined) times = times.concat(curves.x.times);
        if (curves.y !== undefined) times = times.concat(curves.y.times);
        if (curves.z !== undefined) times = times.concat(curves.z.times);

        // then sort them
        times = times.sort(function (a, b) {
          return a - b;
        });

        // and remove duplicates
        if (times.length > 1) {
          var targetIndex = 1;
          var lastValue = times[0];
          for (var i = 1; i < times.length; i++) {
            var currentValue = times[i];
            if (currentValue !== lastValue) {
              times[targetIndex] = currentValue;
              lastValue = currentValue;
              targetIndex++;
            }
          }
          times = times.slice(0, targetIndex);
        }
        return times;
      }
    }, {
      key: "getKeyframeTrackValues",
      value: function getKeyframeTrackValues(times, curves, initialValue) {
        var prevValue = initialValue;
        var values = [];
        var xIndex = -1;
        var yIndex = -1;
        var zIndex = -1;
        times.forEach(function (time) {
          if (curves.x) xIndex = curves.x.times.indexOf(time);
          if (curves.y) yIndex = curves.y.times.indexOf(time);
          if (curves.z) zIndex = curves.z.times.indexOf(time);

          // if there is an x value defined for this frame, use that
          if (xIndex !== -1) {
            var xValue = curves.x.values[xIndex];
            values.push(xValue);
            prevValue[0] = xValue;
          } else {
            // otherwise use the x value from the previous frame
            values.push(prevValue[0]);
          }
          if (yIndex !== -1) {
            var yValue = curves.y.values[yIndex];
            values.push(yValue);
            prevValue[1] = yValue;
          } else {
            values.push(prevValue[1]);
          }
          if (zIndex !== -1) {
            var zValue = curves.z.values[zIndex];
            values.push(zValue);
            prevValue[2] = zValue;
          } else {
            values.push(prevValue[2]);
          }
        });
        return values;
      }

      // Rotations are defined as Euler angles which can have values  of any size
      // These will be converted to quaternions which don't support values greater than
      // PI, so we'll interpolate large rotations
    }, {
      key: "interpolateRotations",
      value: function interpolateRotations(curve) {
        for (var i = 1; i < curve.values.length; i++) {
          var initialValue = curve.values[i - 1];
          var valuesSpan = curve.values[i] - initialValue;
          var absoluteSpan = Math.abs(valuesSpan);
          if (absoluteSpan >= 180) {
            var numSubIntervals = absoluteSpan / 180;
            var step = valuesSpan / numSubIntervals;
            var nextValue = initialValue + step;
            var initialTime = curve.times[i - 1];
            var timeSpan = curve.times[i] - initialTime;
            var interval = timeSpan / numSubIntervals;
            var nextTime = initialTime + interval;
            var interpolatedTimes = [];
            var interpolatedValues = [];
            while (nextTime < curve.times[i]) {
              interpolatedTimes.push(nextTime);
              nextTime += interval;
              interpolatedValues.push(nextValue);
              nextValue += step;
            }
            curve.times = inject(curve.times, i, interpolatedTimes);
            curve.values = inject(curve.values, i, interpolatedValues);
          }
        }
      }
    }]);
    return AnimationParser;
  }(); // parse an FBX file in ASCII format
  var TextParser = /*#__PURE__*/function () {
    function TextParser() {
      _classCallCheck(this, TextParser);
    }
    _createClass(TextParser, [{
      key: "getPrevNode",
      value: function getPrevNode() {
        return this.nodeStack[this.currentIndent - 2];
      }
    }, {
      key: "getCurrentNode",
      value: function getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1];
      }
    }, {
      key: "getCurrentProp",
      value: function getCurrentProp() {
        return this.currentProp;
      }
    }, {
      key: "pushStack",
      value: function pushStack(node) {
        this.nodeStack.push(node);
        this.currentIndent += 1;
      }
    }, {
      key: "popStack",
      value: function popStack() {
        this.nodeStack.pop();
        this.currentIndent -= 1;
      }
    }, {
      key: "setCurrentProp",
      value: function setCurrentProp(val, name) {
        this.currentProp = val;
        this.currentPropName = name;
      }
    }, {
      key: "parse",
      value: function parse(text) {
        this.currentIndent = 0;
        this.allNodes = new FBXTree();
        this.nodeStack = [];
        this.currentProp = [];
        this.currentPropName = '';
        var scope = this;
        var split = text.split(/[\r\n]+/);
        split.forEach(function (line, i) {
          var matchComment = line.match(/^[\s\t]*;/);
          var matchEmpty = line.match(/^[\s\t]*$/);
          if (matchComment || matchEmpty) return;
          var matchBeginning = line.match('^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '');
          var matchProperty = line.match('^\\t{' + scope.currentIndent + '}(\\w+):[\\s\\t\\r\\n](.*)');
          var matchEnd = line.match('^\\t{' + (scope.currentIndent - 1) + '}}');
          if (matchBeginning) {
            scope.parseNodeBegin(line, matchBeginning);
          } else if (matchProperty) {
            scope.parseNodeProperty(line, matchProperty, split[++i]);
          } else if (matchEnd) {
            scope.popStack();
          } else if (line.match(/^[^\s\t}]/)) {
            // large arrays are split over multiple lines terminated with a ',' character
            // if this is encountered the line needs to be joined to the previous line
            scope.parseNodePropertyContinued(line);
          }
        });
        return this.allNodes;
      }
    }, {
      key: "parseNodeBegin",
      value: function parseNodeBegin(line, property) {
        var nodeName = property[1].trim().replace(/^"/, '').replace(/"$/, '');
        var nodeAttrs = property[2].split(',').map(function (attr) {
          return attr.trim().replace(/^"/, '').replace(/"$/, '');
        });
        var node = {
          name: nodeName
        };
        var attrs = this.parseNodeAttr(nodeAttrs);
        var currentNode = this.getCurrentNode();

        // a top node
        if (this.currentIndent === 0) {
          this.allNodes.add(nodeName, node);
        } else {
          // a subnode

          // if the subnode already exists, append it
          if (nodeName in currentNode) {
            // special case Pose needs PoseNodes as an array
            if (nodeName === 'PoseNode') {
              currentNode.PoseNode.push(node);
            } else if (currentNode[nodeName].id !== undefined) {
              currentNode[nodeName] = {};
              currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
            }
            if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;
          } else if (typeof attrs.id === 'number') {
            currentNode[nodeName] = {};
            currentNode[nodeName][attrs.id] = node;
          } else if (nodeName !== 'Properties70') {
            if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;
          }
        }
        if (typeof attrs.id === 'number') node.id = attrs.id;
        if (attrs.name !== '') node.attrName = attrs.name;
        if (attrs.type !== '') node.attrType = attrs.type;
        this.pushStack(node);
      }
    }, {
      key: "parseNodeAttr",
      value: function parseNodeAttr(attrs) {
        var id = attrs[0];
        if (attrs[0] !== '') {
          id = parseInt(attrs[0]);
          if (isNaN(id)) {
            id = attrs[0];
          }
        }
        var name = '',
          type = '';
        if (attrs.length > 1) {
          name = attrs[1].replace(/^(\w+)::/, '');
          type = attrs[2];
        }
        return {
          id: id,
          name: name,
          type: type
        };
      }
    }, {
      key: "parseNodeProperty",
      value: function parseNodeProperty(line, property, contentLine) {
        var propName = property[1].replace(/^"/, '').replace(/"$/, '').trim();
        var propValue = property[2].replace(/^"/, '').replace(/"$/, '').trim();

        // for special case: base64 image data follows "Content: ," line
        //	Content: ,
        //	 "/9j/4RDaRXhpZgAATU0A..."
        if (propName === 'Content' && propValue === ',') {
          propValue = contentLine.replace(/"/g, '').replace(/,$/, '').trim();
        }
        var currentNode = this.getCurrentNode();
        var parentName = currentNode.name;
        if (parentName === 'Properties70') {
          this.parseNodeSpecialProperty(line, propName, propValue);
          return;
        }

        // Connections
        if (propName === 'C') {
          var connProps = propValue.split(',').slice(1);
          var from = parseInt(connProps[0]);
          var to = parseInt(connProps[1]);
          var rest = propValue.split(',').slice(3);
          rest = rest.map(function (elem) {
            return elem.trim().replace(/^"/, '');
          });
          propName = 'connections';
          propValue = [from, to];
          append(propValue, rest);
          if (currentNode[propName] === undefined) {
            currentNode[propName] = [];
          }
        }

        // Node
        if (propName === 'Node') currentNode.id = propValue;

        // connections
        if (propName in currentNode && Array.isArray(currentNode[propName])) {
          currentNode[propName].push(propValue);
        } else {
          if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;
        }
        this.setCurrentProp(currentNode, propName);

        // convert string to array, unless it ends in ',' in which case more will be added to it
        if (propName === 'a' && propValue.slice(-1) !== ',') {
          currentNode.a = parseNumberArray(propValue);
        }
      }
    }, {
      key: "parseNodePropertyContinued",
      value: function parseNodePropertyContinued(line) {
        var currentNode = this.getCurrentNode();
        currentNode.a += line;

        // if the line doesn't end in ',' we have reached the end of the property value
        // so convert the string to an array
        if (line.slice(-1) !== ',') {
          currentNode.a = parseNumberArray(currentNode.a);
        }
      }

      // parse "Property70"
    }, {
      key: "parseNodeSpecialProperty",
      value: function parseNodeSpecialProperty(line, propName, propValue) {
        // split this
        // P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
        // into array like below
        // ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
        var props = propValue.split('",').map(function (prop) {
          return prop.trim().replace(/^\"/, '').replace(/\s/, '_');
        });
        var innerPropName = props[0];
        var innerPropType1 = props[1];
        var innerPropType2 = props[2];
        var innerPropFlag = props[3];
        var innerPropValue = props[4];

        // cast values where needed, otherwise leave as strings
        switch (innerPropType1) {
          case 'int':
          case 'enum':
          case 'bool':
          case 'ULongLong':
          case 'double':
          case 'Number':
          case 'FieldOfView':
            innerPropValue = parseFloat(innerPropValue);
            break;
          case 'Color':
          case 'ColorRGB':
          case 'Vector3D':
          case 'Lcl_Translation':
          case 'Lcl_Rotation':
          case 'Lcl_Scaling':
            innerPropValue = parseNumberArray(innerPropValue);
            break;
        }

        // CAUTION: these props must append to parent's parent
        this.getPrevNode()[innerPropName] = {
          'type': innerPropType1,
          'type2': innerPropType2,
          'flag': innerPropFlag,
          'value': innerPropValue
        };
        this.setCurrentProp(this.getPrevNode(), innerPropName);
      }
    }]);
    return TextParser;
  }(); // Parse an FBX file in Binary format
  var BinaryParser = /*#__PURE__*/function () {
    function BinaryParser() {
      _classCallCheck(this, BinaryParser);
    }
    _createClass(BinaryParser, [{
      key: "parse",
      value: function parse(buffer) {
        var reader = new BinaryReader(buffer);
        reader.skip(23); // skip magic 23 bytes

        var version = reader.getUint32();
        if (version < 6400) {
          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version);
        }
        var allNodes = new FBXTree();
        while (!this.endOfContent(reader)) {
          var node = this.parseNode(reader, version);
          if (node !== null) allNodes.add(node.name, node);
        }
        return allNodes;
      }

      // Check if reader has reached the end of content.
    }, {
      key: "endOfContent",
      value: function endOfContent(reader) {
        // footer size: 160bytes + 16-byte alignment padding
        // - 16bytes: magic
        // - padding til 16-byte alignment (at least 1byte?)
        //	(seems like some exporters embed fixed 15 or 16bytes?)
        // - 4bytes: magic
        // - 4bytes: version
        // - 120bytes: zero
        // - 16bytes: magic
        if (reader.size() % 16 === 0) {
          return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();
        } else {
          return reader.getOffset() + 160 + 16 >= reader.size();
        }
      }

      // recursively parse nodes until the end of the file is reached
    }, {
      key: "parseNode",
      value: function parseNode(reader, version) {
        var node = {};

        // The first three data sizes depends on version.
        var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
        var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
        version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used

        var nameLen = reader.getUint8();
        var name = reader.getString(nameLen);

        // Regards this node as NULL-record if endOffset is zero
        if (endOffset === 0) return null;
        var propertyList = [];
        for (var i = 0; i < numProperties; i++) {
          propertyList.push(this.parseProperty(reader));
        }

        // Regards the first three elements in propertyList as id, attrName, and attrType
        var id = propertyList.length > 0 ? propertyList[0] : '';
        var attrName = propertyList.length > 1 ? propertyList[1] : '';
        var attrType = propertyList.length > 2 ? propertyList[2] : '';

        // check if this node represents just a single property
        // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
        node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
        while (endOffset > reader.getOffset()) {
          var subNode = this.parseNode(reader, version);
          if (subNode !== null) this.parseSubNode(name, node, subNode);
        }
        node.propertyList = propertyList; // raw property list used by parent

        if (typeof id === 'number') node.id = id;
        if (attrName !== '') node.attrName = attrName;
        if (attrType !== '') node.attrType = attrType;
        if (name !== '') node.name = name;
        return node;
      }
    }, {
      key: "parseSubNode",
      value: function parseSubNode(name, node, subNode) {
        // special case: child node is single property
        if (subNode.singleProperty === true) {
          var value = subNode.propertyList[0];
          if (Array.isArray(value)) {
            node[subNode.name] = subNode;
            subNode.a = value;
          } else {
            node[subNode.name] = value;
          }
        } else if (name === 'Connections' && subNode.name === 'C') {
          var array = [];
          subNode.propertyList.forEach(function (property, i) {
            // first Connection is FBX type (OO, OP, etc.). We'll discard these
            if (i !== 0) array.push(property);
          });
          if (node.connections === undefined) {
            node.connections = [];
          }
          node.connections.push(array);
        } else if (subNode.name === 'Properties70') {
          var keys = Object.keys(subNode);
          keys.forEach(function (key) {
            node[key] = subNode[key];
          });
        } else if (name === 'Properties70' && subNode.name === 'P') {
          var innerPropName = subNode.propertyList[0];
          var innerPropType1 = subNode.propertyList[1];
          var innerPropType2 = subNode.propertyList[2];
          var innerPropFlag = subNode.propertyList[3];
          var innerPropValue;
          if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');
          if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');
          if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {
            innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];
          } else {
            innerPropValue = subNode.propertyList[4];
          }

          // this will be copied to parent, see above
          node[innerPropName] = {
            'type': innerPropType1,
            'type2': innerPropType2,
            'flag': innerPropFlag,
            'value': innerPropValue
          };
        } else if (node[subNode.name] === undefined) {
          if (typeof subNode.id === 'number') {
            node[subNode.name] = {};
            node[subNode.name][subNode.id] = subNode;
          } else {
            node[subNode.name] = subNode;
          }
        } else {
          if (subNode.name === 'PoseNode') {
            if (!Array.isArray(node[subNode.name])) {
              node[subNode.name] = [node[subNode.name]];
            }
            node[subNode.name].push(subNode);
          } else if (node[subNode.name][subNode.id] === undefined) {
            node[subNode.name][subNode.id] = subNode;
          }
        }
      }
    }, {
      key: "parseProperty",
      value: function parseProperty(reader) {
        var type = reader.getString(1);
        var length;
        switch (type) {
          case 'C':
            return reader.getBoolean();
          case 'D':
            return reader.getFloat64();
          case 'F':
            return reader.getFloat32();
          case 'I':
            return reader.getInt32();
          case 'L':
            return reader.getInt64();
          case 'R':
            length = reader.getUint32();
            return reader.getArrayBuffer(length);
          case 'S':
            length = reader.getUint32();
            return reader.getString(length);
          case 'Y':
            return reader.getInt16();
          case 'b':
          case 'c':
          case 'd':
          case 'f':
          case 'i':
          case 'l':
            var arrayLength = reader.getUint32();
            var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
            var compressedLength = reader.getUint32();
            if (encoding === 0) {
              switch (type) {
                case 'b':
                case 'c':
                  return reader.getBooleanArray(arrayLength);
                case 'd':
                  return reader.getFloat64Array(arrayLength);
                case 'f':
                  return reader.getFloat32Array(arrayLength);
                case 'i':
                  return reader.getInt32Array(arrayLength);
                case 'l':
                  return reader.getInt64Array(arrayLength);
              }
            }
            if (typeof fflate === 'undefined') {
              console.error('THREE.FBXLoader: External library fflate.min.js required.');
            }
            var data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef
            var reader2 = new BinaryReader(data.buffer);
            switch (type) {
              case 'b':
              case 'c':
                return reader2.getBooleanArray(arrayLength);
              case 'd':
                return reader2.getFloat64Array(arrayLength);
              case 'f':
                return reader2.getFloat32Array(arrayLength);
              case 'i':
                return reader2.getInt32Array(arrayLength);
              case 'l':
                return reader2.getInt64Array(arrayLength);
            }
            break;
          // cannot happen but is required by the DeepScan

          default:
            throw new Error('THREE.FBXLoader: Unknown property type ' + type);
        }
      }
    }]);
    return BinaryParser;
  }();
  var BinaryReader = /*#__PURE__*/function () {
    function BinaryReader(buffer, littleEndian) {
      _classCallCheck(this, BinaryReader);
      this.dv = new DataView(buffer);
      this.offset = 0;
      this.littleEndian = littleEndian !== undefined ? littleEndian : true;
    }
    _createClass(BinaryReader, [{
      key: "getOffset",
      value: function getOffset() {
        return this.offset;
      }
    }, {
      key: "size",
      value: function size() {
        return this.dv.buffer.byteLength;
      }
    }, {
      key: "skip",
      value: function skip(length) {
        this.offset += length;
      }

      // seems like true/false representation depends on exporter.
      // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
      // then sees LSB.
    }, {
      key: "getBoolean",
      value: function getBoolean() {
        return (this.getUint8() & 1) === 1;
      }
    }, {
      key: "getBooleanArray",
      value: function getBooleanArray(size) {
        var a = [];
        for (var i = 0; i < size; i++) {
          a.push(this.getBoolean());
        }
        return a;
      }
    }, {
      key: "getUint8",
      value: function getUint8() {
        var value = this.dv.getUint8(this.offset);
        this.offset += 1;
        return value;
      }
    }, {
      key: "getInt16",
      value: function getInt16() {
        var value = this.dv.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
    }, {
      key: "getInt32",
      value: function getInt32() {
        var value = this.dv.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
    }, {
      key: "getInt32Array",
      value: function getInt32Array(size) {
        var a = [];
        for (var i = 0; i < size; i++) {
          a.push(this.getInt32());
        }
        return a;
      }
    }, {
      key: "getUint32",
      value: function getUint32() {
        var value = this.dv.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }

      // JavaScript doesn't support 64-bit integer so calculate this here
      // 1 << 32 will return 1 so using multiply operation instead here.
      // There's a possibility that this method returns wrong value if the value
      // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
      // TODO: safely handle 64-bit integer
    }, {
      key: "getInt64",
      value: function getInt64() {
        var low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }

        // calculate negative value
        if (high & 0x80000000) {
          high = ~high & 0xFFFFFFFF;
          low = ~low & 0xFFFFFFFF;
          if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;
          low = low + 1 & 0xFFFFFFFF;
          return -(high * 0x100000000 + low);
        }
        return high * 0x100000000 + low;
      }
    }, {
      key: "getInt64Array",
      value: function getInt64Array(size) {
        var a = [];
        for (var i = 0; i < size; i++) {
          a.push(this.getInt64());
        }
        return a;
      }

      // Note: see getInt64() comment
    }, {
      key: "getUint64",
      value: function getUint64() {
        var low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }
        return high * 0x100000000 + low;
      }
    }, {
      key: "getFloat32",
      value: function getFloat32() {
        var value = this.dv.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
    }, {
      key: "getFloat32Array",
      value: function getFloat32Array(size) {
        var a = [];
        for (var i = 0; i < size; i++) {
          a.push(this.getFloat32());
        }
        return a;
      }
    }, {
      key: "getFloat64",
      value: function getFloat64() {
        var value = this.dv.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
    }, {
      key: "getFloat64Array",
      value: function getFloat64Array(size) {
        var a = [];
        for (var i = 0; i < size; i++) {
          a.push(this.getFloat64());
        }
        return a;
      }
    }, {
      key: "getArrayBuffer",
      value: function getArrayBuffer(size) {
        var value = this.dv.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return value;
      }
    }, {
      key: "getString",
      value: function getString(size) {
        // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead
        var a = [];
        for (var i = 0; i < size; i++) {
          a[i] = this.getUint8();
        }
        var nullByte = a.indexOf(0);
        if (nullByte >= 0) a = a.slice(0, nullByte);
        return LoaderUtils.decodeText(new Uint8Array(a));
      }
    }]);
    return BinaryReader;
  }(); // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
  // and BinaryParser( FBX Binary format)
  var FBXTree = /*#__PURE__*/function () {
    function FBXTree() {
      _classCallCheck(this, FBXTree);
    }
    _createClass(FBXTree, [{
      key: "add",
      value: function add(key, val) {
        this[key] = val;
      }
    }]);
    return FBXTree;
  }(); // ************** UTILITY FUNCTIONS **************
  function isFbxFormatBinary(buffer) {
    var CORRECT = "Kaydara FBX Binary  \0";
    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
  }
  function isFbxFormatASCII(text) {
    var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\'];
    var cursor = 0;
    function read(offset) {
      var result = text[offset - 1];
      text = text.slice(cursor + offset);
      cursor++;
      return result;
    }
    for (var i = 0; i < CORRECT.length; ++i) {
      var num = read(1);
      if (num === CORRECT[i]) {
        return false;
      }
    }
    return true;
  }
  function getFbxVersion(text) {
    var versionRegExp = /FBXVersion: (\d+)/;
    var match = text.match(versionRegExp);
    if (match) {
      var version = parseInt(match[1]);
      return version;
    }
    throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');
  }

  // Converts FBX ticks into real time seconds.
  function convertFBXTimeToSeconds(time) {
    return time / 46186158000;
  }
  var dataArray = [];

  // extracts the data from the correct position in the FBX array based on indexing type
  function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
    var index;
    switch (infoObject.mappingType) {
      case 'ByPolygonVertex':
        index = polygonVertexIndex;
        break;
      case 'ByPolygon':
        index = polygonIndex;
        break;
      case 'ByVertice':
        index = vertexIndex;
        break;
      case 'AllSame':
        index = infoObject.indices[0];
        break;
      default:
        console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);
    }
    if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];
    var from = index * infoObject.dataSize;
    var to = from + infoObject.dataSize;
    return slice(dataArray, infoObject.buffer, from, to);
  }
  var tempEuler = new Euler();
  var tempVec = new Vector3();

  // generate transformation from FBX transform data
  // ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
  // ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
  function generateTransform(transformData) {
    var lTranslationM = new Matrix4$1();
    var lPreRotationM = new Matrix4$1();
    var lRotationM = new Matrix4$1();
    var lPostRotationM = new Matrix4$1();
    var lScalingM = new Matrix4$1();
    var lScalingPivotM = new Matrix4$1();
    var lScalingOffsetM = new Matrix4$1();
    var lRotationOffsetM = new Matrix4$1();
    var lRotationPivotM = new Matrix4$1();
    var lParentGX = new Matrix4$1();
    var lParentLX = new Matrix4$1();
    var lGlobalT = new Matrix4$1();
    var inheritType = transformData.inheritType ? transformData.inheritType : 0;
    if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
    if (transformData.preRotation) {
      var array = transformData.preRotation.map(MathUtils.degToRad);
      array.push(transformData.eulerOrder);
      lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    }
    if (transformData.rotation) {
      var _array = transformData.rotation.map(MathUtils.degToRad);
      _array.push(transformData.eulerOrder);
      lRotationM.makeRotationFromEuler(tempEuler.fromArray(_array));
    }
    if (transformData.postRotation) {
      var _array2 = transformData.postRotation.map(MathUtils.degToRad);
      _array2.push(transformData.eulerOrder);
      lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(_array2));
      lPostRotationM.invert();
    }
    if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));

    // Pivots and offsets
    if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
    if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
    if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
    if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));

    // parent transform
    if (transformData.parentMatrixWorld) {
      lParentLX.copy(transformData.parentMatrix);
      lParentGX.copy(transformData.parentMatrixWorld);
    }
    var lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
    // Global Rotation
    var lParentGRM = new Matrix4$1();
    lParentGRM.extractRotation(lParentGX);

    // Global Shear*Scaling
    var lParentTM = new Matrix4$1();
    lParentTM.copyPosition(lParentGX);
    var lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
    var lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
    var lLSM = lScalingM;
    var lGlobalRS = new Matrix4$1();
    if (inheritType === 0) {
      lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
    } else if (inheritType === 1) {
      lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
    } else {
      var lParentLSM = new Matrix4$1().scale(new Vector3().setFromMatrixScale(lParentLX));
      var lParentLSM_inv = lParentLSM.clone().invert();
      var lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
      lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
    }
    var lRotationPivotM_inv = lRotationPivotM.clone().invert();
    var lScalingPivotM_inv = lScalingPivotM.clone().invert();
    // Calculate the local transform matrix
    var lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
    var lLocalTWithAllPivotAndOffsetInfo = new Matrix4$1().copyPosition(lTransform);
    var lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
    lGlobalT.copyPosition(lGlobalTranslation);
    lTransform = lGlobalT.clone().multiply(lGlobalRS);

    // from global to local
    lTransform.premultiply(lParentGX.invert());
    return lTransform;
  }

  // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
  // ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
  function getEulerOrder(order) {
    order = order || 0;
    var enums = ['ZYX',
    // -> XYZ extrinsic
    'YZX',
    // -> XZY extrinsic
    'XZY',
    // -> YZX extrinsic
    'ZXY',
    // -> YXZ extrinsic
    'YXZ',
    // -> ZXY extrinsic
    'XYZ' // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
    ];

    if (order === 6) {
      console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');
      return enums[0];
    }
    return enums[order];
  }

  // Parses comma separated list of numbers and returns them an array.
  // Used internally by the TextParser
  function parseNumberArray(value) {
    var array = value.split(',').map(function (val) {
      return parseFloat(val);
    });
    return array;
  }
  function convertArrayBufferToString(buffer, from, to) {
    if (from === undefined) from = 0;
    if (to === undefined) to = buffer.byteLength;
    return LoaderUtils.decodeText(new Uint8Array(buffer, from, to));
  }
  function append(a, b) {
    for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {
      a[j] = b[i];
    }
  }
  function slice(a, b, from, to) {
    for (var i = from, j = 0; i < to; i++, j++) {
      a[j] = b[i];
    }
    return a;
  }

  // inject array a2 into array a1 at index
  function inject(a1, index, a2) {
    return a1.slice(0, index).concat(a2).concat(a1.slice(index));
  }

  var propertyList = ['show', 'uri', 'scale', 'rotation', 'minimumPixelSize', 'maximumScale', 'heightReference', 'color', 'distanceDisplayCondition'];
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class Model
   * 模型类
   */
  var Model = /*#__PURE__*/function () {
    /**
     * Model类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Cartesian3} options.rotation <code>optional</code> 指定模型的旋转角度。
     * @param {Cartesian3} options.scale <code>optional</code> 指定模型的缩放比例。
     * @param {String} options.uri <code>optional</code> 指定3D模型的资源路径。
     */
    function Model(options) {
      var _this = this;
      _classCallCheck(this, Model);
      this._definitionChanged = new Event();
      propertyList.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    /**
     * 复制此实例
     * @param {Plot} result 用于存储结果的对象。
     * @returns {Plot} -修改后的结果参数，如果未提供则为新实例。
     */
    _createClass(Model, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new Plot(this);
        }
        propertyList.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
      /**
       * 将此对象上未分配的每个属性分配给提供的源对象上相同属性的值。
       * @param {Plot} source 要合并到此对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        propertyList.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return Model;
  }();
  Object.defineProperties(Model.prototype, {
    /**
     * 获取每当属性或子属性被更改或修改时触发的事件。
     * @memberof Box.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    show: createPropertyDescriptor('show'),
    uri: createPropertyDescriptor('uri'),
    scale: createPropertyDescriptor('scale'),
    rotation: createPropertyDescriptor('rotation'),
    minimumPixelSize: createPropertyDescriptor('minimumPixelSize'),
    maximumScale: createPropertyDescriptor('maximumScale'),
    heightReference: createPropertyDescriptor('heightReference'),
    color: createPropertyDescriptor('color'),
    distanceDisplayCondition: createPropertyDescriptor('distanceDisplayCondition')
  });
  var addModel = function addModel(globe, layer, entity, threeEarth) {
    var url = entity.model.uri._value;
    var _entity$getLonLatPosi = entity.getLonLatPosition();
      _entity$getLonLatPosi.lon;
      _entity$getLonLatPosi.lat;
      _entity$getLonLatPosi.positionHeight;
    var strRegex = /\.(fbx|obj|gltf|glb)$/;
    var loader,
      hasScene = false;
    if (strRegex.test(url.toLowerCase())) {
      //判断什么类型
      if (/\.obj$/.test(url.toLowerCase())) {
        loader = new OBJLoader();
      } else if (/\.(glb|gltf)$/.test(url.toLowerCase())) {
        loader = new GLTFLoader();
        hasScene = true;
      } else if (/\.fbx$/.test(url.toLowerCase())) {
        loader = new FBXLoader();
      }
    } else {
      console.error('暂不支持的模型格式！');
      return;
    }
    loadModelByUrl(loader, url).then(function (res) {
      var model = hasScene ? res.scene : res;
      if (entity.model.scale) {
        var scale = entity.model.scale._value;
        model.scale.set(scale.x, scale.y, scale.z);
      }

      //设置默认方向
      if (entity.model.rotation) {
        var rotation = entity.model.rotation._value;
        if (rotation instanceof HeadingPitchRoll) {
          rotation.pitch -= Math.PI / 2;
          model.rotation.set(rotation.pitch, rotation.heading, rotation.roll);
        }
      } else {
        model.rotation.set(-Math.PI / 2, 0, 0);
      }
      var primitiveInstance = entity.primitiveInstance;
      primitiveInstance.add(model);
      entity.model._id = model.id;
    });
  };
  var loadModelByUrl = function loadModelByUrl(loader, url) {
    return new Promise(function (resolve, reject) {
      loader.load(url, function (result) {
        resolve(result);
      });
    });
  };

  /**
   * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
   *
   * @function
   *
   * @returns {String}
   *
   *
   * @example
   * this.guid = Cesium.createGuid();
   *
   * @see {@link http://www.ietf.org/rfc/rfc4122.txt|RFC 4122 A Universally Unique IDentifier (UUID) URN Namespace}
   */
  function createGuid() {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0;
      var v = c === "x" ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }

  /*
   * @FilePath: createRawPropertyDescriptor.js
   * @Author: chenqian
   * @Date: 2023-02-08 14:06:39
   * @LastEditors: cheniqan
   * @LastEditTime: 2023-02-08 14:27:41
   * @Descripttion:
   */
  function createRawProperty(value) {
    return value;
  }

  /**
   * @private
   */
  function createRawPropertyDescriptor(name, configurable) {
    return createPropertyDescriptor(name, configurable, createRawProperty);
  }

  /**
   * A 4D Cartesian point.
   * @alias Cartesian4
   * @constructor
   *
   * @param {Number} [x=0.0] The X component.
   * @param {Number} [y=0.0] The Y component.
   * @param {Number} [z=0.0] The Z component.
   * @param {Number} [w=0.0] The W component.
   *
   * @see Cartesian2
   * @see Cartesian3
   * @see Packable
   */
  function Cartesian4(x, y, z, w) {
    /**
     * The X component.
     * @type {Number}
     * @default 0.0
     */
    this.x = defaultValue$1(x, 0.0);

    /**
     * The Y component.
     * @type {Number}
     * @default 0.0
     */
    this.y = defaultValue$1(y, 0.0);

    /**
     * The Z component.
     * @type {Number}
     * @default 0.0
     */
    this.z = defaultValue$1(z, 0.0);

    /**
     * The W component.
     * @type {Number}
     * @default 0.0
     */
    this.w = defaultValue$1(w, 0.0);
  }

  /**
   * Creates a Cartesian4 instance from x, y, z and w coordinates.
   *
   * @param {Number} x The x coordinate.
   * @param {Number} y The y coordinate.
   * @param {Number} z The z coordinate.
   * @param {Number} w The w coordinate.
   * @param {Cartesian4} [result] The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  Cartesian4.fromElements = function (x, y, z, w, result) {
    if (!defined$1(result)) {
      return new Cartesian4(x, y, z, w);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };

  /**
   * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
   * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
   *
   * @param {Color} color The source color.
   * @param {Cartesian4} [result] The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  Cartesian4.fromColor = function (color, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("color", color);
    //>>includeEnd('debug');
    if (!defined$1(result)) {
      return new Cartesian4(color.red, color.green, color.blue, color.alpha);
    }
    result.x = color.red;
    result.y = color.green;
    result.z = color.blue;
    result.w = color.alpha;
    return result;
  };

  /**
   * Duplicates a Cartesian4 instance.
   *
   * @param {Cartesian4} cartesian The Cartesian to duplicate.
   * @param {Cartesian4} [result] The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)
   */
  Cartesian4.clone = function (cartesian, result) {
    if (!defined$1(cartesian)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    result.z = cartesian.z;
    result.w = cartesian.w;
    return result;
  };

  /**
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Cartesian4.packedLength = 4;

  /**
   * Stores the provided instance into the provided array.
   *
   * @param {Cartesian4} value The value to pack.
   * @param {Number[]} array The array to pack into.
   * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
   *
   * @returns {Number[]} The array that was packed into
   */
  Cartesian4.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("value", value);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex++] = value.z;
    array[startingIndex] = value.w;
    return array;
  };

  /**
   * Retrieves an instance from a packed array.
   *
   * @param {Number[]} array The packed array.
   * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
   * @param {Cartesian4} [result] The object into which to store the result.
   * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  Cartesian4.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new Cartesian4();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex++];
    result.z = array[startingIndex++];
    result.w = array[startingIndex];
    return result;
  };

  /**
   * Flattens an array of Cartesian4s into an array of components.
   *
   * @param {Cartesian4[]} array The array of cartesians to pack.
   * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.
   * @returns {Number[]} The packed array.
   */
  Cartesian4.packArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    var length = array.length;
    var resultLength = length * 4;
    if (!defined$1(result)) {
      result = new Array(resultLength);
    } else if (!Array.isArray(result) && result.length !== resultLength) {
      //>>includeStart('debug', pragmas.debug);
      throw new DeveloperError$1("If result is a typed array, it must have exactly array.length * 4 elements");
      //>>includeEnd('debug');
    } else if (result.length !== resultLength) {
      result.length = resultLength;
    }
    for (var i = 0; i < length; ++i) {
      Cartesian4.pack(array[i], result, i * 4);
    }
    return result;
  };

  /**
   * Unpacks an array of cartesian components into an array of Cartesian4s.
   *
   * @param {Number[]} array The array of components to unpack.
   * @param {Cartesian4[]} [result] The array onto which to store the result.
   * @returns {Cartesian4[]} The unpacked array.
   */
  Cartesian4.unpackArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 4);
    if (array.length % 4 !== 0) {
      throw new DeveloperError$1("array length must be a multiple of 4.");
    }
    //>>includeEnd('debug');

    var length = array.length;
    if (!defined$1(result)) {
      result = new Array(length / 4);
    } else {
      result.length = length / 4;
    }
    for (var i = 0; i < length; i += 4) {
      var index = i / 4;
      result[index] = Cartesian4.unpack(array, i, result[index]);
    }
    return result;
  };

  /**
   * Creates a Cartesian4 from four consecutive elements in an array.
   * @function
   *
   * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
   * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
   * @param {Cartesian4} [result] The object onto which to store the result.
   * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
   *
   * @example
   * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)
   * const v = [1.0, 2.0, 3.0, 4.0];
   * const p = Cesium.Cartesian4.fromArray(v);
   *
   * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];
   * const p2 = Cesium.Cartesian4.fromArray(v2, 2);
   */
  Cartesian4.fromArray = Cartesian4.unpack;

  /**
   * Computes the value of the maximum component for the supplied Cartesian.
   *
   * @param {Cartesian4} cartesian The cartesian to use.
   * @returns {Number} The value of the maximum component.
   */
  Cartesian4.maximumComponent = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    //>>includeEnd('debug');

    return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
  };

  /**
   * Computes the value of the minimum component for the supplied Cartesian.
   *
   * @param {Cartesian4} cartesian The cartesian to use.
   * @returns {Number} The value of the minimum component.
   */
  Cartesian4.minimumComponent = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    //>>includeEnd('debug');

    return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
  };

  /**
   * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
   *
   * @param {Cartesian4} first A cartesian to compare.
   * @param {Cartesian4} second A cartesian to compare.
   * @param {Cartesian4} result The object into which to store the result.
   * @returns {Cartesian4} A cartesian with the minimum components.
   */
  Cartesian4.minimumByComponent = function (first, second, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("first", first);
    Check.typeOf.object("second", second);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    result.z = Math.min(first.z, second.z);
    result.w = Math.min(first.w, second.w);
    return result;
  };

  /**
   * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
   *
   * @param {Cartesian4} first A cartesian to compare.
   * @param {Cartesian4} second A cartesian to compare.
   * @param {Cartesian4} result The object into which to store the result.
   * @returns {Cartesian4} A cartesian with the maximum components.
   */
  Cartesian4.maximumByComponent = function (first, second, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("first", first);
    Check.typeOf.object("second", second);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    result.z = Math.max(first.z, second.z);
    result.w = Math.max(first.w, second.w);
    return result;
  };

  /**
   * Constrain a value to lie between two values.
   *
   * @param {Cartesian4} value The value to clamp.
   * @param {Cartesian4} min The minimum bound.
   * @param {Cartesian4} max The maximum bound.
   * @param {Cartesian4} result The object into which to store the result.
   * @returns {Cartesian4} The clamped value such that min <= result <= max.
   */
  Cartesian4.clamp = function (value, min, max, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("value", value);
    Check.typeOf.object("min", min);
    Check.typeOf.object("max", max);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var x = CesiumMath.clamp(value.x, min.x, max.x);
    var y = CesiumMath.clamp(value.y, min.y, max.y);
    var z = CesiumMath.clamp(value.z, min.z, max.z);
    var w = CesiumMath.clamp(value.w, min.w, max.w);
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };

  /**
   * Computes the provided Cartesian's squared magnitude.
   *
   * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.
   * @returns {Number} The squared magnitude.
   */
  Cartesian4.magnitudeSquared = function (cartesian) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    //>>includeEnd('debug');

    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
  };

  /**
   * Computes the Cartesian's magnitude (length).
   *
   * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.
   * @returns {Number} The magnitude.
   */
  Cartesian4.magnitude = function (cartesian) {
    return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
  };
  var distanceScratch = new Cartesian4();

  /**
   * Computes the 4-space distance between two points.
   *
   * @param {Cartesian4} left The first point to compute the distance from.
   * @param {Cartesian4} right The second point to compute the distance to.
   * @returns {Number} The distance between two points.
   *
   * @example
   * // Returns 1.0
   * const d = Cesium.Cartesian4.distance(
   *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
   *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));
   */
  Cartesian4.distance = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    Cartesian4.subtract(left, right, distanceScratch);
    return Cartesian4.magnitude(distanceScratch);
  };

  /**
   * Computes the squared distance between two points.  Comparing squared distances
   * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
   *
   * @param {Cartesian4} left The first point to compute the distance from.
   * @param {Cartesian4} right The second point to compute the distance to.
   * @returns {Number} The distance between two points.
   *
   * @example
   * // Returns 4.0, not 2.0
   * const d = Cesium.Cartesian4.distance(
   *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
   *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));
   */
  Cartesian4.distanceSquared = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    Cartesian4.subtract(left, right, distanceScratch);
    return Cartesian4.magnitudeSquared(distanceScratch);
  };

  /**
   * Computes the normalized form of the supplied Cartesian.
   *
   * @param {Cartesian4} cartesian The Cartesian to be normalized.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.normalize = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var magnitude = Cartesian4.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    result.z = cartesian.z / magnitude;
    result.w = cartesian.w / magnitude;

    //>>includeStart('debug', pragmas.debug);
    if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z) || isNaN(result.w)) {
      throw new DeveloperError$1("normalized result is not a number");
    }
    //>>includeEnd('debug');

    return result;
  };

  /**
   * Computes the dot (scalar) product of two Cartesians.
   *
   * @param {Cartesian4} left The first Cartesian.
   * @param {Cartesian4} right The second Cartesian.
   * @returns {Number} The dot product.
   */
  Cartesian4.dot = function (left, right) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    //>>includeEnd('debug');

    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  };

  /**
   * Computes the componentwise product of two Cartesians.
   *
   * @param {Cartesian4} left The first Cartesian.
   * @param {Cartesian4} right The second Cartesian.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.multiplyComponents = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x * right.x;
    result.y = left.y * right.y;
    result.z = left.z * right.z;
    result.w = left.w * right.w;
    return result;
  };

  /**
   * Computes the componentwise quotient of two Cartesians.
   *
   * @param {Cartesian4} left The first Cartesian.
   * @param {Cartesian4} right The second Cartesian.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.divideComponents = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x / right.x;
    result.y = left.y / right.y;
    result.z = left.z / right.z;
    result.w = left.w / right.w;
    return result;
  };

  /**
   * Computes the componentwise sum of two Cartesians.
   *
   * @param {Cartesian4} left The first Cartesian.
   * @param {Cartesian4} right The second Cartesian.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.add = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    result.w = left.w + right.w;
    return result;
  };

  /**
   * Computes the componentwise difference of two Cartesians.
   *
   * @param {Cartesian4} left The first Cartesian.
   * @param {Cartesian4} right The second Cartesian.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.subtract = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    result.w = left.w - right.w;
    return result;
  };

  /**
   * Multiplies the provided Cartesian componentwise by the provided scalar.
   *
   * @param {Cartesian4} cartesian The Cartesian to be scaled.
   * @param {Number} scalar The scalar to multiply with.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.multiplyByScalar = function (cartesian, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.number("scalar", scalar);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    result.z = cartesian.z * scalar;
    result.w = cartesian.w * scalar;
    return result;
  };

  /**
   * Divides the provided Cartesian componentwise by the provided scalar.
   *
   * @param {Cartesian4} cartesian The Cartesian to be divided.
   * @param {Number} scalar The scalar to divide by.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.divideByScalar = function (cartesian, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.number("scalar", scalar);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    result.z = cartesian.z / scalar;
    result.w = cartesian.w / scalar;
    return result;
  };

  /**
   * Negates the provided Cartesian.
   *
   * @param {Cartesian4} cartesian The Cartesian to be negated.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.negate = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = -cartesian.x;
    result.y = -cartesian.y;
    result.z = -cartesian.z;
    result.w = -cartesian.w;
    return result;
  };

  /**
   * Computes the absolute value of the provided Cartesian.
   *
   * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.abs = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    result.z = Math.abs(cartesian.z);
    result.w = Math.abs(cartesian.w);
    return result;
  };
  var lerpScratch = new Cartesian4();
  /**
   * Computes the linear interpolation or extrapolation at t using the provided cartesians.
   *
   * @param {Cartesian4} start The value corresponding to t at 0.0.
   * @param {Cartesian4}end The value corresponding to t at 1.0.
   * @param {Number} t The point along t at which to interpolate.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter.
   */
  Cartesian4.lerp = function (start, end, t, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("start", start);
    Check.typeOf.object("end", end);
    Check.typeOf.number("t", t);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    Cartesian4.multiplyByScalar(end, t, lerpScratch);
    result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
    return Cartesian4.add(lerpScratch, result, result);
  };
  var mostOrthogonalAxisScratch = new Cartesian4();
  /**
   * Returns the axis that is most orthogonal to the provided Cartesian.
   *
   * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.
   * @param {Cartesian4} result The object onto which to store the result.
   * @returns {Cartesian4} The most orthogonal axis.
   */
  Cartesian4.mostOrthogonalAxis = function (cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);
    Cartesian4.abs(f, f);
    if (f.x <= f.y) {
      if (f.x <= f.z) {
        if (f.x <= f.w) {
          result = Cartesian4.clone(Cartesian4.UNIT_X, result);
        } else {
          result = Cartesian4.clone(Cartesian4.UNIT_W, result);
        }
      } else if (f.z <= f.w) {
        result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
      } else {
        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
      }
    } else if (f.y <= f.z) {
      if (f.y <= f.w) {
        result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
      } else {
        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
      }
    } else if (f.z <= f.w) {
      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
    } else {
      result = Cartesian4.clone(Cartesian4.UNIT_W, result);
    }
    return result;
  };

  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {Cartesian4} [left] The first Cartesian.
   * @param {Cartesian4} [right] The second Cartesian.
   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  Cartesian4.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;
  };

  /**
   * @private
   */
  Cartesian4.equalsArray = function (cartesian, array, offset) {
    return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];
  };

  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   *
   * @param {Cartesian4} [left] The first Cartesian.
   * @param {Cartesian4} [right] The second Cartesian.
   * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
   * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
   * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  Cartesian4.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    return left === right || defined$1(left) && defined$1(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon);
  };

  /**
   * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
   *
   * @type {Cartesian4}
   * @constant
   */
  Cartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));

  /**
   * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).
   *
   * @type {Cartesian4}
   * @constant
   */
  Cartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));

  /**
   * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
   *
   * @type {Cartesian4}
   * @constant
   */
  Cartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));

  /**
   * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
   *
   * @type {Cartesian4}
   * @constant
   */
  Cartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));

  /**
   * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
   *
   * @type {Cartesian4}
   * @constant
   */
  Cartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));

  /**
   * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
   *
   * @type {Cartesian4}
   * @constant
   */
  Cartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));

  /**
   * Duplicates this Cartesian4 instance.
   *
   * @param {Cartesian4} [result] The object onto which to store the result.
   * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  Cartesian4.prototype.clone = function (result) {
    return Cartesian4.clone(this, result);
  };

  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {Cartesian4} [right] The right hand side Cartesian.
   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  Cartesian4.prototype.equals = function (right) {
    return Cartesian4.equals(this, right);
  };

  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   *
   * @param {Cartesian4} [right] The right hand side Cartesian.
   * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
   * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
   * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  Cartesian4.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {
    return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };

  /**
   * Creates a string representing this Cartesian in the format '(x, y, z, w)'.
   *
   * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.
   */
  Cartesian4.prototype.toString = function () {
    return "(".concat(this.x, ", ").concat(this.y, ", ").concat(this.z, ", ").concat(this.w, ")");
  };

  // scratchU8Array and scratchF32Array are views into the same buffer
  var scratchF32Array = new Float32Array(1);
  var scratchU8Array = new Uint8Array(scratchF32Array.buffer);
  var testU32 = new Uint32Array([0x11223344]);
  var testU8 = new Uint8Array(testU32.buffer);
  var littleEndian = testU8[0] === 0x44;

  /**
   * Packs an arbitrary floating point value to 4 values representable using uint8.
   *
   * @param {Number} value A floating point number.
   * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.
   * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.
   */
  Cartesian4.packFloat = function (value, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("value", value);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Cartesian4();
    }

    // scratchU8Array and scratchF32Array are views into the same buffer
    scratchF32Array[0] = value;
    if (littleEndian) {
      result.x = scratchU8Array[0];
      result.y = scratchU8Array[1];
      result.z = scratchU8Array[2];
      result.w = scratchU8Array[3];
    } else {
      // convert from big-endian to little-endian
      result.x = scratchU8Array[3];
      result.y = scratchU8Array[2];
      result.z = scratchU8Array[1];
      result.w = scratchU8Array[0];
    }
    return result;
  };

  /**
   * Unpacks a float packed using Cartesian4.packFloat.
   *
   * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.
   * @returns {Number} The unpacked float.
   * @private
   */
  Cartesian4.unpackFloat = function (packedFloat) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("packedFloat", packedFloat);
    //>>includeEnd('debug');

    // scratchU8Array and scratchF32Array are views into the same buffer
    if (littleEndian) {
      scratchU8Array[0] = packedFloat.x;
      scratchU8Array[1] = packedFloat.y;
      scratchU8Array[2] = packedFloat.z;
      scratchU8Array[3] = packedFloat.w;
    } else {
      // convert from little-endian to big-endian
      scratchU8Array[0] = packedFloat.w;
      scratchU8Array[1] = packedFloat.z;
      scratchU8Array[2] = packedFloat.y;
      scratchU8Array[3] = packedFloat.x;
    }
    return scratchF32Array[0];
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * @class Matrix3
   * 一个3x3矩阵，可以像按列顺序的数组一样进行索引。构造函数参数按行主序（row-major）顺序排列，以提高代码的可读性。
   * @constructor
   *
   * @param {Number} column0Row0=0.0 <code>optional</code> 第0列第0行的值
   * @param {Number} column1Row0=0.0 <code>optional</code> 第1列第0行的值
   * @param {Number} column2Row0=0.0 <code>optional</code> 第2列第0行的值
   * @param {Number} column0Row1=0.0 <code>optional</code> 第0列第1行的值
   * @param {Number} column1Row1=0.0 <code>optional</code> 第1列第1行的值
   * @param {Number} column2Row1=0.0 <code>optional</code> 第2列第1行的值
   * @param {Number} column0Row2=0.0 <code>optional</code> 第0列第2行的值
   * @param {Number} column1Row2=0.0 <code>optional</code> 第1列第2行的值
   * @param {Number} column2Row2=0.0 <code>optional</code> 第2列第2行的值
   *
   */
  function Matrix3(column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {
    this[0] = defaultValue$1(column0Row0, 0.0);
    this[1] = defaultValue$1(column0Row1, 0.0);
    this[2] = defaultValue$1(column0Row2, 0.0);
    this[3] = defaultValue$1(column1Row0, 0.0);
    this[4] = defaultValue$1(column1Row1, 0.0);
    this[5] = defaultValue$1(column1Row2, 0.0);
    this[6] = defaultValue$1(column2Row0, 0.0);
    this[7] = defaultValue$1(column2Row1, 0.0);
    this[8] = defaultValue$1(column2Row2, 0.0);
  }

  /*
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Matrix3.packedLength = 9;

  /**
   * 将提供的实例存储到提供的数组中。
   * @param {Matrix3} value 要打包的值。
   * @param {Number[]} array 要打包到的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 开始打包元素的数组索引。
   * @returns {Number[]} 已打包的数组
   */
  Matrix3.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("value", value);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value[0];
    array[startingIndex++] = value[1];
    array[startingIndex++] = value[2];
    array[startingIndex++] = value[3];
    array[startingIndex++] = value[4];
    array[startingIndex++] = value[5];
    array[startingIndex++] = value[6];
    array[startingIndex++] = value[7];
    array[startingIndex++] = value[8];
    return array;
  };

  /**
   * 从一个打包的数组中检索一个实例。
   * @param {Number[]} array 打包的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 要解包的元素的起始索引。
   * @param {Matrix3} result <code>optional</code> 用于存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数或如果未提供则为新的Matrix3实例。
   */
  Matrix3.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new Matrix3();
    }
    result[0] = array[startingIndex++];
    result[1] = array[startingIndex++];
    result[2] = array[startingIndex++];
    result[3] = array[startingIndex++];
    result[4] = array[startingIndex++];
    result[5] = array[startingIndex++];
    result[6] = array[startingIndex++];
    result[7] = array[startingIndex++];
    result[8] = array[startingIndex++];
    return result;
  };

  /**
   * 将Matrix3数组展平为组件数组。组件按列主序（column-major）顺序存储。
   * @param {Matrix3[]} array 要打包的矩阵数组。
   * @param {Number[]} result <code>optional</code> 用于存储结果的数组。如果这是一个类型化数组，则必须有array.length * 9个组件，否则将抛出一个{@link DeveloperError}。如果它是一个普通数组，则将调整大小以具有(array.length * 9)个元素。
   * @returns {Number[]} 打包后的数组
   */
  Matrix3.packArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    var length = array.length;
    var resultLength = length * 9;
    if (!defined$1(result)) {
      result = new Array(resultLength);
    } else if (!Array.isArray(result) && result.length !== resultLength) {
      //>>includeStart('debug', pragmas.debug);
      throw new DeveloperError$1("If result is a typed array, it must have exactly array.length * 9 elements");
      //>>includeEnd('debug');
    } else if (result.length !== resultLength) {
      result.length = resultLength;
    }
    for (var i = 0; i < length; ++i) {
      Matrix3.pack(array[i], result, i * 9);
    }
    return result;
  };

  /**
   * 将按列主序排列的矩阵组件数组解包成Matrix3数组。
   * @param {Number[]} array 要解包的组件数组。
   * @param {Matrix3[]} result <code>optional</code> 用于存储结果的数组。
   * @returns {Matrix3[]} 解包后的数组。
   */
  Matrix3.unpackArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 9);
    if (array.length % 9 !== 0) {
      throw new DeveloperError$1("array length must be a multiple of 9.");
    }
    //>>includeEnd('debug');

    var length = array.length;
    if (!defined$1(result)) {
      result = new Array(length / 9);
    } else {
      result.length = length / 9;
    }
    for (var i = 0; i < length; i += 9) {
      var index = i / 9;
      result[index] = Matrix3.unpack(array, i, result[index]);
    }
    return result;
  };

  /**
   * 复制一个Matrix3实例。
   * @param {Matrix3} matrix 要复制的矩阵。
   * @param {Matrix3} result <code>optional</code> 用于存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数或如果未提供则为新的Matrix3实例。（如果matrix是未定义，则返回undefined）
   */
  Matrix3.clone = function (matrix, result) {
    if (!defined$1(matrix)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Matrix3(matrix[0], matrix[3], matrix[6], matrix[1], matrix[4], matrix[7], matrix[2], matrix[5], matrix[8]);
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    return result;
  };

  /**
   * 从数组中的9个连续元素创建Matrix3。
   * @function
   * @param {Number[]} array 包含矩阵9个连续元素的数组。假定按列主序排列。
   * @param {Number} startingIndex=0 <code>optional</code> 第一个元素在数组中的偏移量，对应于矩阵的第一列第一行位置。
   * @param {Matrix3} result <code>optional</code> 用于存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数或如果未提供则为新的Matrix3实例。
   *
   * @example
   * // Create the Matrix3:
   * // [1.0, 2.0, 3.0]
   * // [1.0, 2.0, 3.0]
   * // [1.0, 2.0, 3.0]
   *
   * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
   * const m = Earth.Matrix3.fromArray(v);
   *
   * // Create same Matrix3 with using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
   * const m2 = Earth.Matrix3.fromArray(v2, 2);
   */
  Matrix3.fromArray = Matrix3.unpack;

  /**
   * 从列主序数组创建 Matrix3 实例。
   * @param {Number[]} values 列主序数组。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix3} 修改后的结果参数，如果未提供，则返回新的 Matrix3 实例。
   */
  Matrix3.fromColumnMajorArray = function (values, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("values", values);
    //>>includeEnd('debug');

    return Matrix3.clone(values, result);
  };

  /**
   * 从行主序数组创建 Matrix3 实例。生成的矩阵将采用列主序排列。
   * @param {Number[]} values 行主序数组。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix3} 修改后的结果参数，如果未提供，则返回新的 Matrix3 实例。
   */
  Matrix3.fromRowMajorArray = function (values, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("values", values);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Matrix3(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8]);
    }
    result[0] = values[0];
    result[1] = values[3];
    result[2] = values[6];
    result[3] = values[1];
    result[4] = values[4];
    result[5] = values[7];
    result[6] = values[2];
    result[7] = values[5];
    result[8] = values[8];
    return result;
  };

  /**
   * 从提供的四元数计算一个 3x3 的旋转矩阵。
   * @param {Quaternion} quaternion 要使用的四元数。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix3} 此四元数的 3x3 旋转矩阵。
   */
  Matrix3.fromQuaternion = function (quaternion, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("quaternion", quaternion);
    //>>includeEnd('debug');

    var x2 = quaternion.x * quaternion.x;
    var xy = quaternion.x * quaternion.y;
    var xz = quaternion.x * quaternion.z;
    var xw = quaternion.x * quaternion.w;
    var y2 = quaternion.y * quaternion.y;
    var yz = quaternion.y * quaternion.z;
    var yw = quaternion.y * quaternion.w;
    var z2 = quaternion.z * quaternion.z;
    var zw = quaternion.z * quaternion.w;
    var w2 = quaternion.w * quaternion.w;
    var m00 = x2 - y2 - z2 + w2;
    var m01 = 2.0 * (xy - zw);
    var m02 = 2.0 * (xz + yw);
    var m10 = 2.0 * (xy + zw);
    var m11 = -x2 + y2 - z2 + w2;
    var m12 = 2.0 * (yz - xw);
    var m20 = 2.0 * (xz - yw);
    var m21 = 2.0 * (yz + xw);
    var m22 = -x2 - y2 + z2 + w2;
    if (!defined$1(result)) {
      return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    result[0] = m00;
    result[1] = m10;
    result[2] = m20;
    result[3] = m01;
    result[4] = m11;
    result[5] = m21;
    result[6] = m02;
    result[7] = m12;
    result[8] = m22;
    return result;
  };

  /**
   * 从提供的 headingPitchRoll 计算一个 3x3 的旋转矩阵。
   * @param {HeadingPitchRoll} headingPitchRoll 要使用的 headingPitchRoll。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix3} 此 headingPitchRoll 的 3x3 旋转矩阵。
   */
  Matrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("headingPitchRoll", headingPitchRoll);
    //>>includeEnd('debug');

    var cosTheta = Math.cos(-headingPitchRoll.pitch);
    var cosPsi = Math.cos(-headingPitchRoll.heading);
    var cosPhi = Math.cos(headingPitchRoll.roll);
    var sinTheta = Math.sin(-headingPitchRoll.pitch);
    var sinPsi = Math.sin(-headingPitchRoll.heading);
    var sinPhi = Math.sin(headingPitchRoll.roll);
    var m00 = cosTheta * cosPsi;
    var m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;
    var m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;
    var m10 = cosTheta * sinPsi;
    var m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;
    var m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;
    var m20 = -sinTheta;
    var m21 = sinPhi * cosTheta;
    var m22 = cosPhi * cosTheta;
    if (!defined$1(result)) {
      return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    result[0] = m00;
    result[1] = m10;
    result[2] = m20;
    result[3] = m01;
    result[4] = m11;
    result[5] = m21;
    result[6] = m02;
    result[7] = m12;
    result[8] = m22;
    return result;
  };

  /**
   * 计算一个表示非均匀缩放的 Matrix3 实例。
   * @param {Cartesian3} scale 缩放因子的 x、y 和 z 值。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix3} 修改后的结果参数，如果未提供则返回一个新的 Matrix3 实例。
   *
   * @example
   * // Creates
   * //   [7.0, 0.0, 0.0]
   * //   [0.0, 8.0, 0.0]
   * //   [0.0, 0.0, 9.0]
   * const m = Earth.Matrix3.fromScale(new Earth.Cartesian3(7.0, 8.0, 9.0));
   */
  Matrix3.fromScale = function (scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("scale", scale);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
    }
    result[0] = scale.x;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = scale.y;
    result[5] = 0.0;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = scale.z;
    return result;
  };

  /**
   * 计算表示均匀缩放的Matrix3实例。
   * @param {Number} scale 均匀缩放因子。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix3} 修改后的结果参数，如果未提供，则返回一个新的Matrix3实例。
   *
   * @example
   * // Creates
   * //   [2.0, 0.0, 0.0]
   * //   [0.0, 2.0, 0.0]
   * //   [0.0, 0.0, 2.0]
   * const m = Earth.Matrix3.fromUniformScale(2.0);
   */
  Matrix3.fromUniformScale = function (scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("scale", scale);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);
    }
    result[0] = scale;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = scale;
    result[5] = 0.0;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = scale;
    return result;
  };

  /**
   * 计算一个Matrix3实例，表示一个Cartesian3向量的叉积等价矩阵。
   * @param {Cartesian3} vector 叉积运算左侧的向量。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix3} 修改后的结果参数，如果未提供，则返回一个新的Matrix3实例。
   *
   * @example
   * // Creates
   * //   [0.0, -9.0,  8.0]
   * //   [9.0,  0.0, -7.0]
   * //   [-8.0, 7.0,  0.0]
   * const m = Earth.Matrix3.fromCrossProduct(new Earth.Cartesian3(7.0, 8.0, 9.0));
   */
  Matrix3.fromCrossProduct = function (vector, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("vector", vector);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Matrix3(0.0, -vector.z, vector.y, vector.z, 0.0, -vector.x, -vector.y, vector.x, 0.0);
    }
    result[0] = 0.0;
    result[1] = vector.z;
    result[2] = -vector.y;
    result[3] = -vector.z;
    result[4] = 0.0;
    result[5] = vector.x;
    result[6] = vector.y;
    result[7] = -vector.x;
    result[8] = 0.0;
    return result;
  };

  /**
   * 创建一个绕x轴旋转的旋转矩阵。
   * @param {Number} angle 旋转角度，以弧度为单位。正角度为逆时针旋转。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix3} 修改后的结果参数，如果未提供，则返回一个新的Matrix3实例
   *
   * @example
   * // Rotate a point 45 degrees counterclockwise around the x-axis.
   * const p = new Earth.Cartesian3(5, 6, 7);
   * const m = Earth.Matrix3.fromRotationX(Earth.Math.toRadians(45.0));
   * const rotated = Earth.Matrix3.multiplyByVector(m, p, new Earth.Cartesian3());
   */
  Matrix3.fromRotationX = function (angle, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("angle", angle);
    //>>includeEnd('debug');

    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined$1(result)) {
      return new Matrix3(1.0, 0.0, 0.0, 0.0, cosAngle, -sinAngle, 0.0, sinAngle, cosAngle);
    }
    result[0] = 1.0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = cosAngle;
    result[5] = sinAngle;
    result[6] = 0.0;
    result[7] = -sinAngle;
    result[8] = cosAngle;
    return result;
  };

  /**
   * 创建绕 y 轴旋转的旋转矩阵。
   * @param {Number} angle 旋转的角度，以弧度为单位。正角度表示逆时针旋转。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix3} 修改后的 result 参数，如果未提供，则返回一个新的 Matrix3 实例。
   *
   * @example
   * // Rotate a point 45 degrees counterclockwise around the y-axis.
   * const p = new Earth.Cartesian3(5, 6, 7);
   * const m = Earth.Matrix3.fromRotationY(Earth.Math.toRadians(45.0));
   * const rotated = Earth.Matrix3.multiplyByVector(m, p, new Earth.Cartesian3());
   */
  Matrix3.fromRotationY = function (angle, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("angle", angle);
    //>>includeEnd('debug');

    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined$1(result)) {
      return new Matrix3(cosAngle, 0.0, sinAngle, 0.0, 1.0, 0.0, -sinAngle, 0.0, cosAngle);
    }
    result[0] = cosAngle;
    result[1] = 0.0;
    result[2] = -sinAngle;
    result[3] = 0.0;
    result[4] = 1.0;
    result[5] = 0.0;
    result[6] = sinAngle;
    result[7] = 0.0;
    result[8] = cosAngle;
    return result;
  };

  /**
   * 创建绕 z 轴旋转的旋转矩阵。
   * @param {Number} angle 旋转的角度，以弧度为单位。正角度表示逆时针旋转。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix3} 修改后的 result 参数，如果未提供，则返回一个新的 Matrix3 实例。
   *
   * @example
   * // Rotate a point 45 degrees counterclockwise around the z-axis.
   * const p = new Earth.Cartesian3(5, 6, 7);
   * const m = Earth.Matrix3.fromRotationZ(Earth.Math.toRadians(45.0));
   * const rotated = Earth.Matrix3.multiplyByVector(m, p, new Earth.Cartesian3());
   */
  Matrix3.fromRotationZ = function (angle, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("angle", angle);
    //>>includeEnd('debug');

    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined$1(result)) {
      return new Matrix3(cosAngle, -sinAngle, 0.0, sinAngle, cosAngle, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = cosAngle;
    result[1] = sinAngle;
    result[2] = 0.0;
    result[3] = -sinAngle;
    result[4] = cosAngle;
    result[5] = 0.0;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 1.0;
    return result;
  };

  /**
   * 从提供的 Matrix3 实例创建一个数组。数组将按列主序排列。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Number[]} result <code>optional</code> 存储结果的数组。
   * @returns {Number[]} 修改后的数组参数或一个新的数组实例，如果未提供则返回新的实例。
   */
  Matrix3.toArray = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    return result;
  };

  /**
   * 计算提供的行列所对应的数组索引。
   * @param {Number} column 列的从零开始的索引。
   * @param {Number} row 行的从零开始的索引。
   * @returns {Number} 提供的行和列所对应的元素的索引。
   * @exception {DeveloperError} 行必须为0、1或2。
   * @exception {DeveloperError} 列必须为0、1或2。
   *
   * @example
   * const myMatrix = new Earth.Matrix3();
   * const column1Row0Index = Earth.Matrix3.getElementIndex(1, 0);
   * const column1Row0 = myMatrix[column1Row0Index]
   * myMatrix[column1Row0Index] = 10.0;
   */
  Matrix3.getElementIndex = function (column, row) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number.greaterThanOrEquals("row", row, 0);
    Check.typeOf.number.lessThanOrEquals("row", row, 2);
    Check.typeOf.number.greaterThanOrEquals("column", column, 0);
    Check.typeOf.number.lessThanOrEquals("column", column, 2);
    //>>includeEnd('debug');

    return column * 3 + row;
  };

  /**
   * 检索指定索引处的矩阵列作为Cartesian3实例的副本。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Number} index 要检索的列的从零开始的索引。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   * @exception {DeveloperError} 索引必须为0、1或2。
   */
  Matrix3.getColumn = function (matrix, index, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 2);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var startIndex = index * 3;
    var x = matrix[startIndex];
    var y = matrix[startIndex + 1];
    var z = matrix[startIndex + 2];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 计算一个新的矩阵，将提供的矩阵中指定列替换为提供的Cartesian3实例。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Number} index 要设置的列的从零开始的索引。
   * @param {Cartesian3} cartesian 其值将被分配给指定列的Cartesian。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   * @exception {DeveloperError} 索引必须为0、1或2。
   */
  Matrix3.setColumn = function (matrix, index, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 2);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result = Matrix3.clone(matrix, result);
    var startIndex = index * 3;
    result[startIndex] = cartesian.x;
    result[startIndex + 1] = cartesian.y;
    result[startIndex + 2] = cartesian.z;
    return result;
  };

  /**
   * 检索指定索引处的矩阵行作为Cartesian3实例的副本。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Number} index 要检索的行的从零开始的索引。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   * @exception {DeveloperError} 索引必须为0、1或2。
   */
  Matrix3.getRow = function (matrix, index, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 2);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var x = matrix[index];
    var y = matrix[index + 3];
    var z = matrix[index + 6];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 计算一个新的矩阵，将提供的矩阵中指定行替换为提供的Cartesian3实例。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Number} index 要设置的行的从零开始的索引。
   * @param {Cartesian3} cartesian 其值将被分配给指定行的Cartesian。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   * @exception {DeveloperError} 索引必须为0、1或2。
   */
  Matrix3.setRow = function (matrix, index, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 2);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result = Matrix3.clone(matrix, result);
    result[index] = cartesian.x;
    result[index + 3] = cartesian.y;
    result[index + 6] = cartesian.z;
    return result;
  };
  var scaleScratch1$1 = new Cartesian3();

  /**
   * 计算一个新的矩阵，将比例替换为提供的比例。这假定矩阵是一种仿射变换。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Cartesian3} scale 替换提供的矩阵的比例的比例。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   *
   * @see Matrix3.setUniformScale
   * @see Matrix3.fromScale
   * @see Matrix3.fromUniformScale
   * @see Matrix3.multiplyByScale
   * @see Matrix3.multiplyByUniformScale
   * @see Matrix3.getScale
   */
  Matrix3.setScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var existingScale = Matrix3.getScale(matrix, scaleScratch1$1);
    var scaleRatioX = scale.x / existingScale.x;
    var scaleRatioY = scale.y / existingScale.y;
    var scaleRatioZ = scale.z / existingScale.z;
    result[0] = matrix[0] * scaleRatioX;
    result[1] = matrix[1] * scaleRatioX;
    result[2] = matrix[2] * scaleRatioX;
    result[3] = matrix[3] * scaleRatioY;
    result[4] = matrix[4] * scaleRatioY;
    result[5] = matrix[5] * scaleRatioY;
    result[6] = matrix[6] * scaleRatioZ;
    result[7] = matrix[7] * scaleRatioZ;
    result[8] = matrix[8] * scaleRatioZ;
    return result;
  };
  var scaleScratch2$1 = new Cartesian3();

  /**
   * 计算一个新的矩阵，将比例替换为提供的统一比例。
   * 这假定矩阵是一种仿射变换。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Number} scale 替换提供的矩阵的比例的统一比例。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   *
   * @see Matrix3.setScale
   * @see Matrix3.fromScale
   * @see Matrix3.fromUniformScale
   * @see Matrix3.multiplyByScale
   * @see Matrix3.multiplyByUniformScale
   * @see Matrix3.getScale
   */
  Matrix3.setUniformScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var existingScale = Matrix3.getScale(matrix, scaleScratch2$1);
    var scaleRatioX = scale / existingScale.x;
    var scaleRatioY = scale / existingScale.y;
    var scaleRatioZ = scale / existingScale.z;
    result[0] = matrix[0] * scaleRatioX;
    result[1] = matrix[1] * scaleRatioX;
    result[2] = matrix[2] * scaleRatioX;
    result[3] = matrix[3] * scaleRatioY;
    result[4] = matrix[4] * scaleRatioY;
    result[5] = matrix[5] * scaleRatioY;
    result[6] = matrix[6] * scaleRatioZ;
    result[7] = matrix[7] * scaleRatioZ;
    result[8] = matrix[8] * scaleRatioZ;
    return result;
  };
  var scratchColumn$1 = new Cartesian3();

  /**
   * 假设矩阵是一种仿射变换，提取非统一比例。
   * @param {Matrix3} matrix 矩阵。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   *
   * @see Matrix3.multiplyByScale
   * @see Matrix3.multiplyByUniformScale
   * @see Matrix3.fromScale
   * @see Matrix3.fromUniformScale
   * @see Matrix3.setScale
   * @see Matrix3.setUniformScale
   */
  Matrix3.getScale = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn$1));
    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn$1));
    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn$1));
    return result;
  };
  var scaleScratch3$1 = new Cartesian3();

  /**
   * 假设矩阵是一种仿射变换，计算最大比例。最大比例是列向量的最大长度。
   * @param {Matrix3} matrix 矩阵。
   * @returns {Number} 最大比例。
   */
  Matrix3.getMaximumScale = function (matrix) {
    Matrix3.getScale(matrix, scaleScratch3$1);
    return Cartesian3.maximumComponent(scaleScratch3$1);
  };
  var scaleScratch4$1 = new Cartesian3();

  /**
   * 假设矩阵是一种仿射变换，设置旋转。
   * @param {Matrix3} matrix 矩阵。
   * @param {Matrix3} rotation 旋转矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   *
   * @see Matrix3.getRotation
   */
  Matrix3.setRotation = function (matrix, rotation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var scale = Matrix3.getScale(matrix, scaleScratch4$1);
    result[0] = rotation[0] * scale.x;
    result[1] = rotation[1] * scale.x;
    result[2] = rotation[2] * scale.x;
    result[3] = rotation[3] * scale.y;
    result[4] = rotation[4] * scale.y;
    result[5] = rotation[5] * scale.y;
    result[6] = rotation[6] * scale.z;
    result[7] = rotation[7] * scale.z;
    result[8] = rotation[8] * scale.z;
    return result;
  };
  var scaleScratch5$1 = new Cartesian3();

  /**
   * 假定矩阵是仿射变换，提取旋转矩阵。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   *
   * @see Matrix3.setRotation
   */
  Matrix3.getRotation = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var scale = Matrix3.getScale(matrix, scaleScratch5$1);
    result[0] = matrix[0] / scale.x;
    result[1] = matrix[1] / scale.x;
    result[2] = matrix[2] / scale.x;
    result[3] = matrix[3] / scale.y;
    result[4] = matrix[4] / scale.y;
    result[5] = matrix[5] / scale.y;
    result[6] = matrix[6] / scale.z;
    result[7] = matrix[7] / scale.z;
    result[8] = matrix[8] / scale.z;
    return result;
  };

  /**
   * 计算两个矩阵的乘积。
   * @param {Matrix3} left 第一个矩阵。
   * @param {Matrix3} right 第二个矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的result参数。
   */
  Matrix3.multiply = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
    var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
    var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];
    var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
    var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
    var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];
    var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
    var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
    var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column1Row0;
    result[4] = column1Row1;
    result[5] = column1Row2;
    result[6] = column2Row0;
    result[7] = column2Row1;
    result[8] = column2Row2;
    return result;
  };

  /**
   * 计算两个矩阵的和。
   * @param {Matrix3} left 第一个矩阵。
   * @param {Matrix3} right 第二个矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   */
  Matrix3.add = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = left[0] + right[0];
    result[1] = left[1] + right[1];
    result[2] = left[2] + right[2];
    result[3] = left[3] + right[3];
    result[4] = left[4] + right[4];
    result[5] = left[5] + right[5];
    result[6] = left[6] + right[6];
    result[7] = left[7] + right[7];
    result[8] = left[8] + right[8];
    return result;
  };

  /**
   * 计算两个矩阵之间的差。
   * @param {Matrix3} left 第一个矩阵。
   * @param {Matrix3} right 第二个矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   */
  Matrix3.subtract = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = left[0] - right[0];
    result[1] = left[1] - right[1];
    result[2] = left[2] - right[2];
    result[3] = left[3] - right[3];
    result[4] = left[4] - right[4];
    result[5] = left[5] - right[5];
    result[6] = left[6] - right[6];
    result[7] = left[7] - right[7];
    result[8] = left[8] - right[8];
    return result;
  };

  /**
   * 计算一个矩阵和一个列向量的乘积。
   * @param {Matrix3} matrix 矩阵。
   * @param {Cartesian3} cartesian 列向量。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   */
  Matrix3.multiplyByVector = function (matrix, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
    var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
    var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 计算一个矩阵和一个标量的乘积。
   * @param {Matrix3} matrix 矩阵。
   * @param {Number} scalar 数字乘数。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   */
  Matrix3.multiplyByScalar = function (matrix, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number("scalar", scalar);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = matrix[0] * scalar;
    result[1] = matrix[1] * scalar;
    result[2] = matrix[2] * scalar;
    result[3] = matrix[3] * scalar;
    result[4] = matrix[4] * scalar;
    result[5] = matrix[5] * scalar;
    result[6] = matrix[6] * scalar;
    result[7] = matrix[7] * scalar;
    result[8] = matrix[8] * scalar;
    return result;
  };

  /**
   * 计算矩阵与非均匀缩放的乘积，就像缩放是一个缩放矩阵一样。
   * @param {Matrix3} matrix 左侧的矩阵。
   * @param {Cartesian3} scale 右侧的非均匀缩放。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   *
   *
   * @example
   * // Instead of Earth.Matrix3.multiply(m, Earth.Matrix3.fromScale(scale), m);
   * Earth.Matrix3.multiplyByScale(m, scale, m);
   *
   * @see Matrix3.multiplyByUniformScale
   * @see Matrix3.fromScale
   * @see Matrix3.fromUniformScale
   * @see Matrix3.setScale
   * @see Matrix3.setUniformScale
   * @see Matrix3.getScale
   */
  Matrix3.multiplyByScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = matrix[0] * scale.x;
    result[1] = matrix[1] * scale.x;
    result[2] = matrix[2] * scale.x;
    result[3] = matrix[3] * scale.y;
    result[4] = matrix[4] * scale.y;
    result[5] = matrix[5] * scale.y;
    result[6] = matrix[6] * scale.z;
    result[7] = matrix[7] * scale.z;
    result[8] = matrix[8] * scale.z;
    return result;
  };

  /**
   * 计算矩阵与均匀缩放的乘积，就像缩放是一个缩放矩阵一样。
   * @param {Matrix3} matrix 左侧的矩阵。
   * @param {Number} scale 右侧的均匀缩放。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   *
   * @example
   * // Instead of Earth.Matrix3.multiply(m, Earth.Matrix3.fromUniformScale(scale), m);
   * Earth.Matrix3.multiplyByUniformScale(m, scale, m);
   *
   * @see Matrix3.multiplyByScale
   * @see Matrix3.fromScale
   * @see Matrix3.fromUniformScale
   * @see Matrix3.setScale
   * @see Matrix3.setUniformScale
   * @see Matrix3.getScale
   */
  Matrix3.multiplyByUniformScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = matrix[0] * scale;
    result[1] = matrix[1] * scale;
    result[2] = matrix[2] * scale;
    result[3] = matrix[3] * scale;
    result[4] = matrix[4] * scale;
    result[5] = matrix[5] * scale;
    result[6] = matrix[6] * scale;
    result[7] = matrix[7] * scale;
    result[8] = matrix[8] * scale;
    return result;
  };

  /**
   * 创建所提供矩阵的取反副本。
   * @param {Matrix3} matrix 要取反的矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   */
  Matrix3.negate = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = -matrix[0];
    result[1] = -matrix[1];
    result[2] = -matrix[2];
    result[3] = -matrix[3];
    result[4] = -matrix[4];
    result[5] = -matrix[5];
    result[6] = -matrix[6];
    result[7] = -matrix[7];
    result[8] = -matrix[8];
    return result;
  };

  /**
   * 计算所提供矩阵的转置。
   * @param {Matrix3} matrix 要转置的矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   */
  Matrix3.transpose = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var column0Row0 = matrix[0];
    var column0Row1 = matrix[3];
    var column0Row2 = matrix[6];
    var column1Row0 = matrix[1];
    var column1Row1 = matrix[4];
    var column1Row2 = matrix[7];
    var column2Row0 = matrix[2];
    var column2Row1 = matrix[5];
    var column2Row2 = matrix[8];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column1Row0;
    result[4] = column1Row1;
    result[5] = column1Row2;
    result[6] = column2Row0;
    result[7] = column2Row1;
    result[8] = column2Row2;
    return result;
  };
  /*
   * 计算矩阵的 Frobenius 范数
   * @param {Matrix3} matrix 要计算的矩阵
   * @returns {Number} 返回平方和的平方根
   */
  function computeFrobeniusNorm(matrix) {
    var norm = 0.0;
    for (var i = 0; i < 9; ++i) {
      var temp = matrix[i];
      norm += temp * temp;
    }
    return Math.sqrt(norm);
  }
  var rowVal = [1, 0, 0];
  var colVal = [2, 2, 1];
  /*
   * 计算矩阵的“非对角线”Frobenius范数
   * @param {Matrix3} matrix 
   * @returns {Number} 返回平方和的平方根
   */
  function offDiagonalFrobeniusNorm(matrix) {
    // Computes the "off-diagonal" Frobenius norm.
    // Assumes matrix is symmetric.

    var norm = 0.0;
    for (var i = 0; i < 3; ++i) {
      var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
      norm += 2.0 * temp * temp;
    }
    return Math.sqrt(norm);
  }
  /*
   * 计算矩阵的Shur分解
   * @param {Matrix3} matrix 要计算的矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 返回降低非对角线元素后的旋转矩阵。
   */
  function shurDecomposition(matrix, result) {
    // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
    // section 8.4.2 The 2by2 Symmetric Schur Decomposition.
    //
    // The routine takes a matrix, which is assumed to be symmetric, and
    // finds the largest off-diagonal term, and then creates
    // a matrix (result) which can be used to help reduce it

    var tolerance = CesiumMath.EPSILON15;
    var maxDiagonal = 0.0;
    var rotAxis = 1;

    // find pivot (rotAxis) based on max diagonal of matrix
    for (var i = 0; i < 3; ++i) {
      var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);
      if (temp > maxDiagonal) {
        rotAxis = i;
        maxDiagonal = temp;
      }
    }
    var c = 1.0;
    var s = 0.0;
    var p = rowVal[rotAxis];
    var q = colVal[rotAxis];
    if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
      var qq = matrix[Matrix3.getElementIndex(q, q)];
      var pp = matrix[Matrix3.getElementIndex(p, p)];
      var qp = matrix[Matrix3.getElementIndex(q, p)];
      var tau = (qq - pp) / 2.0 / qp;
      var t;
      if (tau < 0.0) {
        t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
      } else {
        t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
      }
      c = 1.0 / Math.sqrt(1.0 + t * t);
      s = t * c;
    }
    result = Matrix3.clone(Matrix3.IDENTITY, result);
    result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;
    result[Matrix3.getElementIndex(q, p)] = s;
    result[Matrix3.getElementIndex(p, q)] = -s;
    return result;
  }
  var jMatrix = new Matrix3();
  var jMatrixTranspose = new Matrix3();

  /**
   * 计算对称矩阵的特征向量和特征值。
   * @param {Matrix3} matrix 要分解为对角线和酉矩阵的矩阵。预计是对称的。
   * @param {Object} result <code>optional</code> 一个具有unitary和diagonal属性的对象，它们是矩阵，用于存储结果。
   * @returns {Object} 一个具有unitary和diagonal属性的对象，它们分别是酉矩阵和对角线矩阵。
   * @example
   * const a = //... symetric matrix
   * const result = {
   *     unitary : new Earth.Matrix3(),
   *     diagonal : new Earth.Matrix3()
   * };
   * Earth.Matrix3.computeEigenDecomposition(a, result);
   *
   * const unitaryTranspose = Earth.Matrix3.transpose(result.unitary, new Earth.Matrix3());
   * const b = Earth.Matrix3.multiply(result.unitary, result.diagonal, new Earth.Matrix3());
   * Earth.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a
   *
   * const lambda = Earth.Matrix3.getColumn(result.diagonal, 0, new Earth.Cartesian3()).x;  // first eigenvalue
   * const v = Earth.Matrix3.getColumn(result.unitary, 0, new Earth.Cartesian3());          // first eigenvector
   * const c = Earth.Cartesian3.multiplyByScalar(v, lambda, new Earth.Cartesian3());        // equal to Earth.Matrix3.multiplyByVector(a, v)
   */
  Matrix3.computeEigenDecomposition = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    //>>includeEnd('debug');

    // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
    // section 8.4.3 The Classical Jacobi Algorithm

    var tolerance = CesiumMath.EPSILON20;
    var maxSweeps = 10;
    var count = 0;
    var sweep = 0;
    if (!defined$1(result)) {
      result = {};
    }
    var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);
    var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);
    var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);
    while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
      shurDecomposition(diagMatrix, jMatrix);
      Matrix3.transpose(jMatrix, jMatrixTranspose);
      Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
      Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
      Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);
      if (++count > 2) {
        ++sweep;
        count = 0;
      }
    }
    return result;
  };

  /**
   * 计算一个矩阵，其中包含了提供矩阵元素的绝对值。
   * @param {Matrix3} matrix 带有有符号元素的矩阵。
   * @param {Matrix3} result 用于存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   */
  Matrix3.abs = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = Math.abs(matrix[0]);
    result[1] = Math.abs(matrix[1]);
    result[2] = Math.abs(matrix[2]);
    result[3] = Math.abs(matrix[3]);
    result[4] = Math.abs(matrix[4]);
    result[5] = Math.abs(matrix[5]);
    result[6] = Math.abs(matrix[6]);
    result[7] = Math.abs(matrix[7]);
    result[8] = Math.abs(matrix[8]);
    return result;
  };

  /**
   * 计算提供的矩阵的行列式。
   * @param {Matrix3} matrix 要使用的矩阵。
   * @returns {Number} 矩阵行列式的值。
   */
  Matrix3.determinant = function (matrix) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    //>>includeEnd('debug');

    var m11 = matrix[0];
    var m21 = matrix[3];
    var m31 = matrix[6];
    var m12 = matrix[1];
    var m22 = matrix[4];
    var m32 = matrix[7];
    var m13 = matrix[2];
    var m23 = matrix[5];
    var m33 = matrix[8];
    return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
  };

  /**
   * 计算提供矩阵的逆矩阵。
   * @param {Matrix3} matrix 要求逆矩阵的矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   * @exception {DeveloperError} matrix 不可逆。
   */
  Matrix3.inverse = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var m11 = matrix[0];
    var m21 = matrix[1];
    var m31 = matrix[2];
    var m12 = matrix[3];
    var m22 = matrix[4];
    var m32 = matrix[5];
    var m13 = matrix[6];
    var m23 = matrix[7];
    var m33 = matrix[8];
    var determinant = Matrix3.determinant(matrix);

    //>>includeStart('debug', pragmas.debug);
    if (Math.abs(determinant) <= CesiumMath.EPSILON15) {
      throw new DeveloperError$1("matrix is not invertible");
    }
    //>>includeEnd('debug');

    result[0] = m22 * m33 - m23 * m32;
    result[1] = m23 * m31 - m21 * m33;
    result[2] = m21 * m32 - m22 * m31;
    result[3] = m13 * m32 - m12 * m33;
    result[4] = m11 * m33 - m13 * m31;
    result[5] = m12 * m31 - m11 * m32;
    result[6] = m12 * m23 - m13 * m22;
    result[7] = m13 * m21 - m11 * m23;
    result[8] = m11 * m22 - m12 * m21;
    var scale = 1.0 / determinant;
    return Matrix3.multiplyByScalar(result, scale, result);
  };
  var scratchTransposeMatrix$1 = new Matrix3();

  /**
   * 计算一个矩阵的逆转置。
   * @param {Matrix3} matrix 需要转置和求逆的矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数。
   */
  Matrix3.inverseTranspose = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    return Matrix3.inverse(Matrix3.transpose(matrix, scratchTransposeMatrix$1), result);
  };

  /**
   * 逐个比较提供的两个矩阵，并在它们相等时返回true，否则返回false。
   * @param {Matrix3} left <code>optional</code> 第一个矩阵。
   * @param {Matrix3} right <code>optional</code> 第二个矩阵。
   * @returns {Boolean} 如果 left 和 right 相等，则返回true，否则返回false。
   */
  Matrix3.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8];
  };

  /**
   * 逐个比较提供的两个矩阵，并在它们在给定的epsilon内时返回true，否则返回false。
   * @param {Matrix3} left <code>optional</code> 第一个矩阵。
   * @param {Matrix3} right <code>optional</code> 第二个矩阵。
   * @param {Number} epsilon=0 <code>optional</code> 用于相等性测试的epsilon值。
   * @returns {Boolean} 如果 left 和 right 在给定的 epsilon 范围内，则返回<code>true</code>，否则返回<code>false</code>。
   */
  Matrix3.equalsEpsilon = function (left, right, epsilon) {
    epsilon = defaultValue$1(epsilon, 0);
    return left === right || defined$1(left) && defined$1(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon;
  };

  /*
   * An immutable Matrix3 instance initialized to the identity matrix.
   *
   * @type {Matrix3}
   * @constant
   */
  Matrix3.IDENTITY = Object.freeze(new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0));

  /*
   * An immutable Matrix3 instance initialized to the zero matrix.
   *
   * @type {Matrix3}
   * @constant
   */
  Matrix3.ZERO = Object.freeze(new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

  /*
   * The index into Matrix3 for column 0, row 0.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN0ROW0 = 0;

  /*
   * The index into Matrix3 for column 0, row 1.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN0ROW1 = 1;

  /*
   * The index into Matrix3 for column 0, row 2.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN0ROW2 = 2;

  /*
   * The index into Matrix3 for column 1, row 0.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN1ROW0 = 3;

  /*
   * The index into Matrix3 for column 1, row 1.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN1ROW1 = 4;

  /*
   * The index into Matrix3 for column 1, row 2.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN1ROW2 = 5;

  /*
   * The index into Matrix3 for column 2, row 0.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN2ROW0 = 6;

  /*
   * The index into Matrix3 for column 2, row 1.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN2ROW1 = 7;

  /*
   * The index into Matrix3 for column 2, row 2.
   *
   * @type {Number}
   * @constant
   */
  Matrix3.COLUMN2ROW2 = 8;
  Object.defineProperties(Matrix3.prototype, {
    /** 
     * 获取集合中的项目数量。
     * @memberof Matrix3.prototype
     *
     * @type {Number}
     */
    length: {
      get: function get() {
        return Matrix3.packedLength;
      }
    }
  });

  /**
   * 复制提供的 Matrix3 实例。
   * @param {Matrix3} result <code>optional</code> 存储结果的对象。
   * @returns {Matrix3} 修改后的结果参数或一个新的 Matrix3 实例（如果没有提供结果参数）。
   */
  Matrix3.prototype.clone = function (result) {
    return Matrix3.clone(this, result);
  };

  /**
   * 逐个比较此矩阵和提供的矩阵，并在它们相等时返回true，否则返回false。
   * @param {Matrix3} right <code>optional</code> 右侧矩阵。
   * @returns {Boolean} 如果它们相等，则返回true，否则返回false。
   */
  Matrix3.prototype.equals = function (right) {
    return Matrix3.equals(this, right);
  };

  /**
   * @private
   */
  Matrix3.equalsArray = function (matrix, array, offset) {
    return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8];
  };

  /**
   * 逐个比较此矩阵和提供的矩阵，并在它们在给定的epsilon内时返回true，否则返回false。
   * @param {Matrix3} right <code>optional</code> 右侧矩阵。
   * @param {Number} epsilon=0 <code>optional</code> 用于相等性测试的epsilon值。
   * @returns {Boolean} 如果它们在给定的 epsilon 范围内，则返回true，否则返回false。
   */
  Matrix3.prototype.equalsEpsilon = function (right, epsilon) {
    return Matrix3.equalsEpsilon(this, right, epsilon);
  };

  /**
   * 创建一个字符串，表示该矩阵，每行都在单独的行上，格式为“(column0，column1，column2)”。
   * @returns {String} 表示提供的矩阵的字符串，每行都在单独的行上，格式为“(column0，column1，column2)”。
   */
  Matrix3.prototype.toString = function () {
    return "(".concat(this[0], ", ").concat(this[3], ", ").concat(this[6], ")\n") + "(".concat(this[1], ", ").concat(this[4], ", ").concat(this[7], ")\n") + "(".concat(this[2], ", ").concat(this[5], ", ").concat(this[8], ")");
  };

  /**
   * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
   * out of memory, could not compile shader, etc.  If a function may throw this
   * exception, the calling code should be prepared to catch it.
   * <br /><br />
   * On the other hand, a {@link DeveloperError} indicates an exception due
   * to a developer error, e.g., invalid argument, that usually indicates a bug in the
   * calling code.
   *
   * @alias RuntimeError
   * @constructor
   * @extends Error
   *
   * @param {String} [message] The error message for this exception.
   *
   * @see DeveloperError
   */
  function RuntimeError$1(message) {
    /**
     * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
     * @type {String}
     * @readonly
     */
    this.name = "RuntimeError";

    /**
     * The explanation for why this exception was thrown.
     * @type {String}
     * @readonly
     */
    this.message = message;

    //Browsers such as IE don't have a stack property until you actually throw the error.
    var stack;
    try {
      throw new Error();
    } catch (e) {
      stack = e.stack;
    }

    /**
     * The stack trace of this exception, if available.
     * @type {String}
     * @readonly
     */
    this.stack = stack;
  }
  if (defined$1(Object.create)) {
    RuntimeError$1.prototype = Object.create(Error.prototype);
    RuntimeError$1.prototype.constructor = RuntimeError$1;
  }
  RuntimeError$1.prototype.toString = function () {
    var str = "".concat(this.name, ": ").concat(this.message);
    if (defined$1(this.stack)) {
      str += "\n".concat(this.stack.toString());
    }
    return str;
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 基础模块
   * ---
   */

  /**
   * @class Matrix4
   *  一个可按列为主序数组索引的 4x4 矩阵。构造函数参数按行为主序，以提高代码可读性
   * @constructor
   *
   * @param {Number} column0Row0=0.0 <code>optional</code> 第0列第0行的值，默认值为0.0。
   * @param {Number} column1Row0=0.0 <code>optional</code> 第1列第0行的值，默认值为0.0。
   * @param {Number} column2Row0=0.0 <code>optional</code> 第2列第0行的值，默认值为0.0。
   * @param {Number} column3Row0=0.0 <code>optional</code> 第3列第0行的值，默认值为0.0。
   * @param {Number} column0Row1=0.0 <code>optional</code> 第0列第1行的值，默认值为0.0。
   * @param {Number} column1Row1=0.0 <code>optional</code> 第1列第1行的值，默认值为0.0。
   * @param {Number} column2Row1=0.0 <code>optional</code> 第2列第1行的值，默认值为0.0。
   * @param {Number} column3Row1=0.0 <code>optional</code> 第3列第1行的值，默认值为0.0。
   * @param {Number} column0Row2=0.0 <code>optional</code> 第0列第2行的值，默认值为0.0。
   * @param {Number} column1Row2=0.0 <code>optional</code> 第1列第2行的值，默认值为0.0。
   * @param {Number} column2Row2=0.0 <code>optional</code> 第2列第2行的值，默认值为0.0。
   * @param {Number} column3Row2=0.0 <code>optional</code> 第3列第2行的值，默认值为0.0。
   * @param {Number} column0Row3=0.0 <code>optional</code> 第0列第3行的值，默认值为0.0。
   * @param {Number} column1Row3=0.0 <code>optional</code> 第1列第3行的值，默认值为0.0。
   * @param {Number} column2Row3=0.0 <code>optional</code> 第2列第3行的值，默认值为0.0。
   * @param {Number} column3Row3=0.0 <code>optional</code> 第3列第3行的值，默认值为0.0。
   *
   */
  function Matrix4(column0Row0, column1Row0, column2Row0, column3Row0, column0Row1, column1Row1, column2Row1, column3Row1, column0Row2, column1Row2, column2Row2, column3Row2, column0Row3, column1Row3, column2Row3, column3Row3) {
    this[0] = defaultValue$1(column0Row0, 0.0);
    this[1] = defaultValue$1(column0Row1, 0.0);
    this[2] = defaultValue$1(column0Row2, 0.0);
    this[3] = defaultValue$1(column0Row3, 0.0);
    this[4] = defaultValue$1(column1Row0, 0.0);
    this[5] = defaultValue$1(column1Row1, 0.0);
    this[6] = defaultValue$1(column1Row2, 0.0);
    this[7] = defaultValue$1(column1Row3, 0.0);
    this[8] = defaultValue$1(column2Row0, 0.0);
    this[9] = defaultValue$1(column2Row1, 0.0);
    this[10] = defaultValue$1(column2Row2, 0.0);
    this[11] = defaultValue$1(column2Row3, 0.0);
    this[12] = defaultValue$1(column3Row0, 0.0);
    this[13] = defaultValue$1(column3Row1, 0.0);
    this[14] = defaultValue$1(column3Row2, 0.0);
    this[15] = defaultValue$1(column3Row3, 0.0);
  }

  /*
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Matrix4.packedLength = 16;

  /**
   * 将提供的实例存储到提供的数组中。
   * @param {Matrix4} value 要打包的值。
   * @param {Number[]} array 要打包进的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 开始打包元素的数组索引。
   * @returns {Number[]} 被打包的数组
   */
  Matrix4.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("value", value);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value[0];
    array[startingIndex++] = value[1];
    array[startingIndex++] = value[2];
    array[startingIndex++] = value[3];
    array[startingIndex++] = value[4];
    array[startingIndex++] = value[5];
    array[startingIndex++] = value[6];
    array[startingIndex++] = value[7];
    array[startingIndex++] = value[8];
    array[startingIndex++] = value[9];
    array[startingIndex++] = value[10];
    array[startingIndex++] = value[11];
    array[startingIndex++] = value[12];
    array[startingIndex++] = value[13];
    array[startingIndex++] = value[14];
    array[startingIndex] = value[15];
    return array;
  };

  /**
   * 从打包的数组中获取一个实例。
   * @param {Number[]} array 打包的数组。
   * @param {Number} startingIndex=0 <code>optional</code> 要解包的元素的起始索引。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数或新的 Matrix4 实例（如果未提供）。
   */
  Matrix4.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new Matrix4();
    }
    result[0] = array[startingIndex++];
    result[1] = array[startingIndex++];
    result[2] = array[startingIndex++];
    result[3] = array[startingIndex++];
    result[4] = array[startingIndex++];
    result[5] = array[startingIndex++];
    result[6] = array[startingIndex++];
    result[7] = array[startingIndex++];
    result[8] = array[startingIndex++];
    result[9] = array[startingIndex++];
    result[10] = array[startingIndex++];
    result[11] = array[startingIndex++];
    result[12] = array[startingIndex++];
    result[13] = array[startingIndex++];
    result[14] = array[startingIndex++];
    result[15] = array[startingIndex];
    return result;
  };

  /**
   * 将一个 Matrix4 数组压缩成一个按列顺序存储的组件数组。
   * @param {Matrix4[]} array 要压缩的矩阵数组。
   * @param {Number[]} result <code>optional</code> 存储结果的数组。如果这是一个类型化数组，它必须有 array.length * 16 个组件，否则将抛出 {@link DeveloperError} 异常。如果它是一个普通的数组，它将被调整大小为 (array.length * 16) 元素。
   * @returns {Number[]} 压缩后的数组。
   */
  Matrix4.packArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    //>>includeEnd('debug');

    var length = array.length;
    var resultLength = length * 16;
    if (!defined$1(result)) {
      result = new Array(resultLength);
    } else if (!Array.isArray(result) && result.length !== resultLength) {
      //>>includeStart('debug', pragmas.debug);
      throw new DeveloperError$1("If result is a typed array, it must have exactly array.length * 16 elements");
      //>>includeEnd('debug');
    } else if (result.length !== resultLength) {
      result.length = resultLength;
    }
    for (var i = 0; i < length; ++i) {
      Matrix4.pack(array[i], result, i * 16);
    }
    return result;
  };

  /**
   * 将按列顺序存储的矩阵组件数组解压成 Matrix4 数组。
   * @param {Number[]} array 要解压的组件数组。
   * @param {Matrix4[]} result <code>optional</code> 存储结果的数组。
   * @returns {Matrix4[]} 解压后的数组。
   */
  Matrix4.unpackArray = function (array, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("array", array);
    Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 16);
    if (array.length % 16 !== 0) {
      throw new DeveloperError$1("array length must be a multiple of 16.");
    }
    //>>includeEnd('debug');

    var length = array.length;
    if (!defined$1(result)) {
      result = new Array(length / 16);
    } else {
      result.length = length / 16;
    }
    for (var i = 0; i < length; i += 16) {
      var index = i / 16;
      result[index] = Matrix4.unpack(array, i, result[index]);
    }
    return result;
  };

  /**
   * 复制一个 Matrix4 实例。
   * @param {Matrix4} matrix 要复制的矩阵。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数或者如果未提供，则为新的 Matrix4 实例。（如果 matrix 为 undefined，则返回 undefined）
   */
  Matrix4.clone = function (matrix, result) {
    if (!defined$1(matrix)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Matrix4(matrix[0], matrix[4], matrix[8], matrix[12], matrix[1], matrix[5], matrix[9], matrix[13], matrix[2], matrix[6], matrix[10], matrix[14], matrix[3], matrix[7], matrix[11], matrix[15]);
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };

  /**
   * 从数组的 16 个连续元素创建一个 Matrix4。
   * @param {Number[]} array 包含矩阵位置信息的 16 个连续元素的数组。假定按列顺序。
   * @param {Number} startingIndex=0 <code>optional</code> 数组中第一个元素的偏移量，对应于矩阵的第一列第一行位置。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数或者如果未提供，则为新的 Matrix4 实例。
   *
   * @example
   * // Create the Matrix4:
   * // [1.0, 2.0, 3.0, 4.0]
   * // [1.0, 2.0, 3.0, 4.0]
   * // [1.0, 2.0, 3.0, 4.0]
   * // [1.0, 2.0, 3.0, 4.0]
   *
   * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
   * const m = Earth.Matrix4.fromArray(v);
   *
   * // Create same Matrix4 with using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
   * const m2 = Earth.Matrix4.fromArray(v2, 2);
   */
  Matrix4.fromArray = Matrix4.unpack;

  /**
   * 从按列顺序的数组计算一个 Matrix4 实例。
   * @param {Number[]} values 按列顺序排列的数组。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的结果参数或者如果未提供，则为新的 Matrix4 实例。
   */
  Matrix4.fromColumnMajorArray = function (values, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("values", values);
    //>>includeEnd('debug');

    return Matrix4.clone(values, result);
  };

  /**
   * 从按行顺序的数组计算一个 Matrix4 实例。计算结果的矩阵将按列顺序排列。
   * @param {Number[]} values 按行顺序排列的数组。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的结果参数或者如果未提供，则为新的 Matrix4 实例。
   */
  Matrix4.fromRowMajorArray = function (values, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined("values", values);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Matrix4(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15]);
    }
    result[0] = values[0];
    result[1] = values[4];
    result[2] = values[8];
    result[3] = values[12];
    result[4] = values[1];
    result[5] = values[5];
    result[6] = values[9];
    result[7] = values[13];
    result[8] = values[2];
    result[9] = values[6];
    result[10] = values[10];
    result[11] = values[14];
    result[12] = values[3];
    result[13] = values[7];
    result[14] = values[11];
    result[15] = values[15];
    return result;
  };

  /**
   * 从表示旋转的 Matrix3 和表示平移的 Cartesian3 计算一个 Matrix4 实例。
   * @param {Matrix3} rotation 表示旋转的矩阵的左上部分。
   * @param {Cartesian3} translation=Cartesian3.ZERO <code>optional</code> 表示平移的矩阵的右上部分。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的结果参数或者如果未提供，则为新的 Matrix4 实例。
   */
  Matrix4.fromRotationTranslation = function (rotation, translation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("rotation", rotation);
    //>>includeEnd('debug');

    translation = defaultValue$1(translation, Cartesian3.ZERO);
    if (!defined$1(result)) {
      return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x, rotation[1], rotation[4], rotation[7], translation.y, rotation[2], rotation[5], rotation[8], translation.z, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = rotation[0];
    result[1] = rotation[1];
    result[2] = rotation[2];
    result[3] = 0.0;
    result[4] = rotation[3];
    result[5] = rotation[4];
    result[6] = rotation[5];
    result[7] = 0.0;
    result[8] = rotation[6];
    result[9] = rotation[7];
    result[10] = rotation[8];
    result[11] = 0.0;
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = 1.0;
    return result;
  };

  /**
   * 从平移、旋转和缩放（TRS）表示中的旋转用四元数表示计算一个 Matrix4 实例。
   * @param {Cartesian3} translation 平移变换。
   * @param {Quaternion} rotation 旋转变换。
   * @param {Cartesian3} scale 非均匀缩放变换。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的结果参数或者如果未提供，则为新的 Matrix4 实例。
   *
   * @example
   * const result = Earth.Matrix4.fromTranslationQuaternionRotationScale(
   *   new Earth.Cartesian3(1.0, 2.0, 3.0), // translation
   *   Earth.Quaternion.IDENTITY,           // rotation
   *   new Earth.Cartesian3(7.0, 8.0, 9.0), // scale
   *   result);
   */
  Matrix4.fromTranslationQuaternionRotationScale = function (translation, rotation, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("translation", translation);
    Check.typeOf.object("rotation", rotation);
    Check.typeOf.object("scale", scale);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Matrix4();
    }
    var scaleX = scale.x;
    var scaleY = scale.y;
    var scaleZ = scale.z;
    var x2 = rotation.x * rotation.x;
    var xy = rotation.x * rotation.y;
    var xz = rotation.x * rotation.z;
    var xw = rotation.x * rotation.w;
    var y2 = rotation.y * rotation.y;
    var yz = rotation.y * rotation.z;
    var yw = rotation.y * rotation.w;
    var z2 = rotation.z * rotation.z;
    var zw = rotation.z * rotation.w;
    var w2 = rotation.w * rotation.w;
    var m00 = x2 - y2 - z2 + w2;
    var m01 = 2.0 * (xy - zw);
    var m02 = 2.0 * (xz + yw);
    var m10 = 2.0 * (xy + zw);
    var m11 = -x2 + y2 - z2 + w2;
    var m12 = 2.0 * (yz - xw);
    var m20 = 2.0 * (xz - yw);
    var m21 = 2.0 * (yz + xw);
    var m22 = -x2 - y2 + z2 + w2;
    result[0] = m00 * scaleX;
    result[1] = m10 * scaleX;
    result[2] = m20 * scaleX;
    result[3] = 0.0;
    result[4] = m01 * scaleY;
    result[5] = m11 * scaleY;
    result[6] = m21 * scaleY;
    result[7] = 0.0;
    result[8] = m02 * scaleZ;
    result[9] = m12 * scaleZ;
    result[10] = m22 * scaleZ;
    result[11] = 0.0;
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = 1.0;
    return result;
  };

  /**
   * 从 TranslationRotationScale 实例创建一个 Matrix4 实例。
   * @param {TranslationRotationScale} translationRotationScale 实例。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的结果参数或者如果未提供，则为新的 Matrix4 实例。
   */
  Matrix4.fromTranslationRotationScale = function (translationRotationScale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("translationRotationScale", translationRotationScale);
    //>>includeEnd('debug');

    return Matrix4.fromTranslationQuaternionRotationScale(translationRotationScale.translation, translationRotationScale.rotation, translationRotationScale.scale, result);
  };

  /**
   * 从代表平移的Cartesian3创建一个Matrix4实例。
   * @param {Cartesian3} translation 代表矩阵平移的Cartesian3。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新的实例。
   * @returns {Matrix4} 修改后的result参数，如果未提供，则为新的Matrix4实例。
   *
   * @see Matrix4.multiplyByTranslation
   */
  Matrix4.fromTranslation = function (translation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("translation", translation);
    //>>includeEnd('debug');

    return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
  };

  /**
   * 计算表示非均匀缩放的Matrix4实例。
   * @param {Cartesian3} scale 缩放的x、y、z因子。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的result参数，如果没有提供则是一个新的Matrix4实例。
   *
   * @example
   * // Creates
   * //   [7.0, 0.0, 0.0, 0.0]
   * //   [0.0, 8.0, 0.0, 0.0]
   * //   [0.0, 0.0, 9.0, 0.0]
   * //   [0.0, 0.0, 0.0, 1.0]
   * const m = Earth.Matrix4.fromScale(new Earth.Cartesian3(7.0, 8.0, 9.0));
   */
  Matrix4.fromScale = function (scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("scale", scale);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Matrix4(scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = scale.x;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = scale.y;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = scale.z;
    result[11] = 0.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = 0.0;
    result[15] = 1.0;
    return result;
  };

  /**
   * 计算表示均匀缩放的 Matrix4 实例。
   * @param {Number} scale 均匀缩放因子。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的 result 参数，如果未提供则为新的 Matrix4 实例。
   *
   * @example
   * // Creates
   * //   [2.0, 0.0, 0.0, 0.0]
   * //   [0.0, 2.0, 0.0, 0.0]
   * //   [0.0, 0.0, 2.0, 0.0]
   * //   [0.0, 0.0, 0.0, 1.0]
   * const m = Earth.Matrix4.fromUniformScale(2.0);
   */
  Matrix4.fromUniformScale = function (scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("scale", scale);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Matrix4(scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = scale;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = scale;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = scale;
    result[11] = 0.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = 0.0;
    result[15] = 1.0;
    return result;
  };

  /**
   * 创建一个旋转矩阵。
   * @param {Matrix3} rotation 旋转矩阵。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的 result 参数，如果未提供则为新的 Matrix4 实例。
   */
  Matrix4.fromRotation = function (rotation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("rotation", rotation);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Matrix4();
    }
    result[0] = rotation[0];
    result[1] = rotation[1];
    result[2] = rotation[2];
    result[3] = 0.0;
    result[4] = rotation[3];
    result[5] = rotation[4];
    result[6] = rotation[5];
    result[7] = 0.0;
    result[8] = rotation[6];
    result[9] = rotation[7];
    result[10] = rotation[8];
    result[11] = 0.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = 0.0;
    result[15] = 1.0;
    return result;
  };
  var fromCameraF = new Cartesian3();
  var fromCameraR = new Cartesian3();
  var fromCameraU = new Cartesian3();

  /**
   * 从摄像机参数计算生成一个Matrix4实例。
   * @param {Camera} camera 使用的摄像机。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则会创建一个新实例。
   * @returns {Matrix4} 修改后的结果参数，如果未提供，则为新的Matrix4实例。
   */
  Matrix4.fromCamera = function (camera, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("camera", camera);
    //>>includeEnd('debug');

    var position = camera.position;
    var direction = camera.direction;
    var up = camera.up;

    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("camera.position", position);
    Check.typeOf.object("camera.direction", direction);
    Check.typeOf.object("camera.up", up);
    //>>includeEnd('debug');

    Cartesian3.normalize(direction, fromCameraF);
    Cartesian3.normalize(Cartesian3.cross(fromCameraF, up, fromCameraR), fromCameraR);
    Cartesian3.normalize(Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU), fromCameraU);
    var sX = fromCameraR.x;
    var sY = fromCameraR.y;
    var sZ = fromCameraR.z;
    var fX = fromCameraF.x;
    var fY = fromCameraF.y;
    var fZ = fromCameraF.z;
    var uX = fromCameraU.x;
    var uY = fromCameraU.y;
    var uZ = fromCameraU.z;
    var positionX = position.x;
    var positionY = position.y;
    var positionZ = position.z;
    var t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;
    var t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;
    var t2 = fX * positionX + fY * positionY + fZ * positionZ;

    // The code below this comment is an optimized
    // version of the commented lines.
    // Rather that create two matrices and then multiply,
    // we just bake in the multiplcation as part of creation.
    // const rotation = new Matrix4(
    //                 sX,  sY,  sZ, 0.0,
    //                 uX,  uY,  uZ, 0.0,
    //                -fX, -fY, -fZ, 0.0,
    //                 0.0,  0.0,  0.0, 1.0);
    // const translation = new Matrix4(
    //                 1.0, 0.0, 0.0, -position.x,
    //                 0.0, 1.0, 0.0, -position.y,
    //                 0.0, 0.0, 1.0, -position.z,
    //                 0.0, 0.0, 0.0, 1.0);
    // return rotation.multiply(translation);
    if (!defined$1(result)) {
      return new Matrix4(sX, sY, sZ, t0, uX, uY, uZ, t1, -fX, -fY, -fZ, t2, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = sX;
    result[1] = uX;
    result[2] = -fX;
    result[3] = 0.0;
    result[4] = sY;
    result[5] = uY;
    result[6] = -fY;
    result[7] = 0.0;
    result[8] = sZ;
    result[9] = uZ;
    result[10] = -fZ;
    result[11] = 0.0;
    result[12] = t0;
    result[13] = t1;
    result[14] = t2;
    result[15] = 1.0;
    return result;
  };

  /**
   * 计算表示透视变换的 Matrix4 实例。
   * @param {Number} fovY 沿 Y 轴的视场角，单位为弧度。
   * @param {Number} aspectRatio 长宽比。
   * @param {Number} near 近平面距离（以米为单位）。
   * @param {Number} far 远平面距离（以米为单位）。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   * @exception {DeveloperError} fovY 必须在（0，PI] 范围内。
   * @exception {DeveloperError} aspectRatio 必须大于零。
   * @exception {DeveloperError} near 必须大于零。
   * @exception {DeveloperError} far 必须大于零。
   */
  Matrix4.computePerspectiveFieldOfView = function (fovY, aspectRatio, near, far, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number.greaterThan("fovY", fovY, 0.0);
    Check.typeOf.number.lessThan("fovY", fovY, Math.PI);
    Check.typeOf.number.greaterThan("near", near, 0.0);
    Check.typeOf.number.greaterThan("far", far, 0.0);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var bottom = Math.tan(fovY * 0.5);
    var column1Row1 = 1.0 / bottom;
    var column0Row0 = column1Row1 / aspectRatio;
    var column2Row2 = (far + near) / (near - far);
    var column3Row2 = 2.0 * far * near / (near - far);
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = column2Row2;
    result[11] = -1.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  };

  /**
   * 计算一个表示正交变换矩阵的 Matrix4 实例。
   * @param {Number} left 左侧距离相机多少米的内容会显示出来。
   * @param {Number} right 右侧距离相机多少米的内容会显示出来。
   * @param {Number} bottom 底部距离相机多少米的内容会显示出来。
   * @param {Number} top 顶部距离相机多少米的内容会显示出来。
   * @param {Number} near 近平面的距离（单位：米）。
   * @param {Number} far 远平面的距离（单位：米）。
   * @param {Matrix4} result 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的 result 参数，如果未提供则是一个新的 Matrix4 实例。
   */
  Matrix4.computeOrthographicOffCenter = function (left, right, bottom, top, near, far, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("left", left);
    Check.typeOf.number("right", right);
    Check.typeOf.number("bottom", bottom);
    Check.typeOf.number("top", top);
    Check.typeOf.number("near", near);
    Check.typeOf.number("far", far);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var a = 1.0 / (right - left);
    var b = 1.0 / (top - bottom);
    var c = 1.0 / (far - near);
    var tx = -(right + left) * a;
    var ty = -(top + bottom) * b;
    var tz = -(far + near) * c;
    a *= 2.0;
    b *= 2.0;
    c *= -2.0;
    result[0] = a;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = b;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = c;
    result[11] = 0.0;
    result[12] = tx;
    result[13] = ty;
    result[14] = tz;
    result[15] = 1.0;
    return result;
  };

  /**
   * 计算表示非中心投影变换的 Matrix4 实例。
   * @param {Number} left 摄像机左侧的距离，将在视图中显示。
   * @param {Number} right 摄像机右侧的距离，将在视图中显示。
   * @param {Number} bottom 摄像机下方的距离，将在视图中显示。
   * @param {Number} top 摄像机上方的距离，将在视图中显示。
   * @param {Number} near 到近平面的距离，以米为单位。
   * @param {Number} far 到远平面的距离，以米为单位。
   * @param {Matrix4} result 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix4} 修改后的 result 参数，如果未提供则为新的 Matrix4 实例。
   */
  Matrix4.computePerspectiveOffCenter = function (left, right, bottom, top, near, far, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("left", left);
    Check.typeOf.number("right", right);
    Check.typeOf.number("bottom", bottom);
    Check.typeOf.number("top", top);
    Check.typeOf.number("near", near);
    Check.typeOf.number("far", far);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var column0Row0 = 2.0 * near / (right - left);
    var column1Row1 = 2.0 * near / (top - bottom);
    var column2Row0 = (right + left) / (right - left);
    var column2Row1 = (top + bottom) / (top - bottom);
    var column2Row2 = -(far + near) / (far - near);
    var column2Row3 = -1.0;
    var column3Row2 = -2.0 * far * near / (far - near);
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  };

  /**
   * 计算表示非中心投影变换的 Matrix4 实例。
   * @param {Number} left 摄像机左侧的距离，将在视图中显示。
   * @param {Number} right 摄像机右侧的距离，将在视图中显示。
   * @param {Number} bottom 摄像机下方的距离，将在视图中显示。
   * @param {Number} top 摄像机上方的距离，将在视图中显示。
   * @param {Number} near 到近平面的距离，以米为单位。
   * @param {Number} far 到远平面的距离，以米为单位。
   * @param {Matrix4} result 存储结果的对象，如果未定义，则创建一个新实例。
   * @returns {Matrix4} 修改后的 result 参数，如果未提供则为新的 Matrix4 实例。
   */
  Matrix4.computeInfinitePerspectiveOffCenter = function (left, right, bottom, top, near, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number("left", left);
    Check.typeOf.number("right", right);
    Check.typeOf.number("bottom", bottom);
    Check.typeOf.number("top", top);
    Check.typeOf.number("near", near);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var column0Row0 = 2.0 * near / (right - left);
    var column1Row1 = 2.0 * near / (top - bottom);
    var column2Row0 = (right + left) / (right - left);
    var column2Row1 = (top + bottom) / (top - bottom);
    var column2Row2 = -1.0;
    var column2Row3 = -1.0;
    var column3Row2 = -2.0 * near;
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  };

  /**
   * 计算一个 Matrix4 实例，将归一化设备坐标转换为窗口坐标。
   * @param {Object} viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 } <code>optional</code> 视口的四个角，如示例1所示。
   * @param {Number} nearDepthRange=0.0 <code>optional</code> 窗口坐标中的近平面距离。
   * @param {Number} farDepthRange=1.0 <code>optional</code> 窗口坐标中的远平面距离。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象，如果未定义则创建一个新实例。
   * @returns {Matrix4} 修改后的 result 参数，或者如果没有提供则是一个新的 Matrix4 实例。
   *
   * @example
   * // Create viewport transformation using an explicit viewport and depth range.
   * const m = Earth.Matrix4.computeViewportTransformation({
   *     x : 0.0,
   *     y : 0.0,
   *     width : 1024.0,
   *     height : 768.0
   * }, 0.0, 1.0, new Earth.Matrix4());
   */
  Matrix4.computeViewportTransformation = function (viewport, nearDepthRange, farDepthRange, result) {
    if (!defined$1(result)) {
      result = new Matrix4();
    }
    viewport = defaultValue$1(viewport, defaultValue$1.EMPTY_OBJECT);
    var x = defaultValue$1(viewport.x, 0.0);
    var y = defaultValue$1(viewport.y, 0.0);
    var width = defaultValue$1(viewport.width, 0.0);
    var height = defaultValue$1(viewport.height, 0.0);
    nearDepthRange = defaultValue$1(nearDepthRange, 0.0);
    farDepthRange = defaultValue$1(farDepthRange, 1.0);
    var halfWidth = width * 0.5;
    var halfHeight = height * 0.5;
    var halfDepth = (farDepthRange - nearDepthRange) * 0.5;
    var column0Row0 = halfWidth;
    var column1Row1 = halfHeight;
    var column2Row2 = halfDepth;
    var column3Row0 = x + halfWidth;
    var column3Row1 = y + halfHeight;
    var column3Row2 = nearDepthRange + halfDepth;
    var column3Row3 = 1.0;
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = column2Row2;
    result[11] = 0.0;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = column3Row3;
    return result;
  };

  /**
   * 计算一个从世界空间到视图空间的变换矩阵。
   * @param {Cartesian3} position 相机的位置。
   * @param {Cartesian3} direction 相机的前向方向。
   * @param {Cartesian3} up 相机的上方向。
   * @param {Cartesian3} right 相机的右方向。
   * @param {Matrix4} result 存储结果的对象。如果未定义，则创建一个新实例。
   * @returns {Matrix4} 修改后的result参数，如果未提供则返回新的Matrix4实例。
   */
  Matrix4.computeView = function (position, direction, up, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("position", position);
    Check.typeOf.object("direction", direction);
    Check.typeOf.object("up", up);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = right.x;
    result[1] = up.x;
    result[2] = -direction.x;
    result[3] = 0.0;
    result[4] = right.y;
    result[5] = up.y;
    result[6] = -direction.y;
    result[7] = 0.0;
    result[8] = right.z;
    result[9] = up.z;
    result[10] = -direction.z;
    result[11] = 0.0;
    result[12] = -Cartesian3.dot(right, position);
    result[13] = -Cartesian3.dot(up, position);
    result[14] = Cartesian3.dot(direction, position);
    result[15] = 1.0;
    return result;
  };

  /**
   * 从提供的 Matrix4 实例计算一个数组。数组将按列主序存储。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Number[]} result <code>optional</code> 存储结果的数组。
   * @returns {Number[]} 修改后的数组参数，如果未提供，则为新的数组实例。
   *
   * @example
   * //create an array from an instance of Matrix4
   * // m = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   * const a = Earth.Matrix4.toArray(m);
   *
   * // m remains the same
   * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]
   */
  Matrix4.toArray = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8], matrix[9], matrix[10], matrix[11], matrix[12], matrix[13], matrix[14], matrix[15]];
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };

  /**
   * 计算给定行列对应的元素的数组索引
   * @param {Number} row 行的索引，从0开始
   * @param {Number} column 列的索引，从0开始
   * @returns {Number} 给定行列对应的元素的索引
   * @exception {DeveloperError} row必须为0, 1, 2或3
   * @exception {DeveloperError} column必须为0, 1, 2或3
   *
   * @example
   * const myMatrix = new Earth.Matrix4();
   * const column1Row0Index = Earth.Matrix4.getElementIndex(1, 0);
   * const column1Row0 = myMatrix[column1Row0Index];
   * myMatrix[column1Row0Index] = 10.0;
   */
  Matrix4.getElementIndex = function (column, row) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number.greaterThanOrEquals("row", row, 0);
    Check.typeOf.number.lessThanOrEquals("row", row, 3);
    Check.typeOf.number.greaterThanOrEquals("column", column, 0);
    Check.typeOf.number.lessThanOrEquals("column", column, 3);
    //>>includeEnd('debug');

    return column * 4 + row;
  };

  /**
   * 以 Cartesian4 实例的形式获取提供的索引处的矩阵列的副本。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Number} index 要检索的从零开始的列索引。
   * @param {Cartesian4} result 存储结果的对象。
   * @returns {Cartesian4} 修改后的 result 参数。
   * @exception {DeveloperError} index 必须是 0、1、2 或 3。
   *
   * @example
   * //returns a Cartesian4 instance with values from the specified column
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * //Example 1: Creates an instance of Cartesian
   * const a = Earth.Matrix4.getColumn(m, 2, new Earth.Cartesian4());
   *
   * @example
   * //Example 2: Sets values for Cartesian instance
   * const a = new Earth.Cartesian4();
   * Earth.Matrix4.getColumn(m, 2, a);
   *
   * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;
   */
  Matrix4.getColumn = function (matrix, index, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 3);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var startIndex = index * 4;
    var x = matrix[startIndex];
    var y = matrix[startIndex + 1];
    var z = matrix[startIndex + 2];
    var w = matrix[startIndex + 3];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };

  /**
   * 计算一个新矩阵，用提供的 Cartesian4 实例替换提供的矩阵中的指定列。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Number} index 要设置的从零开始的列索引。
   * @param {Cartesian4} cartesian 其值将被分配到指定列的 Cartesian 实例。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的 result 参数。
   * @exception {DeveloperError} index 必须是 0、1、2 或 3。
   *
   * @example
   * //creates a new Matrix4 instance with new column values from the Cartesian4 instance
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = Earth.Matrix4.setColumn(m, 2, new Earth.Cartesian4(99.0, 98.0, 97.0, 96.0), new Earth.Matrix4());
   *
   * // m remains the same
   * // a = [10.0, 11.0, 99.0, 13.0]
   * //     [14.0, 15.0, 98.0, 17.0]
   * //     [18.0, 19.0, 97.0, 21.0]
   * //     [22.0, 23.0, 96.0, 25.0]
   */
  Matrix4.setColumn = function (matrix, index, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 3);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result = Matrix4.clone(matrix, result);
    var startIndex = index * 4;
    result[startIndex] = cartesian.x;
    result[startIndex + 1] = cartesian.y;
    result[startIndex + 2] = cartesian.z;
    result[startIndex + 3] = cartesian.w;
    return result;
  };

  /**
   * 检索给定索引处的矩阵行作为Cartesian4实例的副本。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Number} index 要检索的零-based索引。
   * @param {Cartesian4} result 用于存储结果的对象。
   * @returns {Cartesian4} 修改后的结果参数。
   *
   * @exception {DeveloperError} 索引必须为0、1、2或3。
   *
   * @example
   * //returns a Cartesian4 instance with values from the specified column
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * //Example 1: Returns an instance of Cartesian
   * const a = Earth.Matrix4.getRow(m, 2, new Earth.Cartesian4());
   *
   * @example
   * //Example 2: Sets values for a Cartesian instance
   * const a = new Earth.Cartesian4();
   * Earth.Matrix4.getRow(m, 2, a);
   *
   * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;
   */
  Matrix4.getRow = function (matrix, index, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 3);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var x = matrix[index];
    var y = matrix[index + 4];
    var z = matrix[index + 8];
    var w = matrix[index + 12];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };

  /**
   * 使用提供的Cartesian4实例计算一个新矩阵，该矩阵将所提供的矩阵中指定的行替换为提供的Cartesian4实例。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Number} index 要设置的从零开始的行索引。
   * @param {Cartesian4} cartesian 其值将赋给指定行的Cartesian4实例。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的result参数。
   * @exception {DeveloperError} index必须为0、1、2或3。
   *
   * @example
   * //create a new Matrix4 instance with new row values from the Cartesian4 instance
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = Earth.Matrix4.setRow(m, 2, new Earth.Cartesian4(99.0, 98.0, 97.0, 96.0), new Earth.Matrix4());
   *
   * // m remains the same
   * // a = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [99.0, 98.0, 97.0, 96.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   */
  Matrix4.setRow = function (matrix, index, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number.greaterThanOrEquals("index", index, 0);
    Check.typeOf.number.lessThanOrEquals("index", index, 3);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result = Matrix4.clone(matrix, result);
    result[index] = cartesian.x;
    result[index + 4] = cartesian.y;
    result[index + 8] = cartesian.z;
    result[index + 12] = cartesian.w;
    return result;
  };

  /**
   * 计算一个新的矩阵，将提供的矩阵最右边的列中的平移替换为提供的平移向量，这里假设该矩阵是仿射变换矩阵。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Cartesian3} translation 替换提供矩阵平移向量的平移向量。
   * @param {Matrix4} result 用于存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   */
  Matrix4.setTranslation = function (matrix, translation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("translation", translation);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = matrix[15];
    return result;
  };
  var scaleScratch1 = new Cartesian3();

  /**
   * 计算一个新的矩阵，用提供的缩放替换原矩阵中的缩放。假设该矩阵是一个仿射变换。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Cartesian3} scale 替换原矩阵缩放的缩放。
   * @param {Matrix4} result 用于存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @see Matrix4.setUniformScale
   * @see Matrix4.fromScale
   * @see Matrix4.fromUniformScale
   * @see Matrix4.multiplyByScale
   * @see Matrix4.multiplyByUniformScale
   * @see Matrix4.getScale
   */
  Matrix4.setScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var existingScale = Matrix4.getScale(matrix, scaleScratch1);
    var scaleRatioX = scale.x / existingScale.x;
    var scaleRatioY = scale.y / existingScale.y;
    var scaleRatioZ = scale.z / existingScale.z;
    result[0] = matrix[0] * scaleRatioX;
    result[1] = matrix[1] * scaleRatioX;
    result[2] = matrix[2] * scaleRatioX;
    result[3] = matrix[3];
    result[4] = matrix[4] * scaleRatioY;
    result[5] = matrix[5] * scaleRatioY;
    result[6] = matrix[6] * scaleRatioY;
    result[7] = matrix[7];
    result[8] = matrix[8] * scaleRatioZ;
    result[9] = matrix[9] * scaleRatioZ;
    result[10] = matrix[10] * scaleRatioZ;
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };
  var scaleScratch2 = new Cartesian3();

  /**
   * 计算一个新矩阵，使用提供的统一缩放替换矩阵的缩放。这假设矩阵是一个仿射变换。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Number} scale 替换提供矩阵的缩放的统一缩放。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @see Matrix4.setScale
   * @see Matrix4.fromScale
   * @see Matrix4.fromUniformScale
   * @see Matrix4.multiplyByScale
   * @see Matrix4.multiplyByUniformScale
   * @see Matrix4.getScale
   */
  Matrix4.setUniformScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var existingScale = Matrix4.getScale(matrix, scaleScratch2);
    var scaleRatioX = scale / existingScale.x;
    var scaleRatioY = scale / existingScale.y;
    var scaleRatioZ = scale / existingScale.z;
    result[0] = matrix[0] * scaleRatioX;
    result[1] = matrix[1] * scaleRatioX;
    result[2] = matrix[2] * scaleRatioX;
    result[3] = matrix[3];
    result[4] = matrix[4] * scaleRatioY;
    result[5] = matrix[5] * scaleRatioY;
    result[6] = matrix[6] * scaleRatioY;
    result[7] = matrix[7];
    result[8] = matrix[8] * scaleRatioZ;
    result[9] = matrix[9] * scaleRatioZ;
    result[10] = matrix[10] * scaleRatioZ;
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };
  var scratchColumn = new Cartesian3();

  /**
   * 假设矩阵是仿射变换，提取非均匀缩放。
   * @param {Matrix4} matrix 待处理的矩阵。
   * @param {Cartesian3} result 用于存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   *
   * @see Matrix4.multiplyByScale
   * @see Matrix4.multiplyByUniformScale
   * @see Matrix4.fromScale
   * @see Matrix4.fromUniformScale
   * @see Matrix4.setScale
   * @see Matrix4.setUniformScale
   */
  Matrix4.getScale = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn));
    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn));
    return result;
  };
  var scaleScratch3 = new Cartesian3();

  /**
   * 假设矩阵是仿射变换，计算最大的缩放值。最大的缩放值是上方左边的3x3矩阵中列向量的最大长度。
   * @param {Matrix4} matrix 矩阵。
   * @returns {Number} 最大的缩放值。
   */
  Matrix4.getMaximumScale = function (matrix) {
    Matrix4.getScale(matrix, scaleScratch3);
    return Cartesian3.maximumComponent(scaleScratch3);
  };
  var scaleScratch4 = new Cartesian3();

  /**
   * 假设矩阵为仿射变换，设置旋转矩阵。
   * @param {Matrix4} matrix 要设置的矩阵。
   * @param {Matrix4} rotation 旋转矩阵。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @see Matrix4.fromRotation
   * @see Matrix4.getRotation
   */
  Matrix4.setRotation = function (matrix, rotation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var scale = Matrix4.getScale(matrix, scaleScratch4);
    result[0] = rotation[0] * scale.x;
    result[1] = rotation[1] * scale.x;
    result[2] = rotation[2] * scale.x;
    result[3] = matrix[3];
    result[4] = rotation[3] * scale.y;
    result[5] = rotation[4] * scale.y;
    result[6] = rotation[5] * scale.y;
    result[7] = matrix[7];
    result[8] = rotation[6] * scale.z;
    result[9] = rotation[7] * scale.z;
    result[10] = rotation[8] * scale.z;
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };
  var scaleScratch5 = new Cartesian3();

  /**
   * 假设矩阵是仿射变换，提取旋转矩阵。
   * @param {Matrix4} matrix 用于提取旋转矩阵的矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的 result 参数。
   *
   * @see Matrix4.setRotation
   * @see Matrix4.fromRotation
   */
  Matrix4.getRotation = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var scale = Matrix4.getScale(matrix, scaleScratch5);
    result[0] = matrix[0] / scale.x;
    result[1] = matrix[1] / scale.x;
    result[2] = matrix[2] / scale.x;
    result[3] = matrix[4] / scale.y;
    result[4] = matrix[5] / scale.y;
    result[5] = matrix[6] / scale.y;
    result[6] = matrix[8] / scale.z;
    result[7] = matrix[9] / scale.z;
    result[8] = matrix[10] / scale.z;
    return result;
  };

  /**
   * 计算两个矩阵的乘积。
   * @param {Matrix4} left 第一个矩阵。
   * @param {Matrix4} right 第二个矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   */
  Matrix4.multiply = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var left0 = left[0];
    var left1 = left[1];
    var left2 = left[2];
    var left3 = left[3];
    var left4 = left[4];
    var left5 = left[5];
    var left6 = left[6];
    var left7 = left[7];
    var left8 = left[8];
    var left9 = left[9];
    var left10 = left[10];
    var left11 = left[11];
    var left12 = left[12];
    var left13 = left[13];
    var left14 = left[14];
    var left15 = left[15];
    var right0 = right[0];
    var right1 = right[1];
    var right2 = right[2];
    var right3 = right[3];
    var right4 = right[4];
    var right5 = right[5];
    var right6 = right[6];
    var right7 = right[7];
    var right8 = right[8];
    var right9 = right[9];
    var right10 = right[10];
    var right11 = right[11];
    var right12 = right[12];
    var right13 = right[13];
    var right14 = right[14];
    var right15 = right[15];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
    var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
    var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
    var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;
    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
    var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column0Row3;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = column1Row3;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = column3Row3;
    return result;
  };

  /**
   * 计算两个矩阵的和。
   * @param {Matrix4} left 第一个矩阵。
   * @param {Matrix4} right 第二个矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   */
  Matrix4.add = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = left[0] + right[0];
    result[1] = left[1] + right[1];
    result[2] = left[2] + right[2];
    result[3] = left[3] + right[3];
    result[4] = left[4] + right[4];
    result[5] = left[5] + right[5];
    result[6] = left[6] + right[6];
    result[7] = left[7] + right[7];
    result[8] = left[8] + right[8];
    result[9] = left[9] + right[9];
    result[10] = left[10] + right[10];
    result[11] = left[11] + right[11];
    result[12] = left[12] + right[12];
    result[13] = left[13] + right[13];
    result[14] = left[14] + right[14];
    result[15] = left[15] + right[15];
    return result;
  };

  /**
   * 计算两个矩阵的差。
   * @param {Matrix4} left 第一个矩阵。
   * @param {Matrix4} right 第二个矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的 result 参数。
   */
  Matrix4.subtract = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = left[0] - right[0];
    result[1] = left[1] - right[1];
    result[2] = left[2] - right[2];
    result[3] = left[3] - right[3];
    result[4] = left[4] - right[4];
    result[5] = left[5] - right[5];
    result[6] = left[6] - right[6];
    result[7] = left[7] - right[7];
    result[8] = left[8] - right[8];
    result[9] = left[9] - right[9];
    result[10] = left[10] - right[10];
    result[11] = left[11] - right[11];
    result[12] = left[12] - right[12];
    result[13] = left[13] - right[13];
    result[14] = left[14] - right[14];
    result[15] = left[15] - right[15];
    return result;
  };

  /**
   * Computes the product of two matrices assuming the matrices are affine transformation matrices,
   * 计算两个矩阵的乘积，假定这两个矩阵是仿射变换矩阵，其中左上角的3x3元素是任意矩阵，第四列的前三个元素是平移，底部行被假定为 [0, 0, 0, 1]。矩阵未被验证为符合此形式。与使用{@link Matrix4.multiply}计算通用4x4矩阵的乘积相比，此方法更快。
   * @param {Matrix4} left 第一个矩阵。
   * @param {Matrix4} right 第二个矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @example
   * const m1 = new Earth.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);
   * const m2 = Earth.Transforms.eastNorthUpToFixedFrame(new Earth.Cartesian3(1.0, 1.0, 1.0));
   * const m3 = Earth.Matrix4.multiplyTransformation(m1, m2, new Earth.Matrix4());
   */
  Matrix4.multiplyTransformation = function (left, right, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("left", left);
    Check.typeOf.object("right", right);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var left0 = left[0];
    var left1 = left[1];
    var left2 = left[2];
    var left4 = left[4];
    var left5 = left[5];
    var left6 = left[6];
    var left8 = left[8];
    var left9 = left[9];
    var left10 = left[10];
    var left12 = left[12];
    var left13 = left[13];
    var left14 = left[14];
    var right0 = right[0];
    var right1 = right[1];
    var right2 = right[2];
    var right4 = right[4];
    var right5 = right[5];
    var right6 = right[6];
    var right8 = right[8];
    var right9 = right[9];
    var right10 = right[10];
    var right12 = right[12];
    var right13 = right[13];
    var right14 = right[14];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;
    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;
    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = 0.0;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = 0.0;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = 1.0;
    return result;
  };

  /**
   * 用一个底部为 [0.0, 0.0, 0.0, 1.0] 的变换矩阵乘以一个 3x3 旋转矩阵。这是一个针对 Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m); 的优化，可以减少分配和算术操作。
   * @param {Matrix4} matrix 左侧的矩阵。
   * @param {Matrix3} rotation 右侧的 3x3 旋转矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的 result 参数。
   *
   * @example
   * // Instead of Earth.Matrix4.multiply(m, Earth.Matrix4.fromRotationTranslation(rotation), m);
   * Earth.Matrix4.multiplyByMatrix3(m, rotation, m);
   */
  Matrix4.multiplyByMatrix3 = function (matrix, rotation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("rotation", rotation);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var left0 = matrix[0];
    var left1 = matrix[1];
    var left2 = matrix[2];
    var left4 = matrix[4];
    var left5 = matrix[5];
    var left6 = matrix[6];
    var left8 = matrix[8];
    var left9 = matrix[9];
    var left10 = matrix[10];
    var right0 = rotation[0];
    var right1 = rotation[1];
    var right2 = rotation[2];
    var right4 = rotation[3];
    var right5 = rotation[4];
    var right6 = rotation[5];
    var right8 = rotation[6];
    var right9 = rotation[7];
    var right10 = rotation[8];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = 0.0;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = 0.0;
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };

  /**
   * 通过一个{@link Cartesian3}向量定义的隐式平移矩阵，将一个转换矩阵（底部行为[0.0, 0.0, 0.0, 1.0]）与其相乘。这是Matrix4.multiply(m, Matrix4.fromTranslation(position), m)的一种优化，使用更少的内存分配和算术运算。
   * @param {Matrix4} matrix 左侧的矩阵。
   * @param {Cartesian3} translation 右侧的平移向量。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @example
   * // Instead of Earth.Matrix4.multiply(m, Earth.Matrix4.fromTranslation(position), m);
   * Earth.Matrix4.multiplyByTranslation(m, position, m);
   */
  Matrix4.multiplyByTranslation = function (matrix, translation, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("translation", translation);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var x = translation.x;
    var y = translation.y;
    var z = translation.z;
    var tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];
    var ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];
    var tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = tx;
    result[13] = ty;
    result[14] = tz;
    result[15] = matrix[15];
    return result;
  };

  /**
   * 将一个仿射变换矩阵（底行为[0.0, 0.0, 0.0, 1.0]）与一个非均匀缩放矩阵相乘。这是对Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);的优化，其中m必须是仿射矩阵。此函数执行较少的分配和算术运算。
   * @param {Matrix4} matrix 左手边的仿射矩阵。
   * @param {Cartesian3} scale 右手边的非均匀缩放。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   *
   * @example
   * // Instead of Earth.Matrix4.multiply(m, Earth.Matrix4.fromScale(scale), m);
   * Earth.Matrix4.multiplyByScale(m, scale, m);
   *
   * @see Matrix4.multiplyByUniformScale
   * @see Matrix4.fromScale
   * @see Matrix4.fromUniformScale
   * @see Matrix4.setScale
   * @see Matrix4.setUniformScale
   * @see Matrix4.getScale
   */
  Matrix4.multiplyByScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var scaleX = scale.x;
    var scaleY = scale.y;
    var scaleZ = scale.z;

    // Faster than Cartesian3.equals
    if (scaleX === 1.0 && scaleY === 1.0 && scaleZ === 1.0) {
      return Matrix4.clone(matrix, result);
    }
    result[0] = scaleX * matrix[0];
    result[1] = scaleX * matrix[1];
    result[2] = scaleX * matrix[2];
    result[3] = matrix[3];
    result[4] = scaleY * matrix[4];
    result[5] = scaleY * matrix[5];
    result[6] = scaleY * matrix[6];
    result[7] = matrix[7];
    result[8] = scaleZ * matrix[8];
    result[9] = scaleZ * matrix[9];
    result[10] = scaleZ * matrix[10];
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };

  /**
   * 计算矩阵乘以一个均匀缩放比例的结果，就好像缩放比例是一个缩放矩阵。
   * @param {Matrix4} matrix 左手边的矩阵。
   * @param {Number} scale 右手边的均匀缩放比例。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @example
   * // Instead of Earth.Matrix4.multiply(m, Earth.Matrix4.fromUniformScale(scale), m);
   * Earth.Matrix4.multiplyByUniformScale(m, scale, m);
   *
   * @see Matrix4.multiplyByScale
   * @see Matrix4.fromScale
   * @see Matrix4.fromUniformScale
   * @see Matrix4.setScale
   * @see Matrix4.setUniformScale
   * @see Matrix4.getScale
   */
  Matrix4.multiplyByUniformScale = function (matrix, scale, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number("scale", scale);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = matrix[0] * scale;
    result[1] = matrix[1] * scale;
    result[2] = matrix[2] * scale;
    result[3] = matrix[3];
    result[4] = matrix[4] * scale;
    result[5] = matrix[5] * scale;
    result[6] = matrix[6] * scale;
    result[7] = matrix[7];
    result[8] = matrix[8] * scale;
    result[9] = matrix[9] * scale;
    result[10] = matrix[10] * scale;
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };

  /**
   * 计算矩阵和列向量的乘积。
   * @param {Matrix4} matrix 矩阵。
   * @param {Cartesian4} cartesian 向量。
   * @param {Cartesian4} result 存储结果的对象。
   * @returns {Cartesian4} 修改后的结果参数。
   */
  Matrix4.multiplyByVector = function (matrix, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var vW = cartesian.w;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
    var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };

  /**
   * 计算矩阵和{@link Cartesian3}的乘积。这相当于使用一个<code>w</code>分量为零的{@link Cartesian4}调用{@link Matrix4.multiplyByVector}。
   * @param {Matrix4} matrix 矩阵。
   * @param {Cartesian3} cartesian 点。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   *
   * @example
   * const p = new Earth.Cartesian3(1.0, 2.0, 3.0);
   * const result = Earth.Matrix4.multiplyByPointAsVector(matrix, p, new Earth.Cartesian3());
   * // A shortcut for
   * //   Cartesian3 p = ...
   * //   Earth.Matrix4.multiplyByVector(matrix, new Earth.Cartesian4(p.x, p.y, p.z, 0.0), result);
   */
  Matrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 计算矩阵与 {@link Cartesian3} 向量的乘积。这相当于使用 {@link Cartesian4} 的 <code>w</code> 分量为 1 调用 {@link Matrix4.multiplyByVector}，但返回的是 {@link Cartesian3} 而不是 {@link Cartesian4}。
   * @param {Matrix4} matrix 矩阵。
   * @param {Cartesian3} cartesian 点。
   * @param {Cartesian3} result 用于存储结果的对象。
   * @returns {Cartesian3} 修改后的结果参数。
   *
   * @example
   * const p = new Earth.Cartesian3(1.0, 2.0, 3.0);
   * const result = Earth.Matrix4.multiplyByPoint(matrix, p, new Earth.Cartesian3());
   */
  Matrix4.multiplyByPoint = function (matrix, cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("cartesian", cartesian);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };

  /**
   * 计算矩阵和标量的乘积。
   * @param {Matrix4} matrix 矩阵。
   * @param {Number} scalar 要乘以的数。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @example
   * //create a Matrix4 instance which is a scaled version of the supplied Matrix4
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = Earth.Matrix4.multiplyByScalar(m, -2, new Earth.Matrix4());
   *
   * // m remains the same
   * // a = [-20.0, -22.0, -24.0, -26.0]
   * //     [-28.0, -30.0, -32.0, -34.0]
   * //     [-36.0, -38.0, -40.0, -42.0]
   * //     [-44.0, -46.0, -48.0, -50.0]
   */
  Matrix4.multiplyByScalar = function (matrix, scalar, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.number("scalar", scalar);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = matrix[0] * scalar;
    result[1] = matrix[1] * scalar;
    result[2] = matrix[2] * scalar;
    result[3] = matrix[3] * scalar;
    result[4] = matrix[4] * scalar;
    result[5] = matrix[5] * scalar;
    result[6] = matrix[6] * scalar;
    result[7] = matrix[7] * scalar;
    result[8] = matrix[8] * scalar;
    result[9] = matrix[9] * scalar;
    result[10] = matrix[10] * scalar;
    result[11] = matrix[11] * scalar;
    result[12] = matrix[12] * scalar;
    result[13] = matrix[13] * scalar;
    result[14] = matrix[14] * scalar;
    result[15] = matrix[15] * scalar;
    return result;
  };

  /**
   * 计算提供的矩阵的否定副本。
   * @param {Matrix4} matrix 要否定的矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @example
   * //create a new Matrix4 instance which is a negation of a Matrix4
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = Earth.Matrix4.negate(m, new Earth.Matrix4());
   *
   * // m remains the same
   * // a = [-10.0, -11.0, -12.0, -13.0]
   * //     [-14.0, -15.0, -16.0, -17.0]
   * //     [-18.0, -19.0, -20.0, -21.0]
   * //     [-22.0, -23.0, -24.0, -25.0]
   */
  Matrix4.negate = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = -matrix[0];
    result[1] = -matrix[1];
    result[2] = -matrix[2];
    result[3] = -matrix[3];
    result[4] = -matrix[4];
    result[5] = -matrix[5];
    result[6] = -matrix[6];
    result[7] = -matrix[7];
    result[8] = -matrix[8];
    result[9] = -matrix[9];
    result[10] = -matrix[10];
    result[11] = -matrix[11];
    result[12] = -matrix[12];
    result[13] = -matrix[13];
    result[14] = -matrix[14];
    result[15] = -matrix[15];
    return result;
  };

  /**
   * 计算提供矩阵的转置矩阵。
   * @param {Matrix4} matrix 要转置的矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   *
   * @example
   * //returns transpose of a Matrix4
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = Earth.Matrix4.transpose(m, new Earth.Matrix4());
   *
   * // m remains the same
   * // a = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   */
  Matrix4.transpose = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    var matrix1 = matrix[1];
    var matrix2 = matrix[2];
    var matrix3 = matrix[3];
    var matrix6 = matrix[6];
    var matrix7 = matrix[7];
    var matrix11 = matrix[11];
    result[0] = matrix[0];
    result[1] = matrix[4];
    result[2] = matrix[8];
    result[3] = matrix[12];
    result[4] = matrix1;
    result[5] = matrix[5];
    result[6] = matrix[9];
    result[7] = matrix[13];
    result[8] = matrix2;
    result[9] = matrix6;
    result[10] = matrix[10];
    result[11] = matrix[14];
    result[12] = matrix3;
    result[13] = matrix7;
    result[14] = matrix11;
    result[15] = matrix[15];
    return result;
  };

  /**
   * 计算一个矩阵，其中包含所提供矩阵元素的绝对值。
   * @param {Matrix4} matrix 带有有符号元素的矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   */
  Matrix4.abs = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = Math.abs(matrix[0]);
    result[1] = Math.abs(matrix[1]);
    result[2] = Math.abs(matrix[2]);
    result[3] = Math.abs(matrix[3]);
    result[4] = Math.abs(matrix[4]);
    result[5] = Math.abs(matrix[5]);
    result[6] = Math.abs(matrix[6]);
    result[7] = Math.abs(matrix[7]);
    result[8] = Math.abs(matrix[8]);
    result[9] = Math.abs(matrix[9]);
    result[10] = Math.abs(matrix[10]);
    result[11] = Math.abs(matrix[11]);
    result[12] = Math.abs(matrix[12]);
    result[13] = Math.abs(matrix[13]);
    result[14] = Math.abs(matrix[14]);
    result[15] = Math.abs(matrix[15]);
    return result;
  };

  /**
   * 逐个比较提供的两个矩阵的组件，如果它们相等则返回true，否则返回false。
   * @param {Matrix4} left <code>optional</code> 第一个矩阵。
   * @param {Matrix4} right <code>optional</code> 第二个矩阵。
   * @returns {Boolean} 如果 left 和 right 相等则返回true，否则返回false。
   *
   * @example
   * //compares two Matrix4 instances
   *
   * // a = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * // b = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * if(Earth.Matrix4.equals(a,b)) {
   *      console.log("Both matrices are equal");
   * } else {
   *      console.log("They are not equal");
   * }
   *
   * //Prints "Both matrices are equal" on the console
   */
  Matrix4.equals = function (left, right) {
    // Given that most matrices will be transformation matrices, the elements
    // are tested in order such that the test is likely to fail as early
    // as possible.  I _think_ this is just as friendly to the L1 cache
    // as testing in index order.  It is certainty faster in practice.
    return left === right || defined$1(left) && defined$1(right) &&
    // Translation
    left[12] === right[12] && left[13] === right[13] && left[14] === right[14] &&
    // Rotation/scale
    left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[8] === right[8] && left[9] === right[9] && left[10] === right[10] &&
    // Bottom row
    left[3] === right[3] && left[7] === right[7] && left[11] === right[11] && left[15] === right[15];
  };

  /**
   * 比较提供的两个矩阵的元素是否分量相等，如果它们在提供的 epsilon 范围内，则返回 true，否则返回 false。
   * @param {Matrix4} left <code>optional</code> 第一个矩阵。
   * @param {Matrix4} right <code>optional</code> 第二个矩阵。
   * @param {Number} epsilon=0 <code>optional</code> 用于相等测试的 epsilon。
   * @returns {Boolean} 如果 left 和 right 在提供的 epsilon 范围内，则返回 true，否则返回 false。
   *
   * @example
   * //compares two Matrix4 instances
   *
   * // a = [10.5, 14.5, 18.5, 22.5]
   * //     [11.5, 15.5, 19.5, 23.5]
   * //     [12.5, 16.5, 20.5, 24.5]
   * //     [13.5, 17.5, 21.5, 25.5]
   *
   * // b = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * if(Earth.Matrix4.equalsEpsilon(a,b,0.1)){
   *      console.log("Difference between both the matrices is less than 0.1");
   * } else {
   *      console.log("Difference between both the matrices is not less than 0.1");
   * }
   *
   * //Prints "Difference between both the matrices is not less than 0.1" on the console
   */
  Matrix4.equalsEpsilon = function (left, right, epsilon) {
    epsilon = defaultValue$1(epsilon, 0);
    return left === right || defined$1(left) && defined$1(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon && Math.abs(left[9] - right[9]) <= epsilon && Math.abs(left[10] - right[10]) <= epsilon && Math.abs(left[11] - right[11]) <= epsilon && Math.abs(left[12] - right[12]) <= epsilon && Math.abs(left[13] - right[13]) <= epsilon && Math.abs(left[14] - right[14]) <= epsilon && Math.abs(left[15] - right[15]) <= epsilon;
  };

  /**
   * 获取提供的矩阵的平移部分，假设该矩阵是一个仿射变换矩阵。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Cartesian3} result 存储结果的对象。
   * @returns {Cartesian3} 修改后的result参数。
   */
  Matrix4.getTranslation = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result.x = matrix[12];
    result.y = matrix[13];
    result.z = matrix[14];
    return result;
  };

  /**
   * 获取提供的矩阵的左上角的3x3矩阵。
   * @param {Matrix4} matrix 要使用的矩阵。
   * @param {Matrix3} result 存储结果的对象。
   * @returns {Matrix3} 修改后的result参数。
   *
   * @example
   * // returns a Matrix3 instance from a Matrix4 instance
   *
   * // m = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * const b = new Earth.Matrix3();
   * Earth.Matrix4.getMatrix3(m,b);
   *
   * // b = [10.0, 14.0, 18.0]
   * //     [11.0, 15.0, 19.0]
   * //     [12.0, 16.0, 20.0]
   */
  Matrix4.getMatrix3 = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[4];
    result[4] = matrix[5];
    result[5] = matrix[6];
    result[6] = matrix[8];
    result[7] = matrix[9];
    result[8] = matrix[10];
    return result;
  };
  var scratchInverseRotation = new Matrix3();
  var scratchMatrix3Zero = new Matrix3();
  var scratchBottomRow = new Cartesian4();
  var scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);

  /**
   * 使用Cramer法则计算提供矩阵的逆矩阵。如果行列式为零，则无法取逆，将抛出异常。如果该矩阵是一个刚性变换矩阵，则使用{@link Matrix4.inverseTransformation}来反转它更加高效。
   * @param {Matrix4} matrix 要反转的矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的result参数。
   * @exception {RuntimeError} 矩阵不可逆，因为其行列式为零。
   */
  Matrix4.inverse = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');
    //
    // Ported from:
    //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf
    //
    var src0 = matrix[0];
    var src1 = matrix[4];
    var src2 = matrix[8];
    var src3 = matrix[12];
    var src4 = matrix[1];
    var src5 = matrix[5];
    var src6 = matrix[9];
    var src7 = matrix[13];
    var src8 = matrix[2];
    var src9 = matrix[6];
    var src10 = matrix[10];
    var src11 = matrix[14];
    var src12 = matrix[3];
    var src13 = matrix[7];
    var src14 = matrix[11];
    var src15 = matrix[15];

    // calculate pairs for first 8 elements (cofactors)
    var tmp0 = src10 * src15;
    var tmp1 = src11 * src14;
    var tmp2 = src9 * src15;
    var tmp3 = src11 * src13;
    var tmp4 = src9 * src14;
    var tmp5 = src10 * src13;
    var tmp6 = src8 * src15;
    var tmp7 = src11 * src12;
    var tmp8 = src8 * src14;
    var tmp9 = src10 * src12;
    var tmp10 = src8 * src13;
    var tmp11 = src9 * src12;

    // calculate first 8 elements (cofactors)
    var dst0 = tmp0 * src5 + tmp3 * src6 + tmp4 * src7 - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
    var dst1 = tmp1 * src4 + tmp6 * src6 + tmp9 * src7 - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
    var dst2 = tmp2 * src4 + tmp7 * src5 + tmp10 * src7 - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
    var dst3 = tmp5 * src4 + tmp8 * src5 + tmp11 * src6 - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
    var dst4 = tmp1 * src1 + tmp2 * src2 + tmp5 * src3 - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
    var dst5 = tmp0 * src0 + tmp7 * src2 + tmp8 * src3 - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
    var dst6 = tmp3 * src0 + tmp6 * src1 + tmp11 * src3 - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
    var dst7 = tmp4 * src0 + tmp9 * src1 + tmp10 * src2 - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);

    // calculate pairs for second 8 elements (cofactors)
    tmp0 = src2 * src7;
    tmp1 = src3 * src6;
    tmp2 = src1 * src7;
    tmp3 = src3 * src5;
    tmp4 = src1 * src6;
    tmp5 = src2 * src5;
    tmp6 = src0 * src7;
    tmp7 = src3 * src4;
    tmp8 = src0 * src6;
    tmp9 = src2 * src4;
    tmp10 = src0 * src5;
    tmp11 = src1 * src4;

    // calculate second 8 elements (cofactors)
    var dst8 = tmp0 * src13 + tmp3 * src14 + tmp4 * src15 - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
    var dst9 = tmp1 * src12 + tmp6 * src14 + tmp9 * src15 - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
    var dst10 = tmp2 * src12 + tmp7 * src13 + tmp10 * src15 - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
    var dst11 = tmp5 * src12 + tmp8 * src13 + tmp11 * src14 - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
    var dst12 = tmp2 * src10 + tmp5 * src11 + tmp1 * src9 - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
    var dst13 = tmp8 * src11 + tmp0 * src8 + tmp7 * src10 - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
    var dst14 = tmp6 * src9 + tmp11 * src11 + tmp3 * src8 - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
    var dst15 = tmp10 * src10 + tmp4 * src8 + tmp9 * src9 - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);

    // calculate determinant
    var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;
    if (Math.abs(det) < CesiumMath.EPSILON21) {
      // Special case for a zero scale matrix that can occur, for example,
      // when a model's node has a [0, 0, 0] scale.
      if (Matrix3.equalsEpsilon(Matrix4.getMatrix3(matrix, scratchInverseRotation), scratchMatrix3Zero, CesiumMath.EPSILON7) && Cartesian4.equals(Matrix4.getRow(matrix, 3, scratchBottomRow), scratchExpectedBottomRow)) {
        result[0] = 0.0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = 0.0;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = 0.0;
        result[9] = 0.0;
        result[10] = 0.0;
        result[11] = 0.0;
        result[12] = -matrix[12];
        result[13] = -matrix[13];
        result[14] = -matrix[14];
        result[15] = 1.0;
        return result;
      }
      throw new RuntimeError$1("matrix is not invertible because its determinate is zero.");
    }

    // calculate matrix inverse
    det = 1.0 / det;
    result[0] = dst0 * det;
    result[1] = dst1 * det;
    result[2] = dst2 * det;
    result[3] = dst3 * det;
    result[4] = dst4 * det;
    result[5] = dst5 * det;
    result[6] = dst6 * det;
    result[7] = dst7 * det;
    result[8] = dst8 * det;
    result[9] = dst9 * det;
    result[10] = dst10 * det;
    result[11] = dst11 * det;
    result[12] = dst12 * det;
    result[13] = dst13 * det;
    result[14] = dst14 * det;
    result[15] = dst15 * det;
    return result;
  };

  /**
   * 假设提供的矩阵是一个合适的刚体矩阵（proper rigid matrix），其中左上角的3x3元素是一个旋转矩阵，前4列中的前3个元素是平移向量。底部一行被假定为 [0, 0, 0, 1]。没有验证矩阵是否处于正确的形式。此方法比使用 {@link Matrix4.inverse} 计算一般4x4矩阵的逆更快。
   * @param {Matrix4} matrix 要求逆的矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的result参数。
   *
   * @param {Matrix4} matrix The matrix to invert.
   * @param {Matrix4} result The object onto which to store the result.
   * @returns {Matrix4} The modified result parameter.
   */
  Matrix4.inverseTransformation = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    //This function is an optimized version of the below 4 lines.
    //const rT = Matrix3.transpose(Matrix4.getMatrix3(matrix));
    //const rTN = Matrix3.negate(rT);
    //const rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));
    //return Matrix4.fromRotationTranslation(rT, rTT, result);

    var matrix0 = matrix[0];
    var matrix1 = matrix[1];
    var matrix2 = matrix[2];
    var matrix4 = matrix[4];
    var matrix5 = matrix[5];
    var matrix6 = matrix[6];
    var matrix8 = matrix[8];
    var matrix9 = matrix[9];
    var matrix10 = matrix[10];
    var vX = matrix[12];
    var vY = matrix[13];
    var vZ = matrix[14];
    var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
    var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
    var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;
    result[0] = matrix0;
    result[1] = matrix4;
    result[2] = matrix8;
    result[3] = 0.0;
    result[4] = matrix1;
    result[5] = matrix5;
    result[6] = matrix9;
    result[7] = 0.0;
    result[8] = matrix2;
    result[9] = matrix6;
    result[10] = matrix10;
    result[11] = 0.0;
    result[12] = x;
    result[13] = y;
    result[14] = z;
    result[15] = 1.0;
    return result;
  };
  var scratchTransposeMatrix = new Matrix4();

  /**
   * 计算矩阵的逆转置矩阵。
   * @param {Matrix4} matrix 要转置和求逆的矩阵。
   * @param {Matrix4} result 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数。
   */
  Matrix4.inverseTranspose = function (matrix, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object("matrix", matrix);
    Check.typeOf.object("result", result);
    //>>includeEnd('debug');

    return Matrix4.inverse(Matrix4.transpose(matrix, scratchTransposeMatrix), result);
  };

  /*
   * An immutable Matrix4 instance initialized to the identity matrix.
   *
   * @type {Matrix4}
   * @constant
   */
  Matrix4.IDENTITY = Object.freeze(new Matrix4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0));

  /*
   * An immutable Matrix4 instance initialized to the zero matrix.
   *
   * @type {Matrix4}
   * @constant
   */
  Matrix4.ZERO = Object.freeze(new Matrix4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

  /*
   * The index into Matrix4 for column 0, row 0.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN0ROW0 = 0;

  /*
   * The index into Matrix4 for column 0, row 1.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN0ROW1 = 1;

  /*
   * The index into Matrix4 for column 0, row 2.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN0ROW2 = 2;

  /*
   * The index into Matrix4 for column 0, row 3.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN0ROW3 = 3;

  /*
   * The index into Matrix4 for column 1, row 0.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN1ROW0 = 4;

  /*
   * The index into Matrix4 for column 1, row 1.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN1ROW1 = 5;

  /*
   * The index into Matrix4 for column 1, row 2.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN1ROW2 = 6;

  /*
   * The index into Matrix4 for column 1, row 3.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN1ROW3 = 7;

  /*
   * The index into Matrix4 for column 2, row 0.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN2ROW0 = 8;

  /*
   * The index into Matrix4 for column 2, row 1.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN2ROW1 = 9;

  /*
   * The index into Matrix4 for column 2, row 2.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN2ROW2 = 10;

  /*
   * The index into Matrix4 for column 2, row 3.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN2ROW3 = 11;

  /*
   * The index into Matrix4 for column 3, row 0.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN3ROW0 = 12;

  /*
   * The index into Matrix4 for column 3, row 1.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN3ROW1 = 13;

  /*
   * The index into Matrix4 for column 3, row 2.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN3ROW2 = 14;

  /*
   * The index into Matrix4 for column 3, row 3.
   *
   * @type {Number}
   * @constant
   */
  Matrix4.COLUMN3ROW3 = 15;
  Object.defineProperties(Matrix4.prototype, {
    /** 
     * 获取集合中的项目数量。
     * @memberof Matrix4.prototype
     *
     * @type {Number}
     */
    length: {
      get: function get() {
        return Matrix4.packedLength;
      }
    }
  });

  /**
   * 复制提供的Matrix4实例。
   * @param {Matrix4} result <code>optional</code> 存储结果的对象。
   * @returns {Matrix4} 修改后的结果参数，如果未提供则返回新的Matrix4实例。
   */
  Matrix4.prototype.clone = function (result) {
    return Matrix4.clone(this, result);
  };

  /**
   * 按照每个元素进行比较，将此矩阵与提供的矩阵进行比较，如果它们相等则返回true，否则返回false。
   * @param {Matrix4} right <code>optional</code> 右侧矩阵。
   * @returns {Boolean} 如果它们相等则返回true，否则返回false。
   */
  Matrix4.prototype.equals = function (right) {
    return Matrix4.equals(this, right);
  };

  /**
   * @private
   */
  Matrix4.equalsArray = function (matrix, array, offset) {
    return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8] && matrix[9] === array[offset + 9] && matrix[10] === array[offset + 10] && matrix[11] === array[offset + 11] && matrix[12] === array[offset + 12] && matrix[13] === array[offset + 13] && matrix[14] === array[offset + 14] && matrix[15] === array[offset + 15];
  };

  /**
   * 按照每个元素进行比较，将此矩阵与提供的矩阵进行比较，如果它们在提供的epsilon范围内则返回true，否则返回false。
   * @param {Matrix4} right <code>optional</code> 右侧矩阵。
   * @param {Number} epsilon=0 <code>optional</code> 用于相等性测试的epsilon。
   * @returns {Boolean} 如果它们在提供的epsilon范围内则返回true，否则返回false。
   */
  Matrix4.prototype.equalsEpsilon = function (right, epsilon) {
    return Matrix4.equalsEpsilon(this, right, epsilon);
  };

  /**
   * 计算一个字符串，表示该矩阵，每一行都在单独的一行上，格式为“(列0，列1，列2，列3)”。
   * @returns {String} 一个字符串，表示该矩阵，每一行都在单独的一行上，格式为“(列0，列1，列2，列3)”。
   */
  Matrix4.prototype.toString = function () {
    return "(".concat(this[0], ", ").concat(this[4], ", ").concat(this[8], ", ").concat(this[12], ")\n") + "(".concat(this[1], ", ").concat(this[5], ", ").concat(this[9], ", ").concat(this[13], ")\n") + "(".concat(this[2], ", ").concat(this[6], ", ").concat(this[10], ", ").concat(this[14], ")\n") + "(".concat(this[3], ", ").concat(this[7], ", ").concat(this[11], ", ").concat(this[15], ")");
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 
   * @class CircleEmitter
   * 从圆形发射粒子的粒子发射器。粒子将定位在一个圆内，并且具有沿z向量移动的初始速度。
   * @constructor
   *
   * @param {Number} [radius=1.0] 圆的半径，以米为单位。
   */
  function CircleEmitter(radius) {
    radius = defaultValue$1(radius, 1.0);

    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number.greaterThan("radius", radius, 0.0);
    //>>includeEnd('debug');

    this._radius = defaultValue$1(radius, 1.0);
  }
  Object.defineProperties(CircleEmitter.prototype, {
    /**
     * 圆锥角（以弧度为单位）。
     * @memberof CircleEmitter.prototype
     * @type {Number}
     * @default 1.0
     */
    radius: {
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThan("value", value, 0.0);
        //>>includeEnd('debug');
        this._radius = value;
      }
    }
  });

  /**
   * Initializes the given {@link Particle} by setting it's position and velocity.
   *
   * @private
   * @param {Particle} particle The particle to initialize.
   */
  CircleEmitter.prototype.emit = function (particle) {
    var theta = CesiumMath.randomBetween(0.0, CesiumMath.TWO_PI);
    var rad = CesiumMath.randomBetween(0.0, this._radius);
    var x = rad * Math.cos(theta);
    var y = rad * Math.sin(theta);
    var z = 0.0;
    particle.position = Cartesian3.fromElements(x, y, z, particle.position);
    particle.velocity = Cartesian3.clone(Cartesian3.UNIT_Z, particle.velocity);
  };

  var defaultSize = new Cartesian2(1.0, 1.0);
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   *
   * @class Particle
   * {@link ParticleSystem}发出的粒子
   * @constructor
   *
   * @param {Object} options 具有以下属性的对象:
   * @param {Number} [options.mass=1.0] 粒子的质量（以千克为单位）。
   * @param {Cartesian3} [options.position=Cartesian3.ZERO] 粒子在世界坐标中的初始位置。
   * @param {Cartesian3} [options.velocity=Cartesian3.ZERO] 世界坐标中粒子的速度向量。
   * @param {Number} [options.life=Number.MAX_VALUE] 粒子的寿命以秒为单位。
   * @param {Object} [options.image] 用于广告牌的URI，HTMLImageElement或HTMLCanvasElemen。
   * @param {Color} [options.startColor=Color.WHITE] 粒子产生时的颜色。 
   * @param {Color} [options.endColor=Color.WHITE] 粒子死亡时的颜色。
   * @param {Number} [options.startScale=1.0] 粒子产生时的比例大小。
   * @param {Number} [options.endScale=1.0] 粒子死亡时的比例大小。
   * @param {Cartesian2} [options.imageSize=new Cartesian2(1.0, 1.0)] 尺寸，宽度乘以高度，以像素为单位缩放粒子图像。
   */
  function Particle(options) {
    options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);

    /**
     * 粒子的质量（以千克为单位）。
     * @type {Number}
     * @default 1.0
     */
    this.mass = defaultValue$1(options.mass, 1.0);
    /**
     * 粒子在世界坐标中的初始位置。
     * @type {Cartesian3}
     * @default Cartesian3.ZERO
     */
    this.position = Cartesian3.clone(defaultValue$1(options.position, Cartesian3.ZERO));
    /**
     * 世界坐标中粒子的速度向量。
     * @type {Cartesian3}
     * @default Cartesian3.ZERO
     */
    this.velocity = Cartesian3.clone(defaultValue$1(options.velocity, Cartesian3.ZERO));
    /**
     * 粒子的寿命以秒为单位。
     * @type {Number}
     * @default Number.MAX_VALUE
     */
    this.life = defaultValue$1(options.life, Number.MAX_VALUE);
    /**
     * 用于粒子的图像。
     * @type {Object}
     * @default undefined
     */
    this.image = options.image;
    /**
     * 粒子产生时的颜色。 
     * @type {Color}
     * @default Color.WHITE
     */
    this.startColor = Color$1.clone(defaultValue$1(options.startColor, Color$1.WHITE));
    /**
     * 粒子死亡时的颜色。
     * @type {Color}
     * @default Color.WHITE
     */
    this.endColor = Color$1.clone(defaultValue$1(options.endColor, Color$1.WHITE));
    /**
     * 粒子产生时的比例大小。
     * @type {Number}
     * @default 1.0
     */
    this.startScale = defaultValue$1(options.startScale, 1.0);
    /**
     * 粒子死亡时的比例大小。
     * @type {Number}
     * @default 1.0
     */
    this.endScale = defaultValue$1(options.endScale, 1.0);
    /**
     * 尺寸，宽度乘以高度，以像素为单位缩放粒子图像。
     * @type {Cartesian2}
     * @default new Cartesian(1.0, 1.0)
     */
    this.imageSize = Cartesian2.clone(defaultValue$1(options.imageSize, defaultSize));
    this._age = 0.0;
    this._normalizedAge = 0.0;

    // used by ParticleSystem
    this._billboard = undefined;
  }
  Object.defineProperties(Particle.prototype, {
    /**
     * 以秒为单位获取粒子的寿命。
     * @memberof Particle.prototype
     * @type {Number}
     */
    age: {
      get: function get() {
        return this._age;
      }
    },
    /**
     * 获取标准化为[0.0，1.0]范围内的值的年龄。
     * @memberof Particle.prototype
     * @type {Number}
     */
    normalizedAge: {
      get: function get() {
        return this._normalizedAge;
      }
    }
  });
  var deltaScratch = new Cartesian3();

  /**
   * @private
   */
  Particle.prototype.update = function (dt, modelMatrix, emitterDirMatrix, particleUpdateFunction) {
    // Apply the velocity
    Cartesian3.multiplyByScalar(this.velocity, dt, deltaScratch);
    Cartesian3.add(this.position, deltaScratch, this.position);

    // Update any forces.
    if (defined$1(particleUpdateFunction)) {
      particleUpdateFunction(this, dt, modelMatrix, emitterDirMatrix);
    }

    // Age the particle
    this._age += dt;

    // Compute the normalized age.
    if (this.life === Number.MAX_VALUE) {
      this._normalizedAge = 0.0;
    } else {
      this._normalizedAge = this._age / this.life;
    }

    // If this particle is older than it's lifespan then die.
    return this._age <= this.life;
  };

  var defaultImageSize = new Cartesian2(1.0, 1.0);
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 粒子系统
   * ---
   */

  /**
   * 
   * @class ParticleSystem
   * 粒子系统，管理粒子集合的更新和显示。
   * @constructor
   *
   * @param {Object} options <code>optional</code> 具有以下属性的对象:
   * @param {Boolean} options.show=true <code>optional</code> 是否显示粒子系统。
   * @param {ParticleSystem.updateCallback} options.updateCallback <code>optional</code> 每帧都要调用一次回调函数以更新粒子。
   * @param {ParticleEmitter} options.emitter=new CircleEmitter(0.5) <code>optional</code> 该系统的粒子发射器。
   * @param {Matrix4} options.modelMatrix=Matrix4.IDENTITY <code>optional</code> 将粒子系统从模型转换为世界坐标的4x4转换矩阵。
   * @param {Matrix4} options.emitterModelMatrix=Matrix4.IDENTITY <code>optional</code> 在粒子系统局部坐标系内转换粒子系统发射器的4x4转换矩阵。
   * @param {Number} options.emissionRate=5 <code>optional</code> 每秒要发射的粒子数。
   * @param {ParticleBurst[]} options.bursts <code>optional</code> ParticleBurst的数组，在周期性时间发射粒子爆发。
   * @param {Boolean} options.loop=true <code>optional</code> 粒子系统完成后是否应该循环爆发。
   * @param {Number} options.scale=1.0 <code>optional</code> 设置在粒子的粒子寿命期间应用于粒子图像的比例。
   * @param {Number} options.startScale <code>optional</code> 在粒子寿命开始时应用于粒子图像的初始比例。
   * @param {Number} options.endScale <code>optional</code> 在粒子寿命结束时应用于粒子图像的最终比例。
   * @param {Color} options.color=Color.WHITE <code>optional</code> 设置粒子在其粒子寿命期间的颜色。
   * @param {Color} options.startColor <code>optional</code> 粒子在其生命初期的颜色。
   * @param {Color} options.endColor <code>optional</code> 粒子寿命结束时的颜色。
   * @param {Object} options.image <code>optional</code> 用于广告牌的URI，HTMLImageElement或HTMLCanvasElement。
   * @param {Cartesian2} options.imageSize=new Cartesian2(1.0, 1.0) <code>optional</code> 如果设置，则将覆盖用来缩放粒子图像尺寸（以像素为单位）的minimumImageSize和maximumImageSize输入。
   * @param {Cartesian2} options.minimumImageSize <code>optional</code> 设置宽度的最小范围，以高度为单位，在该范围上可以随机缩放粒子图像的尺寸（以像素为单位）。
   * @param {Cartesian2} options.maximumImageSize <code>optional</code> 设置最大宽度边界，以高度为单位，在该边界以下可以随机缩放粒子图像的尺寸（以像素为单位）。 
   * @param {Boolean} options.sizeInMeters <code>optional</code> 设置粒子的大小是以米还是像素为单位。
   * @param {Number} options.speed=1.0 <code>optional</code> 如果设置，则用此值覆盖minimumSpeed和maximumSpeed输入。
   * @param {Number} options.minimumSpeed <code>optional</code> 设置以米/秒为单位的最小范围，在该范围上可以随机选择粒子的实际速度。
   * @param {Number} options.maximumSpeed <code>optional</code> 设置以米/秒为单位的最大范围，在该范围内将随机选择粒子的实际速度。
   * @param {Number} options.lifetime=Number.MAX_VALUE <code>optional</code> 粒子系统发射粒子的时间（以秒为单位）。
   * @param {Number} options.particleLife=5.0 <code>optional</code> 如果设置，则使用此值覆盖minimumParticleLife和maximumParticleLife输入。
   * @param {Number} options.minimumParticleLife <code>optional</code> 设置以秒为单位的粒子生命的可能持续时间的最小范围，在该范围内可以随机选择粒子的实际生命。
   * @param {Number} options.maximumParticleLife <code>optional</code> 设置以秒为单位的粒子生命的可能持续时间的最大范围，在该范围内可以随机选择粒子的实际生命。
   * @param {Number} options.mass=1.0 <code>optional</code> 设置粒子的最小和最大质量（以千克为单位）。
   * @param {Number} options.minimumMass <code>optional</code> 设置粒子质量的最小范围（以千克为单位）。粒子的实际质量将被选择为高于该值的随机量。
   * @param {Number} options.maximumMass <code>optional</code> 设置最大粒子质量（以千克为单位）。粒子的实际质量将选择为低于此值的随机量。
   */
  function ParticleSystem(options) {
    this._definitionChanged = new Event();
    options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);

    /**
     * 是否显示粒子系统
     * @type {Boolean}
     * @default true
     */
    this.show = defaultValue$1(options.show, true);

    /**
     * 一组强制回调. 回调将传递一个 {@link Particle} 和上一次不同的
     * @type {ParticleSystem.updateCallback}
     * @default undefined
     */
    this.updateCallback = options.updateCallback;

    /**
     *粒子系统是否循环
     * @type {Boolean}
     * @default true
     */
    this.loop = defaultValue$1(options.loop, true);

    /**
     * 用于广告牌的URI，HTMLImageElement或HTMLCanvasElement。
     * @type {Object}
     * @default undefined
     */
    this.image = defaultValue$1(options.image, undefined);
    this.emitterDir = defaultValue$1(options.emitterDir, new Vector3(0, 0, 0));
    this.emitterDirMatrix = new Matrix4();

    //计算发射器的旋转矩阵
    if (this.emitterDir) {
      var emitterDirMatrix = new Matrix4$1();
      emitterDirMatrix.makeRotationFromEuler(new Euler(this.emitterDir.x, this.emitterDir.y, this.emitterDir.z), 'XYZ');
      Matrix4.fromArray(emitterDirMatrix.toArray(), 0, this.emitterDirMatrix);
    }
    var emitter = options.emitter;
    if (!defined$1(emitter)) {
      emitter = new CircleEmitter(0.5);
    }
    this._emitter = emitter;
    this._bursts = options.bursts;
    this._modelMatrix = Matrix4.clone(defaultValue$1(options.modelMatrix, Matrix4.IDENTITY));
    this._emitterModelMatrix = Matrix4.clone(defaultValue$1(options.emitterModelMatrix, Matrix4.IDENTITY));
    this._matrixDirty = true;
    this._combinedMatrix = new Matrix4();
    this._startColor = Color$1.clone(defaultValue$1(options.color, defaultValue$1(options.startColor, Color$1.WHITE)));
    this._endColor = Color$1.clone(defaultValue$1(options.color, defaultValue$1(options.endColor, Color$1.WHITE)));
    this._startScale = defaultValue$1(options.scale, defaultValue$1(options.startScale, 1.0));
    this._endScale = defaultValue$1(options.scale, defaultValue$1(options.endScale, 1.0));
    this._emissionRate = defaultValue$1(options.emissionRate, 5.0);
    this._minimumSpeed = defaultValue$1(options.speed, defaultValue$1(options.minimumSpeed, 1.0));
    this._maximumSpeed = defaultValue$1(options.speed, defaultValue$1(options.maximumSpeed, 1.0));
    this._minimumParticleLife = defaultValue$1(options.particleLife, defaultValue$1(options.minimumParticleLife, 5.0));
    this._maximumParticleLife = defaultValue$1(options.particleLife, defaultValue$1(options.maximumParticleLife, 5.0));
    this._minimumMass = defaultValue$1(options.mass, defaultValue$1(options.minimumMass, 1.0));
    this._maximumMass = defaultValue$1(options.mass, defaultValue$1(options.maximumMass, 1.0));
    this.imageSize = options.imageSize;
    this._minimumImageSize = Cartesian2.clone(defaultValue$1(options.imageSize, defaultValue$1(options.minimumImageSize, defaultImageSize)));
    this._maximumImageSize = Cartesian2.clone(defaultValue$1(options.imageSize, defaultValue$1(options.maximumImageSize, defaultImageSize)));
    this._sizeInMeters = defaultValue$1(options.sizeInMeters, false);

    //更新，纹理加载
    if (this.image) {
      // this.image.style.width = options.imageSize.x
      // this.image.style.height=options.imageSize.y
      this._map = new TextureLoader().load(this.image);
      this._material = new SpriteMaterial({
        map: this._map,
        alphaMap: this._map,
        transparent: true,
        sizeAttenuation: this.sizeInMeters,
        alphaTest: 0.1
      });
      this._sprite = new Sprite(this._material);
      this._sprite.visible = false;
    }
    this._matrix = new Matrix4$1();
    this._lifetime = defaultValue$1(options.lifetime, Number.MAX_VALUE);
    this._billboardCollection = undefined;
    this._particles = [];

    //我们可以重用而不是分配新粒子的可用粒子数组。（即没有销毁的）
    this._particlePool = [];
    this._previousTime = undefined;
    this._currentTime = 0.0;
    this._carryOver = 0.0;
    this._complete = new Event();
    this._isComplete = false;
    this._updateParticlePool = true;
    this._particleEstimate = 0;

    //继承Object3D
    Object3D$1.call(this, options);
  }

  // console.log(Group)
  //继承Object3D
  ParticleSystem.prototype = new Object3D$1();
  // inheritProtoType(ParticleSystem,Object3D)

  Object.defineProperties(ParticleSystem.prototype, {
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    /**
     * 粒子发射器
     * @memberof ParticleSystem.prototype
     * @type {ParticleEmitter}
     * @default CircleEmitter
     */
    emitter: {
      get: function get() {
        return this._emitter;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.defined("value", value);
        //>>includeEnd('debug');
        this._emitter = value;
      }
    },
    /**
     *{@link ParticleBurst}, 的数组，以周期性的时间发射粒子爆发。
     * @memberof ParticleSystem.prototype
     * @type {ParticleBurst[]}
     * @default undefined
     */
    bursts: {
      get: function get() {
        return this._bursts;
      },
      set: function set(value) {
        this._bursts = value;
        this._updateParticlePool = true;
      }
    },
    /**
     * 将粒子系统从模型转换为世界坐标的4x4转换矩阵。
     * @memberof ParticleSystem.prototype
     * @type {Matrix4}
     * @default Matrix4.IDENTITY
     */
    modelMatrix: {
      get: function get() {
        return this._modelMatrix;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.defined("value", value);
        //>>includeEnd('debug');
        this._matrixDirty = this._matrixDirty || !Matrix4.equals(this._modelMatrix, value);
        Matrix4.clone(value, this._modelMatrix);
      }
    },
    /**
     * 在粒子系统局部坐标系内变换粒子系统发射器的4x4变换矩阵。.
     * @memberof ParticleSystem.prototype
     * @type {Matrix4}
     * @default Matrix4.IDENTITY
     */
    emitterModelMatrix: {
      get: function get() {
        return this._emitterModelMatrix;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.defined("value", value);
        //>>includeEnd('debug');
        this._matrixDirty = this._matrixDirty || !Matrix4.equals(this._emitterModelMatrix, value);
        Matrix4.clone(value, this._emitterModelMatrix);
      }
    },
    /**
     * 粒子生命开始时的颜色。
     * @memberof ParticleSystem.prototype
     * @type {Color}
     * @default Color.WHITE
     */
    startColor: {
      get: function get() {
        return this._startColor;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.defined("value", value);
        //>>includeEnd('debug');
        Color$1.clone(value, this._startColor);
      }
    },
    /**
     * 粒子寿命结束时的颜色。
     * @memberof ParticleSystem.prototype
     * @type {Color}
     * @default Color.WHITE
     */
    endColor: {
      get: function get() {
        return this._endColor;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.defined("value", value);
        //>>includeEnd('debug');
        Color$1.clone(value, this._endColor);
      }
    },
    /**
     * 在粒子生命开始时应用于粒子图像的初始比例。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 1.0
     */
    startScale: {
      get: function get() {
        return this._startScale;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._startScale = value;
      }
    },
    /**
     * 在粒子寿命结束时应用于粒子图像的最终比例。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 1.0
     */
    endScale: {
      get: function get() {
        return this._endScale;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._endScale = value;
      }
    },
    /**
     *每秒发射的粒子数。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 5
     */
    emissionRate: {
      get: function get() {
        return this._emissionRate;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._emissionRate = value;
        this._updateParticlePool = true;
      }
    },
    /**
     *设置以米/秒为单位的最小界限，超过该界限将随机选择粒子的实际速度。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 1.0
     */
    minimumSpeed: {
      get: function get() {
        return this._minimumSpeed;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._minimumSpeed = value;
      }
    },
    /**
     * 设置以米/秒为单位的最大界限，低于该界限将随机选择粒子的实际速度。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 1.0
     */
    maximumSpeed: {
      get: function get() {
        return this._maximumSpeed;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._maximumSpeed = value;
      }
    },
    /**
     * 设置粒子寿命可能持续时间的最小界限（以秒为单位），超过该界限将随机选择粒子的实际寿命。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 5.0
     */
    minimumParticleLife: {
      get: function get() {
        return this._minimumParticleLife;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._minimumParticleLife = value;
      }
    },
    /**
     * 设置粒子寿命可能持续时间的最大界限（以秒为单位），低于该界限将随机选择粒子的实际寿命。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 5.0
     */
    maximumParticleLife: {
      get: function get() {
        return this._maximumParticleLife;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._maximumParticleLife = value;
        this._updateParticlePool = true;
      }
    },
    /**
     * 以千克为单位设置粒子的最小质量。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 1.0
     */
    minimumMass: {
      get: function get() {
        return this._minimumMass;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._minimumMass = value;
      }
    },
    /**
     * 以千克为单位设置粒子的最大质量。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default 1.0
     */
    maximumMass: {
      get: function get() {
        return this._maximumMass;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._maximumMass = value;
      }
    },
    /**
     * 设置最小限制，即以像素为单位，高度乘以宽度的结果，该结果为随机缩放粒子图像尺寸的下限。
     * @memberof ParticleSystem.prototype
     * @type {Cartesian2}
     * @default new Cartesian2(1.0, 1.0)
     */
    minimumImageSize: {
      get: function get() {
        return this._minimumImageSize;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.object("value", value);
        Check.typeOf.number.greaterThanOrEquals("value.x", value.x, 0.0);
        Check.typeOf.number.greaterThanOrEquals("value.y", value.y, 0.0);
        //>>includeEnd('debug');
        this._minimumImageSize = value;
      }
    },
    /**
     * 设置最大限制，即以像素为单位，高度乘以宽度的结果，该结果为随机缩放粒子图像尺寸的上限。
     * @memberof ParticleSystem.prototype
     * @type {Cartesian2}
     * @default new Cartesian2(1.0, 1.0)
     */
    maximumImageSize: {
      get: function get() {
        return this._maximumImageSize;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.object("value", value);
        Check.typeOf.number.greaterThanOrEquals("value.x", value.x, 0.0);
        Check.typeOf.number.greaterThanOrEquals("value.y", value.y, 0.0);
        //>>includeEnd('debug');
        this._maximumImageSize = value;
      }
    },
    /**
     * 获取或设置粒子大小的单位是米还是像素。若为 true，则以米为单位设置粒子大小；否则，以像素为单位设置大小。
     * @memberof ParticleSystem.prototype
     * @type {Boolean}
     * @default false
     */
    sizeInMeters: {
      get: function get() {
        return this._sizeInMeters;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.bool("value", value);
        //>>includeEnd('debug');
        this._sizeInMeters = value;
      }
    },
    /**
     * 粒子系统将发射粒子的时间长度，以秒为单位。
     * @memberof ParticleSystem.prototype
     * @type {Number}
     * @default Number.MAX_VALUE
     */
    lifetime: {
      get: function get() {
        return this._lifetime;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThanOrEquals("value", value, 0.0);
        //>>includeEnd('debug');
        this._lifetime = value;
      }
    },
    /**
     * 在粒子系统到达其生命周期的末尾时触发事件。
     * @memberof ParticleSystem.prototype
     * @type {Event}
     */
    complete: {
      get: function get() {
        return this._complete;
      }
    },
    /**
     * 当值为 true 时，表示粒子系统已经到达了其生命周期的末尾；否则为 false。
     * @memberof ParticleSystem.prototype
     * @type {Boolean}
     */
    isComplete: {
      get: function get() {
        return this._isComplete;
      }
    }
  });
  function updateParticlePool(system) {
    var emissionRate = system._emissionRate;
    var life = system._maximumParticleLife;

    //获取几个脉冲时刻的粒子数量
    var burstAmount = 0;
    var bursts = system._bursts;
    if (defined$1(bursts)) {
      var length = bursts.length;
      for (var i = 0; i < length; ++i) {
        burstAmount += bursts[i].maximum;
      }
    }
    //添加billBoardCollection
    var billboardCollection = system._billboardCollection;
    system.image;
    //总的粒子数量为发射率x存活时间+脉冲时刻发射的粒子数量
    var particleEstimate = Math.ceil(emissionRate * life + burstAmount);
    var particles = system._particles;
    //可重用的粒子
    var particlePool = system._particlePool;
    //需要加的粒子，应该有的
    var numToAdd = Math.max(particleEstimate - particles.length - particlePool.length, 0);

    //新创建的粒子，增加到池中，预备粒子
    for (var j = 0; j < numToAdd; ++j) {
      var particle = new Particle();
      // particle._billboard = billboardCollection.add({
      //     image: image,
      // });  
      particle._billboard = addSprite(system, particle);
      billboardCollection.add(particle._billboard);
      particlePool.push(particle);
    }
    system._particleEstimate = particleEstimate;
  }
  function addSprite(system, particle) {
    var x = particle.imageSize.x;
    var y = particle.imageSize.y;
    var sprite = system._sprite.clone();
    //不可移动，否则不生成粒子
    sprite.center = [0.5, 0];
    sprite.scale.set(x / 1024, y / 1024, 1);
    return sprite;
  }
  function getOrCreateParticle(system) {
    // 尝试复用存在的粒子，获取最后一个
    var particle = system._particlePool.pop();
    if (!defined$1(particle)) {
      //创建一个新的粒子
      particle = new Particle();
    }
    return particle;
  }

  //把粒子加到粒子池中
  function addParticleToPool(system, particle) {
    system._particlePool.push(particle);
  }
  function freeParticlePool(system) {
    var particles = system._particles;
    var particlePool = system._particlePool;
    var billboardCollection = system._billboardCollection;
    var numParticles = particles.length;
    var numInPool = particlePool.length;
    var estimate = system._particleEstimate;
    var start = numInPool - Math.max(estimate - numParticles - numInPool, 0);
    for (var i = start; i < numInPool; ++i) {
      var p = particlePool[i];
      billboardCollection.remove(p._billboard);
      p._billboard.dispose();
    }
    particlePool.length = start;
  }
  function removeBillboard(particle) {
    if (defined$1(particle._billboard)) {
      particle._billboard.visible = false;
    }
  }
  function updateBillboard$1(system, particle) {
    var billboard = particle._billboard;
    if (!defined$1(billboard)) {
      // billboard = particle._billboard = system._billboardCollection.add({
      //     image: particle.image,
      // });

      var sprite = addSprite(system, particle);
      billboard = particle._billboard = sprite;
      system._billboardCollection.add(sprite);
    }
    var position = particle.position.toThreeVector3();
    billboard.position.set(position.x, position.y, position.z);
    billboard.visible = true;
    billboard.matrixWorldNeedsUpdate = true;
    // Update the color
    var r = CesiumMath.lerp(particle.startColor.red, particle.endColor.red, particle.normalizedAge);
    var g = CesiumMath.lerp(particle.startColor.green, particle.endColor.green, particle.normalizedAge);
    var b = CesiumMath.lerp(particle.startColor.blue, particle.endColor.blue, particle.normalizedAge);
    var a = CesiumMath.lerp(particle.startColor.alpha, particle.endColor.alpha, particle.normalizedAge);
    billboard.material.color = new Color$2(r, g, b);
    billboard.material.transparent = true;
    billboard.material.opacity = a;

    // Update the scale
    var scale = CesiumMath.lerp(particle.startScale, particle.endScale, particle.normalizedAge);
    var x = particle.imageSize.x;
    var y = particle.imageSize.y;
    billboard.scale.set(x / 1024 * scale, y / 1024 * scale, scale);
  }
  function addParticle(system, particle) {
    particle.startColor = Color$1.clone(system._startColor, particle.startColor);
    particle.endColor = Color$1.clone(system._endColor, particle.endColor);
    particle.startScale = system._startScale;
    particle.endScale = system._endScale;
    particle.image = system.image;
    particle.life = CesiumMath.randomBetween(system._minimumParticleLife, system._maximumParticleLife);
    particle.mass = CesiumMath.randomBetween(system._minimumMass, system._maximumMass);
    particle.imageSize.x = CesiumMath.randomBetween(system._minimumImageSize.x, system._maximumImageSize.x);
    particle.imageSize.y = CesiumMath.randomBetween(system._minimumImageSize.y, system._maximumImageSize.y);

    // Reset the normalizedAge and age in case the particle was reused.
    particle._normalizedAge = 0.0;
    particle._age = 0.0;
    var speed = CesiumMath.randomBetween(system._minimumSpeed, system._maximumSpeed);
    Cartesian3.multiplyByScalar(particle.velocity, speed, particle.velocity);
    system._particles.push(particle);
  }
  function calculateNumberToEmit(system, dt) {
    //如果发射器超过它的寿命，它就完成了。
    if (system._isComplete) {
      return 0;
    }
    dt = CesiumMath.mod(dt, system._lifetime);

    //基于emissionRate计算要发射的粒子数。这一帧需要发射多少粒子
    var v = dt * system._emissionRate;
    var numToEmit = Math.floor(v);
    system._carryOver += v - numToEmit;
    if (system._carryOver > 1.0) {
      numToEmit++;
      system._carryOver -= 1.0;
    }

    //应用任何爆炸
    if (defined$1(system.bursts)) {
      var length = system.bursts.length;
      for (var i = 0; i < length; i++) {
        var burst = system.bursts[i];
        var currentTime = system._currentTime;
        if (defined$1(burst) && !burst._complete && currentTime > burst.time) {
          numToEmit += CesiumMath.randomBetween(burst.minimum, burst.maximum);
          burst._complete = true;
        }
      }
    }
    return numToEmit;
  }
  var rotatedVelocityScratch = new Cartesian3();

  /**
   * @private
   */
  ParticleSystem.prototype.update = function (frameState) {
    if (!this.show) {
      return;
    }
    if (!defined$1(this._billboardCollection)) {
      // this._billboardCollection = new BillboardCollection();
      this._billboardCollection = new Group$1();
      this.add(this._billboardCollection);
    }

    //增加可复用的粒子（即预备粒子）
    if (this._updateParticlePool) {
      updateParticlePool(this);
      this._updateParticlePool = false;
    }

    //计算帧运行的时间
    var dt = 0.0;
    if (this._previousTime) {
      dt = (frameState.time.getTime() - this._previousTime.getTime()) * 0.001;
      // dt = JulianDate.secondsDifference(frameState.time, this._previousTime);
    }

    if (dt < 0.0) {
      dt = 0.0;
    }
    var particles = this._particles;
    var emitter = this._emitter;
    var updateCallback = this.updateCallback;
    var i;
    var particle;

    // 更新粒子并移出死亡的粒子
    var length = particles.length; //100
    for (i = 0; i < length; ++i) {
      //0  0
      particle = particles[i];
      //判断粒子是否存活，如果不存活，移出最前面的放到最后面去，否则更新粒子位置，大小，颜色等
      if (!particle.update(dt, this._modelMatrix, this.emitterDirMatrix, updateCallback)) {
        //并未移除，不显示
        removeBillboard(particle);
        //增加粒子到粒子池以便能复用，粒子池存储废弃的粒子
        addParticleToPool(this, particle);
        particles[i] = particles[length - 1]; //0,0                           //99,98
        --i; //-1
        --length; //99,98
      } else {
        updateBillboard$1(this, particle);
      }
    }
    particles.length = length;

    //计算这一帧需要发射多少粒子
    var numToEmit = calculateNumberToEmit(this, dt);
    if (numToEmit > 0 && defined$1(emitter)) {
      // 计算粒子发射器的最终位置（世界坐标）
      // if (this._matrixDirty) {
      //     this._combinedMatrix = Matrix4.multiply(
      //         this.modelMatrix,
      //         this.emitterModelMatrix,
      //         this._combinedMatrix
      //     );
      //     this._matrixDirty = false;
      // }

      // const combinedMatrix = this._combinedMatrix;

      for (i = 0; i < numToEmit; i++) {
        // 从粒子池取一个粒子出来，没有就创建一个
        particle = getOrCreateParticle(this);
        particle.velocity = new Cartesian3(0, -1, 0);
        // 发射器初始化粒子（即位置计算）
        this._emitter.emit(particle);

        // //对于速度，我们需要将其添加到原始位置，然后乘以点。
        Cartesian3.add(particle.position, particle.velocity, rotatedVelocityScratch);
        // Matrix4.multiplyByPoint(
        //     combinedMatrix,
        //     rotatedVelocityScratch,
        //     rotatedVelocityScratch
        // );

        // // 将位置更改为世界坐标
        // particle.position = Matrix4.multiplyByPoint(
        //     combinedMatrix,
        //     particle.position,
        //     particle.position
        // );

        // //在世界空间中确定速度方向。
        Cartesian3.subtract(rotatedVelocityScratch, particle.position, particle.velocity);
        Cartesian3.normalize(particle.velocity, particle.velocity);

        //将粒子添加到系统中。
        addParticle(this, particle);
        //计算粒子大小位置等
        updateBillboard$1(this, particle);
      }
    }

    // this._billboardCollection.update(frameState);

    // this._previousTime = JulianDate.clone(frameState.time, this._previousTime);
    this._previousTime = frameState.time;
    this._currentTime += dt;
    if (this._lifetime !== Number.MAX_VALUE && this._currentTime > this._lifetime) {
      if (this.loop) {
        this._currentTime = CesiumMath.mod(this._currentTime, this._lifetime);
        if (this.bursts) {
          var burstLength = this.bursts.length;
          // Reset any bursts
          for (i = 0; i < burstLength; i++) {
            this.bursts[i]._complete = false;
          }
        }
      } else {
        this._isComplete = true;
        this._complete.raiseEvent(this);
      }
    }

    // free particles in the pool and release billboard GPU memory
    if (frameState.frameNumber % 120 === 0) {
      freeParticlePool(this);
    }

    // //更新当前位置
    frameState.threeEarth.updateWorldMatrix(this, this._matrix.fromArray(Matrix4.toArray(this._modelMatrix)));
    this._billboardCollection.rotation.set(this.emitterDir.x, this.emitterDir.y, this.emitterDir.z);
  };

  /**
   * 如果该对象已被销毁，则返回 true；否则返回 false。
   * 如果该对象已被销毁，则不应继续使用；调用除了 isDestroyed 之外的任何函数都会导致 DeveloperError 异常。
   * 返回值为 Boolean 类型，若该对象已被销毁，则返回 true，否则返回 false。
   *
   */
  ParticleSystem.prototype.isDestroyed = function () {
    return false;
  };

  /**
   * 销毁该对象持有的 WebGL 资源。通过销毁对象，可以确定性地释放 WebGL 资源，而不是依赖垃圾收集器来销毁该对象。
   * 一旦对象被销毁，就不应继续使用；调用除了 isDestroyed 之外的任何函数都会导致 DeveloperError 异常。因此，应该将返回值（即 undefined）赋值给对象，如示例中所示。
   * 该函数会抛出 DeveloperError 异常，表示该对象已被销毁（即已调用 destroy()）。
   */
  ParticleSystem.prototype.destroy = function () {
    this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy();
    return destroyObject(this);
  };
  var addParticleSystem = function addParticleSystem(globe, layer, entity, threeEarth) {
    var _entity$getLonLatPosi = entity.getLonLatPosition(),
      lon = _entity$getLonLatPosi.lon,
      lat = _entity$getLonLatPosi.lat,
      positionHeight = _entity$getLonLatPosi.positionHeight;
    var matrix = threeEarth.computeWorldMatrix(lon, lat, positionHeight);
    var transform = Earth.Matrix4.fromArray(matrix.toArray());
    var particleSystemParams = entity.getParamsByName('particleSystem');
    var particleSystem = new ParticleSystem(_objectSpread2(_objectSpread2({}, particleSystemParams), {}, {
      modelMatrix: transform
    }));
    layer.add(particleSystem);
    entity.particleSystem._id = particleSystem.id;
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * @class WeatherParticle
   * 天气粒子
   * @extends Points
   */
  var WeatherParticle = /*#__PURE__*/function (_Points) {
    _inherits(WeatherParticle, _Points);
    var _super = _createSuper(WeatherParticle);
    /**
     * WeatherParticle类的构造函数
     * @param {Number} size
     * @param {Boolean} transparent
     * @param {Boolean} sizeAttenuation
     * @param {Image} image
     * @param {Number} speed
     * @param {Number} particalNumber  
     */
    /*
     * @param {*设置粒子大小} size
     * @param {*设置粒子是否透明} transparent
     * @param {*设置粒子是否近大远小} sizeAttenuation
     * @param {*粒子纹理图片} image
     * @param {*粒子运行速度} speed
     * @param {*粒子个数} particalNumber 
     */
    function WeatherParticle(_ref) {
      var _this;
      var _ref$size = _ref.size,
        size = _ref$size === void 0 ? 20 : _ref$size,
        _ref$transparent = _ref.transparent,
        transparent = _ref$transparent === void 0 ? false : _ref$transparent,
        _ref$sizeAttenuation = _ref.sizeAttenuation,
        sizeAttenuation = _ref$sizeAttenuation === void 0 ? true : _ref$sizeAttenuation,
        _ref$image = _ref.image,
        image = _ref$image === void 0 ? null : _ref$image,
        _ref$speed = _ref.speed,
        speed = _ref$speed === void 0 ? 0.5 : _ref$speed,
        _ref$particleNumber = _ref.particleNumber,
        particleNumber = _ref$particleNumber === void 0 ? 100000 : _ref$particleNumber,
        _ref$radius = _ref.radius,
        radius = _ref$radius === void 0 ? 2500 : _ref$radius,
        _ref$maxHeight = _ref.maxHeight,
        maxHeight = _ref$maxHeight === void 0 ? 8000 : _ref$maxHeight,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE : _ref$color;
      _classCallCheck(this, WeatherParticle);
      _this = _super.call(this);
      _this._size = size;
      _this._transparent = transparent;
      _this._sizeAttenuation = sizeAttenuation;
      if (image) {
        _this._image = image;
      }
      _this._height = maxHeight;
      _this._speed = speed;
      _this._particleNumber = particleNumber;
      _this._radius = radius;
      var textureLoader = new TextureLoader();
      var sprite = textureLoader.load(_this._image);
      var colorArray = color.toBytes();
      _this.material = new PointsMaterial({
        size: _this._size,
        map: sprite,
        transparent: _this._transparent,
        blending: AdditiveBlending,
        depthTest: true,
        depthWrite: false,
        color: new Color$2(colorArray[0], colorArray[1], colorArray[2]),
        opacity: colorArray[3] / 255.0,
        sizeAttenuation: _this._sizeAttenuation
      });
      _this.geometry = new BufferGeometry();
      var vertices = [];
      for (var i = 0; i < _this._particleNumber; i++) {
        var x = Math.random() * 2 - 1;
        var y = (i % 2 === 1 ? 1 : -1) * Math.sqrt(1 - x * x);
        var z = _this._height * Math.random();
        vertices.push(x * _this._radius, y * Math.random() * _this._radius, z);
      }
      _this.geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      _this.position.set(0, 0, 0);
      _this.scale.set(2, 1, 1);
      _this.rotation.set(-Math.PI, 0, 0);
      _this._definitionChanged = new Event();
      return _this;
    }
    /**
     * 获取事件
     */
    _createClass(WeatherParticle, [{
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }
      /**
       * 更新粒子效果
       * @param {FrameState} frameState -帧状态
       */
    }, {
      key: "update",
      value: function update(frameState) {
        var distance = frameState.threeEarth.worldCamera.getDistance();
        if (distance > this._height * 10) {
          this.visible = false;
        } else {
          this.visible = true;
        }
        //监听相机高度
        var positions = this.geometry.attributes.position.array;
        for (var i = 0; i < positions.length; i += 3) {
          if (positions[i + 2] < 0 - (Math.abs(positions[i]) + Math.abs(positions[i + 1])) * 0.02) {
            positions[i + 2] = this._height - (Math.abs(positions[i]) + Math.abs(positions[i + 1])) * 0.02;
          } else {
            positions[i + 2] -= this._speed;
          }
        }
        this.geometry.attributes.position.needsUpdate = true;
      }
    }]);
    return WeatherParticle;
  }(Points);
  /**
   * 添加天气系统
   * @param {Globe} globe 
   * @param {Layer} layer 
   * @param {Entity} entity 
   * @param {ThreeEarth} threeEarth 
   */
  var addWeatherSystem = function addWeatherSystem(globe, layer, entity, threeEarth) {
    var weatherParticle = entity.weatherSystem;
    entity.primitiveInstance.weatherSystem = weatherParticle;
    entity.weatherSystem._id = weatherParticle.id;
  };

  var Plane = /*#__PURE__*/function (_BaseGraphic) {
    _inherits(Plane, _BaseGraphic);
    var _super = _createSuper(Plane);
    function Plane(options) {
      _classCallCheck(this, Plane);
      return _super.call(this, options, Plane.propertyNames);
    }
    return _createClass(Plane);
  }(BaseGraphic);
  _defineProperty(Plane, "propertyNames", ['width', 'rotation', "height"]);
  Object.defineProperties(Plane.prototype, {
    width: createPropertyDescriptor('width'),
    rotation: createPropertyDescriptor('rotation'),
    height: createPropertyDescriptor('height')
  });
  var addPlane = function addPlane(globe, layer, entity, threeEarth) {
    // const plane = entity.plane
    // const primitiveInstance = entity.primitiveInstance
    // const properties = plane.properties
    // let options = new Object()
    // properties.forEach(item => {

    //   if (item == 'material') {
    //     options[item] = plane[item]
    //   } else {
    //     options[item] = plane[item]?.getValue()
    //   }
    // })

    // const planePrimitive = new PlanePrimitive(options)

    // //设置相机
    // primitiveInstance.planePrimitive = planePrimitive
    // entity.plane._id = planePrimitive.id;
    addGraphic(entity, 'plane', PlanePrimitive, 'planePrimitive');
  };
  //更新面
  var updatePlane = function updatePlane(globe, layer, _ref) {
    var scope = _ref.scope,
      name = _ref.name,
      value = _ref.value;
      _ref.oldValue;
    layer.children.forEach(function (item) {
      var planePrimitive = item.planePrimitive;
      if (planePrimitive.id === scope.id) {
        var result = value._value;
        switch (name) {
          case 'width':
            planePrimitive.scale.set(value._value, scope.height._value, 1);
            break;
          case 'height':
            planePrimitive.scale.set(scope.width._value, value._value, 1);
            break;
          case 'rotation':
            if (value._value instanceof HeadingPitchRoll) {
              var rotation = value._value;
              planePrimitive.setRotation(rotation);
            }
            break;
          default:
            updateGraphic(name, result, planePrimitive);
            break;
        }
      }
    });
  };

  var PixelLineGeometry = /*#__PURE__*/function (_BufferGeometry) {
    _inherits(PixelLineGeometry, _BufferGeometry);
    var _super = _createSuper(PixelLineGeometry);
    function PixelLineGeometry() {
      _classCallCheck(this, PixelLineGeometry);
      return _super.call(this);
    }
    _createClass(PixelLineGeometry, [{
      key: "arr2HighLow",
      value: function arr2HighLow(arr) {
        var highArr = [];
        var lowArr = [];

        //循环遍历，改为高低位
        for (var i = 0; i < arr.length; i++) {
          var highValue = new Vector3();
          var lowValue = new Vector3();
          this.doubleToTwoFloats(arr[i], highValue, lowValue);
          highArr.push(highValue);
          lowArr.push(lowValue);
        }
        this.setAttributes(highArr, lowArr);
        this.setDistance(arr);
      }
    }, {
      key: "setDistance",
      value: function setDistance(points) {
        var geometry = new BufferGeometry().setFromPoints(points);
        var material = new LineBasicMaterial({
          color: 0x0000ff
        });
        var line = new Line(geometry, material);
        line.computeLineDistances();
        //生成一个长度数组
        var arr = geometry.getAttribute("lineDistance").array;
        var percents = [];
        var newArr = [];
        for (var i = 0; i < arr.length; i++) {
          newArr.push(arr[i]);
          newArr.push(arr[i]);
          percents.push(arr[i] / arr[arr.length - 1]);
          percents.push(arr[i] / arr[arr.length - 1]);
        }
        this.setAttribute("lineDistance", new BufferAttribute(new Float32Array(newArr), 1));
        this.setAttribute("percents", new BufferAttribute(new Float32Array(percents), 1));
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(highArr, lowArr) {
        //先给顶点赋值

        var positionHighArr = [];
        var positionLowArr = [];
        var length = highArr.length;
        for (var i = 0; i <= length - 1; i++) {
          positionHighArr.push(highArr[i].x, highArr[i].y, highArr[i].z);
          positionLowArr.push(lowArr[i].x, lowArr[i].y, lowArr[i].z);
          positionHighArr.push(highArr[i].x, highArr[i].y, highArr[i].z);
          positionLowArr.push(lowArr[i].x, lowArr[i].y, lowArr[i].z);
        }
        this.setAttribute("highPosition", new BufferAttribute(new Float32Array(positionHighArr), 3));
        this.setAttribute("lowPosition", new BufferAttribute(new Float32Array(positionLowArr), 3));

        //给索引赋值
        var indexArray = [];
        for (var _i = 0; _i < length - 1; _i++) {
          var n = _i * 2;
          indexArray.push(n, n + 1, n + 2);
          indexArray.push(n + 2, n + 1, n + 3);
        }
        this.setIndex(new BufferAttribute(new Uint16Array(indexArray), 1));
        // geometry.attributes.index.needsUpdate = true;

        var prevHighArr = [];
        var prevLowArr = [];
        //给上个点赋值

        for (var _i2 = 0; _i2 <= length - 1; _i2++) {
          var prev = _i2 - 1;
          if (prev < 0) {
            var diffHigh = {
              x: highArr[1].x - highArr[0].x,
              y: highArr[1].y - highArr[0].y,
              z: highArr[1].z - highArr[0].z
            };
            var diffLow = {
              x: lowArr[1].x - lowArr[0].x,
              y: lowArr[1].y - lowArr[0].y,
              z: lowArr[1].z - lowArr[0].z
            };
            var minHigh = {
              x: highArr[0].x - diffHigh.x,
              y: highArr[0].y - diffHigh.y,
              z: highArr[0].z - diffHigh.z
            };
            var minLow = {
              x: lowArr[0].x - diffLow.x,
              y: lowArr[0].y - diffLow.y,
              z: lowArr[0].z - diffLow.z
            };
            prevHighArr.push(minHigh.x, minHigh.y, minHigh.z);
            prevHighArr.push(minHigh.x, minHigh.y, minHigh.z);
            prevLowArr.push(minLow.x, minLow.y, minLow.z);
            prevLowArr.push(minLow.x, minLow.y, minLow.z);
          } else {
            prevHighArr.push(highArr[prev].x, highArr[prev].y, highArr[prev].z);
            prevHighArr.push(highArr[prev].x, highArr[prev].y, highArr[prev].z);
            prevLowArr.push(lowArr[prev].x, lowArr[prev].y, lowArr[prev].z);
            prevLowArr.push(lowArr[prev].x, lowArr[prev].y, lowArr[prev].z);
          }
        }
        this.setAttribute("prevHighPosition", new BufferAttribute(new Float32Array(prevHighArr), 3));
        this.setAttribute("prevLowPosition", new BufferAttribute(new Float32Array(prevLowArr), 3));

        //   geometry.attributes.prev.needsUpdate = true;

        var nextHighArr = [];
        var nextLowArr = [];
        //给下个点赋值
        //如果第0个和最后一个相等，则就取再前一个

        for (var _i3 = 0; _i3 <= length - 1; _i3++) {
          var next = _i3 + 1;
          if (next > length - 1) {
            var _diffHigh = {
              x: highArr[_i3 - 1].x - highArr[_i3].x,
              y: highArr[_i3 - 1].y - highArr[_i3].y,
              z: highArr[_i3 - 1].z - highArr[_i3].z
            };
            var _diffLow = {
              x: lowArr[_i3 - 1].x - lowArr[_i3].x,
              y: lowArr[_i3 - 1].y - lowArr[_i3].y,
              z: lowArr[_i3 - 1].z - lowArr[_i3].z
            };
            var _minHigh = {
              x: highArr[_i3].x - _diffHigh.x,
              y: highArr[_i3].y - _diffHigh.y,
              z: highArr[_i3].z - _diffHigh.z
            };
            var _minLow = {
              x: lowArr[_i3].x - _diffLow.x,
              y: lowArr[_i3].y - _diffLow.y,
              z: lowArr[_i3].z - _diffLow.z
            };
            nextHighArr.push(_minHigh.x, _minHigh.y, _minHigh.z);
            nextHighArr.push(_minHigh.x, _minHigh.y, _minHigh.z);
            nextLowArr.push(_minLow.x, _minLow.y, _minLow.z);
            nextLowArr.push(_minLow.x, _minLow.y, _minLow.z);
          } else {
            nextHighArr.push(highArr[next].x, highArr[next].y, highArr[next].z);
            nextHighArr.push(highArr[next].x, highArr[next].y, highArr[next].z);
            nextLowArr.push(lowArr[next].x, lowArr[next].y, lowArr[next].z);
            nextLowArr.push(lowArr[next].x, lowArr[next].y, lowArr[next].z);
          }
        }
        this.setAttribute("nextHighPosition", new BufferAttribute(new Float32Array(nextHighArr), 3));
        this.setAttribute("nextLowPosition", new BufferAttribute(new Float32Array(nextLowArr), 3));
        //   geometry.attributes.next.needsUpdate = true;

        var sideArr = [];
        for (var _i4 = 0; _i4 <= length - 1; _i4++) {
          sideArr.push(1);
          sideArr.push(-1);
        }
        this.setAttribute("side", new BufferAttribute(new Float32Array(sideArr), 1));
      }
    }, {
      key: "doubleToTwoFloats",
      value: function doubleToTwoFloats(v, high, low) {
        var x = v.x,
          y = v.y,
          z = v.z;
        if (x >= 0.0) {
          var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
          high.x = Math.fround(doubleHigh);
          low.x = Math.fround(x - doubleHigh);
        } else {
          var _doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
          high.x = Math.fround(-_doubleHigh);
          low.x = Math.fround(x + _doubleHigh);
        }
        if (y >= 0.0) {
          var _doubleHigh2 = Math.floor(y / 65536.0) * 65536.0;
          high.y = Math.fround(_doubleHigh2);
          low.y = Math.fround(y - _doubleHigh2);
        } else {
          var _doubleHigh3 = Math.floor(-y / 65536.0) * 65536.0;
          high.y = Math.fround(-_doubleHigh3);
          low.y = Math.fround(y + _doubleHigh3);
        }
        if (z >= 0.0) {
          var _doubleHigh4 = Math.floor(z / 65536.0) * 65536.0;
          high.z = Math.fround(_doubleHigh4);
          low.z = Math.fround(z - _doubleHigh4);
        } else {
          var _doubleHigh5 = Math.floor(-z / 65536.0) * 65536.0;
          high.z = Math.fround(-_doubleHigh5);
          low.z = Math.fround(z + _doubleHigh5);
        }
      }
    }, {
      key: "doubleToTwoFloat32Array",
      value: function doubleToTwoFloat32Array(v, high, low) {
        var x = v.x,
          y = v.y,
          z = v.z;
        if (x >= 0.0) {
          var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
          high[0] = Math.fround(doubleHigh);
          low[0] = Math.fround(x - doubleHigh);
        } else {
          var _doubleHigh6 = Math.floor(-x / 65536.0) * 65536.0;
          high[0] = Math.fround(-_doubleHigh6);
          low[0] = Math.fround(x + _doubleHigh6);
        }
        if (y >= 0.0) {
          var _doubleHigh7 = Math.floor(y / 65536.0) * 65536.0;
          high[1] = Math.fround(_doubleHigh7);
          low[1] = Math.fround(y - _doubleHigh7);
        } else {
          var _doubleHigh8 = Math.floor(-y / 65536.0) * 65536.0;
          high[1] = Math.fround(-_doubleHigh8);
          low[1] = Math.fround(y + _doubleHigh8);
        }
        if (z >= 0.0) {
          var _doubleHigh9 = Math.floor(z / 65536.0) * 65536.0;
          high[2] = Math.fround(_doubleHigh9);
          low[2] = Math.fround(z - _doubleHigh9);
        } else {
          var _doubleHigh10 = Math.floor(-z / 65536.0) * 65536.0;
          high[2] = Math.fround(-_doubleHigh10);
          low[2] = Math.fround(z + _doubleHigh10);
        }
      }
    }]);
    return PixelLineGeometry;
  }(BufferGeometry);

  var PixelLineMaterial = /*#__PURE__*/function (_ShaderMaterial) {
    _inherits(PixelLineMaterial, _ShaderMaterial);
    var _super = _createSuper(PixelLineMaterial);
    function PixelLineMaterial(options) {
      var _this;
      _classCallCheck(this, PixelLineMaterial);
      _this = _super.call(this);
      _this.vertexShader = /*glsl*/"\n              attribute vec3 highPosition;\n              attribute vec3 lowPosition;\n          \n              attribute vec3 prevHighPosition;\n              attribute vec3 prevLowPosition;\n          \n              attribute vec3 nextHighPosition;\n              attribute vec3 nextLowPosition;\n  \n  \n              attribute float side;\n              attribute float lineDistance;\n              attribute float percents;\n  \n              uniform vec2 resolution;\n              uniform float lineWidth;\n              \n              uniform vec3 refCenterHigh;\n              uniform vec3 refCenterLow;\n              uniform float near;\n\n\n              varying vec3 vPosition;\n              varying float vLineDistance;\n              varying vec2 vUV;\n              varying float vPercents;\n\n              /**\n              \u88C1\u526A\u5230\u8FD1\u5E73\u9762\n               */\n              void clipLineSegmentToNearPlane(vec3 p0, vec3 p1,out bool culledByNearPlane,out bool clipped,out vec4 clippedPositionEC) {\n                culledByNearPlane = false;\n\n                vec3 p0ToP1 = p1 - p0;\n                float magnitude = length(p0ToP1);\n                vec3 direction = normalize(p0ToP1);\n\n                //\u8BA1\u7B97p0\u5230\u8FD1\u5E73\u9762\u7684\u8DDD\u79BB\n                float endPoint0Distance = near + p0.z;\n\n                // \u76F8\u673A\u770B\u5411-z\n                //denominator\u4E3A\u65B9\u5411-z\uFF0C\u4E5F\u4E3Ap0->p1\u4E0EendPoint0Distance\u7684\u5939\u89D2\u4F59\u5F26\u503C\n                float denominator = -direction.z;\n\n                if(endPoint0Distance > 0.0 && abs(denominator) < 0.00000001) {\n                    //p0\u5728\u8FD1\u5E73\u9762\u5916\u9762\uFF0C\u4E14p0->p1\u4E0E\u8FD1\u5E73\u9762\u57FA\u672C\u5E73\u884C\n                    culledByNearPlane = true;\n                } else if(endPoint0Distance > 0.0) {\n                    // //p0\u5728\u8FD1\u5E73\u9762\u5916\u9762\uFF0C\u4E14p0->p1\u4E0E\u8FD1\u5E73\u9762\u4E0D\u5E73\u884C\uFF0C\u5F80\u91CC\u6216\u8005\u5F80\u5916\n\n                    //\u5F53t<0,\u5373cos Theta\u5C0F\u4E8E0\uFF0C\u5939\u89D2\u5927\u4E8E90\u5EA6\uFF0Ct0->t1\u65B9\u5411\u5F80\u5916\uFF0C\n                    //\u5F53 t > magnitude,t0->t1\u65B9\u5411\u5F80\u91CC\uFF0C\u6B64\u65F6t0->t1\u8DDD\u79BB\u5C0F\u4E8Et0\u5230\u8FD1\u5E73\u9762\u8DDD\u79BB\uFF0C\u5E94\u8BE5\u4E5F\u8981\u88AB\u5254\u9664\n                    float t = endPoint0Distance / denominator;\n                    if(t < 0.0 || t > magnitude) {       \n                        culledByNearPlane = true;\n                    } else {\n                        //\u6B64\u65F6p0->p1\u7684\u7EBF\u6BB5\u4E0E\u8FD1\u5E73\u9762\u76F8\u4EA4\uFF0C\u9700\u8981\u5C06p0\u8BA1\u7B97\u5230\u8FD1\u5E73\u9762\u4E0A\u53BB\n                        p0 = p0 + t * direction;\n\n                        //\u9632\u6B62\u4E00\u4E9B\u7CBE\u5EA6\u9519\u8BEF\n                        p0.z = min(p0.z, -near);\n\n                        clipped = true;\n                    }\n                }\n\n                clippedPositionEC = vec4(p0, 1.0);\n            }\n\n\n             \n              //\u8F6C\u6362\u5230ndc\u5750\u6807\n              vec2 trans2NDCSpace(vec4 point,float aspect){\n                  vec2 ndcPoint =point.xy/point.w;\n                  ndcPoint.x *= aspect;\n                  return ndcPoint;\n              }\n              void main() {\n                  vLineDistance=lineDistance;\n                  vPercents=percents;\n\n                  vec3 diffHigh=highPosition-refCenterHigh;\n                  vec3 diffLow=lowPosition-refCenterLow;\n\n                  vec3 diffHighPrev=prevHighPosition-refCenterHigh;\n                  vec3 diffLowPrev=prevLowPosition-refCenterLow;\n\n                  vec3 diffHighNext=nextHighPosition-refCenterHigh;\n                  vec3 diffLowNext=nextLowPosition-refCenterLow;\n                \n                  vec4 worldPosition=modelMatrix*vec4(diffHigh+diffLow,1.0);\n                  vec4 worldPrevPosition=modelMatrix*vec4(diffHighPrev+diffLowPrev,1.0);\n                  vec4 worldNextPosition=modelMatrix*vec4(diffHighNext+diffLowNext,1.0);\n\n                \n                  // mat4 viewRelativeToEye=viewMatrix;\n                  // viewRelativeToEye[3].x=0.0;\n                  // viewRelativeToEye[3].y=0.0;\n                  // viewRelativeToEye[3].z=0.0;\n                  vec4 view_position= viewMatrix*vec4(worldPosition.xyz,worldPosition.w);\n                  vec4 view_prevPoint=viewMatrix*vec4(worldPrevPosition.xyz,worldPrevPosition.w);\n                  vec4 view_nextPoint=viewMatrix*vec4(worldNextPosition.xyz,worldNextPosition.w);\n                   \n                  //\u88C1\u526A\u5230\u8FD1\u5E73\u9762\n                  //\u8BA1\u7B97\u524D\u4E00\u4E2A\u70B9\u88C1\u5207\u540E\u7684\u5750\u6807\n                  bool prevCulled,prevCliped;\n                  vec4 prev_clippedPositionEC;\n                  clipLineSegmentToNearPlane(view_prevPoint.xyz, view_position.xyz,prevCulled,prevCliped, prev_clippedPositionEC);\n\n\n                   //\u8BA1\u7B97\u540E\u4E00\u4E2A\u70B9\u88C1\u5207\u540E\u7684\u5750\u6807\n                  bool nextCulled,nextCliped;\n                  vec4 next_clippedPositionEC;\n                  clipLineSegmentToNearPlane(view_nextPoint.xyz, view_position.xyz,nextCulled,nextCliped, next_clippedPositionEC);\n\n                  // //\u8BA1\u7B97\u5F53\u524D\u70B9\u88C1\u5207\u540E\u5750\u6807\n                  bool culled=false,cliped;\n                  vec4 clippedPositionEC;\n                  clipLineSegmentToNearPlane(view_position.xyz,  view_prevPoint.xyz ,culled,cliped, clippedPositionEC);\n                  // //\u5982\u679C\u4ECE\u524D\u4E00\u4E2A\u70B9\u5224\u65AD\u5E94\u8BE5\u88AB\u5254\u9664\uFF0C\u8FD8\u9700\u8981\u8BA1\u7B97\u4E0B\u4E00\u4E2A\u70B9\uFF0C\u5426\u5219\u56DE\u4E22\u5931\u7EBF\u6BB5\n                  // if(culled==true){\n                  //   bool culledNext;\n                  //    clipLineSegmentToNearPlane(view_position.xyz, view_nextPoint.xyz,culledNext, clippedPositionEC);\n                  //    culled=culled&&culledNext;\n                  // }\n                  //\u8BA1\u7B97\u6295\u5F71\u7A7A\u95F4\u7684\u5750\u6807\n                  vec4 clip_position=projectionMatrix*vec4(clippedPositionEC);\n                \n                  //\u5982\u679C\u5F53\u524D\u70B9\u88AB\u5254\u9664\uFF0C\u7ED9\u4E2A\u9ED8\u8BA4\u70B9\n                  if(culled==true) {\n                      //  clip_position =vec4(0.0, 0.0, -1.0, 1.0);\n                  }else{\n                     \n                      //\u8BA1\u7B97\u6295\u5F71\u7A7A\u95F4\u7684\u5750\u6807\n                      vec4 clip_prevPoint = projectionMatrix * vec4(prev_clippedPositionEC);\n                      vec4 clip_nextPoint = projectionMatrix * vec4(next_clippedPositionEC);\n                      //\u8F6C\u5316\u5230\u5F52\u4E00\u5316\u5750\u6807\u7A7A\u95F4\n                      float aspect = resolution.x / resolution.y;\n                      vec2 ndcPoint = trans2NDCSpace(clip_position, aspect);\n                      vec2 ndcPrevPoint = trans2NDCSpace(clip_prevPoint, aspect);\n                      vec2 ndcNextPoint = trans2NDCSpace(clip_nextPoint, aspect);\n\n\n                      float thickNess=lineWidth;\n                      vec2 dir1=normalize(ndcPoint-ndcPrevPoint);\n                      vec2 dir2=normalize(ndcNextPoint-ndcPoint);\n                      vec2 dir;\n                      if(nextCulled==true){\n                        dir=dir1;\n                      }else if(prevCulled==true){\n                        dir=dir2;\n                      }\n                      else{\n                      \n                        vec2 dir1Normal=vec2(-dir1.y,dir1.x);\n                        dir=normalize(dir1+dir2);\n                        //\u8BA1\u7B97\u5939\u89D2\n                        float cosTheta=dot(dir,dir1);\n                        thickNess/=cosTheta;\n                      }\n                      //ndc\u7A7A\u95F4\u5750\u6807\n                      vec4 normal=vec4(-dir.y,dir.x,0.0,1.0);\n                      //\u8BA1\u7B97ndc\u7A7A\u95F4\u5BBD\u5EA6\n                      normal.xy *= .5 * min(thickNess,5.0*lineWidth);\n\n\n                    \n                      //\u5355\u4F4D\u8F6C\u6362\u4E3A\u7C73\n                      normal *= projectionMatrix;\n                      float sizeAttenuation=0.0;\n                      //\u5982\u679C\u6CA1\u6709\u8FD1\u5927\u8FDC\u5C0F\u6548\u679C\n                      if( sizeAttenuation == 0. ) {\n                          //\u8F6C\u6362\u5230\u6295\u5F71\u7A7A\u95F4\n                          normal.xy *= clip_position.w;\n                          //\u7C73\u8F6C\u6362\u5230\u50CF\u7D20\n                          normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n                      }\n\n                      clip_position.xy += normal.xy * side;\n                  }\n                \n\n                 \n\n                  gl_Position = clip_position;\n              }\n              \n          ", _this.fragmentShader = /*glsl*/"\n              uniform vec3 color;\n              uniform float opacity;\n              uniform float scale;\n              uniform float frameNumber;\n              uniform float dashOffset;\n              uniform float speed;\n              uniform float cameraDistance;\n              varying vec2 vUV;\n              varying float vLineDistance;\n              varying float vPercents;\n               varying vec3 vPosition;\n              void main() {\n                float alpha=opacity;\n                #ifdef DASHED\n                  float offset=length(cameraPosition)*0.000001/scale;\n                  float mod=mod(vPercents/offset,0.2);\n                  if(mod<0.2*dashOffset){\n                    alpha*=0.0;\n                  }\n                #endif\n                #ifdef FADE\n                      alpha*=fract(vPercents-frameNumber*speed);\n                #endif\n                gl_FragColor = vec4( color,alpha);             \n              }", _this.uniforms = {
        color: {
          value: options.color
        },
        resolution: {
          value: options.resolution
        },
        lineWidth: {
          value: options.lineWidth
        },
        opacity: {
          value: options.opacity
        },
        frameNumber: {
          value: options.frameNumber
        },
        scale: {
          value: options.scale
        },
        dashOffset: {
          value: options.dashOffset
        },
        speed: {
          value: options.speed
        },
        // relativeViewMatrix: { value: new Matrix4() },
        // worldCameraPosition: { value: new Vector3(0, 0, 0) },
        refCenterHigh: {
          value: new Vector3()
        },
        refCenterLow: {
          value: new Vector3()
        },
        near: {
          value: 1
        }
      }, _this.defines = {
        DASHED: options.dashed,
        WORLDUNIT: options.worldUnit,
        FADE: options.fade
      }, _this.blending = AdditiveBlending, _this.depthTest = true, _this.transparent = true, _this.polygonOffset = false, _this.polygonOffsetFactor = -1, _this.polygonOffsetUnits = -10, _this.precision = "highp",
      // this.side = DoubleSide,
      _this.extensions = {
        derivatives: false,
        // set to use derivatives
        fragDepth: true,
        // set to use fragment depth values
        drawBuffers: false,
        // set to use draw buffers
        shaderTextureLOD: false // set to use shader texture LOD
      };
      return _this;
    }
    return _createClass(PixelLineMaterial);
  }(ShaderMaterial);

  var PixelLinePrimitive = /*#__PURE__*/function (_Mesh) {
    _inherits(PixelLinePrimitive, _Mesh);
    var _super = _createSuper(PixelLinePrimitive);
    function PixelLinePrimitive(_ref, threeEarth) {
      var _this;
      var _ref$color = _ref.color,
        color = _ref$color === void 0 ? 'white' : _ref$color,
        _ref$lineWidth = _ref.lineWidth,
        lineWidth = _ref$lineWidth === void 0 ? 2 : _ref$lineWidth,
        _ref$opacity = _ref.opacity,
        opacity = _ref$opacity === void 0 ? 1.0 : _ref$opacity,
        _ref$fade = _ref.fade,
        fade = _ref$fade === void 0 ? false : _ref$fade,
        _ref$speed = _ref.speed,
        speed = _ref$speed === void 0 ? 0.01 : _ref$speed,
        dashed = _ref.dashed,
        dashOffset = _ref.dashOffset,
        _ref$scale = _ref.scale,
        scale = _ref$scale === void 0 ? 100 : _ref$scale;
      _classCallCheck(this, PixelLinePrimitive);
      _this = _super.call(this);
      _this.geometry = new PixelLineGeometry();
      _this.material = new PixelLineMaterial({
        color: new Color$2(color.red, color.green, color.blue),
        resolution: new Vector2(window.innerWidth, window.innerHeight),
        lineWidth: lineWidth,
        opacity: opacity,
        frameNumber: 0,
        scale: scale,
        dashed: dashed,
        dashOffset: dashOffset,
        fade: fade,
        worldUnit: false,
        speed: speed
      });
      _this.frustumCulled = false;
      _this._threeEarth = threeEarth;
      _this._definitionChanged = new Event();
      return _this;
    }
    _createClass(PixelLinePrimitive, [{
      key: "setPositions",
      value: function setPositions(positions) {
        this.geometry.arr2HighLow(positions);
      }
    }, {
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }
    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return this.geometry;
      }
    }, {
      key: "update",
      value: function update(frameState) {
        // console.log(frameState.uniformStates.relativeViewMatrix)
        // const worldCameraPosition = frameState.threeEarth.worldCamera.getCameraPosition()

        var camera = frameState.threeEarth;
        var refCenter = camera.worldCamera.getReferenceCenter();
        var canvas = camera.globeControl.getCanvas();
        var refCenterHigh = new Vector3();
        var refCenterLow = new Vector3();
        //转换为高低位
        this.geometry.doubleToTwoFloats(refCenter, refCenterHigh, refCenterLow);
        // console.log(worldCameraPosition, position, refCenter)
        if (this.material instanceof ShaderMaterial) {
          this.material.uniforms.frameNumber.value = frameState.frameNumber;
          this.material.uniforms.resolution.value = new Vector2(canvas.clientWidth, canvas.clientHeight);
          // this.material.uniforms.worldCameraPosition.value = new Vector3(worldCameraPosition.x, worldCameraPosition.y, worldCameraPosition.z)
          this.material.uniforms.refCenterHigh.value = refCenterHigh;
          this.material.uniforms.refCenterLow.value = refCenterLow;
          this.material.uniforms.near.value = camera.near;
        }
      }
    }]);
    return PixelLinePrimitive;
  }(Mesh);
  var addPixelLine = function addPixelLine(globe, layer, entity, threeEarth) {
    // console.log(layer.parent)
    var params = entity.getParamsByName('pixelLine');
    var positions = params.positions;
    var pixelLine = entity.pixelLine;
    pixelLine.setPositions(positions);
    layer.parent.add(pixelLine);
  };

  function LabelBoxTool() {}
  LabelBoxTool = {
    //
    createConentInBox1: function createConentInBox1(_ref) {
      var _ref$theme = _ref.theme,
        theme = _ref$theme === void 0 ? 'yellow' : _ref$theme,
        _ref$title = _ref.title,
        title = _ref$title === void 0 ? '宏图大厦' : _ref$title,
        _ref$items = _ref.items1,
        items1 = _ref$items === void 0 ? [{
          label: '车位数',
          num: 2499,
          unit: '位'
        }, {
          label: '当前空余',
          num: 126,
          unit: '位'
        }] : _ref$items,
        _ref$items2 = _ref.items2,
        items2 = _ref$items2 === void 0 ? [{
          label: '车库状态',
          status1: '1号',
          status2: '2号'
        }, {
          label: '车库入口',
          status1: '1号',
          status2: '2号'
        }] : _ref$items2;
      var themeClass = '';
      //获取主题颜色
      if (theme === 'red') {
        themeClass = 'pie3dTiltPanel-theme-red';
      } else if (theme === 'green') {
        themeClass = 'pie3dTiltPanel-theme-green';
      } else if (theme === 'blue') {
        themeClass = 'pie3dTiltPanel-theme-blue';
      } else {
        themeClass = 'pie3dTiltPanel-theme-e9b709';
      }
      var html = "<div class=\"pie3dTiltPanel " + themeClass + "\">\n" + "        <div class=\"pie3dTiltPanel-wrap\">\n" + "            <div class=\"area\">\n" + "                <div class=\"arrow-lt\"></div>\n" + "                <div class=\"b-t\"></div>\n" + "                <div class=\"b-r\"></div>\n" + "                <div class=\"b-b\"></div>\n" + "                <div class=\"b-l\"></div>\n" + "                <div class=\"arrow-rb\"></div>\n" + "                <div class=\"label-wrap\">\n" + "                    <div class=\"title\">" + title + "</div>\n" + "                    <div class=\"label-content\">\n";
      items1.forEach(function (element) {
        var str = "                        <div class=\"data-li\">\n" + "                            <div class=\"data-label\">" + element.label + ":</div>\n" + "                            <div class=\"data-value\">\n" + "                                <span  class=\"label-num\">" + element.num + "</span>\n" + "                                <span  class=\"label-unit\">" + element.unit + "</span>\n" + "                            </div>\n" + "                        </div>\n";
        html += str;
      });
      items2.forEach(function (element) {
        var str = "                        <div class=\"data-li\">\n" + "                            <div class=\"data-label\">" + element.label + ":</div>\n" + "                            <div class=\"data-value\">\n" + "                                <span class=\"label-tag data-value-status-1\" alt=\"中间状态\">" + element.status1 + "</span>\n" + "                                <span class=\"label-tag data-value-status-0\" alt=\"关闭状态\">" + element.status2 + "</span>\n" + "                            </div>\n" + "                        </div>\n";
        html += str;
      });
      html += "                    </div>\n" + "                </div>\n" + "            </div>\n" + "            <div class=\"b-t-l\"></div>\n" + "            <div class=\"b-b-r\"></div>\n" + "        </div>\n" + "        <div class=\"arrow\"></div>\n" + "    </div>";
      return html;
    },
    createConentInBox2: function createConentInBox2(_ref2) {
      var _ref2$text = _ref2.text,
        text = _ref2$text === void 0 ? '标牌' : _ref2$text,
        _ref2$fontSize = _ref2.fontSize,
        fontSize = _ref2$fontSize === void 0 ? 14 : _ref2$fontSize,
        _ref2$fontFamily = _ref2.fontFamily,
        fontFamily = _ref2$fontFamily === void 0 ? "PingFang-SC-Medium" : _ref2$fontFamily,
        _ref2$color = _ref2.color,
        color = _ref2$color === void 0 ? "#FFFFFF" : _ref2$color,
        _ref2$backgroundColor = _ref2.backgroundColor,
        backgroundColor = _ref2$backgroundColor === void 0 ? "rgba(30,111,255,.1)" : _ref2$backgroundColor,
        _ref2$boderColor = _ref2.boderColor,
        boderColor = _ref2$boderColor === void 0 ? "#1E6FFF" : _ref2$boderColor;
      var rgbColor = this.fromHex(boderColor);
      var result = this.textSize(fontSize, fontFamily, text);
      var width = result.width + 8;
      var width_1 = width + 10;
      var width_2 = width + 10 - 2;
      var height = result.height;
      var height_1 = height + 4;
      var height_2 = height + 8 - 2;
      var html = "<div class=\"pie3d-divBoderLabel\" style=\"--text-font-size:" + fontSize + 'px' + ";\n" + "    --boder-width: " + width + "px;\n" + "    --clip-width-1: " + width_1 + "px;\n" + "    --clip-width-2: " + width_2 + "px;\n" + "    --boder-height: " + height + "px;\n" + "    --clip-height-1: " + height_1 + "px;\n" + "    --clip-height-2: " + height_2 + "px;\n" + "    --text-color: " + color + ";\n" + "   --text-backgroundcolor: " + backgroundColor + ";\n" + "    --border-color: " + boderColor + ";\n" + "    --box-shadow-color: rgba(" + rgbColor.r + "," + rgbColor.g + "," + rgbColor.b + ",0.56);\">\n" + "        <div class=\"pie3d-divBoderLabel-boder\">\n" + "            <span class=\"pie3d-divBoderLabel-text\" \"font-family: " + fontFamily + ";\">" + text + "</span>\n" + "        </div>\n" + "    </div>\n";
      return html;
    },
    createConentInBox3: function createConentInBox3(_ref3) {
      var _ref3$text = _ref3.text,
        text = _ref3$text === void 0 ? '北京航天宏图' : _ref3$text;
      return "<div class=\"pie3dBlackPanel  pie3dBlackPanel-highlight\">\n" + "        <div class=\"pie3dBlackPanel-text\">" + text + "</div>\n" + "    </div>";
    },
    createConentInBox4: function createConentInBox4(_ref4) {
      var _ref4$text = _ref4.text,
        text = _ref4$text === void 0 ? '北京航天宏图' : _ref4$text;
      return "<div class=\"pie3dBlueGradientPnl\">\n" + text + "    </div>";
    },
    createConentInBox5: function createConentInBox5(_ref5) {
      var _ref5$url = _ref5.url,
        url = _ref5$url === void 0 ? '' : _ref5$url,
        _ref5$text = _ref5.text,
        text = _ref5$text === void 0 ? '' : _ref5$text,
        _ref5$textColor = _ref5.textColor,
        textColor = _ref5$textColor === void 0 ? 'black' : _ref5$textColor;
      // const image=
      // return " <img src=" + image + " \"width: 20px;height: 43px\">"
      return "<div style='text-align: center'> <img src=\"".concat(url, "\" ><span style=\"color: ").concat(textColor, ";\">").concat(text, "</span></div>");
    },
    createConentInBox6: function createConentInBox6(_ref6) {
      var _ref6$text = _ref6.text,
        text = _ref6$text === void 0 ? '高新技术开发' : _ref6$text;
      return "<div class=\"pie3d-spot\">\n" + "        <div  class=\"pie3d-spot-board\">\n" + "        <h5 'margin-top: 9%'>" + text + "</h5>\n" + "        </div>\n" + "        <div class=\"pie3d-spot-line\"></div>\n" + "      </div>";
    },
    // createConentInBox7({
    //   // url = './images/symbol2.png'
    //   url = ''
    // }) {
    //   return "<div 'text-align: center'> <img src=" + url + " \"width: 35px;height: 40px\">图标</div>"
    // },
    // createConentInBox8({
    //   // url = "./image/tf.gif"
    //   url = ''
    // }) {
    //   return "<div 'text-align: center'> <img src=" + url + " \"width: 35px;height: 40px\"><span \"color: red;\"/span>台风</div>"
    // },
    createConentInBox7: function createConentInBox7(_ref7) {
      var _ref7$url = _ref7.url,
        url = _ref7$url === void 0 ? '' : _ref7$url;
      return "<div class=\"pie3d-camera\"><div class=\"pie3d-camera-content\">\n                                   <img class=\"pie3d-camera-img\" src=".concat(url, ">\n                               </div>\" \n                            <div class=\"pie3d-camera-line\"></div>\n                               <div class=\"pie3d-camera-point\"></div></div>");
    },
    createConentInBox8: function createConentInBox8(_ref8) {
      var _ref8$text = _ref8.text,
        text = _ref8$text === void 0 ? "我是竖立的文本" : _ref8$text,
        _ref8$color = _ref8.color,
        color = _ref8$color === void 0 ? "#0000ff" : _ref8$color,
        _ref8$fontSize = _ref8.fontSize,
        fontSize = _ref8$fontSize === void 0 ? 8 : _ref8$fontSize,
        _ref8$fontFamily = _ref8.fontFamily,
        fontFamily = _ref8$fontFamily === void 0 ? "微软雅黑" : _ref8$fontFamily,
        _ref8$lineHeight = _ref8.lineHeight,
        lineHeight = _ref8$lineHeight === void 0 ? 20 : _ref8$lineHeight,
        _ref8$circleSize = _ref8.circleSize,
        circleSize = _ref8$circleSize === void 0 ? 10 : _ref8$circleSize;
      return "<div class=\"pie3d-divUpLabel\" \"color: " + color + ";\">\n" + "      <div class=\"pie3d-divUpLabel-text\" \"font-family:" + fontFamily + ";font-size: " + fontSize + "px;\">" + text + "</div>\n" + "      <div class=\"pie3d-divUpLabel-line\" \"\n" + "          height: " + lineHeight + "px;\n" + "          background-color: " + color + ";\"></div>\n" + "      <div \"border-radius: 50%;\n" + "          width: " + circleSize + "px;\n" + "          height: " + circleSize + "px;\n" + "          background-color: " + color + ";\"></div>\n" + "    </div>";
    },
    createConentInBox10: function createConentInBox10(_ref9) {
      var _ref9$html = _ref9.html,
        html = _ref9$html === void 0 ? "\u8FD9\u91CC\u53EF\u4EE5\u653E\u5165\u4EFB\u610F\u6587\u5B57<br /> \u6C14\u6CE1\u6837\u5F0F" : _ref9$html,
        _ref9$color = _ref9.color,
        color = _ref9$color === void 0 ? 'white' : _ref9$color,
        _ref9$backgroundColor = _ref9.backgroundColor,
        backgroundColor = _ref9$backgroundColor === void 0 ? 'rgba(63, 72, 84, 0.9)' : _ref9$backgroundColor;
      return "<div class=\"pie3d-popup\" >\n              <div class=\"pie3d-popup-content-wrapper\" style=\"background-color:".concat(backgroundColor, ";color:").concat(color, "\">\n                <div class=\"pie3d-popup-content\" >").concat(html, "</div>\n              </div>\n              <div class=\"pie3d-popup-tip-container\" >\n                <div class=\"pie3d-popup-tip\" style=\"background-color:").concat(backgroundColor, ";color:").concat(color, "\"></div>\n              </div>\n            </div>");
    },
    createConentInBox0: function createConentInBox0(_ref10) {
      var _ref10$html = _ref10.html,
        html = _ref10$html === void 0 ? "<div style='background-color:blue;color:white'>\u5B8C\u5168\u81EA\u5B9A\u4E49\u6837\u5F0F</div>" : _ref10$html;
      return html;
    },
    /**
    * 求文字的长度及宽度
    * @param fontSize
    * @param fontFamily
    * @param text
    */
    textSize: function textSize(fontSize, fontFamily, text) {
      var span = document.createElement("span");
      var result = {
        width: span.offsetWidth,
        height: span.offsetHeight
      };
      span.style.visibility = "hidden";
      span.style.fontSize = fontSize + "px";
      span.style.position = 'absolute';
      document.body.appendChild(span);
      if (typeof span.textContent != "undefined") {
        span.textContent = text;
      } else {
        span.innerText = text;
      }
      result.width = span.offsetWidth - result.width;
      result.height = span.offsetHeight - result.height;
      if (span.parentNode) {
        span.parentNode.removeChild(span);
      }
      return result;
    },
    /**
    * 颜色转换
    * @param color
    */
    fromHex: function fromHex(color) {
      var t = {},
        bits = color.length == 4 ? 4 : 8,
        //假设是shorthand。 #fff, 那么bits为4位, 每一位代表的个属性, 其他的为8位 每两位代表一个属性 #ffffff00
        mask = (1 << bits) - 1; //表示字节占位符。 向左移4位或8位，var a = (1 << 4 ) - 1 -> 10000 - 1,  a.toString(2); // 1111。或者 8位的 1111 1111
      color = "0x" + color.substr(1); //#ff0000 转变为16进制0xff0000;
      if (isNaN(color)) {
        return null; // Color
      }

      ["b", "g", "r"].forEach(function (x) {
        var c = color & mask;
        color >>= bits;
        t[x] = bits == 4 ? 17 * c : c; // 0xfff ， 一个f应该代表 255, 应该当[0-255]，按15等份划分，每一等份间隔 17。
        //所以获得的值须要乘以17, 才干表示rgb中255的值
      });

      return t; // Color
    }
  };

  var _LabelBoxType;
  var LabelBoxType = (_LabelBoxType = {
    box0: 0,
    box2: 1
  }, _defineProperty(_LabelBoxType, "box2", 2), _defineProperty(_LabelBoxType, "box3", 3), _defineProperty(_LabelBoxType, "box4", 4), _defineProperty(_LabelBoxType, "box5", 5), _defineProperty(_LabelBoxType, "box6", 6), _defineProperty(_LabelBoxType, "box7", 7), _defineProperty(_LabelBoxType, "box8", 8), _defineProperty(_LabelBoxType, "box9", 9), _defineProperty(_LabelBoxType, "box10", 10), _LabelBoxType);
  //生成唯一id
  function guid() {
    return 'x4xxxyxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }
  var LabelBox = /*#__PURE__*/function () {
    function LabelBox(_ref) {
      var _ref$lon = _ref.lon,
        lon = _ref$lon === void 0 ? 0 : _ref$lon,
        _ref$lat = _ref.lat,
        lat = _ref$lat === void 0 ? 0 : _ref$lat,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? 0 : _ref$height,
        _ref$maxHeight = _ref.maxHeight,
        maxHeight = _ref$maxHeight === void 0 ? 10000000 : _ref$maxHeight,
        _ref$scale = _ref.scale,
        scale = _ref$scale === void 0 ? 0.8 : _ref$scale;
      _classCallCheck(this, LabelBox);
      // this._globe = globe
      // this._canvas = canvas
      this._lon = lon;
      this._lat = lat;
      this._height = height;
      this._maxHeight = maxHeight;
      this._scale = scale;
      this._definitionChanged = new Event();
      this._show = true;
    }
    _createClass(LabelBox, [{
      key: "id",
      get: function get() {
        return this._id;
      }
    }, {
      key: "init",
      value: function init(globe, canvas) {
        this._id = "labelBox" + guid();
        this._container = document.createElement("div");
        this._container.style.setProperty('position', 'absolute');
        this._container.style.setProperty('min-width', '10px');
        this._globe = globe;
        this._canvas = canvas;

        //转屏幕坐标
        var _this$toScreen = this.toScreen(this._lon, this._lat, this._height),
          x = _this$toScreen.x,
          y = _this$toScreen.y;
        this._container.style.setProperty('left', x + 'px');
        this._container.style.setProperty('top', y + 'px');
        this._screenX = x;
        this._screenY = y;
        this._canvas.parentNode.appendChild(this._container);
      }
    }, {
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }

      /**
       * @param {number} value
       */
    }, {
      key: "scale",
      set: function set(value) {
        this._scale = value;
      }
    }, {
      key: "setContent",
      value: function setContent(content) {
        this.innerHTML = undefined;
        if (content instanceof HTMLElement) {
          this._container.appendChild(content);
        } else {
          this._container.innerHTML = content;
        }

        // this._container.appendChild(content)
        // console.log(this._container.getBoundingClientRect())
      }
    }, {
      key: "setPosition",
      value: function setPosition(lon, lat, height) {
        this._lon = lon;
        this._lat = lat;
        this._height = height;
      }
    }, {
      key: "setBoxType",
      value: function setBoxType(type, option, offset) {
        this._offsetWidth = (offset === null || offset === void 0 ? void 0 : offset.x) || 0;
        this._offsetHeight = (offset === null || offset === void 0 ? void 0 : offset.y) || 0;
        var content = '';
        switch (type) {
          case LabelBoxType.box0:
            content = LabelBoxTool.createConentInBox0(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box1:
            content = LabelBoxTool.createConentInBox1(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box2:
            content = LabelBoxTool.createConentInBox2(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box3:
            content = LabelBoxTool.createConentInBox3(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box4:
            content = LabelBoxTool.createConentInBox4(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box5:
            content = LabelBoxTool.createConentInBox5(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box6:
            content = LabelBoxTool.createConentInBox6(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box7:
            content = LabelBoxTool.createConentInBox7(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box8:
            content = LabelBoxTool.createConentInBox8(option);
            content = this.addToBox(content);
            break;
          case LabelBoxType.box9:
            content = this.addToLightBox(option.color);
            break;
          case LabelBoxType.box10:
            content = LabelBoxTool.createConentInBox10(option);
            content = this.addToBox(content);
            break;
          default:
            {
              console.warn('不支持的类型！');
            }
        }
        this.setContent(content);
      }
    }, {
      key: "addToBox",
      value: function addToBox(content) {
        var transFormOrigin = [-0.5, -0.5];
        var divGraphic = document.createElement('div');
        divGraphic.className = 'pie3d-divGraphic';
        divGraphic.style.setProperty('pointer-events', 'none');
        divGraphic.style.setProperty('display', 'block');
        divGraphic.style.setProperty('transform', "scale(".concat(this._scale, ")"));
        // divGraphic.style.setProperty('transform-origin', transFormOrigin[0] * this._scale * 100 + "% " + transFormOrigin[1] * this._scale * 100 + "% 0px;")
        divGraphic.style.setProperty('transform-origin', "".concat(transFormOrigin[0] * 100 * this._scale, "% ").concat(transFormOrigin[1] * 100 * this._scale, "% 0"));
        divGraphic.style.setProperty('z-index', 'auto');
        divGraphic.innerHTML = content;
        return divGraphic;
      }
    }, {
      key: "addToLightBox",
      value: function addToLightBox(color) {
        var size = '20px';
        var divGraphic = " <span class=\"pie3d-animation-point\" style=\"color:" + color + ";width: " + size + ";height: " + size + "\">\n" + "        <p></p>\n" + "    </div>";
        return divGraphic;
      }

      /**
       * @param {any} value
       */
    }, {
      key: "show",
      get: function get() {
        return this._show;
      },
      set: function set(value) {
        if (this._container) {
          this._show = value;
          if (value) {
            this._container.style.setProperty('display', 'block');
          } else {
            this._container.style.setProperty('display', 'none');
          }
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this._canvas.parentNode.removeChild(this._container);
      }
    }, {
      key: "update",
      value: function update() {
        if (this._show) {
          var _this$toScreen2 = this.toScreen(this._lon, this._lat, this._height),
            x = _this$toScreen2.x,
            y = _this$toScreen2.y;
          this._container.style.setProperty('left', x + this._offsetWidth + 'px');
          this._container.style.setProperty('top', y + this._offsetHeight + 'px');
          var worldPoint = this._globe.geoToWorld([this._lon, this._lat], this._height); // 设置面板的地理位置
          var cameraPosition = this._globe.getWorldCamera().getCameraPosition(); // 获取相机位置

          //到背面去即隐藏
          if (worldPoint.dot(cameraPosition.sub(worldPoint)) <= 0.0 && this._globe.getSceneMode() == 1) {
            this._container.style.display = 'none';
          } else {
            //超出边界隐藏
            if (x + 300 * this._scale >= this._canvas.cilentWidth || y + 10 * this._scale >= this._canvas.cilentHeight || x <= 10 * this._scale || y <= 10 * this._scale) {
              this._container.style.display = 'none';
            } else {
              //获取相机高度
              var height = this._globe.getWorldCamera().getDistance();
              if (height > this._maxHeight) {
                this._container.style.display = 'none';
              } else {
                this._container.style.display = 'block';
              }
            }
          }
        }
      }
    }, {
      key: "toScreen",
      value: function toScreen(x, y, z) {
        var globe = this._globe;
        var worldPoint = globe.geoToWorld([x, y], z);
        return globe.worldToDevice(worldPoint);
      }
    }]);
    return LabelBox;
  }();
  var addLabelBox = function addLabelBox(globe, layer, entity, earthCamera) {
    var canvas = earthCamera.globeControl.getCanvas();
    // console.log()
    var params = entity.getParamsByName('labelBox');
    var _entity$getLonLatPosi = entity.getLonLatPosition(),
      lon = _entity$getLonLatPosi.lon,
      lat = _entity$getLonLatPosi.lat,
      positionHeight = _entity$getLonLatPosi.positionHeight;
    var type = params.type;
    var scale = params.scale;
    var offset = params.offset;
    var style = params.style;
    var box = entity.labelBox;
    box.init(globe, canvas);
    box.setPosition(lon, lat, positionHeight);
    box.scale = scale;
    box.setBoxType(type, style, offset);
    layer.push(box);
    // entity.id = box.id
  };

  var Circle = /*#__PURE__*/function (_BaseGraphic) {
    _inherits(Circle, _BaseGraphic);
    var _super = _createSuper(Circle);
    function Circle(options) {
      _classCallCheck(this, Circle);
      return _super.call(this, options, Circle.propertyList);
    }
    return _createClass(Circle);
  }(BaseGraphic);
  _defineProperty(Circle, "propertyList", ["radius"]);
  Object.defineProperties(Circle.prototype, {
    radius: createPropertyDescriptor('radius')
  });
  var addCircle = function addCircle(globe, layer, entity, threeEarth) {
    // const primitiveInstance = entity.primitiveInstance
    // const circle = entity.circle
    // const circlePrimitive = new CirclePrimitive({
    //   image: circle.image?._value,//纹理图片
    //   radius: entity.circle.radius?._value,
    //   material: circle.material,
    //   color: entity.circle.color?._value,
    //   opacity: entity.circle.opacity?._value,
    //   transparent: entity.circle.transparent?._value,
    //   heightReference: entity.circle.heightReference?._value,
    //   animate: entity.circle.animate?._value,
    //   amplitude: entity.circle.amplitude?._value,
    // })
    // //设置相机
    // primitiveInstance.circlePrimitive = circlePrimitive
    // entity.circle._id = circlePrimitive.id;
    addGraphic(entity, 'circle', CirclePrimitive, 'circlePrimitive');
  };
  //更新圆
  var updateCircle = function updateCircle(globe, layer, _ref) {
    var scope = _ref.scope,
      name = _ref.name,
      value = _ref.value;
      _ref.oldValue;
    layer.children.forEach(function (item) {
      var circlePrimitive = item.circlePrimitive;
      if (circlePrimitive.id === scope.id) {
        var result = value._value;
        switch (name) {
          case 'radius':
            circlePrimitive.scale.set(result, result, result);
            break;
          default:
            updateGraphic(name, result, circlePrimitive);
            break;
        }
      }
    });
  };

  var Cone = /*#__PURE__*/function (_BaseGraphic) {
    _inherits(Cone, _BaseGraphic);
    var _super = _createSuper(Cone);
    function Cone(options) {
      _classCallCheck(this, Cone);
      return _super.call(this, options, Cone.propertyList);
    }
    return _createClass(Cone);
  }(BaseGraphic);
  _defineProperty(Cone, "propertyList", ['width', 'rotation', "height", "radialSegments", "radius", "outline", "outlineColor", "outlineWidth"]);
  Object.defineProperties(Cone.prototype, {
    width: createPropertyDescriptor('width'),
    rotation: createPropertyDescriptor('rotation'),
    height: createPropertyDescriptor('height'),
    radialSegments: createPropertyDescriptor('radialSegments'),
    radius: createPropertyDescriptor('radius'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outline: createPropertyDescriptor('outline'),
    outlineWidth: createPropertyDescriptor('outlineWidth')
    // material: createPropertyDescriptor('material'),
  });

  var addCone = function addCone(globe, layer, entity, threeEarth) {
    var primitiveInstance = entity.primitiveInstance;
    // const conePrimitive = new ConePrimitive({
    //   image: entity.cone.image._value,//纹理图片
    //   opacity: entity.cone.opacity ? entity.cone.opacity._value : 1,
    //   radialSegments: entity.cone.radialSegments ? entity.cone.radialSegments._value : 4,//棱的个数
    //   animate: entity.cone.animate ? entity.cone.animate._value : false,//是否有弹跳动画
    //   amplitude: entity.cone.amplitude ? entity.cone.amplitude._value : 0.2,//弹跳幅度
    //   color: entity.cone.color ? entity.cone.color._value : null,//颜色会与纹理融合
    //   transparent: entity.cone.transparent ? entity.cone.transparent._value : true,//是否透明
    //   height: entity.cone.height ? entity.cone.height._value : 2000,
    //   rotation: entity.cone.rotation ? entity.cone.rotation._value : null,
    //   radius: entity.cone.radius ? entity.cone.radius : 1000,
    //   heightReference: entity.cone.heightReference?.value,
    //   material: entity.cone.material,
    // })
    // primitiveInstance.conePrimitive = conePrimitive
    // entity.cone._id = conePrimitive.id;
    var conePrimitive = addGraphic(entity, 'cone', ConePrimitive, 'conePrimitive');
    var outlineWidth = defaultValue$1(entity.cone.outlineWidth ? entity.cone.outlineWidth._value : 1);
    var outlineColor, outlineOpacity;
    if (!defined$1(entity.cone.outlineColor)) {
      outlineOpacity = 1;
      outlineColor = new Color$2('rgb(0,0,0)');
    } else {
      outlineOpacity = defaultValue$1(entity.cone.outlineColor._value.alpha, 1);
      outlineColor = transformCesiumColorToArray$1(entity.cone.outlineColor);
      outlineColor = new Color$2("rgb(".concat(outlineColor[0], ", ").concat(outlineColor[1], ", ").concat(outlineColor[2], ")"));
    }
    if (defined$1(entity.cone.outline) && entity.cone.outline._value == true) {
      primitiveInstance.addBorder(conePrimitive, outlineColor, outlineOpacity, outlineWidth);
    }
  };
  //更新面
  var updateCone = function updateCone(globe, layer, _ref) {
    var scope = _ref.scope,
      name = _ref.name,
      value = _ref.value;
      _ref.oldValue;
    layer.children.forEach(function (item) {
      var conePrimitive = item.conePrimitive;
      if (conePrimitive.id === scope.id) {
        var result = value._value;
        switch (name) {
          case 'width':
          case 'height':
            conePrimitive.scale.set(scope.width._value, scope.height._value, 1);
            break;
          case 'radius':
            conePrimitive._radius._value = scope.radius._value;
            break;
          case 'rotation':
            conePrimitive._rotation = scope.rotation._value;
            break;
          default:
            updateGraphic(name, result, conePrimitive);
            break;
        }
      }
    });
  };
  var transformCesiumColorToArray$1 = function transformCesiumColorToArray(color) {
    if (!defined$1(color)) return color;
    var new_color = new Color$1(color._value.red, color._value.green, color._value.blue, color._value.alpha);
    var value = new_color.toBytes();
    return value;
  };

  var propertyNames = ['show', 'data', 'foreColor', 'backColor', 'foreLineWidth', 'backLineWidth'];
  var FlyLine = /*#__PURE__*/function () {
    function FlyLine(options) {
      var _this = this;
      _classCallCheck(this, FlyLine);
      _defineProperty(this, "_id", void 0);
      this._definitionChanged = new Event();
      this._propertyNames = propertyNames;
      this._propertyNames.forEach(function (name) {
        _this['_' + name] = undefined;
      });
      this.merge(defaultValue$1(options, defaultValue$1.EMPTY_OBJECT));
    }
    _createClass(FlyLine, [{
      key: "clone",
      value: function clone(result) {
        var _this2 = this;
        if (!defined$1(result)) {
          return new FlyLine(this);
        }
        this._propertyNames.forEach(function (name) {
          result[name] = _this2[name];
        });
        return result;
      }
    }, {
      key: "merge",
      value: function merge(source) {
        var _this3 = this;
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }
        this._propertyNames.forEach(function (name) {
          _this3[name] = defaultValue$1(_this3[name], source[name]);
        });
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }
    }]);
    return FlyLine;
  }();
  Object.defineProperties(FlyLine.prototype, {
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     * @memberof Point.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    id: {
      get: function get() {
        return this._id;
      }
    },
    show: createPropertyDescriptor('show'),
    data: createPropertyDescriptor('data'),
    foreColor: createPropertyDescriptor('foreColor'),
    backColor: createPropertyDescriptor('backColor'),
    foreLineWidth: createPropertyDescriptor('foreLineWidth'),
    backLineWidth: createPropertyDescriptor('backLineWidth')
  });
  var addFlyLine = function addFlyLine(globe, layer, options) {
    // const instance = new PrimitiveInstance({
    //   show: options.flyLine.show._value,
    // })
    var show = options.show && options.flyLine.show._value;
    var renderableLayer = layer;
    var geoLineJSON = options.flyLine.data._value;
    var foreLineWidth = options.flyLine.foreLineWidth ? options.flyLine.foreLineWidth._value : 2;
    var backLineWidth = options.flyLine.backLineWidth ? options.flyLine.backLineWidth._value : 4;
    var foreColor = options.flyLine.foreColor ? options.flyLine.foreColor._value : [233, 255, 255, 255];
    var backColor = options.flyLine.backColor ? options.flyLine.backColor._value : [106, 141, 255, 32];

    // let urls = ["data/BigData/foretrace.png", "data/BigData/flights.json"]
    var renderSysLine = new PIERenderSysLineCycleSet();
    renderSysLine.setSpatialRefType(0);
    renderSysLine.setEnableDepthTest(true);
    renderSysLine.setLineSmooth(false); // 设置光滑线
    renderSysLine.setEnableBackTraceTime(true); // 设置跟踪启用时间
    renderSysLine.setEnableBackLine(false); // 设置循环返回启用线
    renderSysLine.setForeLineWidth(foreLineWidth); // 设置循环前进线宽度
    renderSysLine.setBackLineWidth(backLineWidth); // 设置循环返回线宽度
    renderSysLine.setPosition([0, 0, 0]);
    renderSysLine.setForeColor(foreColor); // 设置循环颜色
    renderSysLine.setBackColor(backColor); // 设置循环返回颜色
    // renderSysLine.setBackPath(urls[0]); // 设置循环返回路径
    // renderSysLine.setForePath(urls[0]); // 设置循环前进路径
    renderSysLine.setStartTime(0);
    renderSysLine.setBackTraceTime(10000);
    renderSysLine.setEndTime(100 * 200);
    renderSysLine.setTraceTime(500);
    renderSysLine.setSpeedPerFrame(20);
    renderSysLine.setVisible(show);
    renderableLayer.add(renderSysLine);
    var From = new PIEVector2(0, 0);
    var To = new PIEVector2(116.41667, 39.91667);
    var Airports = [];
    var AirRoutes = [];
    var airports = geoLineJSON.airports;
    airports.map(function (v, i) {
      var airport = {
        Name: "",
        Country: "",
        City: "",
        Position: [v[3], v[4]]
      };
      Airports.push(airport);
    });
    var airRoutes = geoLineJSON.routes;
    airRoutes.map(function (r, i) {
      var airRoute = {
        Airline: r[0],
        From: r[1],
        To: r[2]
      };
      AirRoutes.push(airRoute);
    });
    var dtor = CesiumMath.DTOR;
    for (var i = 0; i < AirRoutes.length; i++) {
      var positionForm = Airports[AirRoutes[i].From].Position;
      var From = new PIEVector2(positionForm[0], positionForm[1]);
      var positionTo = Airports[AirRoutes[i].To].Position;
      var To = new PIEVector2(positionTo[0], positionTo[1]);
      var dDistance = CesiumMath.sphereDistance([From.x, From.y], [To.x, To.y]);
      var nCount = Math.floor(dDistance / 100000) + 1;
      if (nCount < 2) {
        continue;
      }
      if (nCount % 2 != 0) {
        nCount++;
      }
      var traceList = new PIETraceList();
      traceList.setSpatialRefType(0);
      var dRatioX = (To.x - From.x) / (nCount - 1);
      var dRatioY = (To.y - From.y) / (nCount - 1);
      var positionsArray = [];
      for (var j = 0; j < nCount; j++) {
        var dHeight = 0;
        if (j < nCount / 2) {
          var dValue = CesiumMath.smoothstep(0, 1.0, 1.0 * j / (nCount / 2 - 1));
          dHeight = nCount * 30000.0 * dValue;
        } else {
          var dValue = CesiumMath.smoothstep(0, 1.0, 1.0 * (j - nCount / 2) / (nCount / 2 - 1));
          dHeight = nCount * 30000.0 * (1.0 - dValue);
        }
        var Point = new PIEVector2(From.x + dRatioX * j, From.y + dRatioY * j);
        var Cartesian = new PIEVector3.sphericalToCartesian(Point.x * dtor, Point.y * dtor, 6378137 + dHeight);
        positionsArray.push(Cartesian.x);
        positionsArray.push(Cartesian.y);
        positionsArray.push(Cartesian.z);
        positionsArray.push(j * 200);
        //traceList.addPositions([Cartesian.x, Cartesian.y, Cartesian.z, j * 200]);
      }

      traceList.addPositions(positionsArray);
      renderSysLine.addTraceList(traceList);
    }
    options.flyLine._id = renderSysLine.getID();
    options.flyLine.renderSysLine = renderSysLine;
  };
  var updateFlyLine = function updateFlyLine(globe, layer, _ref) {
    var scope = _ref.scope,
      name = _ref.name,
      value = _ref.value;
      _ref.oldValue;
    var renderObj = layer.get(scope.id);
    switch (name) {
      case 'show':
        renderObj.setVisible(value._value);
        break;
      case 'foreColor':
        scope.renderSysLine.setForeColor(value._value);
        break;
      case 'backColor':
        scope.renderSysLine.setBackColor(value._value);
        break;
      case 'foreLineWidth':
        scope.renderSysLine.setForeLineWidth(value._value);
        break;
      case 'backLineWidth':
        scope.renderSysLine.setBackLineWidth(value._value);
        break;
    }
  };

  // http://mrl.nyu.edu/~perlin/noise/

  var _p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
  for (var i = 0; i < 256; i++) {
    _p[256 + i] = _p[i];
  }
  function fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }
  function lerp(t, a, b) {
    return a + t * (b - a);
  }
  function grad(hash, x, y, z) {
    var h = hash & 15;
    var u = h < 8 ? x : y,
      v = h < 4 ? y : h == 12 || h == 14 ? x : z;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
  }
  var ImprovedNoise = /*#__PURE__*/function () {
    function ImprovedNoise() {
      _classCallCheck(this, ImprovedNoise);
    }
    _createClass(ImprovedNoise, [{
      key: "noise",
      value: function noise(x, y, z) {
        var floorX = Math.floor(x),
          floorY = Math.floor(y),
          floorZ = Math.floor(z);
        var X = floorX & 255,
          Y = floorY & 255,
          Z = floorZ & 255;
        x -= floorX;
        y -= floorY;
        z -= floorZ;
        var xMinus1 = x - 1,
          yMinus1 = y - 1,
          zMinus1 = z - 1;
        var u = fade(x),
          v = fade(y),
          w = fade(z);
        var A = _p[X] + Y,
          AA = _p[A] + Z,
          AB = _p[A + 1] + Z,
          B = _p[X + 1] + Y,
          BA = _p[B] + Z,
          BB = _p[B + 1] + Z;
        return lerp(w, lerp(v, lerp(u, grad(_p[AA], x, y, z), grad(_p[BA], xMinus1, y, z)), lerp(u, grad(_p[AB], x, yMinus1, z), grad(_p[BB], xMinus1, yMinus1, z))), lerp(v, lerp(u, grad(_p[AA + 1], x, y, zMinus1), grad(_p[BA + 1], xMinus1, y, zMinus1)), lerp(u, grad(_p[AB + 1], x, yMinus1, zMinus1), grad(_p[BB + 1], xMinus1, yMinus1, zMinus1))));
      }
    }]);
    return ImprovedNoise;
  }();

  var VolumeCloudMaterial = /*#__PURE__*/function (_RawShaderMaterial) {
    _inherits(VolumeCloudMaterial, _RawShaderMaterial);
    var _super = _createSuper(VolumeCloudMaterial);
    function VolumeCloudMaterial(_ref) {
      var _this;
      var _ref$color = _ref.color,
        color = _ref$color === void 0 ? new Color$2(0xffffff) : _ref$color,
        _ref$opacity = _ref.opacity,
        opacity = _ref$opacity === void 0 ? 0.6 : _ref$opacity;
      _classCallCheck(this, VolumeCloudMaterial);
      _this = _super.call(this);
      var texture = _this.createData();
      _this.vertexShader = /* glsl */"\n\t\t\t\t\tin vec3 position;\n\n\t\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\t\t\t\t\tuniform vec3 cameraPos;\n\n\t\t\t\t\tout vec3 vOrigin;\n\t\t\t\t\tout vec3 vDirection;\n\n\t\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t\t\tvOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;\n\t\t\t\t\t\tvDirection = position - vOrigin;\n\n\t\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t\t\t}\n\t\t\t\t";
      _this.fragmentShader = /* glsl */"\n\t\t\t\t\tprecision highp float;\n\t\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\t\t\tin vec3 vOrigin;\n\t\t\t\t\tin vec3 vDirection;\n\n\t\t\t\t\tout vec4 color;\n\n\t\t\t\t\tuniform vec3 base;\n\t\t\t\t\tuniform sampler3D map;\n\n\t\t\t\t\tuniform float threshold;\n\t\t\t\t\tuniform float range;\n\t\t\t\t\tuniform float opacity;\n\t\t\t\t\tuniform float steps;\n\t\t\t\t\tuniform float frame;\n\n\t\t\t\t\tuint wang_hash(uint seed)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tseed = (seed ^ 61u) ^ (seed >> 16u);\n\t\t\t\t\t\t\tseed *= 9u;\n\t\t\t\t\t\t\tseed = seed ^ (seed >> 4u);\n\t\t\t\t\t\t\tseed *= 0x27d4eb2du;\n\t\t\t\t\t\t\tseed = seed ^ (seed >> 15u);\n\t\t\t\t\t\t\treturn seed;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat randomFloat(inout uint seed)\n\t\t\t\t\t{\n\t\t\t\t\t\t\treturn float(wang_hash(seed)) / 4294967296.;\n\t\t\t\t\t}\n\n\t\t\t\t\tvec2 hitBox( vec3 orig, vec3 dir ) {\n\t\t\t\t\t\tconst vec3 box_min = vec3( - 0.5 );\n\t\t\t\t\t\tconst vec3 box_max = vec3( 0.5 );\n\t\t\t\t\t\tvec3 inv_dir = 1.0 / dir;\n\t\t\t\t\t\tvec3 tmin_tmp = ( box_min - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmax_tmp = ( box_max - orig ) * inv_dir;\n\t\t\t\t\t\tvec3 tmin = min( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tvec3 tmax = max( tmin_tmp, tmax_tmp );\n\t\t\t\t\t\tfloat t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\t\t\t\t\t\tfloat t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\t\t\t\t\t\treturn vec2( t0, t1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat sample1( vec3 p ) {\n\t\t\t\t\t\treturn texture( map, p ).r;\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat shading( vec3 coord ) {\n\t\t\t\t\t\tfloat step = 0.01;\n\t\t\t\t\t\treturn sample1( coord + vec3( - step ) ) - sample1( coord + vec3( step ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tvoid main(){\n\t\t\t\t\t\tvec3 rayDir = normalize( vDirection );\n\t\t\t\t\t\tvec2 bounds = hitBox( vOrigin, rayDir );\n\n\t\t\t\t\t\tif ( bounds.x > bounds.y ) discard;\n\n\t\t\t\t\t\tbounds.x = max( bounds.x, 0.0 );\n\n\t\t\t\t\t\tvec3 p = vOrigin + bounds.x * rayDir;\n\t\t\t\t\t\tvec3 inc = 1.0 / abs( rayDir );\n\t\t\t\t\t\tfloat delta = min( inc.x, min( inc.y, inc.z ) );\n\t\t\t\t\t\tdelta /= steps;\n\n\t\t\t\t\t\t// Jitter\n\n\t\t\t\t\t\t// Nice little seed from\n\t\t\t\t\t\t// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n\t\t\t\t\t\tuint seed = uint( gl_FragCoord.x ) * uint( 1973 ) + uint( gl_FragCoord.y ) * uint( 9277 ) + uint( frame ) * uint( 26699 );\n\t\t\t\t\t\tvec3 size = vec3( textureSize( map, 0 ) );\n\t\t\t\t\t\tfloat randNum = randomFloat( seed ) * 2.0 - 1.0;\n\t\t\t\t\t\tp += rayDir * randNum * ( 1.0 / size );\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tvec4 ac = vec4( base, 0.0 );\n\n\t\t\t\t\t\tfor ( float t = bounds.x; t < bounds.y; t += delta ) {\n\n\t\t\t\t\t\t\tfloat d = sample1( p + 0.5 );\n\n\t\t\t\t\t\t\td = smoothstep( threshold - range, threshold + range, d ) * opacity;\n\n\t\t\t\t\t\t\tfloat col = shading( p + 0.5 ) * 3.0 + ( ( p.x + p.y ) * 0.25 ) + 0.2;\n\n\t\t\t\t\t\t\tac.rgb += ( 1.0 - ac.a ) * d * col;\n\n\t\t\t\t\t\t\tac.a += ( 1.0 - ac.a ) * d;\n\n\t\t\t\t\t\t\tif ( ac.a >= 0.95 ) break;\n\n\t\t\t\t\t\t\tp += rayDir * delta;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolor = ac;\n\n\t\t\t\t\t\tif ( color.a == 0.0 ) discard;\n\n\t\t\t\t\t}\n\t\t\t\t";
      _this.glslVersion = GLSL3;
      _this.uniforms = {
        base: {
          value: color
        },
        map: {
          value: texture
        },
        cameraPos: {
          value: new Vector3()
        },
        threshold: {
          value: 0.25
        },
        opacity: {
          value: opacity
        },
        range: {
          value: 0.1
        },
        steps: {
          value: 100
        },
        frame: {
          value: 0
        }
      };
      _this.side = BackSide;
      _this.transparent = true;
      return _this;
    }
    _createClass(VolumeCloudMaterial, [{
      key: "createData",
      value: function createData() {
        var size = 128;
        var data = new Uint8Array(size * size * size);
        var i = 0;
        var scale = 0.05;
        var perlin = new ImprovedNoise();
        var vector = new Vector3();
        for (var z = 0; z < size; z++) {
          for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
              var d = 1.0 - vector.set(x, y, z).subScalar(size / 2).divideScalar(size).length();
              data[i] = (128 + 128 * perlin.noise(x * scale / 1.5, y * scale, z * scale / 1.5)) * d * d;
              i++;
            }
          }
        }
        var texture = new DataTexture3D(data, size, size, size);
        texture.format = RedFormat;
        texture.minFilter = LinearFilter;
        texture.magFilter = LinearFilter;
        texture.unpackAlignment = 1;
        return texture;
      }
    }]);
    return VolumeCloudMaterial;
  }(RawShaderMaterial);

  var VolumeCloud = /*#__PURE__*/function (_Mesh) {
    _inherits(VolumeCloud, _Mesh);
    var _super = _createSuper(VolumeCloud);
    function VolumeCloud(_ref) {
      var _this;
      var _ref$width = _ref.width,
        width = _ref$width === void 0 ? 1000 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? 1000 : _ref$height,
        _ref$depth = _ref.depth,
        depth = _ref$depth === void 0 ? 300 : _ref$depth,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? Color$1.WHITE.withAlpha(0.05) : _ref$color;
      _classCallCheck(this, VolumeCloud);
      _this = _super.call(this);
      _this.material = new VolumeCloudMaterial({
        color: new Color$2(color.red, color.green, color.blue),
        opacity: color.alpha
      });
      _this.geometry = new BoxGeometry(1, 1, 1);
      _this.scale.set(width, height, depth);
      _this._definitionChanged = new Event();
      return _this;
    }
    /**
     * 获取事件
     */
    _createClass(VolumeCloud, [{
      key: "definitionChanged",
      get: function get() {
        return this._definitionChanged;
      }
    }, {
      key: "width",
      set: function set(value) {
        this.scale.x = value;
      }
    }, {
      key: "height",
      set: function set(value) {
        this.scale.y = value;
      }
    }, {
      key: "depth",
      set: function set(value) {
        this.scale.z = value;
      }
    }, {
      key: "color",
      set: function set(value) {
        this.material.uniforms.base.value = new Color$2(value.red, value.blue, value.green);
        this.material.uniforms.opacity.value = value.alpha;
      }
    }, {
      key: "update",
      value: function update(frameState) {
        // material.uniforms.threshold.value = parameters.threshold;
        // material.uniforms.opacity.value = parameters.opacity;
        // material.uniforms.range.value = parameters.range;
        // material.uniforms.steps.value = parameters.steps;

        this.material.uniforms.cameraPos.value.copy(frameState.threeEarth.position);
        this.rotation.z = -performance.now() / 25000;
        this.material.uniforms.frame.value = frameState.frameNumber;
      }
    }]);
    return VolumeCloud;
  }(Mesh);
  function addVolumeCloud(globe, layer, entity, threeEarth) {
    var volumeCloud = entity.volumeCloud;
    entity.primitiveInstance.volumeCloud = volumeCloud;
    entity.volumeCloud._id = volumeCloud.id;
  }

  //更新面
  function updateVolumeCloud(globe, layer, _ref2) {
    _ref2.scope;
      _ref2.name;
      _ref2.value;
      _ref2.oldValue;
  } // layer.children.forEach(function (item) {

  function createPropertyTypeDescriptor(name, Type) {
    return createPropertyDescriptor(name, undefined, function (value) {
      if (value instanceof Type) {
        return value;
      }
      return new Type(value);
    });
  }
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class Entity
   * 实体实例将多种形式的可视化聚合成一个高级对象。它们可以手动创建并添加到 Viewer.entities 中，也可以由数据源（例如GeoJsonDataSource）生成。
   */
  var Entity = /*#__PURE__*/function () {
    /**
     * Entity类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.name 显示给用户的可读名称。
     * @param {Boolean} options.show 指是否显示实体及其子实体。
     */
    function Entity(options) {
      _classCallCheck(this, Entity);
      _defineProperty(this, "_locationPoint", void 0);
      _defineProperty(this, "_classCode", void 0);
      _defineProperty(this, "_relationTo", void 0);
      _defineProperty(this, "_options", void 0);
      options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
      this._options = options;
      var id = options.id;
      if (!defined$1(id)) {
        id = createGuid();
      }
      this._id = id;
      this._definitionChanged = new Event();
      this._name = options.name;
      this._show = defaultValue$1(options.show, true);
      this._propertyNames = ['billboard', 'box', 'rectangle', 'cylinder', 'ellipse',
      //
      'ellipsoid', 'label', 'orientation', 'path', 'plane', 'plot', 'point', 'polygon',
      //
      'polyline', 'polylineVolume', 'position', 'properties', 'wall', 'overlayImage', 'model', 'particleSystem', 'weatherSystem', 'cone', 'circle', 'plane', 'pixelLine', 'heatMap', 'densityMap', 'labelBox', 'flyLine', 'volumeCloud'];
      this._point = undefined;
      this._polyline = undefined;
      this._polygon = undefined;
      this._plot = undefined;
      this._box = undefined;
      this._ellipsoid = undefined;
      this._label = undefined;
      this._billboard = undefined;
      this._rectangle = undefined;
      this._label = undefined;
      this._billboard = undefined;
      this._overlaylmage = undefined;
      this._model = undefined;
      this._particleSystem = undefined;
      this._weatherSystem = undefined;
      this._cone = undefined;
      this._circle = undefined;
      this._plane = undefined;
      this._heatMap = undefined;
      this._densityMap = undefined;
      this._labelBox = undefined;
      this._flyLine = undefined;
      this._volumeCloud = undefined;
      /*
       * Gets or sets the entity collection that this entity belongs to.
       * @type {EntityCollection}
       */
      this.entityCollection = undefined;

      /*
       * 用来添加三维对象
       */
      this._primitiveInstance = new PrimitiveInstance(options.position);
      this.merge(options);
    }
    /** 
     * 设置三维场景
     * @param {PieGlobe} value
     */
    _createClass(Entity, [{
      key: "pieGlobe",
      set: function set(value) {
        this._pieGlobe = value;
      }
    }, {
      key: "value",
      get: function get() {
        return this;
      }

      /**
       * 获取图元实例
       * @returns {PrimitiveInstance}
       */
    }, {
      key: "primitiveInstance",
      get: function get() {
        return this._primitiveInstance;
      }
      /**
       * 将提供的源对象上与此对象相同属性的值分配给此对象上尚未分配的属性。
       * @param {Entity} source 要合并到该对象中的对象。
       */
    }, {
      key: "merge",
      value: function merge(source) {
        if (!defined$1(source)) {
          throw new DeveloperError$1('source is required.');
        }

        //Name, show, and availability are not Property objects and are currently handled differently.
        //source.show is intentionally ignored because this.show always has a value.
        this.name = defaultValue$1(this.name, source.name);
        this.availability = defaultValue$1(this.availability, source.availability);
        var propertyNames = this._propertyNames;
        var sourcePropertyNames = defined$1(source._propertyNames) ? source._propertyNames : Object.keys(source);
        var propertyNamesLength = sourcePropertyNames.length;
        for (var i = 0; i < propertyNamesLength; i++) {
          var name = sourcePropertyNames[i];
          //While source is required by the API to be an Entity, we internally call this method from the
          //constructor with an options object to configure initial custom properties.
          //So we need to ignore reserved-non-property.
          if (name === 'name' || name === 'availability') {
            continue;
          }
          var targetProperty = this[name];
          var sourceProperty = source[name];

          //Custom properties that are registered on the source entity must also
          //get registered on this entity.
          if (!defined$1(targetProperty) && propertyNames.indexOf(name) === -1) {
            this.addProperty(name);
          }
          if (defined$1(sourceProperty)) {
            if (defined$1(targetProperty)) {
              if (defined$1(targetProperty.merge)) {
                targetProperty.merge(sourceProperty);
              }
            } else if (defined$1(sourceProperty.merge) && defined$1(sourceProperty.clone)) {
              this[name] = sourceProperty.clone();
            } else {
              this[name] = sourceProperty;
            }
          }
        }
      }
      /**
       * 向此对象添加属性。
       * @param {String} propertyName 要添加的属性的名称。
       */
    }, {
      key: "addProperty",
      value: function addProperty(propertyName) {
        var propertyNames = this._propertyNames;

        //>>includeStart('debug', pragmas.debug);
        if (!defined$1(propertyName)) {
          throw new DeveloperError$1('propertyName is required.');
        }
        if (propertyNames.indexOf(propertyName) !== -1) {
          throw new DeveloperError$1("".concat(propertyName, " is already a registered property."));
        }
        if (propertyName in this) {
          throw new DeveloperError$1("".concat(propertyName, " is a reserved property name."));
        }
        //>>includeEnd('debug');

        propertyNames.push(propertyName);
        Object.defineProperty(this, propertyName, createRawPropertyDescriptor(propertyName, true));
      }
    }]);
    return Entity;
  }();
  Object.defineProperties(Entity.prototype, {
    /*
     * The availability, if any, associated with this object.
     * If availability is undefined, it is assumed that this object's
     * other properties will return valid data for any provided time.
     * If availability exists, the objects other properties will only
     * provide valid data if queried within the given interval.
     * @memberof Entity.prototype
     * @type {TimeIntervalCollection|undefined}
     */
    availability: createRawPropertyDescriptor('availability'),
    /**
     * 获取与该对象关联的唯一标识符。
     * @memberof Entity.prototype
     * @type {String}
     */
    id: {
      get: function get() {
        return this._id;
      },
      set: function set(value) {
        this._id = value;
      }
    },
    /**
     * 获取每当属性或子属性被更改或修改时触发的事件。
     * @memberof Entity.prototype
     *
     * @type {Event}
     * @readonly
     */
    definitionChanged: {
      get: function get() {
        return this._definitionChanged;
      }
    },
    /**
     * 获取或设置对象的名称。该名称用于最终用户使用，不需要是唯一的。
     * @memberof Entity.prototype
     * @type {String|undefined}
     */
    name: createRawPropertyDescriptor('name'),
    show: {
      get: function get() {
        return this._show;
      },
      set: function set(value) {
        if (!defined$1(value)) {
          throw new DeveloperError$1('value is required.');
        }
        if (value === this._show) {
          return;
        }
        var oldVal = this._show;
        this._show = value;
        this._definitionChanged.raiseEvent(this, 'show', value, oldVal);
      }
    },
    /**
     * 获取此实体是否正在显示，考虑到任何祖先实体的可见性。
     * @memberof Entity.prototype
     * @type {Boolean}
     */
    isShowing: {
      get: function get() {
        return this._show && (!defined$1(this.entityCollection) || this.entityCollection.show);
      }
    },
    /**
     * 获取在此实例上注册的所有属性的名称。
     * @memberof Entity.prototype
     * @type {string[]}
     */
    propertyNames: {
      get: function get() {
        return this._propertyNames;
      }
    },
    /**
     * 获取或设置描述。
     * @memberof Entity.prototype
     * @type {Property|undefined}
     */
    description: createPropertyDescriptor('description'),
    /**
     * 获取或设置位置。
     * @memberof Entity.prototype
     * @type {PositionProperty|undefined}
     */
    position: {
      get: function get() {
        return this._position;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined$1(value)) {
          throw new DeveloperError$1('value is required.');
        }
        if (!(value instanceof Cartesian3)) {
          throw new DeveloperError$1('value must be Cartesian3.');
        }
        //>>includeEnd('debug');
        var oldVal = this._position;
        if (value === this._position) {
          return;
        }
        this._position = value;
        this._definitionChanged.raiseEvent(this, 'position', value, oldVal);
      }
    },
    /*
     * Gets or sets the point graphic.
     * @memberof Entity.prototype
     * @type {Point|undefined}
     */
    point: createPropertyTypeDescriptor('point', Point$2),
    polyline: createPropertyTypeDescriptor('polyline', Polyline),
    polygon: createPropertyTypeDescriptor('polygon', Polygon),
    plot: createPropertyTypeDescriptor('plot', Plot$1),
    box: createPropertyTypeDescriptor('box', Box),
    ellipsoid: createPropertyTypeDescriptor('ellipsoid', Ellipsoid),
    label: createPropertyTypeDescriptor('label', Label),
    billboard: createPropertyTypeDescriptor('billboard', Billboard),
    overlayImage: createPropertyTypeDescriptor('overlayImage', OverlayImage),
    rectangle: createPropertyTypeDescriptor('rectangle', Rectangle),
    model: createPropertyTypeDescriptor('model', Model),
    particleSystem: createPropertyTypeDescriptor('particleSystem', ParticleSystem),
    weatherSystem: createPropertyTypeDescriptor('weatherSystem', WeatherParticle),
    cone: createPropertyTypeDescriptor('cone', Cone),
    // circle: createPropertyTypeDescriptor('circle', CirclePrimitive),
    plane: createPropertyTypeDescriptor('panel', Plane),
    pixelLine: createPropertyTypeDescriptor('pixelLine', PixelLinePrimitive),
    heatMap: createPropertyTypeDescriptor('heatMap', HeatMap),
    densityMap: createPropertyTypeDescriptor('densityMap', DensityMap),
    labelBox: createPropertyTypeDescriptor('labelBox', LabelBox),
    circle: createPropertyTypeDescriptor("circle", Circle),
    flyLine: createPropertyTypeDescriptor("flyLine", FlyLine),
    volumeCloud: createPropertyTypeDescriptor("volumeCloud", VolumeCloud)
  });
  Entity.prototype.getParamsByName = function (name) {
    return this._options[name];
  };

  /**
   * 获取经度纬度和位置高度
   * @returns {Array}
   */
  Entity.prototype.getLonLatPosition = function () {
    var _Cartographic$fromCar = Cartographic.fromCartesian(this._position),
      longitude = _Cartographic$fromCar.longitude,
      latitude = _Cartographic$fromCar.latitude,
      height = _Cartographic$fromCar.height;
    var lon = CesiumMath.toDegrees(longitude);
    var lat = CesiumMath.toDegrees(latitude);
    var positionHeight = height;
    return {
      lon: lon,
      lat: lat,
      positionHeight: positionHeight
    };
  };

  /*
   * @FilePath: ConstantIconProperty.js
   * @Author: chenqian
   * @Date: 2023-02-13 20:26:27
   * @LastEditors: cheniqan
   * @LastEditTime: 2023-02-15 14:15:40
   * @Descripttion:常量图标管理
   */
  var POINTICONID = 95; //点图标

  var Arr_iconID = []; //解决ID被占用覆盖得问题
  var id_iconID = 1000;
  var addPoint = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(globe, layer, options) {
      var _options$point$height, _options$show;
      var cartographic, longitude, latitude, height, x, y, pointSR, renderPoint, _heightReference, pointS, altitudeMode, _show, id;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            // await beforeAdd(globe);
            cartographic = Cartographic.fromCartesian(options.position);
            longitude = cartographic.longitude, latitude = cartographic.latitude, height = cartographic.height;
            x = CesiumMath.toDegrees(longitude);
            y = CesiumMath.toDegrees(latitude);
            pointSR = globe.getSpatialReference().forward([x, y]);
            _heightReference = defaultValue$1((_options$point$height = options.point.heightReference) === null || _options$point$height === void 0 ? void 0 : _options$point$height._value, HeightReference$1.NONE);
            if (_heightReference == HeightReference$1.CLAMP_TO_GROUND) {
              renderPoint = creatRenderPoint2D(pointSR, options);
            } else {
              pointS = [pointSR[0], pointSR[1], height];
              renderPoint = creatRenderPoint3D(pointS, options);
              //设置altitudeMode
              altitudeMode = _heightReference == HeightReference$1.RELATIVE_TO_GROUND ? PIEAltitudeMode.RelativeToGround : PIEAltitudeMode.AbsoluteAltitude;
              renderPoint.getStyle().setAltitudeMode(altitudeMode);
            }
            _show = defaultValue$1((_options$show = options.show) === null || _options$show === void 0 ? void 0 : _options$show._value, true); // const _show = options.show && options.point.show._value;
            renderPoint.setVisible(_show);
            layer.add(renderPoint);
            id = renderPoint.getID();
            options.point.id = id;
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function addPoint(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  var addPolyline = function addPolyline(globe, layer, options) {
    var _positions = options.polyline.positions.getValue();
    var renderPolyline;
    if (_positions.length < 2) {
      //给的坐标点不够，不予创建
      return false;
    }
    var _heightReference = options.polyline.clampToGround ? options.polyline.clampToGround._value : true;
    if (_heightReference) {
      renderPolyline = creatRenderPolyline2D(globe, _positions, options);
    } else {
      renderPolyline = creatRenderPolyline3D(globe, _positions, options);
    }
    var _show = options.show && options.polyline.show._value;
    renderPolyline.setVisible(_show);
    layer.add(renderPolyline);
    var id = renderPolyline.getID();
    options.polyline._id = id;
    return true;
  };
  var addPolygon = function addPolygon(globe, layer, options, threeEarth) {
    //todo 岛或者洞的处理
    if (!defined$1(options.polygon.hierarchy)) {
      return false;
    }
    var _positions = options.polygon.hierarchy.getValue().positions;
    var _heightReference = options.polygon.heightReference ? options.polygon.heightReference._value : 1;
    var renderPolygon;
    if (_positions.length < 3) {
      //给的坐标点不够，不予创建
      return false;
    }

    //判断三维
    if (defined$1(options.polygon.extrudedHeight)) {
      var _options$polygon$outl;
      var positions = options.polygon.hierarchy._value.positions;
      // options.polygon.hierarchy._value.positions.forEach((item) => {
      //   const carto = Cartographic.fromCartesian(item);
      //   positions.push((carto.longitude / Math.PI) * 180);
      //   positions.push((carto.latitude / Math.PI) * 180);
      //   positions.push(options.polygon.extrudedHeight._value);
      // });

      var color;
      var customMaterial = null;
      if (!defined$1(options.polygon.material) && !defined$1(options.polygon.color)) {
        // color = 'rgb(255, 255, 255)';
        color = Color$1.WHITE;
      } else {
        var material = options.polygon.material || options.polygon.color;
        if (material._value instanceof Color$1) {
          // opacity = defaultValue(material._value.alpha, 1);
          // color = transformCesiumColorToArray(options.polygon.material);
          // color = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
          color = material._value;
        } else {
          customMaterial = material;
        }
      }
      var primitiveInstance = options.primitiveInstance;
      var polygonPrimitive = new PolygonPrimitive$1({
        positions: positions,
        extrudedHeight: options.polygon.extrudedHeight._value,
        // opacity: opacity,
        color: color,
        material: customMaterial
      });
      var worldCenter = polygonPrimitive.worldCenter;
      var cartographic = Cartographic.fromCartesian(worldCenter);
      polygonPrimitive._worldMatrix = threeEarth.computeWorldMatrix(cartographic.longitude / Math.PI * 180, cartographic.latitude / Math.PI * 180, cartographic.height);
      primitiveInstance.polygonPrimitive = polygonPrimitive;
      primitiveInstance._polygonPrimitive.applyMatrix(polygonPrimitive._worldMatrix);
      var outlineWidth = defaultValue$1((_options$polygon$outl = options.polygon.outlineWidth) === null || _options$polygon$outl === void 0 ? void 0 : _options$polygon$outl._value, 1);
      var outlineColor, outlineOpacity;
      if (!defined$1(options.polygon.outlineColor)) {
        outlineOpacity = 1;
        outlineColor = new Color$2('rgb(0,0,0)');
      } else {
        outlineOpacity = defaultValue$1(options.polygon.outlineColor._value.alpha, 1);
        outlineColor = transformCesiumColorToArray(options.polygon.outlineColor);
        outlineColor = new Color$2("rgb(".concat(outlineColor[0], ", ").concat(outlineColor[1], ", ").concat(outlineColor[2], ")"));
      }
      if (defined$1(options.polygon.outline) && options.polygon.outline._value == true) {
        primitiveInstance.addBorder(polygonPrimitive, outlineColor, outlineOpacity, outlineWidth);
      }

      // layer.add(threePolygon);
      options.polygon._id = polygonPrimitive.id;
      return true;
    }
    if (_heightReference == HeightReference$1.CLAMP_TO_GROUND) {
      renderPolygon = creatRenderPolygon2D(globe, _positions, options);
    }
    if (_heightReference == HeightReference$1.NONE) {
      renderPolygon = creatRenderPolygon3D(globe, _positions, options);
    }
    var _show = options.show && options.polygon.show._value;
    renderPolygon.setVisible(_show);
    layer.add(renderPolygon);
    var id = renderPolygon.getID();
    options.polygon._id = id;
    return true;
  };
  var addRectangle = function addRectangle(globe, layer, options) {
    var _positions = options.rectangle.coordinates.getValue();
    var _heightReference = options.rectangle.heightReference ? options.rectangle.heightReference._value : 1;
    var render;
    if (_heightReference == 1) {
      render = creatRenderRectangle2D(globe, _positions, options);
    }
    if (_heightReference == 0) {
      render = creatRenderRectangle3D(globe, _positions, options);
    }
    var _show = options.show && options.rectangle.show._value;
    render.setVisible(_show);
    layer.add(render);
    var id = render.getID();
    options.rectangle.id = id;
  };
  var addLabel = function addLabel(globe, layer, entity) {
    var cartographic = Cartographic.fromCartesian(entity.position);
    var longitude = cartographic.longitude,
      latitude = cartographic.latitude,
      height = cartographic.height;
    var lon = CesiumMath.toDegrees(longitude);
    var lat = CesiumMath.toDegrees(latitude);
    var spatialReference = globe.getSpatialReference();
    var point = spatialReference.forward([lon, lat]);

    /*
    //字体大小
    * */
    var fontsize = 16;
    if (entity.label.font) {
      fontsize = entity.label.font._value;
      var index = fontsize.toUpperCase().indexOf('PX');
      fontsize = fontsize.substring(0, index);
    }
    var label = '';
    if (entity.label.text) label = entity.label.text._value;
    var color = new Color$1(255, 0, 0, 255);
    if (entity.label.fillColor) color = transformCesiumColorToArray(entity.label.fillColor);
    var heightReference = 0;
    if (entity.label.heightReference) heightReference = entity.label.heightReference._value;
    // let _verticalOrigin=0;//center
    // if (entity.label.verticalOrigin)
    //     _verticalOrigin = entity.label.verticalOrigin._value;
    // let _horizontalOrigin=0;//center
    // if (entity.label.horizontalOrigin)
    //     _horizontalOrigin = entity.label.horizontalOrigin._value;
    //返回对应得位置
    var _align = 7; //居中为7 默认
    if (entity.label.verticalOrigin || entity.label.horizontalOrigin) {
      _align = getAlign(entity.label.verticalOrigin, entity.label.horizontalOrigin);
    }
    var renderLabel = null;
    var text = new PIEText({
      point: point,
      text: label
    });
    if (heightReference == 1) {
      //贴地
      renderLabel = new PIERenderText({
        text: text,
        color: color,
        width: fontsize,
        height: fontsize,
        align: _align
      });
    } else if (heightReference == 0) {
      //贴地形
      text = new PIEText3D({
        point: [point[0], point[1], height],
        text: label
      });
      renderLabel = new PIERenderText3D({
        text3D: text,
        color: color,
        width: fontsize,
        height: fontsize,
        align: _align
      });
    } else {
      //贴地形加高度
      text = new PIEText3D({
        point: [point[0], point[1], height],
        //海拔加高度 需修改
        text: label
      });
      renderLabel = new PIERenderText3D({
        text3D: text,
        color: color,
        width: fontsize,
        height: fontsize,
        align: _align
      });
    }
    var vectorStyle = new PIEVectorStyle({
      // pointType: PointType.Icon, //设置点符号类型
      // pointStyle: 5, //点图标样式，与上方设置符号属性ID保持一致
      // pointSize: [32, 32], //设置点符号标识大小
      // lineColor: [0, 0, 255, 255],
      // lineWidth: 1,
      // fillColor: [0, 255, 0, 64],
      altitudeMode: 1,
      //依地形
      pointAlign: _align //设置点符号对齐方式
    });

    var textStyle = new PIETextStyle();
    textStyle.setForeColor(color); //前景色
    textStyle.setWidth(fontsize);
    textStyle.setHeight(fontsize);
    textStyle.setAlign(_align);
    if (entity.label.showBackground != false) {
      if (entity.label.backgroundColor) {
        var _backgroundColor = transformCesiumColorToArray(entity.label.backgroundColor);
        textStyle.setBackColor(_backgroundColor);
      }
    }
    if (entity.label.pixelOffset) {
      var pixelOffset = entity.label.pixelOffset._value;
      textStyle.setOffset([pixelOffset.x, pixelOffset.y]);
    }
    text.setTextStyle(textStyle);
    textStyle.dispose(); //风格对象内部会进行克隆，此处需要进行释放
    // let symbolStyle=new SymbolStyle();
    // symbolStyle.setVectorStyle(vectorStyle);
    // symbolStyle.setTextStyle(textStyle);
    renderLabel.setStyle(vectorStyle); //几何对象风格
    if (entity.show != false) {
      renderLabel.setVisible(entity.label.show ? entity.label.show._value ? true : false : true);
    }
    layer.add(renderLabel);
    var id = renderLabel.getID();
    entity.label.id = id;
  };
  var addBillboard = function addBillboard(globe, layer, entity) {
    if (defined$1(entity.billboard)) {
      var cartographic = Cartographic.fromCartesian(entity.position);
      var longitude = cartographic.longitude,
        latitude = cartographic.latitude,
        height = cartographic.height;
      var lon = CesiumMath.toDegrees(longitude);
      var lat = CesiumMath.toDegrees(latitude);
      var spatialReference = globe.getSpatialReference();
      var point = spatialReference.forward([lon, lat]);

      /** 加载符号 **/
      var workspace = globe.getDocument(); // 获取工作空间
      var symbolLib = workspace.getSymbolLib(); //获取符号库
      // const symbolGroup = symbolLib.getGroup(PIE.SymbolGroupType.Icon); //获取符号组
      var symbolGroup = symbolLib.getGroup(PIESymbolGroupType.Icon); //空类型
      var iconSymbol = new PIEIconSymbol(); //创建符号
      while (symbolGroup.getByID(id_iconID) != null || Arr_iconID.includes(id_iconID) == true) {
        id_iconID++;
      }
      Arr_iconID.push(id_iconID);
      var options = {
        url: entity.billboard.image._value,
        id: id_iconID,
        name: 'billboard'
      };
      var iconID = id_iconID;
      var _color = [255, 0, 0, 255];
      if (entity.billboard.color) _color = transformCesiumColorToArray(entity.billboard.color);
      var _width = 32;
      if (entity.billboard.width) _width = entity.billboard.width._value;
      var _height = 32;
      if (entity.billboard.height) _height = entity.billboard.height._value;
      if (entity.billboard.heightReference) entity.billboard.heightReference._value;
      /** 点渲染操作函数 **/
      var pointS = [point[0], point[1], height];
      var point3D = new PIEPoint3D({
        point: pointS
      });
      var _align = 7; //居中为7 默认
      if (entity.billboard.verticalOrigin || entity.billboard.horizontalOrigin) {
        _align = getAlign(entity.billboard.verticalOrigin, entity.billboard.horizontalOrigin);
      }
      ////////

      var renderPoint = new PIERenderPoint3D({
        point3D: point3D,
        color: _color,
        size: [_width, _height],
        type: PIEPointType.Icon,
        align: _align,
        style: iconID
        // altitudeMode:1,
      });

      if (renderPoint.getStyle().enablePointColor) {
        renderPoint.getStyle().enablePointColor(true);
      }
      if (renderPoint.getStyle().setBlendPointColor) {
        renderPoint.getStyle().setBlendPointColor(true);
      }
      if (entity.billboard.sizeInMeters) {
        renderPoint.setFixedSize(!entity.billboard.sizeInMeters._value);
      }
      if (entity.billboard.rotation) {
        renderPoint.getStyle().setPointAngle(entity.billboard.rotation._value);
      }
      if (entity.show != false) {
        renderPoint.setVisible(entity.billboard.show ? entity.billboard.show._value ? true : false : true);
      }
      layer.add(renderPoint);
      var id = renderPoint.getID();
      entity.billboard._id = id;
      // let iconID = value.getID();

      iconSymbol.load(options).then(function (value) {
        symbolGroup.add(value); //value为成功设置name，id的iconSymbol，可将该符号对象添加至符号组中
        layer.updateGeometry(renderPoint.getFeature().getGeometry());
        entity.billboard._symbolId = value.getID();
      });
    }
  };
  var addOverlayImage = function addOverlayImage(globe, layer, entity) {
    if (defined$1(entity.overlayImage)) {
      var cartographic = Cartographic.fromCartesian(entity.position);
      var longitude = cartographic.longitude,
        latitude = cartographic.latitude;
        cartographic.height;
      var lon = CesiumMath.toDegrees(longitude);
      var lat = CesiumMath.toDegrees(latitude);
      var spatialReference = globe.getSpatialReference();
      var pointSR = spatialReference.forward([lon, lat]);

      /** 加载符号 **/
      var workspace = globe.getDocument(); // 获取工作空间
      var symbolLib = workspace.getSymbolLib(); //获取符号库
      var symbolGroup = symbolLib.getGroup(PIESymbolGroupType.Icon); //空类型
      var iconSymbol = new PIEIconSymbol(); //创建符号
      while (symbolGroup.getByID(id_iconID) != null || Arr_iconID.includes(id_iconID) == true) {
        id_iconID++;
      }
      Arr_iconID.push(id_iconID);
      var options = {
        url: entity.overlayImage.image._value,
        id: id_iconID,
        name: 'overlayImage'
      };
      // (function(_index){
      //
      // })(id_iconID)
      iconSymbol.load(options).then(function (value) {
        symbolGroup.add(value); //value为成功设置name，id的iconSymbol，可将该符号对象添加至符号组中
        var iconID = value.getID();
        var _color = new Color$1(255, 0, 0, 255);
        if (entity.overlayImage.color) _color = transformCesiumColorToArray(entity.overlayImage.color);
        var _width = 50;
        if (entity.overlayImage.width) _width = entity.overlayImage.width._value;
        var _height = 50;
        if (entity.overlayImage.height) _height = entity.overlayImage.height._value;
        if (entity.overlayImage.heightReference) entity.overlayImage.heightReference._value;
        var point = new PIEPoint({
          point: pointSR
        });
        /**创建风格**/
        var vectorStyle = new PIEVectorStyle({
          pointColor: _color,
          pointSize: [_width, _height],
          pointType: PIEPointType.Icon,
          pointStyle: iconID
        });
        point.setStyle(vectorStyle);
        /** 点渲染操作函数 **/
        var featureElementPoint = new PIEGlobeFeatureElement({
          geometry: point
        });
        if (entity.show != false) {
          featureElementPoint.setVisible(entity.overlayImage.show ? entity.overlayImage.show._value ? true : false : true);
        }
        layer.add(featureElementPoint);
        var id = featureElementPoint.getID();
        entity.overlayImage._id = id;
      });
    }
  };
  var updatePoint = function updatePoint(globe, layer, options) {
    var scope = options.scope,
      name = options.name,
      value = options.value,
      oldValue = options.oldValue,
      entity = options.entity;
    if (!defined$1(scope.id)) {
      return;
    }
    var renderPoint = layer.get(scope.id);
    if (value == oldValue) return;
    switch (name) {
      case 'show':
        //显影
        renderPoint.setVisible(value._value);
        break;
      case 'pixelSize':
        //半径
        renderPoint.getStyle().setPointSize([value._value, value._value]);
        layer.updateGeometry(renderPoint.getFeature().getGeometry());
        break;
      case 'color':
        //颜色
        debugger;
        renderPoint.getStyle().setPointColor(transformCesiumColorToArray(value));
        layer.updateGeometry(renderPoint.getFeature().getGeometry());
        break;
      case 'outlineColor': //边界颜色
      case 'outlineWidth': //边界宽度
      case 'distanceDisplayCondition':
        //显影按距离控制属性
        break;
      case 'heightReference':
        //贴地
        var cartographic = Cartographic.fromCartesian(options.entity.position);
        var longitude = cartographic.longitude,
          latitude = cartographic.latitude,
          height = cartographic.height;
        var x = CesiumMath.toDegrees(longitude);
        var y = CesiumMath.toDegrees(latitude);
        var pointSR = globe.getSpatialReference().forward([x, y]);
        layer.remove(scope.id);
        var render_new;
        if (value._value == HeightReference$1.CLAMP_TO_GROUND) {
          render_new = creatRenderPoint2D(pointSR, entity);
        } else {
          var pointS = [pointSR[0], pointSR[1], height];
          render_new = creatRenderPoint3D(pointS, entity);
          //设置altitudeMode
          var altitudeMode = value._value == HeightReference$1.RELATIVE_TO_GROUND ? PIEAltitudeMode.RelativeToGround : PIEAltitudeMode.AbsoluteAltitude;
          render_new.getStyle().setAltitudeMode(altitudeMode);
        }
        layer.add(render_new);
        var id = render_new.getID();
        scope.id = id;
        break;
    }
  };
  var updatePolyline = function updatePolyline(globe, layer, options) {
    var scope = options.scope,
      name = options.name,
      value = options.value,
      oldValue = options.oldValue,
      entity = options.entity;
    if (!defined$1(scope.id)) {
      var res = addPolyline(globe, layer, entity);
      if (!res) return; //再次创建polygon失败，返回
    }

    var render = layer.get(scope.id);
    if (value == oldValue) return;
    switch (name) {
      case 'show':
        //显影
        render.setVisible(value._value);
        break;
      case 'width':
        //宽度
        render.getStyle().setLineWidth(value._value);
        layer.updateGeometry(render.getFeature().getGeometry());
        break;
      case 'color':
      case 'material':
        //颜色
        render.getStyle().setLineColor(transformCesiumColorToArray(value));
        layer.updateGeometry(render.getFeature().getGeometry());
        break;
      case 'positions': //位置

      case 'clampToGround':
        //是否贴地
        layer.remove(scope.id);
        var _positions = scope.positions.getValue();
        var _heightReference = scope.clampToGround.getValue();
        var render_new;
        if (_heightReference) {
          render_new = creatRenderPolyline2D(globe, _positions, entity);
        } else {
          render_new = creatRenderPolyline3D(globe, _positions, entity);
        }
        layer.add(render_new);
        var id = render_new.getID();
        scope._id = id;
        break;
    }
  };
  var updatePolygon = function updatePolygon(globe, layer, options, threeEarth) {
    var scope = options.scope,
      name = options.name,
      value = options.value,
      oldValue = options.oldValue,
      entity = options.entity;
    if (value == oldValue) return;
    //处理extrudedHeight
    if (name == 'extrudedHeight') {
      if (!defined$1(oldValue) && defined$1(scope.id)) {
        //删除二维polygon
        entity.entityCollection._renderableLayer.remove(scope.id);
        scope._id = null;
      }
    }
    if (!defined$1(scope.id)) {
      var res = addPolygon(globe, layer, entity, threeEarth);
      if (!res) return; //再次创建polygon失败，返回
    }

    if (defined$1(entity.polygon.extrudedHeight)) {
      layer.children.forEach(function (item) {
        var polygonPrimitive = item.polygonPrimitive;
        if (polygonPrimitive && polygonPrimitive.id === scope.id) {
          var threeMesh = polygonPrimitive;
          switch (name) {
            case 'fill':
              // new ThreeColor(`rgb(${value._value.red},0,0)`);
              // threeMesh.material.color = new ThreeColor(value._value.toCssHexString());
              threeMesh.material.visible = value._value & scope.show._value;
              break;
            case 'show':
              threeMesh.material.visible = value._value & scope.show._value;
              threeMesh.children.forEach(function (item) {
                if (item.type === 'LineSegments') {
                  item.material.visible = value._value & scope.outline._value;
                }
              });
              break;
            case 'extrudedHeight':
              threeMesh.scale.setZ(value._value);
              break;
            case 'color':
            case 'material':
              if (value._value instanceof Color$1) {
                var opacity = value._value.alpha;
                // let color = transformCesiumColorToArray(value);
                // color = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                // threeMesh.material.color = color;
                threeMesh.material.color = new Color$2(value._value.red, value._value.green, value._value.blue);
                threeMesh.material.opacity = opacity;
              } else {
                threeMesh.material = value._value;
              }
              break;
            case 'outline':
              threeMesh.children.forEach(function (item) {
                if (item.type === 'LineSegments') {
                  item.material.visible = value._value & scope.show._value;
                }
              });
              break;
            case 'outlineColor':
              threeMesh.children.forEach(function (item) {
                if (item.type === 'LineSegments' && scope.outline._value) {
                  item.material.color = new Color$2(value._value.red, value._value.green, value._value.blue);
                  item.material.opacity = value._value.alpha;
                }
              });
              break;
            case 'outlineWidth':
              threeMesh.children.forEach(function (item) {
                if (item.type === 'LineSegments' && scope.outline._value) {
                  item.material.linewidth = value._value;
                }
              });
              break;
            case 'hierarchy':
              item.parent.remove(polygonPrimitive);
              scope._id = null;
              addPolygon(globe, layer, entity, threeEarth);
          }
        }
      });
      return;
    }
    var render = layer.get(scope.id);
    switch (name) {
      case 'show':
        //显影
        render.setVisible(value._value);
        break;
      case 'color': //颜色
      case 'material':
        //颜色
        render.getStyle().setForeFillColor(transformCesiumColorToArray(value));
        layer.updateGeometry(render.getFeature().getGeometry());
        break;
      case 'hierarchy': //位置
      case 'heightReference':
        //是否贴地
        layer.remove(scope.id);
        var _positions = scope.hierarchy.getValue().positions;
        var _heightReference = scope.heightReference.getValue();
        var render_new;
        if (_heightReference) {
          render_new = creatRenderPolygon2D(globe, _positions, entity);
        } else {
          render_new = creatRenderPolygon3D(globe, _positions, entity);
        }
        layer.add(render_new);
        var id = render_new.getID();
        scope._id = id;
        break;
      case 'height':
        //位置
        render.setHeight(value._value);
        break;
    }
  };
  var addPlot = function addPlot(globe, layer, entity) {
    if (defined$1(entity.plot)) {
      var _entity$plot$unitLeng;
      if (!defined$1(entity.plot.plotCode)) {
        throw new DeveloperError('plotCode is required.');
      }
      //判断点线面jb
      var point;
      //线面
      var _positions = entity.plot.positions;
      if (defined$1(_positions)) {
        var points = [];
        _positions.getValue().forEach(function (element) {
          var cartographic = Cartographic.fromCartesian(element);
          var lon = CesiumMath.toDegrees(cartographic.longitude);
          var lat = CesiumMath.toDegrees(cartographic.latitude);

          // const pointSR = globe.getSpatialReference().forward([lon, lat]);
          // points.push(pointSR[0], pointSR[1]);
          points.push(lon, lat);
        });
        point = globe.getPlotPoint(points);
      } else {
        //点.
        if (!defined$1(entity.position)) return;
        var cartographic = Cartographic.fromCartesian(entity.position);
        var lon = CesiumMath.toDegrees(cartographic.longitude);
        var lat = CesiumMath.toDegrees(cartographic.latitude);
        globe.getSpatialReference();
        // point = spatialReference.forward([lon, lat]);
        point = globe.getPlotPoint([lon, lat]);
      }
      var options = {
        code: entity.plot.plotCode._value,
        points: point,
        unitLength: defaultValue$1((_entity$plot$unitLeng = entity.plot.unitLength) === null || _entity$plot$unitLeng === void 0 ? void 0 : _entity$plot$unitLeng._value, 1000)
      };
      var geoPlot = new PIEGeoPlot(options);
      //排除show属性
      var PlotPropertyNames = entity.plot._propertyNames.concat([]);
      var showIndex = PlotPropertyNames.findIndex(function (name) {
        return name == 'show';
      });
      PlotPropertyNames.splice(showIndex, 1);
      PlotPropertyNames.forEach(function (name) {
        var value = entity.plot[name];
        if (defined$1(value)) {
          var scope = entity.plot;
          updatePlot(globe, layer, {
            scope: scope,
            name: name,
            value: value,
            geoPlot: geoPlot
          });
        }
      });
      // geoPlot.getStyle().setFontCode(5250);
      var renderPlot = new PIERenderPlot({
        plot: geoPlot
      });

      //renderPlot层级控制显隐
      renderPlot.setVisible(entity.plot.show ? entity.plot.show._value ? true : false : true);
      layer.add(renderPlot);
      entity.plot._id = renderPlot.getID();
    }
  };
  var updatePlot = function updatePlot(globe, layer, _ref2) {
    var scope = _ref2.scope,
      name = _ref2.name,
      value = _ref2.value;
      _ref2.oldValue;
      var geoPlot = _ref2.geoPlot;
    if (!defined$1(geoPlot)) {
      if (!defined$1(scope.id)) {
        return;
      }
      geoPlot = layer.get(scope.id).getGeometry();
    }
    // const geoPlot = layer.get(scope.id);
    switch (name) {
      case 'show':
        //仅更新时
        layer.get(scope.id).setVisible(scope.show ? scope.show._value ? true : false : true);
        break;
      case 'lineColor':
        geoPlot.getStyle().setLineColor(transformCesiumColorToArray(value));
        break;
      case 'outlineColor':
        geoPlot.getStyle().setOutLineColor(transformCesiumColorToArray(value));
        break;
      case 'fillColor':
        //填充前景色 背景色
        var _fillColor = transformCesiumColorToArray(value);
        geoPlot.getStyle().setFillForeColor(_fillColor);
        geoPlot.getStyle().setFillOpacity(_fillColor[3]);
        break;
      case 'lineWidth':
        //边线
        geoPlot.getStyle().setLineWidth(value._value);
        break;
      case 'outlineWidth':
        //衬线
        geoPlot.getStyle().setOutLineWidth(value._value);
        break;
      case 'textColor':
        geoPlot.getStyle().setFontTextColor(transformCesiumColorToArray(value));
        break;
      case 'label':
        //注记
        geoPlot.getStyle().setLabel(value._value);
        break;
      case 'labelPos':
        geoPlot.getStyle().setLabelPos(value._value);
        break;
      case 'fillMode':
        geoPlot.getStyle().setFillMode(value._value);
        break;
      case 'sizeMode':
        geoPlot.getStyle().setSizeMode(value._value);
        break;
      case 'innerText':
        //旗面文字
        geoPlot.getStyle().setText(value._value);
        break;
      case 'size':
        geoPlot.getStyle().setSymbolSize([value._value, value._value]);
        break;
      case 'fontSize':
        geoPlot.getStyle().setFontSize(value._value);
        break;
    }
    if (defined$1(scope.id)) {
      layer.updateGeometry(layer.get(scope.id).getGeometry());
    }
  };
  var updateLabel = function updateLabel(globe, layer, _ref3) {
    var scope = _ref3.scope,
      name = _ref3.name,
      value = _ref3.value;
      _ref3.oldValue;
    if (!defined$1(scope.id)) return;
    var geoLabel = layer.get(scope.id);
    switch (name) {
      case 'show':
        //显影
        geoLabel.setVisible(value._value);
        break;
      case 'text':
        geoLabel.getFeature().getGeometry().setText(value._value);
        break;
      case 'font':
        var fontsize = 16;
        fontsize = value._value;
        var index = fontsize.toUpperCase().indexOf('PX');
        fontsize = fontsize.substring(0, index);
        geoLabel.getTextStyle().setWidth(fontsize);
        geoLabel.getTextStyle().setHeight(fontsize);
        break;
      case 'fillColor':
        geoLabel.getTextStyle().setForeColor(transformCesiumColorToArray(value));
        break;
      case 'heightReference':
        break;
      case 'verticalOrigin':
        //垂直
        var _align = 7; //居中为7 默认
        _align = geoLabel.getTextStyle().getAlign();
        //把水平垂直解出来
        var arrAlign = getVerticalHorizontal(_align);
        _align = getAlignNumber(value._value, arrAlign[1]);
        geoLabel.getTextStyle().setAlign(_align);
        break;
      case 'pixelOffset':
        geoLabel.getTextStyle().setOffset([value._value.x, value._value.y]);
        break;
      case 'showBackground':
        break;
      case 'eyeOffset':
        break;
      case 'backgroundColor':
        geoLabel.getTextStyle().setBackColor(transformCesiumColorToArray(value));
        break;
      case 'horizontalOrigin':
        //水平
        var hor_align = 7; //居中为7 默认
        hor_align = geoLabel.getTextStyle().getAlign();
        //把水平垂直解出来
        var arrAlign_hor = getVerticalHorizontal(hor_align);
        hor_align = getAlignNumber(arrAlign_hor[0], value._value);
        geoLabel.getTextStyle().setAlign(hor_align);
        break;
    }
    if (defined$1(scope.id)) {
      layer.updateGeometry(layer.get(scope.id).getFeature().getGeometry());
    }
  };
  var updateBillboard = function updateBillboard(globe, layer, options) {
    var scope = options.scope,
      name = options.name,
      value = options.value,
      oldValue = options.oldValue;
      options.entity;
    if (!defined$1(scope.id)) return;
    var rendbillboard = layer.get(scope.id);
    if (value == oldValue) return;
    switch (name) {
      case 'show':
        //显影
        rendbillboard.setVisible(value._value);
        break;
      case 'width':
        var piesize = rendbillboard.getStyle().getPointSize();
        rendbillboard.getStyle().setPointSize([value._value, piesize.cy]);
        break;
      case 'height':
        var size = rendbillboard.getStyle().getPointSize();
        rendbillboard.getStyle().setPointSize([size.cx, value._value]);
        break;
      case 'verticalOrigin':
        //垂直
        var _align = 7; //居中为7 默认
        _align = rendbillboard.getStyle().getPointAlign();
        //把水平垂直解出来
        var arrAlign = getVerticalHorizontal(_align);
        _align = getAlignNumber(value._value, arrAlign[1]);
        rendbillboard.getStyle().setPointAlign(_align);
        break;
      case 'horizontalOrigin':
        //水平
        var hor_align = 7; //居中为7 默认
        hor_align = rendbillboard.getStyle().getPointAlign();
        //把水平垂直解出来
        var arrAlign_hor = getVerticalHorizontal(hor_align);
        hor_align = getAlignNumber(arrAlign_hor[0], value._value);
        rendbillboard.getStyle().setPointAlign(hor_align);
        break;
      case 'pixelOffset':
        //
        break;
      case 'color':
        //颜色
        rendbillboard.getStyle().setPointColor(transformCesiumColorToArray(value));
        break;
      case 'outlineColor': //边界颜色
      case 'outlineWidth': //边界宽度
      case 'distanceDisplayCondition':
        //显影按距离控制属性
        break;
      case 'rotation':
        //显影按距离控制属性
        rendbillboard.getStyle().setPointAngle(value._value);
        break;
      case 'heightReference':
        //贴地
        // const cartographic = Cartographic.fromCartesian(options.entity.position);
        // const { longitude, latitude, height } = cartographic;
        // const x = CesiumMath.toDegrees(longitude);
        // const y = CesiumMath.toDegrees(latitude);
        // const pointSR = globe.getSpatialReference().forward([x, y]);
        // layer.remove(scope.id);
        // let render_new;
        // if (value._value == 1) {
        //     render_new = creatRenderPoint2D(pointSR, entity);
        // } else if (value._value == 2) {
        //     const pointS = [pointSR[0], pointSR[1], height];
        //     render_new = creatRenderPoint3D(pointS, entity);
        // }
        // layer.add(render_new);
        // const id = render_new.getID();
        // scope.id = id;
        break;
      case 'sizeInMeters':
        if (rendbillboard.setFixedSize) {
          rendbillboard.setFixedSize(!value._value);
        }
        break;
    }
    if (defined$1(scope.id)) {
      layer.updateGeometry(layer.get(scope.id).getFeature().getGeometry());
    }
  };
  var updateOverlayImage = function updateOverlayImage(globe, layer, options) {
    var scope = options.scope,
      name = options.name,
      value = options.value,
      oldValue = options.oldValue;
      options.entity;
    var rendimage = layer.get(scope.id);
    if (value == oldValue) return;
    switch (name) {
      case 'show':
        //显隐
        rendimage.setVisible(value._value);
        break;
      case 'width':
        var imgsize = rendimage.getFeature().getGeometry().getStyle().getPointSize();
        rendimage.getFeature().getGeometry().getStyle().setPointSize([imgsize.cx, value._value]);
        break;
      case 'height':
        var size = rendimage.getFeature().getGeometry().getStyle().getPointSize();
        rendimage.getFeature().getGeometry().getStyle().setPointSize([value._value, size.cy]);
        break;
      case 'pixelOffset':
        //
        rendimage.getStyle().setPointSize([value._value, value._value]);
        break;
      case 'color':
        //
        rendimage.getFeature().getGeometry().getStyle().setPointColor(transformCesiumColorToArray(value));
        break;
      case 'outlineColor': //边界颜色
      case 'outlineWidth': //边界宽度
      case 'rotation':
        rendimage.getFeature().getGeometry().getStyle().setPointAngle(value._value);
        break;
    }
    globe.refresh(false, false);
  };
  var addPolylineVolume = function addPolylineVolume(globe, layer, entity, threeEarth) {
    if (defined$1(entity.polylineVolume)) {
      var width = entity.box.dimensions._value.x;
      var height = entity.box.dimensions._value.y;
      var depth = entity.box.dimensions._value.z;
      var cartographic = Cartographic.fromCartesian(entity.position);
      var longitude = cartographic.longitude,
        latitude = cartographic.latitude;
      var lon = CesiumMath.toDegrees(longitude);
      var lat = CesiumMath.toDegrees(latitude);
      var positionHeight = cartographic.height + depth / 2;
      var boxEntity = new PrimitiveInstance({
        boxParams: {
          width: width,
          height: height,
          depth: depth,
          opacity: 0.7,
          color: 'red'
        },
        position: {
          lon: lon,
          lat: lat,
          height: positionHeight
        },
        threeEarth: threeEarth
      });
      layer.add(boxEntity);
    }
  };
  var updateRectangle = function updateRectangle(globe, layer, options) {
    var scope = options.scope,
      name = options.name,
      value = options.value,
      oldValue = options.oldValue,
      entity = options.entity;
    var render = layer.get(scope.id);
    if (value == oldValue) return;
    switch (name) {
      case 'show':
        //显影
        render.setVisible(value._value);
        break;
      case 'color':
        //颜色
        render.getStyle().setForeFillColor(transformCesiumColorToArray(value));
        layer.updateGeometry(render.getFeature().getGeometry());
        break;
      case 'coordinates': //位置
      case 'heightReference':
        //是否贴地
        layer.remove(scope.id);
        var _positions = scope.coordinates.getValue();
        var _heightReference = scope.heightReference.getValue();
        var render_new;
        if (_heightReference) {
          render_new = creatRenderRectangle2D(globe, _positions, entity);
        } else {
          render_new = creatRenderRectangle3D(globe, _positions, entity);
        }
        layer.add(render_new);
        var id = render_new.getID();
        scope.id = id;
        break;
      case 'height':
        //位置
        render.setHeight(value._value);
        break;
    }
  };
  var addHeatMap = function addHeatMap(globe, layer, entity) {
    var _entity$heatMap$radiu, _entity$heatMap$color;
    var radiusOption = defaultValue$1((_entity$heatMap$radiu = entity.heatMap.radius) === null || _entity$heatMap$radiu === void 0 ? void 0 : _entity$heatMap$radiu._value, 52);
    var colorRange = defaultValue$1((_entity$heatMap$color = entity.heatMap.colorRange) === null || _entity$heatMap$color === void 0 ? void 0 : _entity$heatMap$color._value, [Color$1.fromBytes(2, 0, 138, 255), Color$1.fromBytes(3, 26, 252, 255), Color$1.fromBytes(0, 175, 251, 255), Color$1.fromBytes(61, 255, 194, 255), Color$1.fromBytes(206, 255, 39, 255), Color$1.fromBytes(25, 255, 25, 255), Color$1.fromBytes(255, 158, 2, 255), Color$1.fromBytes(253, 123, 3, 255), Color$1.fromBytes(237, 92, 30, 255)]);
    var show = entity.show && entity.heatMap.show._value;
    var renderableLayer = layer;
    var heatPoints = [];
    var maxValue = -20;
    var data = entity.heatMap.data._value;
    var lonSum = 0,
      latSum = 0;
    for (var i = 0; i < data.length; i++) {
      var weight = data[i].value;
      if (maxValue < weight) {
        maxValue = weight;
      }
      lonSum += data[i].x;
      latSum += data[i].y;
      var HeatPoint = {
        lon: data[i].x,
        lat: data[i].y,
        value: weight
      };
      heatPoints.push(HeatPoint);
    }
    var nCount = heatPoints.length;
    var pRenderDensitySet = new PIERenderListDensitySet();
    pRenderDensitySet.setGeometryShader(false);
    pRenderDensitySet.setCanvasRender(true);
    pRenderDensitySet.setSpatialRefType(1);
    pRenderDensitySet.setPoolSize(nCount + 1);
    pRenderDensitySet.setPosition([lonSum / data.length, latSum / data.length, 0]);
    pRenderDensitySet.setStartTime(0);
    pRenderDensitySet.setEndTime(10000);
    pRenderDensitySet.setTraceTime(10000);
    pRenderDensitySet.setSpeedPerFrame(0); //设置为0保证热力图不消失

    pRenderDensitySet.setVisible(show);
    var pRenderCanvas = new PIERenderCanvas();
    pRenderCanvas.add(pRenderDensitySet);
    var ColorTable = new PIEColorRange();
    colorRange.forEach(function (item) {
      ColorTable.addColor(item.toBytes());
    });
    ColorTable.setCeiling(colorRange.length);
    ColorTable.setFloor(0);
    pRenderCanvas.setColorRange(ColorTable);
    renderableLayer.add(pRenderCanvas);
    for (var _i = 0; _i < nCount; _i++) {
      var x = heatPoints[_i].lon;
      var y = heatPoints[_i].lat;
      var dValue = heatPoints[_i].value;
      var alpha = Math.floor(dValue * 255 / maxValue);
      var radius = Math.floor(dValue * radiusOption / maxValue);
      var densityPoint = new PIEDensityPoint();
      densityPoint.setStyle(1);
      densityPoint.setRadius(radius);
      densityPoint.setPosition([x, y, 0, 0]);
      densityPoint.setColor([255, 0, 0, alpha]);
      pRenderDensitySet.updateDensityPoint(_i, densityPoint);
    }
    entity.heatMap._id = pRenderCanvas.getID();
  };
  var addDensityMap = function addDensityMap(globe, layer, options) {
    var _options$densityMap$c, _options$densityMap$r;
    var renderableLayer = layer;
    var color = defaultValue$1((_options$densityMap$c = options.densityMap.color) === null || _options$densityMap$c === void 0 ? void 0 : _options$densityMap$c._value, [200, 200, 0, 204]);
    var radius = defaultValue$1((_options$densityMap$r = options.densityMap.radius) === null || _options$densityMap$r === void 0 ? void 0 : _options$densityMap$r._value, 4);
    var show = options.show && options.densityMap.show._value;
    var weiboJSON = options.densityMap.data._value;
    var value1 = weiboJSON[0];
    var count1 = value1.length;
    var WorldListDensitySet = new PIERenderWorldListDensitySet();
    WorldListDensitySet.setGeometryShader(false);
    WorldListDensitySet.setSpatialRefType(1);
    WorldListDensitySet.setPoolSize(count1);
    WorldListDensitySet.setPosition([0, 0, 0]);
    WorldListDensitySet.setStartTime(0);
    WorldListDensitySet.setEndTime(3000 * 24 * 60 * 60);
    WorldListDensitySet.setTraceTime(3000 * 24 * 60 * 60);
    WorldListDensitySet.setSpeedPerFrame(1);
    renderableLayer.add(WorldListDensitySet);
    WorldListDensitySet.setVisible(show);
    for (var i = 0; i < count1; i++) {
      var geoCoord = value1[i];
      var pos = geoCoord.geoCoord;
      var vecPos = new PIEVector4(pos[0], pos[1], 0, 0);
      var densityPoint = new PIEDensityPoint();
      densityPoint.setRadius(radius);
      densityPoint.setColor(color);
      densityPoint.setPosition(vecPos);
      WorldListDensitySet.addDensityPoint(densityPoint);
    }
    options.densityMap._id = WorldListDensitySet.getID();
  };
  var updateHeatMap = function updateHeatMap(globe, layer, _ref5) {
    var scope = _ref5.scope,
      name = _ref5.name,
      value = _ref5.value;
      _ref5.oldValue;
    var renderObj = layer.get(scope.id);
    // if (value == oldValue) return;
    switch (name) {
      case 'show':
        renderObj.setVisible(value._value);
        break;
    }
  };
  var updateDensityMap = function updateDensityMap(globe, layer, _ref6) {
    var scope = _ref6.scope,
      name = _ref6.name,
      value = _ref6.value;
      _ref6.oldValue;
    var renderObj = layer.get(scope.id);
    var count = layer.getCurDensityCount();
    switch (name) {
      case 'show':
        renderObj.setVisible(value._value);
        break;
      case 'radius':
        for (var i = 0; i < count; i++) {
          var _densityPoint = renderObj.getDensityPoint(i);
          _densityPoint.setRadius(value._value);
        }
        break;
      case 'color':
        for (var _i2 = 0; _i2 < count; _i2++) {
          var _densityPoint2 = renderObj.getDensityPoint(_i2);
          _densityPoint2.setColor(value._value);
        }
        break;
      case 'data':
        renderObj.removeAllDensityPoint();
        var weiboJSON = value._value;
        var value1 = weiboJSON[0];
        var count1 = value1.length;
        for (var _i3 = 0; _i3 < count1; _i3++) {
          var geoCoord = value1[_i3];
          var pos = geoCoord.geoCoord;
          var vecPos = new PIEVector4(pos[0], pos[1], 0, 0);
          var densityPoint = new PIEDensityPoint();
          densityPoint.setRadius(scope.radius._value);
          densityPoint.setColor(scope.color._value);
          densityPoint.setPosition(vecPos);
          renderObj.addDensityPoint(densityPoint);
        }
        break;
    }
  };
  /**
   *
   * @param {pieGlobe}[globe]
   * @param {GlobeRenderableLayer}[layer]
   * @param {Entity}[options]
   * @returns {Polygon} The modified result parameter or a new instance if one was not provided.
   */
  var createProperties = {
    addPoint: addPoint,
    addPolyline: addPolyline,
    addLabel: addLabel,
    addBillboard: addBillboard,
    addOverlayImage: addOverlayImage,
    addPolygon: addPolygon,
    addPlot: addPlot,
    addPolylineVolume: addPolylineVolume,
    addBox: addBox,
    addEllipsoid: addEllipsoid,
    addRectangle: addRectangle,
    addModel: addModel,
    addParticleSystem: addParticleSystem,
    addWeatherSystem: addWeatherSystem,
    addCone: addCone,
    addCircle: addCircle,
    addPlane: addPlane,
    addPixelLine: addPixelLine,
    addHeatMap: addHeatMap,
    addDensityMap: addDensityMap,
    addLabelBox: addLabelBox,
    addFlyLine: addFlyLine,
    addVolumeCloud: addVolumeCloud
  };
  var updateProperties = {
    updatePoint: updatePoint,
    updatePolyline: updatePolyline,
    updatePolygon: updatePolygon,
    updateRectangle: updateRectangle,
    updatePlot: updatePlot,
    updateBox: updateBox,
    updateEllipsoid: updateEllipsoid,
    updateLabel: updateLabel,
    updateBillboard: updateBillboard,
    updateOverlayImage: updateOverlayImage,
    updateHeatMap: updateHeatMap,
    updateDensityMap: updateDensityMap,
    updateCircle: updateCircle,
    updatePlane: updatePlane,
    updateCone: updateCone,
    updateFlyLine: updateFlyLine,
    updateVolumeCloud: updateVolumeCloud
  };
  var transformCesiumColorToArray = function transformCesiumColorToArray(color) {
    if (!defined$1(color)) return color;
    var new_color = new Color$1(color._value.red, color._value.green, color._value.blue, color._value.alpha);
    var value = new_color.toBytes();
    return value;
  };
  var getAlign = function getAlign(verticalOrigin, horizontalOrigin) {
    // VerticalOrigin 垂直方向 horizontalOrigin:水平方向
    var _Align = 7; //居中为7 默认
    var _verticalOrigin,
      _horizontalOrigin = 0;
    if (verticalOrigin) _verticalOrigin = verticalOrigin._value;
    if (horizontalOrigin) _horizontalOrigin = horizontalOrigin._value;
    //水平方向左中右 垂直方向上中下 共9种组合 对应TextAlignType 9个类型
    if (_verticalOrigin == 0 && _horizontalOrigin == 0) _Align = 7;
    //居中
    else if (_verticalOrigin == 0 && _horizontalOrigin == 0) _Align = 7;
    //
    else if (_verticalOrigin == 0 && _horizontalOrigin == 1) _Align = 6;else if (_verticalOrigin == 0 && _horizontalOrigin == -1) _Align = 8;else if (_verticalOrigin == 1 && _horizontalOrigin == 0) _Align = 4;else if (_verticalOrigin == 1 && _horizontalOrigin == 1) _Align = 3;else if (_verticalOrigin == 1 && _horizontalOrigin == -1) _Align = 5;else if (_verticalOrigin == -1 && _horizontalOrigin == 0) _Align = 1;else if (_verticalOrigin == -1 && _horizontalOrigin == 1) _Align = 0;else if (_verticalOrigin == -1 && _horizontalOrigin == -1) _Align = 2;else _Align = 7;
    return _Align;
  };
  var getAlignNumber = function getAlignNumber(verticalOrigin, horizontalOrigin) {
    // VerticalOrigin 垂直方向 horizontalOrigin:水平方向
    var _Align = 7; //居中为7 默认
    var _verticalOrigin = verticalOrigin;
    var _horizontalOrigin = horizontalOrigin;
    //水平方向左中右 垂直方向上中下 共9种组合 对应TextAlignType 9个类型
    if (_verticalOrigin == 0 && _horizontalOrigin == 0) _Align = 7;
    //居中
    else if (_verticalOrigin == 0 && _horizontalOrigin == 0) _Align = 7;
    //
    else if (_verticalOrigin == 0 && _horizontalOrigin == 1) _Align = 6;else if (_verticalOrigin == 0 && _horizontalOrigin == -1) _Align = 8;else if (_verticalOrigin == 1 && _horizontalOrigin == 0) _Align = 4;else if (_verticalOrigin == 1 && _horizontalOrigin == 1) _Align = 3;else if (_verticalOrigin == 1 && _horizontalOrigin == -1) _Align = 5;else if (_verticalOrigin == -1 && _horizontalOrigin == 0) _Align = 1;else if (_verticalOrigin == -1 && _horizontalOrigin == 1) _Align = 0;else if (_verticalOrigin == -1 && _horizontalOrigin == -1) _Align = 2;else _Align = 7;
    return _Align;
  };
  var getVerticalHorizontal = function getVerticalHorizontal(Align) {
    var VerticalHorizontal = [];
    switch (Align) {
      case 0:
        VerticalHorizontal = [-1, 1];
        break;
      case 1:
        VerticalHorizontal = [-1, 0];
        break;
      case 2:
        VerticalHorizontal = [-1, -1];
        break;
      case 3:
        VerticalHorizontal = [1, 1];
        break;
      case 4:
        VerticalHorizontal = [1, 0];
        break;
      case 5:
        VerticalHorizontal = [1, -1];
        break;
      case 6:
        VerticalHorizontal = [0, 1];
        break;
      case 7:
        VerticalHorizontal = [0, 0];
        break;
      case 8:
        VerticalHorizontal = [0, -1];
        break;
      default:
        VerticalHorizontal = [0, 0];
    }
    return VerticalHorizontal;
  };
  var creatRenderPoint2D = function creatRenderPoint2D(position, options) {
    var _options$point = options.point,
      color = _options$point.color,
      pixelSize = _options$point.pixelSize;
    var point = new PIEPoint({
      point: position
    });
    var _pixelSize = defaultValue$1(pixelSize === null || pixelSize === void 0 ? void 0 : pixelSize._value, 1);
    var renderPoint = new PIERenderPoint({
      point: point,
      color: defaultValue$1(transformCesiumColorToArray(color), [255, 0, 0, 255]),
      size: [_pixelSize, _pixelSize],
      type: PIEPointType.Icon,
      align: PIEPointAlignType.BottomCenter,
      style: POINTICONID
    });
    renderPoint.getStyle().enablePointColor(true);
    return renderPoint;
  };
  var creatRenderPoint3D = function creatRenderPoint3D(position, options) {
    var _options$point2 = options.point,
      color = _options$point2.color,
      pixelSize = _options$point2.pixelSize;
    var point = new PIEPoint3D({
      point: position
    });
    var _pixelSize = defaultValue$1(pixelSize === null || pixelSize === void 0 ? void 0 : pixelSize._value, 1);
    var renderPoint = new PIERenderPoint3D({
      point3D: point,
      color: defaultValue$1(transformCesiumColorToArray(color), [255, 0, 0, 255]),
      size: [_pixelSize, _pixelSize],
      type: PIEPointType.Icon,
      align: PIEPointAlignType.BottomCenter,
      style: POINTICONID
    });
    renderPoint.getStyle().enablePointColor(true);
    return renderPoint;
  };
  var creatRenderPolyline2D = function creatRenderPolyline2D(globe, positions, options) {
    var _options$polyline = options.polyline,
      material = _options$polyline.material,
      color = _options$polyline.color,
      width = _options$polyline.width;
    var points = [];
    positions.map(function (it) {
      var cartographic = Cartographic.fromCartesian(it);
      var longitude = cartographic.longitude,
        latitude = cartographic.latitude;
        cartographic.height;
      var x = CesiumMath.toDegrees(longitude);
      var y = CesiumMath.toDegrees(latitude);
      var pointSR = globe.getSpatialReference().forward([x, y]);
      points.push(pointSR[0]);
      points.push(pointSR[1]);
    });
    var polyline = new PIEPolyline({
      points: points
    });
    var renderPolyline = new PIERenderPolyline({
      polyline: polyline,
      color: defaultValue$1(transformCesiumColorToArray(material || color), [255, 0, 0, 255]),
      width: defaultValue$1(width === null || width === void 0 ? void 0 : width._value, 1)
    });
    return renderPolyline;
  };
  var creatRenderPolyline3D = function creatRenderPolyline3D(globe, positions, options) {
    var _options$polyline2 = options.polyline,
      material = _options$polyline2.material,
      color = _options$polyline2.color,
      width = _options$polyline2.width;
    var points = [];
    positions.map(function (it) {
      var cartographic = Cartographic.fromCartesian(it);
      var longitude = cartographic.longitude,
        latitude = cartographic.latitude,
        height = cartographic.height;
      var x = CesiumMath.toDegrees(longitude);
      var y = CesiumMath.toDegrees(latitude);
      var pointSR = globe.getSpatialReference().forward([x, y]);
      points.push(pointSR[0]);
      points.push(pointSR[1]);
      points.push(height);
    });
    var polyline3D = new PIEPolyline3D({
      points: points
    });
    var renderPolyline = new PIERenderPolyline3D({
      polyline3D: polyline3D,
      color: defaultValue$1(transformCesiumColorToArray(material || color), [255, 0, 0, 255]),
      // width: width.getValue(),
      width: defaultValue$1(width === null || width === void 0 ? void 0 : width._value, 1),
      type: PIELineType.Null,
      style: 7
    });
    return renderPolyline;
  };
  var creatRenderPolygon2D = function creatRenderPolygon2D(globe, positions, options) {
    var points = [];
    positions.map(function (it) {
      var cartographic = Cartographic.fromCartesian(it);
      var longitude = cartographic.longitude,
        latitude = cartographic.latitude;
        cartographic.height;
      var x = CesiumMath.toDegrees(longitude);
      var y = CesiumMath.toDegrees(latitude);
      var pointSR = globe.getSpatialReference().forward([x, y]);
      points.push(pointSR[0]);
      points.push(pointSR[1]);
    });
    var polygon = new PIEPolygon({
      points: points
    });
    var renderPolygon = new PIERenderPolygon({
      polygon: polygon,
      color: defaultValue$1(transformCesiumColorToArray(options.polygon.material || options.polygon.color), [255, 0, 0, 255])
    });
    return renderPolygon;
  };
  var creatRenderPolygon3D = function creatRenderPolygon3D(globe, positions, options) {
    var _options$polygon$heig, _options$polygon$perP;
    var _options$polygon = options.polygon,
      material = _options$polygon.material,
      color = _options$polygon.color;
    var height = defaultValue$1((_options$polygon$heig = options.polygon.height) === null || _options$polygon$heig === void 0 ? void 0 : _options$polygon$heig._value, 1);
    var points = [];
    var _perPositionHeight = defaultValue$1((_options$polygon$perP = options.polygon.perPositionHeight) === null || _options$polygon$perP === void 0 ? void 0 : _options$polygon$perP._value, false);
    positions.map(function (it) {
      var cartographic = Cartographic.fromCartesian(it);
      var longitude = cartographic.longitude,
        latitude = cartographic.latitude;
      var x = CesiumMath.toDegrees(longitude);
      var y = CesiumMath.toDegrees(latitude);
      var pointSR = globe.getSpatialReference().forward([x, y]);
      points.push(pointSR[0]);
      points.push(pointSR[1]);
      if (_perPositionHeight) {
        points.push(cartographic.height);
      } else {
        points.push(height);
      }
    });
    var polygon3D = new PIEPolygon3D({
      points: points
    });
    var renderPolygon = new PIERenderPolygon3D({
      polygon3D: polygon3D,
      color: defaultValue$1(transformCesiumColorToArray(material || color), [255, 0, 0, 255])
    });
    return renderPolygon;
  };
  var creatRenderRectangle2D = function creatRenderRectangle2D(globe, positions, options) {
    var color = options.rectangle.color;
    var coordinates = [];
    if (positions.length === 4) {
      coordinates = [[positions[0], positions[1]], [positions[2], positions[1]], [positions[2], positions[3]], [positions[0], positions[3]], [positions[0], positions[1]]];
    } else {
      throw new RuntimeError("Rectangele's coordinates must be a array of 4 ");
    }
    var points = [];
    coordinates.map(function (it) {
      var pointSR = globe.getSpatialReference().forward([it[0], it[1]]);
      points.push(pointSR[0]);
      points.push(pointSR[1]);
    });
    var polygon = new PIEPolygon({
      points: points
    });
    var renderPolygon = new PIERenderPolygon({
      polygon: polygon,
      color: defaultValue$1(transformCesiumColorToArray(color), [255, 0, 0, 255])
    });
    return renderPolygon;
  };
  var creatRenderRectangle3D = function creatRenderRectangle3D(globe, positions, options) {
    var _options$rectangle = options.rectangle,
      color = _options$rectangle.color,
      _options$rectangle$he = _options$rectangle.height,
      height = _options$rectangle$he === void 0 ? 1000 : _options$rectangle$he;
    var coordinates = [];
    if (positions.length === 4) {
      coordinates = [[positions[0], positions[1]], [positions[2], positions[1]], [positions[2], positions[3]], [positions[0], positions[3]], [positions[0], positions[1]]];
    } else {
      throw new RuntimeError("Rectangele's coordinates must be a array of 4 ");
    }
    var points = [];
    coordinates.map(function (it) {
      var pointSR = globe.getSpatialReference().forward([it[0], it[1]]);
      points.push(pointSR[0]);
      points.push(pointSR[1]);
      points.push(height);
    });
    var polygon3D = new PIEPolygon3D({
      points: points
    });
    var renderPolygon = new PIERenderPolygon3D({
      polygon3D: polygon3D,
      color: defaultValue$1(transformCesiumColorToArray(color), [255, 0, 0, 255])
    });
    return renderPolygon;
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * 参考系类型枚举
   * @readonly
   * @enum {number}
   */
  var SpatialRefType = {
    /**自定义平面坐标系*/
    USERPLANAR: 0,
    /**地理坐标系*/
    GEOGRAPHIC: 1,
    /**投影坐标系*/
    PROJECTION: 2
  };
  var SpatialRefType$1 = Object.freeze(SpatialRefType);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 
   * @class ReferenceTranslator
   * 空间参考转换器操作函数
   *
   */
  var ReferenceTranslator = /*#__PURE__*/function () {
    /**
     * 创建空间参考转换器
     * @param {PIEReferenceTranslator} handle 
     * 
     */
    function ReferenceTranslator(handle) {
      _classCallCheck(this, ReferenceTranslator);
      _defineProperty(this, "_ReferenceTranslator", void 0);
      if (handle == null) {
        this._ReferenceTranslator = new PIEReferenceTranslator();
      } else {
        if (handle != null) {
          this._ReferenceTranslator = handle;
        } else {
          this._ReferenceTranslator = new PIEReferenceTranslator();
        }
      }
    }
    _createClass(ReferenceTranslator, [{
      key: "handle",
      get: function get() {
        return this._ReferenceTranslator;
      }
      /**
       * 获取转换器
       * @memberof ReferenceTranslator
       * @returns {PIEReferenceTranslator}
       */
    }, {
      key: "getHandle",
      value: function getHandle() {
        return this._ReferenceTranslator;
      }
      /**
       * 删除空间参考转换器
       * 
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this._ReferenceTranslator.dispose();
      }
      /**
       * 设置源空间参考系
       * @memberof ReferenceTranslator
       * @param {SpatialReference} spatialReference -空间参考系对象
       * 
       * @returns {boolean} 返回是否设置成功
       *
       */
    }, {
      key: "setCoordSysSrc",
      value: function setCoordSysSrc(spatialReference) {
        return this._ReferenceTranslator.setCoordSysSrc(spatialReference.getHandle());
      }
      /**
       * 设置目标坐标系
       * @memberof ReferenceTranslator
       * @param {SpatialReference} spatialReference -空间参考系对象
       * 
       * @returns {boolean} 返回是否设置成功
       */
    }, {
      key: "setCoordSysDes",
      value: function setCoordSysDes(spatialReference) {
        return this._ReferenceTranslator.setCoordSysDes(spatialReference.getHandle());
      }
      /**
       * 点坐标转换
       * @memberof ReferenceTranslator
       * @param {} point -坐标点
       * @param {boolean} forward - 标识正算或反算(true-正算：即源参考系转换为目标参考系；false-反算：即目标参考系转换为源参考系)
       * @returns {Vector2} 转换成功返回Vector2点对象，失败返回null
       */
    }, {
      key: "translatePoint",
      value: function translatePoint(point, forward) {
        if (forward == undefined) {
          forward = true;
        }
        if (!point) return null;
        if (point instanceof Cartesian2) {
          var ARRPoint = [point.x, point.y];
          var retPoint = this._ReferenceTranslator.translatePoint(ARRPoint, forward);
          return new Cartesian2(retPoint.x, retPoint.y);
        } else {
          var repoint = this._ReferenceTranslator.translatePoint(point, forward);
          if (repoint) return [repoint.x, repoint.y];
        }
        return null;
      }
      /**
       * 范围坐标转换
       * 超出转换范围时，搜索并截取最大有效范围
       * @memberof ReferenceTranslator
       * @param {} rcBounds -范围
       * @param {boolean} forward - 标识正算或反算，默认正算(true-正算：即源参考系转换为目标参考系；false-反算：即目标参考系转换为源参考系)
       * @returns {Bounds} 转换成功返回Bounds对象，失败返回null
       */
    }, {
      key: "translateBounds",
      value: function translateBounds(rcBounds, forward) {
        if (forward == undefined) {
          forward = true;
        }
        var reBounds = this._ReferenceTranslator.translateBounds(rcBounds, forward);
        if (reBounds) return [reBounds.left, reBounds.top, reBounds.right, reBounds.bottom];
        return null;
      }
    }]);
    return ReferenceTranslator;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 
   * @class SpatialReference
   * 空间参考系操作函数
   *
   */
  var SpatialReference = /*#__PURE__*/function () {
    /**
     * SpatialReference类的构造函数
     * @param {SpatialReference} handle 
     */
    function SpatialReference(handle) {
      _classCallCheck(this, SpatialReference);
      _defineProperty(this, "_SpatialReference", void 0);
      if (handle != null) {
        this._SpatialReference = handle;
      }
    }
    _createClass(SpatialReference, [{
      key: "handle",
      get: function get() {
        return this._SpatialReference;
      }
      /**
       * 获取空间参考
       * @memberof SpatialReference
       * @returns {PIEReferenceTranslator}
       */
    }, {
      key: "getHandle",
      value: function getHandle() {
        return this._SpatialReference;
      }
      /**
       * 删除坐标系统对象
       * @memberof SpatialReference
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this._SpatialReference.dispose();
      }
      /**
       * 将坐标系统输出为WKT格式
       * @memberof SpatialReference
       * @returns {String} 返回是否成功将坐标系统输出为WKT字符串
       */
    }, {
      key: "toWKT",
      value: function toWKT() {
        return this._SpatialReference.toWKT();
      }
      /**
       * 经纬度坐标转投影坐标
       * @memberof SpatialReference
       * @param  {Cartesian2} point -待转换的经纬度坐标点
       * @returns {Cartesian2} 返回转换后的投影坐标点
       */
    }, {
      key: "forward",
      value: function forward(point) {
        //待确认入参与返回值
        // Cartesian2(12956475.533429114, 4779131.18122614)
        if (!point) return null;
        if (point instanceof Cartesian2) {
          // const cartographic = Cartographic.fromCartesian(point);
          // const { longitude, latitude, height } = cartographic;
          // const x = CesiumMath.toDegrees(longitude);
          // const y = CesiumMath.toDegrees(latitude);
          var ARRPoint = [point.x, point.y];
          var retPoint = this._SpatialReference.forward(ARRPoint);
          return new Cartesian2(retPoint[0], retPoint[1]);
        } else {
          return this._SpatialReference.forward(point);
        }
      }
      /**
       * 投影坐标转经纬度坐标
       * @memberof SpatialReference
       * @param {Cartesian2} point -待转换的投影坐标点
       * @returns {Cartesian2} 返回转换后的经纬度坐标点
       */
    }, {
      key: "inverse",
      value: function inverse(point) {
        //待确认入参与返回值
        if (!point) return null;
        if (point instanceof Cartesian2) {
          var ARPoint = [point.x, point.y];
          var retPoint = this._SpatialReference.inverse(ARPoint);
          if (!retPoint) return null;else return new Cartesian2(retPoint[0], retPoint[1]);
        } else {
          return this._SpatialReference.inverse(point);
          // if (!rePoint) return null;
          // else
          //     return new Cartesian2(rePoint[0],rePoint[1]);
        }
      }

      /**
       * 经纬度范围转投影范围
       * @memberof SpatialReference
       * @param {Array} bounds -待转换的范围
       * @returns {Array} 返回转换后的范围
       */
    }, {
      key: "forwardBounds",
      value: function forwardBounds(bounds) {
        return this._SpatialReference.forwardBounds(bounds);
      }
      /**
       * 投影范围转经纬度范围
       * @memberof SpatialReference
       * @param {Array} bounds -待转换的范围
       * @returns {Array} 返回转换后的范围
       */
    }, {
      key: "inverseBounds",
      value: function inverseBounds(bounds) {
        return this._SpatialReference.inverseBounds(bounds);
      }

      /**
       * 获取坐标系统的空间坐标系类型
       * @memberof SpatialReference
       * @returns {SpatialRefType} 返回的空间坐标系类型
       */
    }, {
      key: "getType",
      value: function getType() {
        return this._SpatialReference.getType();
      }
    }, {
      key: "type",
      get: function get() {
        return this._SpatialReference.getType();
      }
      /**
       * 获取坐标系名称
       * @memberof SpatialReference
       * @returns {String} 返回的坐标系名称
       */
    }, {
      key: "getName",
      value: function getName() {
        return this._SpatialReference.getName();
        // var strName = new PIEString(256);
        // Module._SpatialReference_GetName(this.handle, strName.getHandle());
        // var name = strName.toString();
        // strName.dispose();
        // return name;
      }
    }, {
      key: "name",
      get: function get() {
        return this._SpatialReference.getName();
      }
      /**
       * 判断两个坐标系统是否相同
       * @memberof SpatialReference
       * @param {SpatialReference} SpatialReference -目标坐标系统对象
       *
       * @returns {Boolean} true表示相同，false表示不相同
       */
    }, {
      key: "isSame",
      value: function isSame(_SpatialReference) {
        return this._SpatialReference.isSame(_SpatialReference);
      }
      /**
       * 根据EPSG代码从CRS库中读取坐标系统
       * @memberof SpatialReference
       * @param {Number} code -EPSG代码
       * @returns {SpatialReference} 返回坐标系统对象
       */
    }, {
      key: "fromEpsg",
      value: function fromEpsg(code) {
        return new SpatialReference(PIESpatialReference.fromEpsg(code));

        // return  SpatialReference.fromEpsg(code);
      }
    }, {
      key: "createWebMercator",
      value:
      /**
       * 创建Web Mercator坐标系统对象
       * @memberof SpatialReference
       * @returns {SpatialReference} 返回新建的坐标系统对象
       */
      function createWebMercator() {
        return new SpatialReference(PIESpatialReference.createWebMercator());
        // return SpatialReference.createWebMercator();
      }
    }, {
      key: "createChina2000",
      value:
      /**
       * 创建CGCS2000坐标系统对象
       * @memberof SpatialReference
       * @returns {SpatialReference} 返回新建的坐标系统对象
       */
      function createChina2000() {
        // return   SpatialReference.createChina2000();
        return new SpatialReference(PIESpatialReference.createChina2000());
      }
    }, {
      key: "createWGS1984",
      value:
      /**
       * 创建WGS84坐标系统对象
       * @memberof SpatialReference
       * @returns {SpatialReference} 返回新建的坐标系统对象
       */
      function createWGS1984() {
        return new SpatialReference(PIESpatialReference.createWGS1984());
        // return  SpatialReference.createWGS1984();
      }
    }, {
      key: "CreateAlbersConicEqualArea",
      value:
      /**
       * 创建AlbersConicEqualArea坐标系统对象
       * @memberof SpatialReference
       * @param {Number} left -bounds
       * @param {Number} right -bounds
       * @param {Number} top -bounds
       * @param {Number} bottom -bounds
       * @returns {SpatialReference} 返回新建的坐标系统对象
       */
      function CreateAlbersConicEqualArea(spatialReference, left, right, top, bottom) {
        return new SpatialReference(PIESpatialReference.CreateAlbersConicEqualArea(spatialReference, left, right, top, bottom));
      }
    }, {
      key: "fromWKT",
      value:
      /**
       * 从WKT中读取坐标系统
       * @memberof SpatialReference
       * @param {String} wkt -WKT字符串
       * @returns {SpatialReference} 返回坐标系统对象
       */
      function fromWKT(wkt) {
        return new SpatialReference(PIESpatialReference.fromWKT(wkt));
        // return SpatialReference.fromWKT(wkt);
      }
    }], [{
      key: "fromEpsg",
      value: function fromEpsg(code) {
        return new SpatialReference(PIESpatialReference.fromEpsg(code));

        // return  SpatialReference.fromEpsg(code);
      }
    }, {
      key: "createWebMercator",
      value: function createWebMercator() {
        return new SpatialReference(PIESpatialReference.createWebMercator());
        // return SpatialReference.createWebMercator();
      }
    }, {
      key: "createChina2000",
      value: function createChina2000() {
        // return   SpatialReference.createChina2000();
        return new SpatialReference(PIESpatialReference.createChina2000());
      }
    }, {
      key: "createWGS1984",
      value: function createWGS1984() {
        return new SpatialReference(PIESpatialReference.createWGS1984());
        // return  SpatialReference.createWGS1984();
      }
    }, {
      key: "CreateAlbersConicEqualArea",
      value: function CreateAlbersConicEqualArea(spatialReference, left, right, top, bottom) {
        return new SpatialReference(PIESpatialReference.CreateAlbersConicEqualArea(spatialReference, left, right, top, bottom));
      }
    }, {
      key: "fromWKT",
      value: function fromWKT(wkt) {
        return new SpatialReference(PIESpatialReference.fromWKT(wkt));
        // return SpatialReference.fromWKT(wkt);
      }
    }]);
    return SpatialReference;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * @class Globe
   * 场景中渲染的地球，包括其地形（terrainProvider ）和影像图层（imageryLayers）。
   */
  var Globe = /*#__PURE__*/function () {
    // _referenceTranslator;

    /**
     * 创建场景中的地球
     * @param {Ellipsoid} ellipsoid -确定地球尺寸和形状
     */
    function Globe(ellipsoid) {
      _classCallCheck(this, Globe);
      _defineProperty(this, "_pieGlobeControl", void 0);
      _defineProperty(this, "_pieGlobe", void 0);
      _defineProperty(this, "_ellipsoid", void 0);
      _defineProperty(this, "_spatialReference", void 0);
      _defineProperty(this, "_spatialRefType", void 0);
      _defineProperty(this, "baseColor", void 0);
      _defineProperty(this, "atmosphere", void 0);
      _defineProperty(this, "lighting", void 0);
      this._ellipsoid = defaultValue$1(ellipsoid, Ellipsoid$1.WGS84);
      // this._referenceTranslator=new ReferenceTranslator();
      this._spatialRefType = SpatialRefType$1;
    }
    /**
     * 设置三维场景控制器
     * @param {PieGlobeControl} value
     */
    _createClass(Globe, [{
      key: "pieGlobeControl",
      set: function set(value) {
        this._pieGlobeControl = value;
        this._spatialReference = new SpatialReference(value.getGlobe().getSpatialReference());
      }
      /**
       * 获取描述此地球形状的椭圆体
       * @returns {Ellipsoid}
       */
    }, {
      key: "ellipsoid",
      get: function get() {
        return this._ellipsoid;
      }
      /**
       * 获取空间参考
       * @returns {SpatialReference}
       */
    }, {
      key: "spatialReference",
      get: function get() {
        return this._spatialReference;
      }
      // get referenceTranslator() {
      //   return this._referenceTranslator;
      // }
      /**
       * 确定是否显示地球
       * @param {Boolean}boolean
       */
    }, {
      key: "show",
      get:
      /**
       * 获取是否显示地球
       * @returns {Boolean}
       */
      function get() {
        return this._pieGlobe.isEnableGlobe();
      }
      /**
       * 设置是否绘制地球上的地面大气
       * @param {Boolean}boolean
       */,
      set: function set(_boolean) {
        this._pieGlobe.setEnableGlobe(_boolean);
      }
    }, {
      key: "showGroundAtmosphere",
      get:
      /**
       * 获取是否绘制地球上的地面大气
       * @returns {Boolean}
       */
      function get() {
        var pieAtmosphere = this._pieGlobe.getAtmosphere();
        return pieAtmosphere.isVisible();
      }
      /**
       * 设置地形放大系数
       * @param {Number}scale
       */,
      set: function set(_boolean2) {
        var pieAtmosphere = this._pieGlobe.getAtmosphere();
        pieAtmosphere.setVisible(_boolean2);
      }
    }, {
      key: "terrainExaggeration",
      get:
      /**
       * 获取放大系数
       * @returns {Number}
       */
      function get() {
        var pieGlobeModel = this._pieGlobe.getGlobeModel();
        return pieGlobeModel.getTerrainScale();
      }
      /**
       * 设置是否启用光照
       * @param {Boolean}boolean
       */,
      set: function set(scale) {
        var pieGlobeModel = this._pieGlobe.getGlobeModel();
        pieGlobeModel.setTerrainScale(scale);
      }
    }, {
      key: "enableLighting",
      get:
      /**
       * 获取是否启用光照
       * @returns {Boolean}
       */
      function get() {
        var PIESunLight = this._pieGlobe.getSunLight();
        return PIESunLight.isVisible();
      }
      /**
       * 获取像素比例
       * @returns {Number}
       */,
      set: function set(_boolean3) {
        var PIESunLight = this._pieGlobe.getSunLight();
        PIESunLight.setVisible(_boolean3);
      }
    }, {
      key: "pixelRatio",
      get: function get() {
        return this._pieGlobeControl.getPixelRatio();
      }

      /**
       * 当前显示设备的物理像素分辨率与CSS像素分辨率之比
       */,
      set: function set(val) {
        this._pieGlobeControl.setPixelRatio(val);
      }
      /**
       * 设置球体工具
       * @param {GlobeTool} tool 用户操作类型
       */
    }, {
      key: "setGlobeTool",
      value: function setGlobeTool(tool) {
        if (defined$1(tool)) {
          this._pieGlobeControl.setGlobeTool(tool);
        }
      }
      /**
       * 获取用户操作类型
       * @memberOf Globe#
       * @returns {GlobeTool} -返回用户当前指定工具对象
       *
       */
    }, {
      key: "getGlobeTool",
      value: function getGlobeTool() {
        var tool = this._pieGlobeControl.getGlobeTool();
        return tool;
      }
      /**
       * 获取给定制图上的表面高度
       * @param {Cartographic} position 要查找高度的制图
       * @returns {Number|undefined} -返回高度
       */
    }, {
      key: "getHeight",
      value: function getHeight(position) {
        if (position instanceof Cartographic) {
          var lon = position.longitude / Math.PI * 180;
          var lat = position.latitude / Math.PI * 180;
          var pieCamera = this._pieGlobe.getWorldCamera();
          var pieSceneMode = this._pieGlobe.getSceneMode();
          var pieSpatialReference = this._pieGlobe.getSpatialReference();
          return pieCamera.getHPElevation(pieSceneMode, pieSpatialReference.forward([lon, lat]));
        } else {
          throw new DeveloperError$1('position must be a Cartographic.');
        }
      }
      // 设备坐标 -> 经纬度 -> Cartesian3
      /**
       * 找到射线与渲染的地球表面之间的交点
       * @param {Array} position
       * @returns {Cartesian3 |undefined} -返回交点或未定义（如果未找到交点）。
       */
    }, {
      key: "pick",
      value: function pick(position) {
        if (position instanceof Array) {
          var mapPoint = this._pieGlobe.deviceToMap(position);
          var geoPoint = this._pieGlobe.mapToGeo(mapPoint);
          return Cartesian3.fromDegrees(geoPoint.x, geoPoint.y);
        } else {
          throw new DeveloperError$1('position must be an Array.');
        }
      }
      /**
       * 世界坐标换算成像素坐标
       * @param {Cartesian3} worldPoint -世界坐标点
       * @memberOf Globe
       *
       * @returns {Cartesian2} 像素坐标点
       */
    }, {
      key: "worldToDevice",
      value: function worldToDevice(worldPoint) {
        var deviceVec = this._pieGlobe.worldToDevice([worldPoint.x, worldPoint.y, worldPoint.z]);
        return new Cartesian2(deviceVec.x, deviceVec.y);
      }
      /**
       * 鼠标滚轮事件响应
       * @param {Object} e -
       * @param {Number} e.detail -返回数字，表示当前点击次数加一
       * @param {Number} e.wheelDelta -返回鼠标滚轮的滚动量
       * @memberOf Globe
       *
       */
    }, {
      key: "onMouseWheel",
      value: function onMouseWheel(e) {
        this._pieGlobeControl.onMouseWheel(e);
      }

      /**
       * 鼠标按下事件响应
       * @param {Object} e -
       * @param {Number} e.button -返回触发鼠标事件时按下的鼠标按钮
       * @memberOf Globe
       *
       */
    }, {
      key: "onMouseDown",
      value: function onMouseDown(e) {
        this._pieGlobeControl.onMouseDown(e);
      }

      /**
       * 鼠标移动事件响应
       * @param {Object} event -
       * @param {Number} event.clientX -返回触发鼠标事件时，鼠标指针相对于当前窗口的水平坐标（根据客户端区域）
       * @param {Number} event.clientY -返回触发鼠标事件时，鼠标指针相对于当前窗口的垂直坐标（根据客户端区域）
       * @memberOf Globe
       *
       */
    }, {
      key: "onMouseMove",
      value: function onMouseMove(e) {
        this._pieGlobeControl.onMouseMove(e);
      }

      /**
       * 鼠标抬起事件响应
       * @param {Object} event -
       * @param {Number} event.clientX -返回触发鼠标事件时，鼠标指针相对于当前窗口的水平坐标（根据客户端区域）
       * @param {Number} event.clientY -返回触发鼠标事件时，鼠标指针相对于当前窗口的垂直坐标（根据客户端区域）
       * @memberOf Globe
       *
       */
    }, {
      key: "onMouseUp",
      value: function onMouseUp(e) {
        this._pieGlobeControl.onMouseUp(e);
      }

      /**
       * 刷新地图窗口
       * @param {Boolean} forceRefresh = false <code>optional</code> 标识是否强制刷新(设置为true时，会主动调用异步绘制，所有图层强制刷新)
       * @param {Boolean} clearCache = false <code>optional</code> 标识是否清除缓存(设置为true时，会清除所有图层缓存，图层做的修改会立即生效)
       */
    }, {
      key: "refresh",
      value: function refresh() {
        var forceRefresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var clearCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this._pieGlobe.refresh(forceRefresh, clearCache);
      }
    }]);
    return Globe;
  }();

  var TYPES = ['point', 'polyline', 'polygon', 'label', 'billboard', 'ellipse', 'ellipsoid', 'rectangle', 'model', 'box', 'polylineVolume', 'plot', 'overlayImage', 'particleSystem', 'weatherSystem', 'cone', 'circle', 'plane', 'pixelLine', 'heatMap', 'densityMap', 'labelBox', 'flyLine', 'volumeCloud'];
  var threeTypes = ['box', 'ellipsoid', 'polylineVolume', 'model', 'particleSystem', 'weatherSystem', 'cone', 'circle', 'plane', 'pixelLine', 'volumeCloud'];
  var pointTypes = ['point', 'label', 'overlayImage', 'billboard', 'model'];
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * @class EntityCollection
   * 实体集合类
   */
  var EntityCollection = /*#__PURE__*/function () {
    /**
     * EntityCollection类的构造函数
     * @param {Camera} camera 相机
     * @param {ThreeLayer} threeLayer three图层
     */
    function EntityCollection(_ref) {
      var camera = _ref.camera,
        threeLayer = _ref.threeLayer;
      _classCallCheck(this, EntityCollection);
      _defineProperty(this, "_entities", []);
      _defineProperty(this, "_renderableLayer", void 0);
      _defineProperty(this, "_graphicsLayer", void 0);
      _defineProperty(this, "_threeViewer", void 0);
      _defineProperty(this, "_threelayer", void 0);
      _defineProperty(this, "_threeEarth", void 0);
      _defineProperty(this, "_pieGlobe", void 0);
      _defineProperty(this, "_addEventPin", 0);
      this._id = createGuid();
      this._renderableLayer = new PIEGlobeRenderableLayer();
      this._renderableLayer.setSelectable(true);
      this._renderableLayer.setName('EntityCollection');
      this._graphicsLayer = new PIEGlobeGraphicsLayer();
      this._graphicsLayer.setSelectable(true);
      this._graphicsLayer.setName('EntityOverlayImage');
      // this._threelayer = new PrimitiveCollection();
      this._threelayer = threeLayer;
      this._threeEarth = camera;
      //UI图层
      this._webLayer = [];
      // this._globe = options.pieGlobe;
    }

    /** 
     * 设置three图层
     * @param {ThreeLayer} threeLayer
     */
    _createClass(EntityCollection, [{
      key: "threeLayer",
      set: function set(threeLayer) {
        this._threelayer = threeLayer;
      }
      // initThreeLayer(threeViewer) {
      //   this._threeViewer = threeViewer;
      //   threeViewer.add(this._threelayer);
      // }
      /**
       * 初始化UI图层
       * @memberof EntityCollection
       * @param {Array} webLayer UI图层
       */
    }, {
      key: "initWebLayer",
      value: function initWebLayer(webLayer) {
        this._webLayer = webLayer;
      }
      /** 
       * 设置三维场景
       * @memberof EntityCollection
       * @param {PieGlobe} value
       */
    }, {
      key: "pieGlobe",
      set: function set(value) {
        this._pieGlobe = value;
        this._pieGlobe.addLayer(this._renderableLayer, true);
        this._pieGlobe.addLayer(this._graphicsLayer, true);
      }
    }, {
      key: "pieGlobeControl",
      set: function set(value) {
        // const threeViewer = new ThreeViewer(value);
        // this._threeEarth = threeViewer.threeEarth;
        // this._threelayer = new EntityLayer();
        // threeViewer.add(this._threelayer);
        // this._threeViewer = threeViewer;
      }
      /**
       * 异步操作来加载资源
       * @memberof EntityCollection
       */
    }, {
      key: "beforeAdd",
      value: function () {
        var _beforeAdd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var symbolLib, symbolGroup, iconOptions, iconSymbol, icon;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                symbolLib = this._globe.getDocument().getSymbolLib(); //获取符号库
                symbolGroup = symbolLib.getGroup(PIESymbolGroupType.Icon); //获取符号组
                iconOptions = {
                  //   url: 'Resource/SymbolLib/System/handlePoint.png',
                  url: 'Resource/SymbolLib/System/04.png',
                  id: POINTICONID,
                  name: 'pointIcon'
                };
                iconSymbol = new PIEIconSymbol();
                _context.next = 6;
                return iconSymbol.load(iconOptions).then(function (value) {
                  symbolGroup.add(value);
                });
              case 6:
                icon = symbolGroup.getByID(POINTICONID);
                console.log(icon);
              case 8:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function beforeAdd() {
          return _beforeAdd.apply(this, arguments);
        }
        return beforeAdd;
      }()
      /**
       * 将实体添加到集合中
       * @memberof EntityCollection
       * @param {Entity} entity 要添加的实体
       * @returns {Entity} 添加的实体。
       */
    }, {
      key: "add",
      value: function add(entity) {
        var _this = this;
        if (!defined$1(entity)) {
          throw new DeveloperError('entity is required.');
        }
        if (!(entity instanceof Entity)) {
          entity = new Entity(entity);
        }
        //将entity中的primitiveInstance添加
        this._threelayer.add(entity.primitiveInstance);
        var id = entity.id;
        var entities = this._entities;
        var findIndex = entities.findIndex(function (item) {
          return item.id == entity.id;
        });
        if (findIndex > -1) {
          throw new RuntimeError("An entity with id ".concat(id, " already exists in this collection."));
        }
        entity.entityCollection = this;
        entities.push(entity);
        TYPES.map(function (prop) {
          if (defined$1(entity[prop])) {
            //判断点的position
            var skipAdd = false;
            if (!defined$1(entity.position) && pointTypes.includes(prop)) {
              skipAdd = true;
            }
            if (!skipAdd) {
              var funName = 'add' + prop[0].toUpperCase() + prop.substring(1);
              createProperties[funName](_this._pieGlobe, getLayer.call(_this, prop, entity), entity, _this._threeEarth);
            }
            _this._addEventListeners(_this._pieGlobe, entity, prop);
          }
        });
        entity.definitionChanged.addEventListener(function (scope, name, value, oldValue) {
          switch (name) {
            case 'position':
              //point label billboard overlayImage plot box  model
              {
                var points = [];
                if (value instanceof Cartesian3) {
                  if (!defined$1(oldValue)) {
                    //先添加点
                    pointTypes.concat('plot').forEach(function (prop) {
                      if (defined$1(entity[prop])) {
                        var funName = 'add' + prop[0].toUpperCase() + prop.substring(1);
                        createProperties[funName](_this._pieGlobe, getLayer.call(_this, prop, entity), entity, _this._threeEarth);
                      }
                    });
                  }
                  var cartographic = Cartographic.fromCartesian(value);
                  var lon = CesiumMath.toDegrees(cartographic.longitude);
                  var lat = CesiumMath.toDegrees(cartographic.latitude);
                  var height = cartographic.height;
                  var pointSR = globe.getSpatialReference().forward([lon, lat]);
                  points.push(pointSR[0], pointSR[1], height);
                  var pointList = ['point', 'label', 'billboard', 'overlayImage', 'plot'];
                  pointList.forEach(function (item) {
                    if (defined$1(entity[item])) {
                      if (defined$1(entity[item].id)) {
                        var _id = entity[item].id;
                        var layer = _this._renderableLayer;
                        if (item == 'overlayImage') {
                          layer = _this._graphicsLayer;
                        }
                        var renderObj = layer.get(_id);
                        renderObj.setPosition(points);
                      } else {
                        //初始化后没有id时
                        var funName = 'add' + item[0].toUpperCase() + item.substring(1);
                        createProperties[funName](_this._pieGlobe, getLayer.call(_this, item, entity), entity, _this._threeEarth);
                      }
                    }
                  });
                  //获取three中的Entity
                  var primitiveInstance = entity.primitiveInstance;
                  //更新位置
                  primitiveInstance.changePosition(value);

                  //Ui相关设置
                  _this._webLayer.forEach(function (box) {
                    if (box.id === entity['labelBox'].id) {
                      box.setPosition(lon, lat, height);
                    }
                  });
                }
              }
              break;
            case 'show':
              {
                TYPES.forEach(function (prop) {
                  if (defined$1(entity[prop]) && defined$1(entity[prop].id)) {
                    var _id2 = entity[prop].id;
                    var layer = _this._renderableLayer;
                    if (prop == 'overlayImage') {
                      layer = _this._graphicsLayer;
                    }
                    if (prop == 'polygon' && defined$1(entity[prop].extrudedHeight)) {
                      var threeObj = _this._threelayer.children.find(function (ent) {
                        return ent.id == _id2;
                      });
                      if (!threeObj) {
                        return;
                      }
                      threeObj.visible = value;
                      return;
                    }
                    var renderObj = layer.get(_id2);
                    if (renderObj) {
                      renderObj.setVisible(value);
                    }
                  }
                });
                //直接让图层隐藏 ==> 还原为单个entity隐藏,全部隐藏会影响其他的entity
                //获取three中的Entity
                var _primitiveInstance = entity.primitiveInstance;
                //更新位置
                _primitiveInstance.visible = value;
                _this._webLayer.forEach(function (box) {
                  if (box.id === entity['labelBox'].id) {
                    box.show = value;
                  }
                });
              }
          }
        });
        this._pieGlobe.refresh(false, false);
        return entity;
      }
      /**
       * 从集合中删除实体
       * @memberof EntityCollection
       * @param {Entity} entity 要删除的实体
       * @returns {Boolean} -如果已删除该实体，则为true；如果该集合中不存在该实体，则为false。
       */
    }, {
      key: "remove",
      value: function remove(entity) {
        if (!defined$1(entity)) {
          return false;
        }
        return this.removeById(entity.id);
      }
      /**
       * 从集合中删除提供的ID的实体
       * @memberof EntityCollection
       * @param {String} id 要删除的实体的ID
       * @returns {Boolean} -如果已删除实体，则为true；如果集合中不存在具有提供的ID的实体，则为false。
       */
    }, {
      key: "removeById",
      value: function removeById(id) {
        var _this2 = this;
        if (!defined$1(id)) {
          return false;
        }
        var findIndex = this._entities.findIndex(function (item) {
          return item.id == id;
        });
        // this._renderableLayer.remove(this._entities[findIndex][prop].id);
        if (findIndex > -1) {
          var entity = this._entities[findIndex];
          //三维场景的直接移除
          var primitiveInstance = entity.primitiveInstance;
          if (primitiveInstance.polygonPrimitive) {
            //polygon特殊判断，用过parent移除
            primitiveInstance.parent.remove(primitiveInstance.polygonPrimitive);
          }
          this._threelayer.remove(primitiveInstance);
          TYPES.map(function (prop) {
            if (defined$1(_this2._entities[findIndex][prop]) && defined$1(_this2._entities[findIndex][prop].id)) if (threeTypes.indexOf(prop) === -1) {
              //单独判断polygon
              if (prop == 'polygon' && defined$1(_this2._entities[findIndex][prop].extrudedHeight)) ; else {
                prop == 'overlayImage' ? _this2._graphicsLayer.remove(_this2._entities[findIndex][prop].id) : _this2._renderableLayer.remove(_this2._entities[findIndex][prop].id);
              }
            }
            // else {
            //   let threeObj;
            //   let hasFind = false;
            //   if (prop == 'model') {
            //     for (let i = 0; i < this._threelayer.children.length; i++) {
            //       let item = this._threelayer.children[i];
            //       if (item.id == this._entities[findIndex][prop].id) {
            //         threeObj = item;
            //         break;
            //       }
            //     }
            //     this._threelayer.remove(threeObj);
            //   } else {
            //     for (let i = 0; i < this._threelayer.children.length; i++) {
            //       let item = this._threelayer.children[i];
            //       if (hasFind) {
            //         break;
            //       }
            //       for (let j = 0; j < item.children.length; j++) {
            //         let itemObj = item.children[j];
            //         if (itemObj.id == this._entities[findIndex][prop].id) {
            //           threeObj = itemObj;
            //           hasFind = true;
            //           break;
            //         }
            //       }
            //     }
            //     this._threelayer.remove(threeObj.parent);
            //   }

            // let threeObj = this._threelayer.children.find((ent) => {
            //   return ent.children.find((item) => {
            //     return item.id == this._entities[findIndex][prop].id;
            //   });
            //   // return ent.id == this._entities[findIndex][prop].id;
            // });
            // }
          });

          this._entities.splice(findIndex, 1);
          return true;
        } else {
          return false;
        }
      }
      /**
       * 从集合中删除所有实体
       * @memberof EntityCollection
       * @returns {Boolean} -如果已删除所有实体，则为true；否则则为false。
       */
    }, {
      key: "removeAll",
      value: function removeAll() {
        if (this._entities.length < 1) {
          return;
        }
        this._renderableLayer.removeAll();
        this._graphicsLayer.removeAll();
        this._threelayer.clear();
        this._entities.splice(0, this._entities.length);
      }
      /*
       * 添加事件监听
       * @param {Globe} globe
       * @param {Entity} entity
       * @param {Array} property
       */
    }, {
      key: "_addEventListeners",
      value: function _addEventListeners(globe, entity, property) {
        var _this3 = this;
        var funName = 'update' + property[0].toUpperCase() + property.substring(1);
        entity[property].definitionChanged.addEventListener(function (scope, name, value, oldValue) {
          updateProperties[funName](globe, getLayer.call(_this3, property, entity), {
            scope: scope,
            name: name,
            value: value,
            oldValue: oldValue,
            entity: entity
          }, _this3._threeEarth);
        }, this);
      }
    }, {
      key: "values",
      get: function get() {
        return this._entities;
      }
    }]);
    return EntityCollection;
  }();
  /**
   * 获取指定类型的图层
   * @memberof EntityCollection
   * @param {String} prop 图层类型
   * @param {Entity} entity 实体
   * @returns {Layer} 返回指定类型的图层
   */
  function getLayer(prop, entity) {
    if (prop == 'polygon' && defined$1(entity.polygon.extrudedHeight)) {
      return this._threelayer;
    } else if (prop == 'labelBox') {
      return this._webLayer;
    } else {
      return threeTypes.indexOf(prop) === -1 ? prop == 'overlayImage' ? this._graphicsLayer : this._renderableLayer : this._threelayer;
    }
  }

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 数据集类型枚举
   * @readonly
   * @enum {Number}
   */
  var DatasetType = {
    /**未知数据集*/
    UnKnown: -1,
    /**属性数据集*/
    Attribute: 0,
    /**点数据集*/
    Point: 1,
    /**线数据集*/
    Line: 3,
    /**面数据集*/
    Region: 5,
    /**文本数据集*/
    Text: 7,
    /**路线数据集*/
    LineM: 35,
    /**复杂数据集*/
    Complex: 149,
    /**栅格数据集*/
    Raster: 170,
    /**瓦片数据集*/
    Tile: 200,
    /**模型数据集*/
    Model: 210,
    /**Tiles3D数据集*/
    Tiles3D: 220,
    /**mapbox数据集*/
    MVT: 224,
    /**GE数据集*/
    GEDataModel: 300
  };
  var DatasetType$1 = Object.freeze(DatasetType);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * @class DatasetFactory
   * 数据集工厂
   */
  var DatasetFactory = /*#__PURE__*/function () {
    function DatasetFactory() {
      _classCallCheck(this, DatasetFactory);
    }
    /**
     * 创建数据集实例
     * @param {Dataset} hDataset 
     * @returns {FeatureDataset}
     */
    _createClass(DatasetFactory, null, [{
      key: "CreateInstance",
      value: function CreateInstance(hDataset) {
        if (hDataset == null) return null;
        var datasetType = hDataset.getType();
        // if (datasetType == DatasetType.Raster) {
        //     return new RasterDataset(hDataset);
        // } else if (datasetType == DatasetType.Model) {
        //     return new ModelDataset(hDataset);
        // } else if (datasetType == DatasetType.Tiles3D) {
        //     return new Tiles3DDataset(hDataset);
        // } else if (datasetType == DatasetType.GEDataModel) {
        //     return new GEDataset(hDataset);
        // } else if (datasetType == DatasetType.Point || datasetType == DatasetType.Line || datasetType == DatasetType.LineM ||
        //     datasetType == DatasetType.Region || datasetType == DatasetType.Text || datasetType == DatasetType.Complex ||
        //     datasetType == DatasetType.Attribute) {
        //     return new FeatureDataset(hDataset);
        // }else if(datasetType == DatasetType.MVT) {
        //     return new MVTDataset(hDataset);
        // }
        if (datasetType == DatasetType$1.Point || datasetType == DatasetType$1.Line || datasetType == DatasetType$1.LineM || datasetType == DatasetType$1.Region || datasetType == DatasetType$1.Text || datasetType == DatasetType$1.Complex || datasetType == DatasetType$1.Attribute) {
          return new FeatureDataset(hDataset);
        }
        return null;
      }
    }]);
    return DatasetFactory;
  }();

  var DataSource$1 = /*#__PURE__*/function () {
    function DataSource() {
      _classCallCheck(this, DataSource);
      _defineProperty(this, "_source", void 0);
      _defineProperty(this, "_layer", void 0);
    } // DeveloperError.throwInstantiationError();
    _createClass(DataSource, [{
      key: "layerHandle",
      get: function get() {
        return this._layer;
      }
    }, {
      key: "sourceHandle",
      get: function get() {
        return this._source;
      }
    }, {
      key: "name",
      get: function get() {
        return this._source.getName();
      }
    }, {
      key: "isOpen",
      get: function get() {
        return this._source.isOpen();
      }
    }, {
      key: "type",
      get: function get() {
        if (this._source) {
          return this._source.getType();
        }
        return undefined;
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._source.getType();
      }
    }, {
      key: "alias",
      get: function get() {
        return this._source.getAlias();
      },
      set: function set(value) {
        this._source.setAlias(value);
      }
    }, {
      key: "setAlias",
      value: function setAlias(value) {
        this._source.setAlias(value);
      }
    }, {
      key: "dataset",
      get: function get() {
        // return this._source.getDataset();
        var hDataset = this._source.getDataset();
        return DatasetFactory.CreateInstance(hDataset);
      }
    }, {
      key: "datasetCount",
      get: function get() {
        return this._source.getDatasetCount();
      }
    }, {
      key: "getDatasetByName",
      value: function getDatasetByName(name) {
        var hDataset = this._source.getDatasetByName(name);
        return DatasetFactory.CreateInstance(hDataset);
      }
    }, {
      key: "getDatasetAt",
      value: function getDatasetAt(index) {
        var hDataset = this._source.getDatasetAt(index);
        return DatasetFactory.CreateInstance(hDataset);
      }
    }, {
      key: "server",
      get: function get() {
        return this._source.getServer();
      }
    }, {
      key: "database",
      get: function get() {
        return this._source.getDatabase();
      }
    }, {
      key: "open",
      value: function open(options) {
        this._source.open(options);
      }
    }, {
      key: "close",
      value: function close() {
        this._source.close();
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._source.dispose();
      }
    }, {
      key: "visible",
      get: function get() {
        return this._layer.isVisible();
      },
      set: function set(value) {
        this._layer.setVisible(value);
      }
    }, {
      key: "setVisible",
      value: function setVisible(value) {
        this._layer.setVisible(value);
      }
    }, {
      key: "maxVisibleScale",
      get: function get() {
        return this._layer.getMaxVisibleScale();
      },
      set: function set(scale) {
        this._layer.setMaxVisibleScale(scale);
      }
    }, {
      key: "setMaxVisibleScale",
      value: function setMaxVisibleScale(scale) {
        this._layer.setMaxVisibleScale(scale);
      }
    }, {
      key: "minVisibleScale",
      get: function get() {
        return this._layer.getMinVisibleScale();
      },
      set: function set(scale) {
        this._layer.setMinVisibleScale(scale);
      }
    }, {
      key: "isAlwaysVisible",
      get: function get() {
        return this._layer.isAlwaysVisible();
      },
      set: function set(visible) {
        this._layer.setAlwaysVisible(visible);
      }
    }, {
      key: "setAlwaysVisible",
      value: function setAlwaysVisible(visible) {
        this._layer.setAlwaysVisible(visible);
      }
    }]);
    return DataSource;
  }();

  /**
   * @vuepress
   *
   * ---
   * title:
   * headline:
   * ---
   */

  /**
   *  矢量渲染器类型枚举
   * @readonly
   * @enum {String}
   */
  var FeatureRenderType = {
    /**  未知渲染器  */
    Null: -1,
    /**  简单矢量渲染器  */
    Simple: 1,
    /** 分段专题图  */
    ThemeRange: 3,
    /** 标签专题图  */
    ThemeLabel: 5,
    /** 唯一值专题图  */
    ThemeUnique: 7,
    /** 分类渲染器 只有分类渲染器才支持矢量沿模型显示或者分类显示  */
    Classify: 8,
    /** J图渲染器 */
    SMS: 10,
    /** H图渲染器 */
    Seamap: 11
  };
  var FeatureRenderType$1 = Object.freeze(FeatureRenderType);

  var FeatureRenderer = /*#__PURE__*/function () {
    function FeatureRenderer() {
      _classCallCheck(this, FeatureRenderer);
      _defineProperty(this, "_render", void 0);
    }
    _createClass(FeatureRenderer, [{
      key: "handle",
      get: function get() {
        return this._render;
      }
    }, {
      key: "type",
      get: function get() {
        return this._render.getType();
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._render.dispose();
      }
    }]);
    return FeatureRenderer;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 风格类型枚举
   * @readonly
   * @enum {number}
   */
  var StyleType = {
    /**空类型*/
    Null: 0,
    /**矢量风格类型*/
    Vector: 1,
    /**文本风格类型*/
    Text: 2,
    /**复合风格类型*/
    Symbol: 3
    // /**模型风格类型*/
    // Model: 4
  };

  var StyleType$1 = Object.freeze(StyleType);

  var Style = /*#__PURE__*/function () {
    function Style() {
      _classCallCheck(this, Style);
      _defineProperty(this, "_pieStyle", void 0);
    } // DeveloperError.throwInstantiationError();
    _createClass(Style, [{
      key: "handle",
      get: function get() {
        return this._pieStyle;
      }
    }, {
      key: "type",
      get: function get() {
        return this._pieStyle.getType();
      }
    }, {
      key: "name",
      get: function get() {
        return this._pieStyle.getName();
      },
      set: function set(value) {
        this._pieStyle.setName(value);
      }
    }, {
      key: "isCollision",
      get: function get() {
        return this._pieStyle.isCollision();
      },
      set: function set(value) {
        this._pieStyle.setIsCollision(value);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        return this._pieStyle.dispose();
      }
    }]);
    return Style;
  }();

  var VectorStyle = /*#__PURE__*/function (_Style) {
    _inherits(VectorStyle, _Style);
    var _super = _createSuper(VectorStyle);
    function VectorStyle(options) {
      var _this;
      _classCallCheck(this, VectorStyle);
      _this = _super.call(this);
      if (options == null) {
        _this._pieStyle = new PIEVectorStyle();
      } else {
        if (options.handle != null) {
          _this._pieStyle = options.handle;
        } else {
          options.pointColor = options.pointColor ? options.pointColor.toBytes() : null;
          options.lineColor = options.lineColor ? options.lineColor.toBytes() : null;
          options.fillColor = options.fillColor ? options.fillColor.toBytes() : null;
          options.pointSize = options.pointSize ? [options.pointSize.x, options.pointSize.y] : null;
          options.pointType = options.pointType ? options.pointType : null;
          options.pointStyle = options.pointStyle ? options.pointStyle : null;
          options.pointAlign = options.pointAlign ? options.pointAlign : null;
          options.lineWidth = options.lineWidth ? options.lineWidth : null;
          options.classifyMode = options.classifyMode ? options.classifyMode : null;
          options.altitudeMode = options.altitudeMode ? options.altitudeMode : null;
          _this._pieStyle = new PIEVectorStyle(options);
        }
      }
      return _this;
    }
    _createClass(VectorStyle, [{
      key: "pointType",
      get: function get() {
        return this._pieStyle.getPointType();
      },
      set: function set(value) {
        this._pieStyle.setPointType(value);
      }
    }, {
      key: "pointStyle",
      get: function get() {
        return this._pieStyle.getPointStyle();
      },
      set: function set(value) {
        this._pieStyle.setPointStyle(value);
      }
    }, {
      key: "pointAngle",
      get: function get() {
        return this._pieStyle.getPointAngle();
      },
      set: function set(value) {
        this._pieStyle.setPointAngle(value);
      }
    }, {
      key: "pointSize",
      get: function get() {
        var size = this._pieStyle.getPointSize();
        return Cartesian2.fromElements(size.cx, size.cy);
      },
      set: function set(value) {
        this._pieStyle.setPointSize([value.x, value.y]);
      }
    }, {
      key: "pointAlign",
      get: function get() {
        return this._pieStyle.getPointAlign();
      },
      set: function set(value) {
        this._pieStyle.setPointAlign(value);
      }
    }, {
      key: "pointColor",
      get: function get() {
        var color = this._pieStyle.getPointColor();
        return Color$1.fromBytes(color.r, color.g, color.b, color.a);
      },
      set: function set(value) {
        this._pieStyle.setPointColor(value.toBytes());
      }
    }, {
      key: "enablePointColor",
      get: function get() {
        return this._pieStyle.isEnablePointColor();
      },
      set: function set(value) {
        this._pieStyle.enablePointColor(value);
      }
    }, {
      key: "billBoardMode",
      get: function get() {
        return this._pieStyle.getBillBoardMode();
      },
      set: function set(value) {
        this._pieStyle.setBillBoardMode(value);
      }
    }, {
      key: "lineType",
      get: function get() {
        return this._pieStyle.getLineType();
      },
      set: function set(value) {
        this._pieStyle.setLineType(value);
      }
    }, {
      key: "lineStyle",
      get: function get() {
        return this._pieStyle.getLineStyle();
      },
      set: function set(value) {
        this._pieStyle.setLineStyle(value);
      }
    }, {
      key: "lineColor",
      get: function get() {
        var color = this._pieStyle.getLineColor();
        return Color$1.fromBytes(color.r, color.g, color.b, color.a);
      },
      set: function set(value) {
        this._pieStyle.setLineColor(value.toBytes());
      }
    }, {
      key: "lineWidth",
      get: function get() {
        return this._pieStyle.getLineWidth();
      },
      set: function set(value) {
        this._pieStyle.setLineWidth(value);
      }
    }, {
      key: "lineCapStyle",
      get: function get() {
        return this._pieStyle.getLineCapStyle();
      },
      set: function set(value) {
        this._pieStyle.setLineCapStyle(value);
      }
    }, {
      key: "lineJoinStyle",
      get: function get() {
        return this._pieStyle.getLineJoinStyle();
      },
      set: function set(value) {
        this._pieStyle.setLineJoinStyle(value);
      }
    }, {
      key: "dashOffset",
      get: function get() {
        return this._pieStyle.getDashOffset();
      },
      set: function set(value) {
        this._pieStyle.setDashOffset(value);
      }
    }, {
      key: "dashCount",
      get: function get() {
        return this._pieStyle.getDashCount();
      }
    }, {
      key: "dashPattern",
      get: function get() {
        return this._pieStyle.getDashPattern();
      },
      set: function set(value) {
        this._pieStyle.setDashPattern(value);
      }
    }, {
      key: "fillType",
      get: function get() {
        return this._pieStyle.getFillType();
      },
      set: function set(value) {
        this._pieStyle.setFillType(value);
      }
    }, {
      key: "fillStyle",
      get: function get() {
        return this._pieStyle.getFillStyle();
      },
      set: function set(value) {
        this._pieStyle.setFillStyle(value);
      }
    }, {
      key: "fillEffect",
      get: function get() {
        return this._pieStyle.getFillEffect();
      },
      set: function set(value) {
        this._pieStyle.setFillEffect(value);
      }
    }, {
      key: "fillForeColor",
      get: function get() {
        var color = this._pieStyle.getForeFillColor();
        return Color$1.fromBytes(color.r, color.g, color.b, color.a);
      },
      set: function set(value) {
        this._pieStyle.setForeFillColor(value.toBytes());
      }
    }, {
      key: "fillBackColor",
      get: function get() {
        var color = this._pieStyle.getBackFillColor();
        return Color$1.fromBytes(color.r, color.g, color.b, color.a);
      },
      set: function set(value) {
        this._pieStyle.setBackFillColor(value.toBytes());
      }
    }, {
      key: "fillAngle",
      get: function get() {
        return this._pieStyle.getFillAngle();
      },
      set: function set(value) {
        this._pieStyle.setFillAngle(value);
      }
    }, {
      key: "fillOffsetX",
      get: function get() {
        return this._pieStyle.getFillOffsetX();
      },
      set: function set(value) {
        this._pieStyle.setFillOffsetX(value);
      }
    }, {
      key: "fillOffsetY",
      get: function get() {
        return this._pieStyle.getFillOffsetY();
      },
      set: function set(value) {
        this._pieStyle.setFillOffsetY(value);
      }
    }, {
      key: "altitudeMode",
      get: function get() {
        return this._pieStyle.getAltitudeMode();
      },
      set: function set(value) {
        this._pieStyle.setAltitudeMode(value);
      }
    }, {
      key: "classifyMode",
      get: function get() {
        return this._pieStyle.getClassifyMode();
      },
      set: function set(value) {
        this._pieStyle.setClassifyMode(value);
      }
    }]);
    return VectorStyle;
  }(Style);

  var TextStyle = /*#__PURE__*/function (_Style) {
    _inherits(TextStyle, _Style);
    var _super = _createSuper(TextStyle);
    function TextStyle(options) {
      var _this;
      _classCallCheck(this, TextStyle);
      _this = _super.call(this);
      if (options == null) {
        _this._pieStyle = new PIETextStyle();
      } else {
        if (options.handle != null) {
          _this._pieStyle = options.handle;
        } else {
          _this._pieStyle = new PIETextStyle();
          options.faceName && _this._pieStyle.setFaceName(options.faceName);
          options.backColor && _this._pieStyle.setBackColor(options.backColor.toBytes());
          options.foreColor && _this._pieStyle.setForeColor(options.foreColor.toBytes());
          options.width && _this._pieStyle.setWidth(options.width);
          options.height && _this._pieStyle.setHeight(options.height);
          options.align && _this._pieStyle.setAlign(options.align);
          options.angle && _this._pieStyle.setAngle(options.angle);
          options.offset && _this._pieStyle.setOffset([options.offset.x, options.offset.y]);
        }
      }
      return _this;
    }
    _createClass(TextStyle, [{
      key: "faceName",
      get: function get() {
        return this._pieStyle.getFaceName();
      },
      set: function set(value) {
        this._pieStyle.setFaceName(value);
      }
    }, {
      key: "backColor",
      get: function get() {
        var color = this._pieStyle.getBackColor();
        return Color$1.fromBytes(color.r, color.g, color.b, color.a);
      },
      set: function set(value) {
        this._pieStyle.setBackColor(value.toBytes());
      }
    }, {
      key: "foreColor",
      get: function get() {
        var color = this._pieStyle.getForeColor();
        return Color$1.fromBytes(color.r, color.g, color.b, color.a);
      },
      set: function set(value) {
        this._pieStyle.setForeColor(value.toBytes());
      }
    }, {
      key: "width",
      get: function get() {
        return this._pieStyle.getWidth();
      },
      set: function set(value) {
        this._pieStyle.setWidth(value);
      }
    }, {
      key: "height",
      get: function get() {
        return this._pieStyle.getHeight();
      },
      set: function set(value) {
        this._pieStyle.setHeight(value);
      }
    }, {
      key: "align",
      get: function get() {
        return this._pieStyle.getAlign();
      },
      set: function set(value) {
        this._pieStyle.setAlign(value);
      }
    }, {
      key: "angle",
      get: function get() {
        return this._pieStyle.getAngle();
      },
      set: function set(value) {
        this._pieStyle.setAngle(value);
      }
    }, {
      key: "offset",
      get: function get() {
        var offset = this._pieStyle.getOffset();
        return Cartesian2.fromElements(offset.cx, offset.cy);
      },
      set: function set(value) {
        this._pieStyle.setOffset([value.x, value.y]);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new TextStyle({
          handle: this
        });
      }
    }]);
    return TextStyle;
  }(Style);

  var SymbolStyle = /*#__PURE__*/function (_Style) {
    _inherits(SymbolStyle, _Style);
    var _super = _createSuper(SymbolStyle);
    function SymbolStyle(options) {
      var _this;
      _classCallCheck(this, SymbolStyle);
      _this = _super.call(this);
      if (options == null) {
        _this._pieStyle = new PIESymbolStyle();
      } else {
        if (options.handle != null) {
          _this._pieStyle = options.handle;
        } else {
          _this._pieStyle = new PIESymbolStyle();
        }
      }
      return _this;
    }
    _createClass(SymbolStyle, [{
      key: "vectorStyle",
      get: function get() {
        var style = this._pieStyle.getVectorStyle();
        return new VectorStyle({
          handle: style
        });
      },
      set: function set(value) {
        this._pieStyle.setVectorStyle(value._pieStyle);
      }
    }, {
      key: "textStyle",
      get: function get() {
        var style = this._pieStyle.getTextStyle();
        return new TextStyle({
          handle: style
        });
      },
      set: function set(value) {
        this._pieStyle.setTextStyle(value._pieStyle);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new SymbolStyle({
          handle: this
        });
      }
    }]);
    return SymbolStyle;
  }(Style);

  var StyleFactory$1 = /*#__PURE__*/function () {
    function StyleFactory() {
      _classCallCheck(this, StyleFactory);
    }
    _createClass(StyleFactory, null, [{
      key: "CreateInstance",
      value: function CreateInstance(style) {
        var styleType = style.getType();
        if (styleType == StyleType$1.Vector) {
          return new VectorStyle({
            handle: style
          });
        } else if (styleType == StyleType$1.Text) {
          return new TextStyle({
            handle: style
          });
        } else if (styleType == StyleType$1.Symbol) {
          return new SymbolStyle({
            handle: style
          });
        }
        return null;
      }
    }]);
    return StyleFactory;
  }();

  var SimpleFeatureRenderer = /*#__PURE__*/function (_FeatureRenderer) {
    _inherits(SimpleFeatureRenderer, _FeatureRenderer);
    var _super = _createSuper(SimpleFeatureRenderer);
    function SimpleFeatureRenderer(options) {
      var _this;
      _classCallCheck(this, SimpleFeatureRenderer);
      _this = _super.call(this);
      if (options != null) {
        _this._render = options.handle;
      } else {
        _this._render = new PIESimpleFeatureRenderer();
      }
      return _this;
    }
    _createClass(SimpleFeatureRenderer, [{
      key: "style",
      get: function get() {
        var style = this._render.getStyle();
        return StyleFactory$1.CreateInstance(style);
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {
        var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this._render.setStyle(style._pieStyle, clone);
      }
    }]);
    return SimpleFeatureRenderer;
  }(FeatureRenderer);

  // import ThemeRangeFeatureRenderer from "../FeatureRendererTheme/ThemeRangeFeatureRenderer";
  // import ThemeLabelFeatureRenderer from "../FeatureRendererTheme/ThemeLabelFeatureRenderer";
  var FeatureRenderFactory = /*#__PURE__*/function () {
    function FeatureRenderFactory() {
      _classCallCheck(this, FeatureRenderFactory);
    }
    _createClass(FeatureRenderFactory, null, [{
      key: "CreateInstance",
      value: function CreateInstance(hRender) {
        var render = new FeatureRenderer(hRender);
        var type = render.type;
        if (type == FeatureRenderType$1.Simple) {
          return new SimpleFeatureRenderer(hRender);
        } //暂时注释分段
        // else if (type == FeatureRenderType.Classify) {
        //     return new  ClassifyFeatureRenderer(hRender);
        // } else if (type == FeatureRenderType.ThemeRange) {
        //     return new  ThemeRangeFeatureRenderer(hRender);
        // } else if (type == FeatureRenderType.ThemeLabel) {
        //     return new  ThemeLabelFeatureRenderer(hRender);
        // }
        else {
          return new FeatureRenderer(hRender);
        }
      }
    }]);
    return FeatureRenderFactory;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 图层选择集基础操作相关函数
   * @name Selection
   *
   */
  var Selection = /*#__PURE__*/function () {
    function Selection(options) {
      _classCallCheck(this, Selection);
      _defineProperty(this, "_selection", void 0);
      if (options != null && options.handle != null) {
        this._selection = options.handle;
      }
    }
    _createClass(Selection, [{
      key: "removeAll",
      value: function removeAll() {
        this._selection.removeAll();
      }

      /**
       * 获取选中集大小
       *
       * @memberOf Selection#
       * @returns {Number} 返回选中对象集中选中对象的数量
       *
       */
    }, {
      key: "size",
      get: function get() {
        return this._selection.getSize();
      }

      /**
       * 获取选中对象集中指定索引值的选中对象的ID
       * @param {Number} index -选中对象的索引值
       * @memberOf Selection#
       *
       * @returns {Number} 返回选中对象集中指定索引值的选中对象的ID
       *
       */
    }, {
      key: "getAt",
      value: function getAt(index) {
        return this._selection.getAt(index);
      }

      /**
       * 设置选中对象集中指定索引值的选中对象的ID
       * @param {Number} index -选中对象的索引值
       * @param {Number} ID -选中对象的ID
       * @memberOf Selection#
       *
       * @returns {Boolean} 返回是否成功设置选中对象集中指定索引值的选中对象的ID
       *
       */
    }, {
      key: "setAt",
      value: function setAt(index, ID) {
        return this._selection.setAt(index, ID);
      }

      /**
       * 选中对象集中增加选中对象ID
       * @param {Number} ID -选中对象的ID
       * @memberOf Selection#
       *
       * @returns {Number} 返回选中对象集中对象的个数
       *
       */
    }, {
      key: "add",
      value: function add(ID) {
        return this._selection.add(ID);
      }

      /**
       * 选中对象集中指定索引值处插入选中对象的ID
       * @param {Number} index -选中对象的索引值
       * @param {Number} ID -选中对象的ID
       * @memberOf Selection#
       *
       * @returns {Boolean} 返回选中对象集中指定索引处插入选中对象的ID是否成功
       *
       */
    }, {
      key: "insertAt",
      value: function insertAt(index, ID) {
        return this._selection.insertAt(index, ID);
      }

      /**
       * 查找指定ID在选择集中的索引
       * @param {Number} ID -选中对象的ID值
       * @param {Number} searchCount -查询个数
       * @memberOf Selection#
       *
       * @returns {Number} 返回索引
       *
       */
    }, {
      key: "findID",
      value: function findID(ID, searchCount) {
        return this._selection.findID(ID, searchCount);
      }

      /**
       * 删除指定索引后的count个选中对象
       * @param {Number} index -选中对象的索引值
       * @param {Number} count -索引后的count选中对象
       * @memberOf Selection#
       *
       * @returns {Number} 返回真正删除的个数
       *
       */
    }, {
      key: "removeAt",
      value: function removeAt(index, count) {
        return this._selection.removeAt(index, count);
      }
    }]);
    return Selection;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 几何对象类型枚举
   * @readonly
   * @enum {number}
   */
  var GeometryType = {
    Null: 0,
    /** 点类型 */
    Point: 1,
    /** 线类型 */
    Line: 3,
    /** 面类型 */
    Region: 5,
    /**复杂面类型*/
    MultiRegion: 8,
    /** 文本类型 */
    Text: 7,
    /**复合对象*/
    Compound: 1000,
    /**三维点*/
    Point3D: 2049,
    /**三维线*/
    Line3D: 2051,
    /**三维面*/
    Region3D: 2053,
    /**三维文本*/
    Text3D: 2055,
    /**三维模型*/
    Model3D: 2176,
    /** 军标类型 */
    GeoPlot: 1042
  };

  var Geometry = /*#__PURE__*/function () {
    function Geometry() {
      _classCallCheck(this, Geometry);
      _defineProperty(this, "_pieGeometry", void 0);
    } //DeveloperError.throwInstantiationError();
    _createClass(Geometry, [{
      key: "dispose",
      value: function dispose() {
        this._pieGeometry.dispose();
      }
    }, {
      key: "handle",
      get: function get() {
        return this._pieGeometry;
      }
    }, {
      key: "type",
      get: function get() {
        return this._pieGeometry.getType();
      }
    }, {
      key: "dimension",
      get: function get() {
        return this._pieGeometry.getDimension();
      }
    }, {
      key: "is3D",
      get: function get() {
        this._pieGeometry.is3D();
      }
    }, {
      key: "ID",
      get: function get() {
        return this._pieGeometry.getID();
      },
      set: function set(value) {
        this._pieGeometry.setID(value);
      }
    }, {
      key: "innerPoint",
      get: function get() {
        var point = this._pieGeometry.getInnerPoint();
        return Cartesian2.fromElements(point.x, point.y);
      }
    }, {
      key: "bounds",
      get: function get() {
        var bounds = this._pieGeometry.getBounds();
        return Cartesian4.fromElements(bounds.left, bounds.top, bounds.right, bounds.bottom);
      }
    }, {
      key: "style",
      get: function get() {
        var style = this._pieGeometry.getStyle();
        return StyleFactory$1.CreateInstance(style);
      },
      set: function set(value) {
        this._pieGeometry.setStyle(value.handle);
      }
    }]);
    return Geometry;
  }();

  var GeoPoint = /*#__PURE__*/function (_Geometry) {
    _inherits(GeoPoint, _Geometry);
    var _super = _createSuper(GeoPoint);
    function GeoPoint(options) {
      var _this;
      _classCallCheck(this, GeoPoint);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry = options.handle;
        } else {
          if (options.point && options.point instanceof Cartesian2) {
            options.point = [options.point.x, options.point.y];
          }
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry = new PIEPoint(options);
        }
      }
      return _this;
    }
    _createClass(GeoPoint, [{
      key: "point",
      get: function get() {
        var point = this._pieGeometry.getPoint();
        return Cartesian2.fromElements(point.x, point.y);
      },
      set: function set(value) {
        return this._pieGeometry.setPoint(value.x, value.y);
      }
    }]);
    return GeoPoint;
  }(Geometry);

  var GeoPolyline = /*#__PURE__*/function (_Geometry) {
    _inherits(GeoPolyline, _Geometry);
    var _super = _createSuper(GeoPolyline);
    function GeoPolyline(options) {
      var _this;
      _classCallCheck(this, GeoPolyline);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry = options.handle;
        } else {
          options.points = options.points ? options.points : null;
          options.subPoints = options.subPoints ? options.subPoints : null;
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry = new PIEPolyline(options);
        }
      }
      return _this;
    }
    _createClass(GeoPolyline, [{
      key: "pointCount",
      get: function get() {
        return this._pieGeometry.getPointCount();
      }
    }, {
      key: "subCount",
      get: function get() {
        return this._pieGeometry.getSubCount();
      }
    }, {
      key: "getSubPointCount",
      value: function getSubPointCount(index) {
        return this._pieGeometry.getSubPointCount(index);
      }
    }, {
      key: "getPoints",
      value: function getPoints() {
        var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this._pieGeometry.getPoints(subIndex);
      }
    }, {
      key: "length",
      get: function get() {
        return this._pieGeometry.getLength();
      }
    }, {
      key: "getLengthInSpatialReference",
      value: function getLengthInSpatialReference(spatialReference) {
        return this._pieGeometry.getLengthInSpatialReference(spatialReference.handle);
      }
    }, {
      key: "setPoint",
      value: function setPoint(index, point) {
        return this._pieGeometry.setPoint(index, new PIEVector2(point.x, point.y));
      }
    }, {
      key: "setSubPoint",
      value: function setSubPoint(subIndex, pointIndex, point) {
        return this._pieGeometry.setSubPoint(subIndex, pointIndex, new PIEVector2(point.x, point.y));
      }
    }, {
      key: "insertPoint",
      value: function insertPoint(subIndex, pointIndex, point) {
        return this._pieGeometry.insertPoint(subIndex, pointIndex, new PIEVector2(point.x, point.y));
      }
    }]);
    return GeoPolyline;
  }(Geometry);

  var GeoPolygon = /*#__PURE__*/function (_Geometry) {
    _inherits(GeoPolygon, _Geometry);
    var _super = _createSuper(GeoPolygon);
    function GeoPolygon(options) {
      var _this;
      _classCallCheck(this, GeoPolygon);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry = options.handle;
        } else {
          options.points = options.points ? options.points : null;
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry = new PIEPolygon(options);
        }
      }
      return _this;
    }
    _createClass(GeoPolygon, [{
      key: "pointCount",
      get: function get() {
        return this._pieGeometry.getPointCount();
      }
    }, {
      key: "subCount",
      get: function get() {
        return this._pieGeometry.getSubCount();
      }
    }, {
      key: "getSubPointCount",
      value: function getSubPointCount(index) {
        return this._pieGeometry.getSubPointCount(index);
      }
    }, {
      key: "getPoints",
      value: function getPoints() {
        var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this._pieGeometry.getPoints(subIndex);
      }
    }, {
      key: "area",
      get: function get() {
        return this._pieGeometry.getArea();
      }
    }, {
      key: "getAreaInSpatialReference",
      value: function getAreaInSpatialReference(spatialReference) {
        this._pieGeometry.getAreaInSpatialReference(spatialReference);
      }
    }, {
      key: "isCounterClockwise",
      value: function isCounterClockwise(subIndex) {
        return this._pieGeometry.isCounterClockwise(subIndex);
      }
    }, {
      key: "reverseSubPolygon",
      value: function reverseSubPolygon(subIndex) {
        this._pieGeometry.reverseSubPolygon(subIndex);
      }
    }, {
      key: "pointInRegion",
      value: function pointInRegion(point, border) {
        return this._pieGeometry.ptInRegion(point, border);
      }
    }, {
      key: "insertPoint",
      value: function insertPoint(subIndex, pointIndex, point) {
        return this._pieGeometry.insertPoint(subIndex, pointIndex, [point.x, point.y]);
      }
    }, {
      key: "getLengthEx",
      value: function getLengthEx(spatialReference) {
        this._pieGeometry.getLengthEx(spatialReference);
      }
    }, {
      key: "length",
      get: function get() {
        this._pieGeometry.getLength();
      }
    }]);
    return GeoPolygon;
  }(Geometry);

  var GeoMultiPolygon = /*#__PURE__*/function (_Geometry) {
    _inherits(GeoMultiPolygon, _Geometry);
    var _super = _createSuper(GeoMultiPolygon);
    function GeoMultiPolygon(options) {
      var _this;
      _classCallCheck(this, GeoMultiPolygon);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry = options.handle;
        } else {
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry = new PIEMultiPolygon(options);
        }
      }
      return _this;
    }
    _createClass(GeoMultiPolygon, [{
      key: "addPolygon",
      value: function addPolygon(polygon) {
        this._pieGeometry.addPolygon(polygon.handle);
      }
    }, {
      key: "PolygonCount",
      get: function get() {
        return this._pieGeometry.getPolygonCount();
      }
    }, {
      key: "getPolygon",
      value: function getPolygon(index) {
        var corePolygon = this._pieGeometry.getPolygon(index);
        if (corePolygon) {
          return new GeoPolygon({
            handle: corePolygon
          });
        }
        return null;
      }
    }, {
      key: "removePolygon",
      value: function removePolygon(index) {
        this._pieGeometry.removePolygon(index);
      }
    }, {
      key: "getSubCount",
      value: function getSubCount(polygonIndex) {
        return this._pieGeometry.getSubCount(polygonIndex);
      }
    }, {
      key: "getSub",
      value: function getSub(polygonIndex, subIndex) {
        var polygon = this._pieGeometry.getSub(polygonIndex, subIndex);
        if (polygon) {
          return new GeoPolygon({
            handle: polygon
          });
        }
        return null;
      }
    }, {
      key: "getSubPntCount",
      value: function getSubPntCount(polygonIndex, subIndex) {
        return this._pieGeometry.getSubPntCount(polygonIndex, subIndex);
      }
    }, {
      key: "getPoints",
      value: function getPoints(polygonIndex, subIndex) {
        this._pieGeometry.getPoints(polygonIndex, subIndex);
      }
    }]);
    return GeoMultiPolygon;
  }(Geometry);

  var GeoText = /*#__PURE__*/function (_Geometry) {
    _inherits(GeoText, _Geometry);
    var _super = _createSuper(GeoText);
    function GeoText(options) {
      var _this;
      _classCallCheck(this, GeoText);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry = options.handle;
        } else {
          if (options.point && options.point instanceof Cartesian2) {
            options.point = [options.point.x, options.point.y];
          }
          options.text = options.text ? options.text : null;
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry = new PIEText(options);
        }
      }
      return _this;
    }
    _createClass(GeoText, [{
      key: "point",
      get: function get() {
        var vecPoint = this._pieGeometry.getPoint();
        return Cartesian2.fromElements(vecPoint.x, vecPoint.y);
      },
      set: function set(point) {
        return this._pieGeometry.setPoint([point.x, point.y]);
      }
    }, {
      key: "text",
      get: function get() {
        return this._pieGeometry.getText();
      },
      set: function set(value) {
        return this._pieGeometry.setText(value);
      }
    }, {
      key: "TextStyle",
      get: function get() {
        var textStyle = this._pieGeometry.getTextStyle();
        return new TextStyle({
          handle: textStyle
        });
      }
    }, {
      key: "textStyle",
      set: function set(value) {
        return this._pieGeometry.setTextStyle(value.handle);
      }
    }]);
    return GeoText;
  }(Geometry);

  var Geometry3D = /*#__PURE__*/function () {
    function Geometry3D() {
      _classCallCheck(this, Geometry3D);
      _defineProperty(this, "_pieGeometry3D", void 0);
    } //DeveloperError.throwInstantiationError();
    _createClass(Geometry3D, [{
      key: "dispose",
      value: function dispose() {
        this._pieGeometry3D.dispose();
      }
    }, {
      key: "handle",
      get: function get() {
        return this._pieGeometry3D;
      }
    }, {
      key: "center3D",
      get: function get() {
        var vecCenter = this._pieGeometry3D.getCenter3D();
        return Cartesian3.fromElements(vecCenter.x, vecCenter, y, vecCenter.z);
      }
    }, {
      key: "position",
      get: function get() {
        var postion = this._pieGeometry3D.getPosition();
        return Cartesian3.fromElements(postion.x, postion, y, postion.z);
      },
      set: function set(value) {
        this._pieGeometry3D.setPosition([value.x, value.y, value.z]);
      }
    }, {
      key: "scale",
      get: function get() {
        var scale = this._pieGeometry3D.getScale();
        return Cartesian3.fromElements(scale.x, scale, y, scale.z);
      },
      set: function set(value) {
        this._pieGeometry3D.setScale([value.x, value.y, value.z]);
      }
    }, {
      key: "rotation",
      get: function get() {
        var rotation = this._pieGeometry3D.getRotation();
        return Cartesian3.fromElements(rotation.x, rotation, y, rotation.z);
      },
      set: function set(value) {
        this._pieGeometry3D.setRotation([value.x, value.y, value.z]);
      }
    }, {
      key: "style",
      get: function get() {
        var style = this._pieGeometry3D.getStyle();
        return StyleFactory.CreateInstance(style);
      },
      set: function set(value) {
        this._pieGeometry3D.setStyle(value.handle);
      }
    }]);
    return Geometry3D;
  }();

  var GeoPoint3D = /*#__PURE__*/function (_Geometry3D) {
    _inherits(GeoPoint3D, _Geometry3D);
    var _super = _createSuper(GeoPoint3D);
    function GeoPoint3D(options) {
      var _this;
      _classCallCheck(this, GeoPoint3D);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry3D = options.handle;
        } else {
          if (options.point && options.point instanceof Cartesian3) {
            options.point = [options.point.x, options.point.y, options.point.z];
          }
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry3D = new PIEPoint3D(options);
        }
      }
      return _this;
    }
    _createClass(GeoPoint3D, [{
      key: "point",
      get: function get() {
        var point = this._pieGeometry3D.getPoint();
        return Cartesian3.fromElements(point.x, point.y);
      },
      set: function set(value) {
        var point = new PIEVector3(value.x, value.y, value.z);
        return this._pieGeometry3D.setPoint(point);
      }
    }]);
    return GeoPoint3D;
  }(Geometry3D);

  var GeoPolyline3D = /*#__PURE__*/function (_Geometry3D) {
    _inherits(GeoPolyline3D, _Geometry3D);
    var _super = _createSuper(GeoPolyline3D);
    function GeoPolyline3D(options) {
      var _this;
      _classCallCheck(this, GeoPolyline3D);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry3D = options.handle;
        } else {
          options.points = options.points ? options.points : null;
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry3D = new PIEPolyline3D(options);
        }
      }
      return _this;
    }
    _createClass(GeoPolyline3D, [{
      key: "pointCount",
      get: function get() {
        return this._pieGeometry3D.getPointCount();
      }
    }, {
      key: "subCount",
      get: function get() {
        return this._pieGeometry3D.getSubCount();
      }
    }, {
      key: "getSubPointCount",
      value: function getSubPointCount(index) {
        return this._pieGeometry3D.getSubPointCount(index);
      }
    }, {
      key: "getPoints",
      value: function getPoints() {
        var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this._pieGeometry3D.getPoints(subIndex);
      }
    }]);
    return GeoPolyline3D;
  }(Geometry3D);

  var GeoPolygon3D = /*#__PURE__*/function (_Geometry3D) {
    _inherits(GeoPolygon3D, _Geometry3D);
    var _super = _createSuper(GeoPolygon3D);
    function GeoPolygon3D(options) {
      var _this;
      _classCallCheck(this, GeoPolygon3D);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry3D = options.handle;
        } else {
          options.points = options.points ? options.points : null;
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry3D = new PIEPolygon3D(options);
        }
      }
      return _this;
    }
    _createClass(GeoPolygon3D, [{
      key: "pointCount",
      get: function get() {
        return this._pieGeometry3D.getPointCount();
      }
    }, {
      key: "subCount",
      get: function get() {
        return this._pieGeometry3D.getSubCount();
      }
    }, {
      key: "getSubPointCount",
      value: function getSubPointCount(index) {
        return this._pieGeometry3D.getSubPointCount(index);
      }
    }, {
      key: "setPoint",
      value: function setPoint(index, point) {
        return this._pieGeometry3D.setPoint(index, [point.x, point.y, point.z]);
      }
    }, {
      key: "setSubPoint",
      value: function setSubPoint(subIndex, pointIndex, point) {
        return this._pieGeometry3D.setSubPoint(subIndex, pointIndex, [point.x, point.y, point.z]);
      }
    }, {
      key: "getPoints",
      value: function getPoints() {
        var subIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this._pieGeometry3D.getPoints(subIndex);
      }
    }, {
      key: "insertPoint",
      value: function insertPoint(subIndex, pointIndex, point) {
        return this._pieGeometry3D.insertPoint(subIndex, pointIndex, [point.x, point.y, point.z]);
      }
    }, {
      key: "area",
      get: function get() {
        return this._pieGeometry3D.getArea();
      }
    }, {
      key: "getAreaInSpatialReference",
      value: function getAreaInSpatialReference(spatialReference) {
        return this._pieGeometry3D.getAreaInSpatialReference(spatialReference.handle);
      }
    }, {
      key: "ptInRegion",
      value: function ptInRegion(point, border, interval) {
        return this._pieGeometry3D.ptInRegion([point.x, point.y], border, interval);
      }
    }, {
      key: "isCounterClockwise",
      value: function isCounterClockwise(subIndex) {
        return this._pieGeometry3D.isCounterClockwise(subIndex);
      }
    }, {
      key: "reverseSubPolygon",
      value: function reverseSubPolygon(subIndex) {
        return this._pieGeometry3D.reverseSubPolygon(subIndex);
      }
    }]);
    return GeoPolygon3D;
  }(Geometry3D);

  var GeoText3D = /*#__PURE__*/function (_Geometry3D) {
    _inherits(GeoText3D, _Geometry3D);
    var _super = _createSuper(GeoText3D);
    function GeoText3D(options) {
      var _this;
      _classCallCheck(this, GeoText3D);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieGeometry3D = options.handle;
        } else {
          if (options.point && options.point instanceof Cartesian3) {
            options.point = [options.point.x, options.point.y, options.point.z];
          }
          options.text = options.text ? options.text : null;
          options.ID = options.ID ? options.ID : null;
          _this._pieGeometry3D = new PIEText3D(options);
        }
      }
      return _this;
    }
    _createClass(GeoText3D, [{
      key: "point",
      get: function get() {
        var vecPoint = this._pieGeometry3D.getPoint();
        return Cartesian3.fromElements(vecPoint.x, vecPoint.y, vecPoint.z);
      },
      set: function set(point) {
        return this._pieGeometry3D.setPoint([point.x, point.y, point.z]);
      }
    }, {
      key: "text",
      get: function get() {
        return this._pieGeometry3D.getText();
      },
      set: function set(value) {
        return this._pieGeometry3D.setText(value);
      }
    }, {
      key: "TextStyle",
      get: function get() {
        var textStyle = this._pieGeometry3D.getTextStyle();
        return new TextStyle({
          handle: textStyle
        });
      }
    }, {
      key: "textStyle",
      set: function set(value) {
        return this._pieGeometry3D.setTextStyle(value.handle);
      }
    }]);
    return GeoText3D;
  }(Geometry3D);

  /**
   * @vuepress
   *
   * ---
   * title: Geo-Earth SDK
   * headline: 几何对象模块
   * ---
   */

  function GeometryFactory() {}
  Object.assign(GeometryFactory.prototype, {});
  GeometryFactory.CreateInstance = function (geometry) {
    var geometryType = geometry.getType();
    if (geometryType == GeometryType.Point) {
      return new GeoPoint({
        handle: geometry
      });
    } else if (geometryType == GeometryType.Point3D) {
      return new GeoPoint3D({
        handle: geometry
      });
    } else if (geometryType == GeometryType.Line) {
      return new GeoPolyline({
        handle: geometry
      });
    } else if (geometryType == GeometryType.Line3D) {
      return new GeoPolyline3D({
        handle: geometry
      });
    } else if (geometryType == GeometryType.Region) {
      return new GeoPolygon({
        handle: geometry
      });
    } else if (geometryType == GeometryType.MultiRegion) {
      return new GeoMultiPolygon({
        handle: geometry
      });
    } else if (geometryType == GeometryType.Region3D) {
      return new GeoPolygon3D({
        handle: geometry
      });
    } else if (geometryType == GeometryType.Text) {
      return new GeoText({
        handle: geometry
      });
    } else if (geometryType == GeometryType.Text3D) {
      return new GeoText3D({
        handle: geometry
      });
    } else if (geometryType == GeometryType.GeoPlot) ; else if (geometryType == GeometryType.Model3D) ;
    return null;
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class FeatureDataSource
   * 矢量数据源
   * @extends DataSource
   */
  var FeatureDataSource = /*#__PURE__*/function (_DataSource) {
    _inherits(FeatureDataSource, _DataSource);
    var _super = _createSuper(FeatureDataSource);
    /**
     * FeatureDataSource类的构造函数
     * @param {Object} options 
     */
    function FeatureDataSource(options) {
      var _this;
      _classCallCheck(this, FeatureDataSource);
      _this = _super.call(this);
      // DeveloperError.throwInstantiationError();
      // this._layer = new _PIEGlobeFeatureLayer();
      // this._source = new _PIEFeatureDataSource();
      _defineProperty(_assertThisInitialized(_this), "_layer", void 0);
      _defineProperty(_assertThisInitialized(_this), "_source", void 0);
      if (options != null) {
        if (options._layer != null) _this._layer = options._layer;else _this._layer = new PIEGlobeFeatureLayer();
        if (options._source != null) _this._source = options._source;else _this._source = new PIEFeatureDataSource();
      } else {
        _this._layer = new PIEGlobeFeatureLayer();
        _this._source = new PIEFeatureDataSource();
      }
      return _this;
    }
    /**
     * 设置数据源名称
     * @param {String}  数据源名称
     *
     */
    _createClass(FeatureDataSource, [{
      key: "dataSourceName",
      get:
      /**
       * 获取数据源名称
       * @returns {String}  -返回数据源名称
       *
       */
      function get() {
        return this._layer.getDataSourceName();
      }
      /**
       * 设置数据集名称
       * @param {String} name -目标数据集名称
       *
       */,
      set: function set(name) {
        this._layer.setDatasetName(name);
      }
    }, {
      key: "setDatasetName",
      value: function setDatasetName(name) {
        this._layer.setDatasetName(name);
      }
      /**
       * 获取数据集名称
       * @returns {String} -返回数据集名称
       *
       */
    }, {
      key: "datasetName",
      get: function get() {
        return this._layer.getDatasetName();
      }
      /**
       * 获取数据源
       * @returns {PIEFeatureDataSource}  -返回数据源
       *
       */,
      set: function set(name) {
        this._layer.setDatasetName(name);
      }
    }, {
      key: "DataSource",
      get: function get() {
        // var hDataset = Module._GlobeBaseFeatureLayer_GetDataset(this.handle);
        // var hDataSource = Module._Dataset_GetDataSource(hDataset);
        // return PIEDataSourceFactory.CreateInstance(hDataSource);
        //
        var hDataset = this._layer.getDataset();
        var hDataSource = this._source.getDataSource(hDataset);
        return DataSourceFactory.CreateInstance(hDataSource);
      }
      // /**
      //  * 设置数据源
      //  * @param {PIEDataSource} datasource -数据源对象
      //  * @memberOf GlobeBaseFeatureLayer#
      //  *
      //  */
    }, {
      key: "setDataSource",
      value: function setDataSource(datasource) {
        this._layer.setDataSource(datasource);
      }
    }, {
      key: "setDataset",
      value: function setDataset(dataset) {
        this._layer.setDataset(dataset);
      }
    }, {
      key: "getDataset",
      value: function getDataset() {
        return DatasetFactory.CreateInstance(this._layer.getDataset());
      }
      /**
       * 设置要素图层渲染器
       * @param {PIEFeatureRenderer} featureRenderer -要素渲染器对象
       *
       */
    }, {
      key: "renderer",
      get:
      /**
       * 获取要素图层渲染器
       * @returns {PIEFeatureRenderer} 成功返回要素渲染器对象，失败返回null
       */
      function get() {
        var hRender = this._layer.getRenderer();
        return FeatureRenderFactory.CreateInstance(hRender);
      }
      /**
       * 设置图层是否可选择
       * @param {Boolean} isSelectable -是否可选择
       *
       */,
      set: function set(featureRenderer) {
        this._layer.setRenderer(featureRenderer);
      }
    }, {
      key: "setRenderer",
      value: function setRenderer(featureRenderer) {
        this._layer.setRenderer(featureRenderer);
      }
    }, {
      key: "selectable",
      set: function set(isSelectable) {
        this._layer.setSelectable(isSelectable);
      }
    }, {
      key: "setSelectable",
      value: function setSelectable(isSelectable) {
        this._layer.setSelectable(isSelectable);
      }
      /**
       * 判断图层是否可选
       * @returns {Boolean} 可见返回true，不可见返回false
       */
    }, {
      key: "isSelectable",
      value: function isSelectable() {
        return this._layer.isSelectable();
      }

      /**
       * 获取图层选择集
       * @returns {PIESelection} 成功返回选中的对象，失败返回null
       */
    }, {
      key: "selection",
      get: function get() {
        var handle = this._layer.getSelection();
        return new Selection({
          handle: handle
        });
      }

      /**
       * 清空要素图层选择集
       * @returns {Boolean} 是否清空成功
       */
    }, {
      key: "clearSelection",
      value: function clearSelection() {
        return this._layer.clearSelection();
      }
      /**
       * 添加几何对象
       * @param {PIEGeometry} geometry -几何对象
       * @returns {Number} 几何对象id
       */
    }, {
      key: "addGemetry",
      value: function addGemetry(geometry) {
        return this._layer.addGemetry(geometry);
      }
      /**
       * 添加几何对象数组
       * @param {Array} geometrys -几何对象数组
       * @returns {Boolean} 是否添加成功
       */
    }, {
      key: "addGemetrys",
      value: function addGemetrys(geometrys) {
        return this._layer.addGemetrys(geometrys);
      }
      /**
       * 更新几何对象
       * @param {PIEGeometry} geometry -几何对象
       * @returns {Boolean} 是否更新成功
       */
    }, {
      key: "updateGeometry",
      value: function updateGeometry(geometry) {
        return this._layer.updateGeometry(geometry);
      }
      /**
       * 更新几何对象数组
       * @param {Array} geometrys -几何对象数组
       * @returns {Boolean} 是否更新成功
       */
    }, {
      key: "updateGeometrys",
      value: function updateGeometrys(geometrys) {
        return this._layer.updateGeometrys(geometrys);
      }
      /**
       * 删除几何对象
       * @param {Number} id -几何对象id
       * @returns {Boolean} 是否更新成功
       */
    }, {
      key: "deleteGeometry",
      value: function deleteGeometry(id) {
        return this._layer.deleteGeometry(id);
      }
      /**
       * 删除几何对象数组
       * @param {Array} idList -几何对象id数组
       * @returns {Boolean} 是否删除成功
       */
    }, {
      key: "deleteGeometrys",
      value: function deleteGeometrys(idList) {
        return this._layer.deleteGeometrys(idList);
      }
      /**
       * 获取几何对象
       * @param {Number} id -几何对象id
       * @returns {PIEGeometry} 几何对象
       */
    }, {
      key: "getGeometry",
      value: function getGeometry(id) {
        // var hGeometry = Module._GlobeBaseFeatureLayer_GetGeometry(this.handle, id);
        // return PIEGeometryFactory.CreateInstance(hGeometry);
        var hGeometry = this._layer.getGeometry(id);
        return GeometryFactory.CreateInstance(hGeometry);
      }
    }]);
    return FeatureDataSource;
  }(DataSource$1);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class GeoJsonDataSource
   * GeoJSON数据源数据
   * @extends FeatureDataSource
   */
  var GeoJsonDataSource = /*#__PURE__*/function (_FeatureDataSource) {
    _inherits(GeoJsonDataSource, _FeatureDataSource);
    var _super = _createSuper(GeoJsonDataSource);
    function GeoJsonDataSource() {
      _classCallCheck(this, GeoJsonDataSource);
      return _super.call(this);
    }
    /**
     * 加载提供的GeoJSON数据
     * @param {Resource | String | Object} data 
     * @param {Object} options 
     * @returns {Promise}
     */
    _createClass(GeoJsonDataSource, [{
      key: "load",
      value: function load(data, options) {
        if (!defined$1(data)) {
          throw new DeveloperError$1('data is required.');
        }
        var that = this;
        return new Promise(function (reslove, reject) {
          options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);

          //可能会存在有些字段用户未填写，为其增加为默认
          options = {
            markerSize: defaultValue$1(options.markerSize, 50),
            markerSymbol: 1,
            markerColor: defaultValue$1(options.markerColor, Color$1.RED),
            strokeWidth: defaultValue$1(options.strokeWidth, 1),
            stroke: defaultValue$1(options.stroke, Color$1.BLUE),
            fill: defaultValue$1(options.fill, Color$1.BLUE),
            clampToGround: defaultValue$1(options.clampToGround, false)
          };
          var geojsonOptions = {
            url: data
          };
          var dataSource = new PIEGeoJsonDataSource();
          dataSource.load(geojsonOptions).then(function (value) {
            that._source = value;
            var vectorStyle = new PIEVectorStyle({
              fillColor: options.fill.toBytes(),
              lineColor: options.stroke.toBytes(),
              lineWidth: options.strokeWidth,
              pointType: PIEPointType.Icon,
              pointStyle: options.markerSymbol,
              pointSize: [options.markerSize, options.markerSize],
              pointColor: options.markerColor.toBytes(),
              altitudeMode: options.clampToGround ? PIEAltitudeMode.ClampToGround : PIEAltitudeMode.RelativeToGround
            });
            var featureRenderer = new PIESimpleFeatureRenderer();
            featureRenderer.setStyle(vectorStyle);
            var featureLayer = new PIEGlobeFeatureLayer();
            featureLayer.setRenderer(featureRenderer);
            that._layer = featureLayer;
            reslove(that);
          });
        });
      }

      /**
      * 创建一个GeoJSONN数据实例的Promise。
      * @param {Resource | String | Object} data 要加载的网址
      * @param {Object} options 具有以下属性的对象:
      * @param {Number} options.markerSize 为每个点创建的地图标记的默认大小（以像素为单位）。
      * @param {Color} options.markerColor 为每个点创建的地图图钉的默认大小。
      * @param {Number} options.strokeWidth 折线和多边形轮廓的默认宽度。
      * @param {Color} options.stroke 折线和多边形轮廓的默认颜色。
      * @param {Color} options.fill 多边形内部的默认颜色。
      * @param {Boolean} options.clampToGround 如果我们希望将几何特征（多边形或线串）固定在地面上，则为true。
      * @returns {Promise}
      */
    }], [{
      key: "load",
      value: function load(data, options) {
        return new GeoJsonDataSource().load(data, options);
      }
    }]);
    return GeoJsonDataSource;
  }(FeatureDataSource);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 点符号对齐方式
   * @readonly
   * @enum {number}
   */
  var PointAlignType = {
    /** 左上对齐*/
    LeftTop: 0,
    /** 中上对齐*/
    TopCenter: 1,
    /** 右上对齐*/
    RightTop: 2,
    /** 左下对齐*/
    LeftBottom: 3,
    /** 中下对齐*/
    BottomCenter: 4,
    /** 右下对齐*/
    RightBottom: 5,
    /** 左中对齐*/
    LeftCenter: 6,
    /** 中心对齐*/
    Center: 7,
    /** 右中对齐*/
    RightCenter: 8
  };
  var PointAlignType$1 = Object.freeze(PointAlignType);

  var GSFDataSource = /*#__PURE__*/function (_FeatureDataSource) {
    _inherits(GSFDataSource, _FeatureDataSource);
    var _super = _createSuper(GSFDataSource);
    function GSFDataSource() {
      var _this;
      _classCallCheck(this, GSFDataSource);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_symbol", void 0);
      return _this;
    }
    _createClass(GSFDataSource, [{
      key: "load",
      value: function load(data, options) {
        var _this2 = this;
        if (!defined$1(data)) {
          throw new DeveloperError$1('data is required.');
        }
        return new Promise(function (reslove, reject) {
          options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
          var renderer = defaultValue$1(options.renderer, new SimpleFeatureRenderer());
          var style = defaultValue$1(options.style, null);
          var gsfOptions = {
            gsfUrl: data
          };
          var vectorStyleOPtions = {
            fillColor: defaultValue$1(getColorToBytes$1(options.fill), [0, 0, 255, 255]),
            lineColor: defaultValue$1(getColorToBytes$1(options.stroke), [0, 0, 255, 255]),
            lineWidth: defaultValue$1(options.strokeWidth, 1),
            pointType: defaultValue$1(options.markerType, PIEPointType.Null),
            pointStyle: defaultValue$1(options.markerSymbol, null),
            pointSize: defaultValue$1(options.markerSize ? [options.markerSize.x, options.markerSize.y] : null, [50, 50]),
            pointColor: defaultValue$1(getColorToBytes$1(options.markerColor), [255, 0, 0, 255]),
            pointAlign: defaultValue$1(options.markerAlign, PointAlignType$1.Center),
            altitudeMode: options.altitudeMode,
            classifyMode: options.classifyMode
          };
          var dataSource = new PIEGSFDataSource();
          dataSource.load(gsfOptions).then( /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value) {
              var iconSymbol, vectorStyle_s, symbolStyle, vectorStyle_c, featureLayer;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!(value.getDataset().getType() === PIEDatasetType.Point)) {
                      _context.next = 11;
                      break;
                    }
                    if (!(options.markerType === PIEPointType.Icon)) {
                      _context.next = 11;
                      break;
                    }
                    if (!options.markerSymbol) {
                      _context.next = 10;
                      break;
                    }
                    vectorStyleOPtions.pointStyle = options.markerSymbol.id;
                    iconSymbol = new PIEIconSymbol();
                    _context.next = 7;
                    return iconSymbol.load(options.markerSymbol);
                  case 7:
                    _this2._symbol = _context.sent;
                    _context.next = 11;
                    break;
                  case 10:
                    throw new DeveloperError$1('markerSymbol is required.');
                  case 11:
                    _context.t0 = renderer.type;
                    _context.next = _context.t0 === FeatureRenderType$1.Null ? 14 : _context.t0 === FeatureRenderType$1.Simple ? 15 : _context.t0 === FeatureRenderType$1.ThemeRange ? 18 : _context.t0 === FeatureRenderType$1.ThemeLabel ? 19 : _context.t0 === FeatureRenderType$1.ThemeUnique ? 23 : _context.t0 === FeatureRenderType$1.Classify ? 24 : _context.t0 === FeatureRenderType$1.SMS ? 27 : _context.t0 === FeatureRenderType$1.Seamap ? 28 : 29;
                    break;
                  case 14:
                    return _context.abrupt("break", 30);
                  case 15:
                    // 简单矢量渲染器
                    vectorStyle_s = new PIEVectorStyle(vectorStyleOPtions);
                    renderer.handle.setStyle(vectorStyle_s);
                    return _context.abrupt("break", 30);
                  case 18:
                    return _context.abrupt("break", 30);
                  case 19:
                    // 标签专题图
                    symbolStyle = new PIESymbolStyle();
                    symbolStyle.setTextStyle(style.handle);
                    renderer.handle.setStyle(symbolStyle);
                    return _context.abrupt("break", 30);
                  case 23:
                    return _context.abrupt("break", 30);
                  case 24:
                    // 分类渲染器
                    vectorStyle_c = new PIEVectorStyle(vectorStyleOPtions);
                    renderer.handle.setStyle(vectorStyle_c);
                    return _context.abrupt("break", 30);
                  case 27:
                    return _context.abrupt("break", 30);
                  case 28:
                    return _context.abrupt("break", 30);
                  case 29:
                    return _context.abrupt("break", 30);
                  case 30:
                    featureLayer = new PIEGlobeFeatureLayer();
                    featureLayer.setRenderer(renderer.handle);
                    _this2._source = value;
                    _this2._layer = featureLayer;
                    reslove(_this2);
                  case 35:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x) {
              return _ref.apply(this, arguments);
            };
          }());
        });
      }
    }, {
      key: "selectable",
      set: function set(_boolean) {
        this._layer.setSelectable(_boolean);
      }
    }], [{
      key: "load",
      value: function load(data, options) {
        return new GSFDataSource().load(data, options);
      }
    }]);
    return GSFDataSource;
  }(FeatureDataSource);
  function getColorToBytes$1(value) {
    if (value) {
      return value.toBytes();
    }
    return null;
  }

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   *  数据源枚举
   * @readonly
   * @enum {String}
   */
  var DataSourceType = {
    /** GeoJson数据源  */
    GeoJson: 'GeoJsonDataSource',
    /** GSF数据源  */
    Gsf: 'GsfDataSource',
    /** OSGB数据源  */
    Osgb: 'OsgbDataSource',
    /** Tiles3D数据源  */
    Tiles3D: 'DataSource3DTiles',
    /** Shp数据源  */
    Shp: 'ShpDataSource',
    /** GE数据源  */
    GE: 'DataSourceGE',
    /** 栅格数据源  */
    Raster: 'GdalRasterDataSource',
    /** 矢量数据源  */
    Feature: 'GdalFeatureDataSource',
    /** Mapbox矢量数据源  */
    MVT: 'MVTDataSource',
    //CityGML数据源
    CityGML: 'CityGMLDataSource',
    //ZCGML数据源
    ZCGML: 'ZCGMLDataSource'
  };

  // 有问题 待解决
  var DataSourceFactory = /*#__PURE__*/function () {
    function DataSourceFactory() {
      _classCallCheck(this, DataSourceFactory);
    }
    _createClass(DataSourceFactory, null, [{
      key: "CreateInstance",
      value: function CreateInstance(hDataSource) {
        if (hDataSource) {
          var type = hDataSource.getType();
          if (type == DataSourceType.GeoJson) {
            return new GeoJsonDataSource(hDataSource);
          } else if (type == DataSourceType.Gsf) {
            return new GSFDataSource(hDataSource);
          } else if (type == DataSourceType.Osgb) {
            return new PIEOSGBDataSource(hDataSource);
          }
          if (type == DataSourceType.Tiles3D) {
            return new PIETiles3DDataSource(hDataSource);
          } else if (type == DataSourceType.GE) {
            return new PIEGEDataSource(hDataSource);
          } else if (type == DataSourceType.Shp) {
            return new PIEShpDataSource(hDataSource);
          } else if (type == DataSourceType.Feature) {
            return new PIEGdalFeatureDataSource(hDataSource);
          } else if (type == DataSourceType.Raster) {
            return new PIEGdalRasterDataSource(hDataSource);
          } else if (type == DataSourceType.MVT) {
            return new PIEMVTDataSource(hDataSource);
          } else {
            return new DataSource(hDataSource);
          }
        }
        return null;
      }
    }]);
    return DataSourceFactory;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class DataSources
   * 数据源集合操作
   */
  var DataSources = /*#__PURE__*/function () {
    /**
     * DataSources类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {PIEDataSources} options.handle 
     */
    function DataSources(options) {
      _classCallCheck(this, DataSources);
      _defineProperty(this, "_DataSources", void 0);
      if (options != null && options.handle != null) {
        this._DataSources = options.handle;
      }
    }

    /**
     * 向工作空间中添加数据源
     * @memberof DataSources
     * @param {PIEDataSource} datasource -需要加入的数据源
     * @returns {Boolean} 如果添加成功返回true,否则返回false
     *
     */
    _createClass(DataSources, [{
      key: "addDataSource",
      value: function addDataSource(datasource) {
        return this._DataSources.addDataSource(datasource);
      }

      /**
       * 获取工作空间中数据源的数量
       * @memberof DataSources
       * @returns {Number} 返回工作空间中数据源的数量
       */
    }, {
      key: "dataSourceCount",
      get: function get() {
        return this._DataSources.getDataSourceCount();
      }

      /**
       * 获取工作空间中指定别名的数据源
       * @memberof DataSources
       * @param {String} alias -数据源别名
       * @returns {PIEDataSource} 如果获取成功返回指定名称的数据源，否则返回null;如果别名为空或不存在，返回null
       *
       */
    }, {
      key: "getDataSource",
      value: function getDataSource(alias) {
        var hDataSource = this._DataSources.getDataSource(alias);
        return DataSourceFactory.CreateInstance(hDataSource);
      }

      /**
       * 获取工作空间中指定索引的数据源
       * @param {Number} index -需要获取的数据源的索引值
       * @memberof DataSources
       * @returns {PIEDataSource} 如果获取成功返回指定索引值的数据源，否则返回null
       *
       */
    }, {
      key: "getDataSourceAt",
      value: function getDataSourceAt(index) {
        var hDataSource = this._DataSources.getDataSourceAt(index);
        return DataSourceFactory.CreateInstance(hDataSource);
      }

      /**
       * 通过数据源查找数据源别名
       * @param {PIEDataSource} datasource -数据源
       * @memberof DataSources
       * @returns {String} 返回数据源的别名
       *
       */
    }, {
      key: "getDataSourceAlias",
      value: function getDataSourceAlias(datasource) {
        return this._DataSources.getDataSourceAlias();
      }

      /**
       * 得到指定索引位置的数据源别名
       * @memberof DataSources
       * @param {Number} index -索引位置
       * @returns {String} 返回数据源的别名
       */
    }, {
      key: "getDataSourceAliasAt",
      value: function getDataSourceAliasAt(index) {
        return this._DataSources.getDataSourceAliasAt(index);
      }

      // /**
      //  * 从XML中序列化数据源
      //  * @param {String} xml -数据源xml
      //  * @memberOf DataSources#
      //  * @return {Boolean} 返回是否成功序列化数据源
      //  */
      // dataSourceFromXML: function (xml) {
      //     var strXml = new PIEString(xml);
      //     var result = Module._Document_DataSourceFromXML(this.handle, strXml.getHandle());
      //     strXml.dispose();
      //     return result;
      // },
      //
      // /**
      //  * 把数据源序列化成xml
      //  * @memberOf DataSources#
      //  * @returns {String} 返回数据源xml
      //  */
      // dataSourceToXML: function () {
      //     var strXml = new PIEString(1024);
      //     Module._Document_DataSourceToXML(this.handle, strXml.getHandle());
      //     var xml = strXml.toString();
      //     strXml.dispose();
      //     return xml;
      // },

      /**
       * 重命名数据源
       * @memberof DataSources
       * @param {String} oldAlias -原数据源别名
       * @param {String} newAlias -新数据源别名
       * @returns {Boolean} 如果重命名成功返回true，否则返回false；如果数据源为null，或者原别名为空或者新别名为空，那么返回false；如果数据源新别名和原别名相同，返回true；如果数据源新别名与已存在的其他数据源名称相同，返回false；
       *
       */
    }, {
      key: "renameDataSource",
      value: function renameDataSource(oldAlias, newAlias) {
        return this._DataSources.renameDataSource(oldAlias, newAlias);
      }

      /**
       * 根据数据源别名移除数据源
       * @memberof DataSources
       * @param {String} alias -数据源别名
       * @returns {PIEDataSource} 如果移除成功返回数据源的对象，否则返回null。 如果别名为空，返回null；如果不存在名称为strAlias的数据源，那么返回null。
       */
    }, {
      key: "removeDataSource",
      value: function removeDataSource(alias) {
        var hDataSource = this._DataSources.removeDataSource(alias);
        return DataSourceFactory.CreateInstance(hDataSource);
      }
    }]);
    return DataSources;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
  * 符号组类型枚举
  * @readonly
  * @enum {number}
  */
  var SymbolGroupType = {
    /**空类型*/
    Null: 0,
    // /**点符号组类型*/
    // Marker: 1,
    // /**线符号组类型*/
    // Line: 3,
    // /**填充符号组类型*/
    // Fill: 5,
    /**图标符号组类型*/
    Icon: 16
    // /**模型符号组类型*/
    // Model: 32
  };

  var SymbolGroupType$1 = Object.freeze(SymbolGroupType);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class DataSourceCollection
   * 数据源集合类
   */
  var DataSourceCollection = /*#__PURE__*/function () {
    function DataSourceCollection() {
      _classCallCheck(this, DataSourceCollection);
      _defineProperty(this, "_dataSources", []);
      _defineProperty(this, "_groupLayer", void 0);
      _defineProperty(this, "_pieGlobe", void 0);
      _defineProperty(this, "_pieGlobeControl", void 0);
      _defineProperty(this, "_threeLayer", void 0);
      _defineProperty(this, "_earthCamera", void 0);
      this._groupLayer = new PIEGlobeGroupLayer();
      this._groupLayer.setName('DataSourceCollection');
    }
    /**
     * 设置三维球体
     * @param {PieGlobe} value
     */
    _createClass(DataSourceCollection, [{
      key: "pieGlobe",
      get:
      /**
       * 获取三维球体
       *@returns {PieGlobe}
       */
      function get() {
        return this._pieGlobe;
      },
      set: function set(value) {
        this._pieGlobe = value;
        this._pieGlobe.addLayer(this._groupLayer);
      }
    }, {
      key: "pieGlobeControl",
      get: function get() {
        return this._pieGlobeControl;
      }

      /**
       * 设置three图层
       * @param {Threelayer} layer
       */,
      set: function set(value) {
        this._pieGlobeControl = value;
      }
    }, {
      key: "threeLayer",
      set: function set(layer) {
        this._threeLayer = layer;
      }
      /**
       * 设置相机
       * @param {Camera} camera
       */
    }, {
      key: "camera",
      set: function set(camera) {
        this._earthCamera = camera;
      }
      /**
       * 将数据源添加到集合中
       * @param {DataSource} dataSource 要添加的数据源
       * @returns -将数据源添加到集合后便会解决的Promise
       */
    }, {
      key: "add",
      value: function add(dataSource) {
        var _this = this;
        var that = this;
        return Promise.resolve(dataSource).then(function (value) {
          if (_this._pieGlobeControl && !_this._pieGlobeControl.bDisposed) {
            switch (value.type) {
              case DataSourceType.CityGML:
                {
                  var layer = value.layer;
                  _this._threeLayer.add(layer);
                  //计算位置
                  var lonlatCenter = layer.lonlatCenter;
                  var worldMatrix = _this._earthCamera.computeWorldMatrix(lonlatCenter[0], lonlatCenter[1], lonlatCenter[2]);
                  _this._earthCamera.updateWorldMatrix(layer, worldMatrix);
                  _this._dataSources.push(value);
                  break;
                }
              case DataSourceType.ZCGML:
                {
                  var _layer = value.layer;
                  _this._threeLayer.add(_layer);
                  _this._dataSources.push(value);
                  break;
                }
              default:
                {
                  that._dataSources.push(value);
                  var workspace = that._pieGlobe.getDocument();
                  if (value._symbol) {
                    var SymbolGroup = workspace.getSymbolLib().getGroup(SymbolGroupType$1.Icon);
                    SymbolGroup.add(value._symbol);
                  }
                  if (value.sourceHandle) {
                    workspace.getDataSourceManager().addDataSource(value.sourceHandle);
                    if (!(value.sourceHandle instanceof PIESMSDataSource)) {
                      value.layerHandle.setDataSource(value.sourceHandle);
                    }
                  }
                  that._groupLayer.addLayer(value.layerHandle, true);
                  that._pieGlobe.refresh(true, false);
                }
            }
            return value;
          }
        });
      }
      /**
       * 获取数据源集合
       * @returns {Array} -返回数据源集合
       */
    }, {
      key: "getDataSources",
      value: function getDataSources() {
        // return new DataSources(this._dataSources);//此处需要改进
        return this._dataSources;
      }
      /**
       * 从集合中删除数据源（如果存在）
       * @param {DataSource} dataSource 要删除的数据源。
       * @param {Boolean} destroy 除删除数据源外是否还要销毁数据源。
       */
    }, {
      key: "remove",
      value: function remove(dataSource, destroy) {
        var _this2 = this;
        destroy = defaultValue$1(destroy, false);
        Promise.resolve(dataSource).then(function (value) {
          if (_this2._pieGlobeControl && !_this2._pieGlobeControl.bDisposed) {
            switch (value.type) {
              case DataSourceType.CityGML:
                {
                  _this2._threeLayer.remove(value.layer);
                  break;
                }
              case DataSourceType.ZCGML:
                {
                  _this2._threeLayer.remove(value.layer);
                  break;
                }
              default:
                {
                  var index = _this2._dataSources.indexOf(value);
                  if (index !== -1) {
                    _this2._dataSources.splice(index, 1);
                    _this2._groupLayer.removeLayer(value._layer);
                    _this2._pieGlobe.refresh(true, false);
                    if (destroy) {
                      if (value._source) {
                        var workspace = _this2._pieGlobe.getDocument();
                        var dataSourceManager = workspace.getDataSourceManager();
                        var alias = dataSourceManager.getDataSourceAlias(value._source);
                        dataSourceManager.removeDataSource(alias);
                      }
                    }
                  }
                }
                return true;
            }
            return false;
          }
        });
      }
      /**
       * 从集合中删除所有数据源
       * @param {Boolean} destroy 除删除数据源外是否还要销毁数据源
       */
    }, {
      key: "removeAll",
      value: function removeAll(destroy) {
        destroy = defaultValue$1(destroy, false);
        var dataSources = this._dataSources;
        for (var i = 0, len = dataSources.length; i < len; ++i) {
          var dataSource = dataSources[i];
          this.remove(dataSource, destroy);
          // if (destroy) {
          //   Promise.resolve(dataSource).then((dataSource) => {
          //     if (dataSource._source) {
          //       let workspace = this._pieGlobe.getDocument();
          //       let dataSourceManager = workspace.getDataSourceManager();
          //       const alias = dataSourceManager.getDataSourceAlias(
          //         dataSource._source
          //       );
          //       dataSourceManager.removeDataSource(alias);
          //     }
          //   });
          // }
        }
        // this._groupLayer.removeAllLayers();
        this._pieGlobe.refresh(true, false);
        // this._dataSources = [];
      }
      /**
       * 获取数据源集合
       * @returns {Array}
       */
    }, {
      key: "values",
      get: function get() {
        return this._dataSources;
      }
    }]);
    return DataSourceCollection;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class TerrainProvider
   * 地形图层类
   *
   */
  var TerrainProvider = /*#__PURE__*/function () {
    function TerrainProvider() {
      _classCallCheck(this, TerrainProvider);
      _defineProperty(this, "_pieGlobe", void 0);
    }
    _createClass(TerrainProvider, [{
      key: "pieGlobe",
      get: function get() {
        return this._pieGlobe;
      },
      set: function set(pieGlobe) {
        this._pieGlobe = pieGlobe;
      }
    }]);
    return TerrainProvider;
  }();

  var EllipsoidTerrainProvider = /*#__PURE__*/function (_TerrainProvider) {
    _inherits(EllipsoidTerrainProvider, _TerrainProvider);
    var _super = _createSuper(EllipsoidTerrainProvider);
    function EllipsoidTerrainProvider() {
      var _this;
      _classCallCheck(this, EllipsoidTerrainProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_pieGlobe", void 0);
      return _this;
    }
    _createClass(EllipsoidTerrainProvider, [{
      key: "pieGlobe",
      get: function get() {
        return this._pieGlobe;
      },
      set: function set(pieGlobe) {
        this._pieGlobe = pieGlobe;
        var globeModel = this._pieGlobe.getGlobeModel();
        globeModel.removeAllLayers();
      }
    }]);
    return EllipsoidTerrainProvider;
  }(TerrainProvider);

  /*
   * ImageryProvider类及其子类封装了加载各种影像图层的方法，可看作影像图层的数据源；
   * ImageryProvider类是抽象类、基类或者可将其理解为接口，它不能被直接实例化；
   * 用对应ImageryProvider子类去加载影像图层数据或服务。
   * 
   * */
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * @class ImageryProvider
   * 提供要显示在椭球表面上的图像。此类是抽象类、基类或者可将其理解为接口，不能直接实例化。
   */
  var ImageryProvider = /*#__PURE__*/_createClass(function ImageryProvider(imageryProvider, options) {
    _classCallCheck(this, ImageryProvider);
  });

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class SingleTileImageryProvider
   * 单张影像图层类
   * @extends ImageryProvider
   *
   */
  var SingleTileImageryProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(SingleTileImageryProvider, _ImageryProvider);
    var _super = _createSuper(SingleTileImageryProvider);
    /**
     * SingleTileImageryProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Resource | String} options.url 数据的Url
     * @param {Rectangle} options.rectangle 影像所覆盖的矩形（以弧度表示）。
     */
    function SingleTileImageryProvider(options) {
      var _this;
      _classCallCheck(this, SingleTileImageryProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('url is required.');
      }
      if (!defined$1(options.rectangle)) {
        throw new DeveloperError$1('rectangle is required.');
      }
      var westGeo = CesiumMath.toDegrees(defaultValue$1(options.rectangle.west, 0.0));
      var southGeo = CesiumMath.toDegrees(defaultValue$1(options.rectangle.south, 0.0));
      var eastGeo = CesiumMath.toDegrees(defaultValue$1(options.rectangle.east, 0.0));
      var northGeo = CesiumMath.toDegrees(defaultValue$1(options.rectangle.north, 0.0));
      options.rectangle = new PIEBounds(westGeo, northGeo, eastGeo, southGeo);
      _this._options = options;
      return _this;
    }
    return _createClass(SingleTileImageryProvider);
  }(ImageryProvider);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * @class ImageryLayer
   * 在Globe上显示来自单个影像提供者的瓦片影像数据的影像层。
   */
  var ImageryLayer = /*#__PURE__*/function () {
    /**
     * ImageryLayer类的构造函数
     * @param {ImageryProvider} imageryProvider -要使用的影像
     * @param {Object} options  
     */
    function ImageryLayer(imageryProvider, options) {
      _classCallCheck(this, ImageryLayer);
      _defineProperty(this, "_imageryProvider", void 0);
      _defineProperty(this, "_imageryLayer", void 0);
      _defineProperty(this, "_dataSource", void 0);
      _defineProperty(this, "_pieGlobe", void 0);
      if (!defined$1(imageryProvider)) {
        throw new DeveloperError$1('imageryProvider is required.');
      }
      this._imageryProvider = imageryProvider;
      if (imageryProvider instanceof SingleTileImageryProvider) {
        // 单张图片
        this._imageryLayer = new PIEGlobeGraphicsLayer();
      } else {
        // 其他影像
        this._dataSource = new PIETileRasterDataSource();
        this._dataSource.create({
          server: imageryProvider._options.url,
          alias: imageryProvider._options.alias || 'ImageryLayer',
          levelOffset: imageryProvider._options.levelOffset || 0,
          epsg: imageryProvider._options.epsg || 3857,
          tms: imageryProvider._options.tms || false
        });
        this._imageryLayer = new PIEGlobeTileRasterLayer();
        this._imageryLayer.setDataSource(this._dataSource);
      }
    }
    // 图层显隐
    /**
     * 获取是否显示此层
     * @returns {Boolean}
     */
    _createClass(ImageryLayer, [{
      key: "show",
      get: function get() {
        return this._imageryLayer.isVisible();
      }
      /**
       * 设置是否显示此层
       * @param {Boolean} value
       */,
      set: function set(value) {
        this._imageryLayer.setVisible(value);
        this._pieGlobe.refreshLayer(this._imageryLayer, false);
      }

      // 可见比例尺范围
      /**
       * 获取最大可见比例尺
       * @returns {Number}
       */
    }, {
      key: "maxVisibleScale",
      get: function get() {
        return this._imageryLayer.getMaxVisibleScale();
      }
      /**
       * 设置最大可见比例尺
       * @param {Number} scale
       */,
      set: function set(scale) {
        this._imageryLayer.setMaxVisibleScale(scale);
      }
      /**
       * 获取最小可见比例尺
       * @returns {Number}
       */
    }, {
      key: "minVisibleScale",
      get: function get() {
        return this._imageryLayer.getMinVisibleScale();
      }
      /**
       * 设置最小可见比例尺
       * @param {Number} scale
       */,
      set: function set(scale) {
        this._imageryLayer.setMinVisibleScale(scale);
      }
      /**
       * 获取使用的影像
       * @returns {imageryProvider}
       */
    }, {
      key: "imageryProvider",
      get: function get() {
        return this._imageryProvider;
      }
      /**
       * 获取影像图层
       * @returns {GlobeGraphicsLayer | GlobeTileRasterLayer}
       */
    }, {
      key: "value",
      get: function get() {
        return this._imageryLayer;
      }
      /**
       * 获取数据源
       * @returns {TileRasterDataSource}
       */
    }, {
      key: "dataSource",
      get: function get() {
        return this._dataSource;
      }
    }, {
      key: "alpha",
      get: function get() {}
      /**
       * 设置影像透明度
       * @param {Number} value
       */,
      set: function set(value) {
        var effectComposer = this._imageryLayer.getEffectComposer();
        var filter = new PIEGlobeColorEffectFilter();
        filter.setOpacity(value);
        effectComposer.addFilter(filter);
      }
    }, {
      key: "brightness",
      get: function get() {},
      set: function set(value) {}
    }, {
      key: "contrast",
      get: function get() {},
      set: function set(value) {}
    }]);
    return ImageryLayer;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class ImageryLayerCollection
   * 影像图层集合类
   */
  var ImageryLayerCollection = /*#__PURE__*/function () {
    // layer集合
    // ImageryLayer实例集合

    function ImageryLayerCollection() {
      _classCallCheck(this, ImageryLayerCollection);
      _defineProperty(this, "_hasAddLayer", false);
      _defineProperty(this, "_groupLayer", void 0);
      _defineProperty(this, "_imageryLayers", []);
      _defineProperty(this, "_pieGlobe", void 0);
      this._groupLayer = new PIEGlobeGroupLayer();
      this._groupLayer.setName('ImageryLayerCollection');
    }
    /**
     * 设置三维球体
     * @param {PieGlobe} value
     */
    _createClass(ImageryLayerCollection, [{
      key: "pieGlobe",
      set: function set(pieGlobe) {
        this._pieGlobe = pieGlobe;
        // this._pieGlobe.addLayer(this._groupLayer);
      }
      /**
       * 获取此集合中的层数
       * @returns {Number}
       */
    }, {
      key: "length",
      get: function get() {
        return this._groupLayer.getLayerCount();
      }
      /**
       * 在集合中添加一个图层
       * @param {ImageryLayer} layer 要添加的层
       * @param {Number} index 在其上添加图层的索引。如果省略，该层将添加在所有现有图层之上。
       */
    }, {
      key: "add",
      value: function add(layer, index) {
        var hasIndex = defined$1(index);
        var earthLayer = layer.value;
        if (!defined$1(layer)) {
          throw new DeveloperError$1('layer is required.');
        }
        if (hasIndex) {
          if (index < 0) {
            throw new DeveloperError$1('index must be greater than or equal to zero.');
          } else if (index > this._groupLayer.getLayerCount()) {
            throw new DeveloperError$1('index must be less than or equal to the number of layers.');
          }
        }
        if (!hasIndex) {
          this._groupLayer.addLayer(earthLayer);
          this._imageryLayers.push(layer);
        } else {
          this._groupLayer.addLayer(earthLayer);
          this._groupLayer.moveLayerTo(this._groupLayer.getLayerIndex(earthLayer), index);
          this._imageryLayers.splice(index, 0, layer);
        }
        if (!this._hasAddLayer) {
          this._pieGlobe.addLayer(this._groupLayer, true);
          //移动影像图层到最下面
          this._pieGlobe.moveLayerTo(this._pieGlobe.getLayerIndex(this._groupLayer), 0);
          // this._pieGlobe.refresh(true, true);
          this._pieGlobe.refreshLayer(this._groupLayer, true);
          this._hasAddLayer = true;
        }
        this._pieGlobe && this._pieGlobe.refresh(true, false);
      }
      /**
       * 使用给定的ImageryProvider创建一个新层，并将其添加到集合中
       * @param {ImageryProvider} imageryProvider 影像提供者为其创建新图层
       * @param {Number} index 在其上添加图层的索引。如果省略，该层将添加在所有现有图层之上。
       * @returns {ImageryLayer} -新创建的图层
       */
    }, {
      key: "addImageryProvider",
      value: function addImageryProvider(imageryProvider, index) {
        if (!defined$1(imageryProvider)) {
          throw new DeveloperError$1('imageryProvider is required.');
        }
        var layer = new ImageryLayer(imageryProvider);
        layer._pieGlobe = this._pieGlobe;
        // 区别单张图片影像
        if (layer.dataSource instanceof PIETileRasterDataSource) {
          var workspace = this._pieGlobe.getDocument();
          workspace.getDataSourceManager().addDataSource(layer.dataSource);
        }
        if (imageryProvider instanceof SingleTileImageryProvider) {
          var rasterBlock = new PIERasterBlock();
          var spatialReference = this._pieGlobe.getSpatialReference();
          var dataBounds = spatialReference.forwardBounds(imageryProvider._options.rectangle);
          var options = {
            bounds: dataBounds,
            url: imageryProvider._options.url
          };
          rasterBlock.load(options).then(function (value) {
            var FeatureElement = new PIEGlobeFeatureElement({
              geometry: value
            });
            layer.value.add(FeatureElement);
          });
        }
        if (!defined$1(index)) {
          this.add(layer);
        } else {
          this.add(layer, index);
        }
        return layer;
      }
      /**
       * 检查集合是否包含给定的图层
       * @param {ImageryLayer} layer
       * @returns {Boolean} -如果集合包含图层，则为true，否则为false。
       */
    }, {
      key: "contains",
      value: function contains(layer) {
        return this._imageryLayers.indexOf(layer) !== -1;
      }
      /**
       * 销毁集合中所有层所拥有的WebGL资源
       */
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAll();
        this._groupLayer.dispose();
        this._imageryLayers = [];
      }
      /**
       * 从集合中按索引获取图层
       * @param {Number} index 要检索的索引
       * @returns  {ImageryLayer} -给定索引处的图像图层
       */
    }, {
      key: "get",
      value: function get(index) {
        if (!defined$1(index)) {
          throw new DeveloperError$1('index is required.');
        }
        return this._imageryLayers[index];
      }
      /**
       * 确定集合中给定图层的索引
       * @param {ImageryLayer} layer 查找索引的层
       * @returns {Number} -集合中图层的索引；如果集合中不存在该图层，则为-1。
       */
    }, {
      key: "indexOf",
      value: function indexOf(layer) {
        if (!defined$1(layer)) {
          throw new DeveloperError$1('layer is required.');
        }
        return this._groupLayer.getLayerIndex(layer.value);
      }
      /**
       * 判断此对象是否销毁
       * @returns {Boolean} -如果此对象已销毁，则返回true；否则返回false。
       */
    }, {
      key: "isDestroyed",
      value: function isDestroyed() {
        return this._groupLayer && this._groupLayer.getHandle();
      }
      /**
       * 将图层降低到集合中的一个位置
       * @param {ImageryLayer} layer 要移动的层
       * @returns -如果在底部返回空
       */
    }, {
      key: "lower",
      value: function lower(layer) {
        var earthLayer = layer.value;
        var index = this._groupLayer.getLayerIndex(earthLayer);
        if (index <= 0) {
          return;
        }
        var temp = this._imageryLayers[index];
        this._imageryLayers[index] = this._imageryLayers[index - 1];
        this._imageryLayers[index - 1] = temp;

        // this._groupLayer.moveLayerDown(index);
        this._groupLayer.moveLayerUp(index);
      }
      /**
       * 将图层降低到集合的底部
       * @param {ImageryLayer} layer 要移动的层
       * @returns -如果在底部返回空
       */
    }, {
      key: "lowerToBottom",
      value: function lowerToBottom(layer) {
        var earthLayer = layer.value;
        var index = this._groupLayer.getLayerIndex(earthLayer);
        if (index === 0) {
          return;
        }
        this._imageryLayers.splice(index, 1);
        this._imageryLayers.splice(0, 0, layer);
        this._groupLayer.moveLayerTop(index);
      }
      /**
       * 在集合中的一个位置上提升一层
       * @param {ImageryLayer} layer 要移动的层
       * @returns -如果在顶部返回空
       */
    }, {
      key: "raise",
      value: function raise(layer) {
        var earthLayer = layer.value;
        var index = this._groupLayer.getLayerIndex(earthLayer);
        if (index >= this.length - 1) {
          return;
        }
        var temp = this._imageryLayers[index];
        this._imageryLayers[index] = this._imageryLayers[index + 1];
        this._imageryLayers[index + 1] = temp;
        this._groupLayer.moveLayerDown(index);
      }
      /**
       * 将一个图层提升到集合的顶部
       * @param {ImageryLayer} layer 要移动的层
       * @returns -如果在顶部返回空
       */
    }, {
      key: "raiseToTop",
      value: function raiseToTop(layer) {
        var earthLayer = layer.value;
        var index = this._groupLayer.getLayerIndex(earthLayer);
        if (index === this.length - 1) {
          return;
        }
        this._imageryLayers.splice(index, 1);
        this._imageryLayers.splice(this._imageryLayers.length, 0, layer);
        this._groupLayer.moveLayerBottom(index);
      }
      /**
       * 从集合中删除一个图层（如果存在）
       * @param {ImageryLayer} layer 要删除的图层
       * @param {Boolean} destroy 除删除图层外是否还要销毁这些图层
       * @returns {Boolean} -如果该图层在集合中并已删除，则为true，如果图层不在集合中，则返回false。
       */
    }, {
      key: "remove",
      value: function remove(layer, destroy) {
        var earthLayer = layer.value;
        // const layerDataSource = layer.dataSource;
        var index = this._imageryLayers.indexOf(layer);
        if (index !== -1) {
          this._imageryLayers.splice(index, 1);
          this._groupLayer.removeLayer(earthLayer);
          // console.log(earthLayer);
          // console.log(layerDataSource);
          // destroy && earthLayer.dispose();
          // destroy && layerDataSource.dispose();
          return true;
        }
        return false;
      }
      /**
       * 删除集合所有图层
       * @param {Boolean} destroy 除删除图层外是否还要销毁这些图层
       */
    }, {
      key: "removeAll",
      value: function removeAll(destroy) {
        // if (destroy) {
        // for (let i = 0; i < this._imageryLayers.length; i++) {
        // const layer = this._imageryLayers[i];
        // const layerDataSource = layer.layer.dataSource;
        // const earthLayer = this._imageryLayers[i].value;
        // earthLayer && earthLayer.dispose();
        // layerDataSource && layerDataSource.dispose();
        // }
        // }
        this._groupLayer.removeAllLayers();
        this._imageryLayers = [];
      }
    }]);
    return ImageryLayerCollection;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * @class Layer3DCollection
   * 三维瓦片图层集合
   */
  var Layer3DCollection = /*#__PURE__*/function () {
    function Layer3DCollection() {
      _classCallCheck(this, Layer3DCollection);
      _defineProperty(this, "_dataSources", []);
      _defineProperty(this, "_groupLayer", void 0);
      _defineProperty(this, "_pieGlobe", void 0);
      this._groupLayer = new PIEGlobeGroupLayer();
      this._groupLayer.setName('Layer3DCollection');
    }
    /**
     * 设置三维球体
     * @param {PieGlobe} value
     */
    _createClass(Layer3DCollection, [{
      key: "pieGlobe",
      get:
      /**
       * 获取三维球体
       * @returns {PieGlobe}
       */
      function get() {
        return this._pieGlobe;
      }
      /**
       * 在集合中添加一个图层
       * @param {DataSource} dataSource 要添加的层
       */,
      set: function set(value) {
        this._pieGlobe = value;
        this._pieGlobe.addLayer(this._groupLayer);
      }
    }, {
      key: "add",
      value: function add(dataSource) {
        this._dataSources.push(dataSource);
        var workspace = this._pieGlobe.getDocument();
        workspace.getDataSourceManager().addDataSource(dataSource._source);
        this._groupLayer.addLayer(dataSource._layer);
        this._pieGlobe.refresh(false, false);
        return dataSource;
      }
      /**
       * 从集合中删除一个图层（如果存在）
       * @param {DataSource} dataSource 要删除的图层
       * @param {Boolean} destroy 除删除图层外是否还要销毁这些图层
       * @returns {Boolean} -如果该图层在集合中并已删除，则为true，如果图层不在集合中，则返回false。
       */
    }, {
      key: "remove",
      value: function remove(dataSource, destroy) {
        destroy = defaultValue$1(destroy, false);
        var index = this._dataSources.indexOf(dataSource);
        if (index !== -1) {
          this._dataSources.splice(index, 1);
          this._groupLayer.removeLayer(dataSource._layer);
          this._pieGlobe.refresh(true, false);
          if (destroy) {
            var workspace = this._pieGlobe.getDocument();
            var dataSourceManager = workspace.getDataSourceManager();
            var alias = dataSourceManager.getDataSourceAlias(dataSource._source);
            dataSourceManager.removeDataSource(alias);
          }
          return true;
        }
        return false;
      }
      /**
       * 删除集合所有图层
       * @param {Boolean} destroy 除删除图层外是否还要销毁这些图层
       */
    }, {
      key: "removeAll",
      value: function removeAll(destroy) {
        destroy = defaultValue$1(destroy, false);
        var dataSources = this._dataSources;
        for (var i = 0, len = dataSources.length; i < len; ++i) {
          var dataSource = dataSources[i];
          this._groupLayer.removeLayer(dataSource._layer);
          this._pieGlobe.refresh(true, false);
          if (destroy) {
            var workspace = this._pieGlobe.getDocument();
            var dataSourceManager = workspace.getDataSourceManager();
            var alias = dataSourceManager.getDataSourceAlias(dataSource._source);
            dataSourceManager.removeDataSource(alias);
          }
        }
        this._dataSources = [];
      }
    }]);
    return Layer3DCollection;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 
   * @class VectorTileLayerCollection
   * 矢量瓦片图层集合类
   *
   */
  var VectorTileLayerCollection = /*#__PURE__*/function () {
    // layer集合
    // vectorTileLayerProvider实例集合

    function VectorTileLayerCollection() {
      _classCallCheck(this, VectorTileLayerCollection);
      _defineProperty(this, "_groupLayer", void 0);
      _defineProperty(this, "_vectorTileLayers", []);
      _defineProperty(this, "_pieGlobe", void 0);
      this._groupLayer = new PIEGlobeGroupLayer();
      this._groupLayer.setName('VectorTileLayerCollection');
    }
    /**
     * 设置三维球体
     * @param {PieGlobe} pieGlobe
     */
    _createClass(VectorTileLayerCollection, [{
      key: "pieGlobe",
      set: function set(pieGlobe) {
        this._pieGlobe = pieGlobe;
        this._pieGlobe.addLayer(this._groupLayer);
      }
      /**
       * 在集合中添加一个图层
       * @param {VectorTileLayerProvider} provider 要添加的层
       * @param {Number} index 在其上添加图层的索引。如果省略，该层将添加在所有现有图层之上。
       */
    }, {
      key: "add",
      value: function add(provider, index) {
        var layer = provider.value;
        var hasIndex = defined$1(index);
        if (!defined$1(provider)) {
          throw new DeveloperError$1('provider is required.');
        }
        if (hasIndex) {
          if (index < 0) {
            throw new DeveloperError$1('index must be greater than or equal to zero.');
          } else if (index > this._groupLayer.getLayerCount()) {
            throw new DeveloperError$1('index must be less than or equal to the number of layers.');
          }
        }
        if (!hasIndex) {
          this._groupLayer.addLayer(layer);
          this._vectorTileLayers.push(provider);
        } else {
          this._groupLayer.addLayer(layer);
          this._groupLayer.moveLayerTo(this._groupLayer.getLayerIndex(layer), index);
          this._vectorTileLayers.splice(index, 0, provider);
        }
        this._pieGlobe && this._pieGlobe.refresh(true, false);
      }
      /**
       * 使用给定的vectorTileLayerProvider创建一个新层，并将其添加到集合中
       * @param {VectorTileLayerProvider} vectorTileLayerProvider   矢量瓦片图层
       * @param {Number} index 在其上添加图层的索引。如果省略，该层将添加在所有现有图层之上。
       * @returns {VectorTileLayerProvider} -新创建的图层
       */
    }, {
      key: "addImageryProvider",
      value: function addImageryProvider(provider, index) {
        if (!defined$1(provider)) {
          throw new DeveloperError$1('provider is required.');
        }
        var layer = provider.value;
        var workspace = this._pieGlobe.getDocument();
        layer.open.apply(layer, [workspace].concat(_toConsumableArray(provider.urlArray)));
        if (!defined$1(index)) {
          this.add(provider);
        } else {
          this.add(provider, index);
        }
        return provider;
      }
      /**
      * 从集合中删除一个给定的vectorTileLayerProvider层（如果存在）
      * @param {vectorTileLayerProvider} provider 要删除的矢量瓦片图层
      * @param {Boolean} destroy 除删除图层外是否还要销毁这些图层
      * @returns {Boolean} -如果该图层在集合中并已删除，则为true，如果图层不在集合中，则返回false。
      */
    }, {
      key: "remove",
      value: function remove(provider, destroy) {
        var earthLayer = provider.value;
        var index = this._vectorTileLayers.indexOf(provider);
        if (index !== -1) {
          this._vectorTileLayers.splice(index, 1);
          this._groupLayer.removeLayer(earthLayer);
          return true;
        }
        return false;
      }
      /**
       * 删除集合所有图层
       * @param {Boolean} destroy 除删除图层外是否还要销毁这些图层
       */
    }, {
      key: "removeAll",
      value: function removeAll(destroy) {
        this._groupLayer.removeAllLayers();
        this._imageryLayers = [];
      }
    }]);
    return VectorTileLayerCollection;
  }();

  /**
   * The Ease class provides a collection of easing functions for use with tween.js.
   */
  var Easing = {
    Linear: {
      None: function None(amount) {
        return amount;
      }
    },
    Quadratic: {
      In: function In(amount) {
        return amount * amount;
      },
      Out: function Out(amount) {
        return amount * (2 - amount);
      },
      InOut: function InOut(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount;
        }
        return -0.5 * (--amount * (amount - 2) - 1);
      }
    },
    Cubic: {
      In: function In(amount) {
        return amount * amount * amount;
      },
      Out: function Out(amount) {
        return --amount * amount * amount + 1;
      },
      InOut: function InOut(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount * amount;
        }
        return 0.5 * ((amount -= 2) * amount * amount + 2);
      }
    },
    Quartic: {
      In: function In(amount) {
        return amount * amount * amount * amount;
      },
      Out: function Out(amount) {
        return 1 - --amount * amount * amount * amount;
      },
      InOut: function InOut(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount * amount * amount;
        }
        return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
      }
    },
    Quintic: {
      In: function In(amount) {
        return amount * amount * amount * amount * amount;
      },
      Out: function Out(amount) {
        return --amount * amount * amount * amount * amount + 1;
      },
      InOut: function InOut(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount * amount * amount * amount;
        }
        return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
      }
    },
    Sinusoidal: {
      In: function In(amount) {
        return 1 - Math.cos(amount * Math.PI / 2);
      },
      Out: function Out(amount) {
        return Math.sin(amount * Math.PI / 2);
      },
      InOut: function InOut(amount) {
        return 0.5 * (1 - Math.cos(Math.PI * amount));
      }
    },
    Exponential: {
      In: function In(amount) {
        return amount === 0 ? 0 : Math.pow(1024, amount - 1);
      },
      Out: function Out(amount) {
        return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
      },
      InOut: function InOut(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        if ((amount *= 2) < 1) {
          return 0.5 * Math.pow(1024, amount - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
      }
    },
    Circular: {
      In: function In(amount) {
        return 1 - Math.sqrt(1 - amount * amount);
      },
      Out: function Out(amount) {
        return Math.sqrt(1 - --amount * amount);
      },
      InOut: function InOut(amount) {
        if ((amount *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
      }
    },
    Elastic: {
      In: function In(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      },
      Out: function Out(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
      },
      InOut: function InOut(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        amount *= 2;
        if (amount < 1) {
          return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        }
        return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
      }
    },
    Back: {
      In: function In(amount) {
        var s = 1.70158;
        return amount * amount * ((s + 1) * amount - s);
      },
      Out: function Out(amount) {
        var s = 1.70158;
        return --amount * amount * ((s + 1) * amount + s) + 1;
      },
      InOut: function InOut(amount) {
        var s = 1.70158 * 1.525;
        if ((amount *= 2) < 1) {
          return 0.5 * (amount * amount * ((s + 1) * amount - s));
        }
        return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
      }
    },
    Bounce: {
      In: function In(amount) {
        return 1 - Easing.Bounce.Out(1 - amount);
      },
      Out: function Out(amount) {
        if (amount < 1 / 2.75) {
          return 7.5625 * amount * amount;
        } else if (amount < 2 / 2.75) {
          return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
        } else if (amount < 2.5 / 2.75) {
          return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
        } else {
          return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
        }
      },
      InOut: function InOut(amount) {
        if (amount < 0.5) {
          return Easing.Bounce.In(amount * 2) * 0.5;
        }
        return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
      }
    }
  };
  var now;
  // Include a performance.now polyfill.
  // In node.js, use process.hrtime.
  // eslint-disable-next-line
  // @ts-ignore
  if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
    now = function now() {
      // eslint-disable-next-line
      // @ts-ignore
      var time = process.hrtime();
      // Convert [seconds, nanoseconds] to milliseconds.
      return time[0] * 1000 + time[1] / 1000000;
    };
  }
  // In a browser, use self.performance.now if it is available.
  else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
  }
  // Use Date.now if it is available.
  else if (Date.now !== undefined) {
    now = Date.now;
  }
  // Otherwise, use 'new Date().getTime()'.
  else {
    now = function now() {
      return new Date().getTime();
    };
  }
  var now$1 = now;

  /**
   * Controlling groups of tweens
   *
   * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
   * In these cases, you may want to create your own smaller groups of tween
   */
  var Group = /** @class */function () {
    function Group() {
      this._tweens = {};
      this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
      var _this = this;
      return Object.keys(this._tweens).map(function (tweenId) {
        return _this._tweens[tweenId];
      });
    };
    Group.prototype.removeAll = function () {
      this._tweens = {};
    };
    Group.prototype.add = function (tween) {
      this._tweens[tween.getId()] = tween;
      this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
      delete this._tweens[tween.getId()];
      delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
      if (time === void 0) {
        time = now$1();
      }
      if (preserve === void 0) {
        preserve = false;
      }
      var tweenIds = Object.keys(this._tweens);
      if (tweenIds.length === 0) {
        return false;
      }
      // Tweens are updated in "batches". If you add a new tween during an
      // update, then the new tween will be updated in the next batch.
      // If you remove a tween during an update, it may or may not be updated.
      // However, if the removed tween was added during the current batch,
      // then it will not be updated.
      while (tweenIds.length > 0) {
        this._tweensAddedDuringUpdate = {};
        for (var i = 0; i < tweenIds.length; i++) {
          var tween = this._tweens[tweenIds[i]];
          var autoStart = !preserve;
          if (tween && tween.update(time, autoStart) === false && !preserve) {
            delete this._tweens[tweenIds[i]];
          }
        }
        tweenIds = Object.keys(this._tweensAddedDuringUpdate);
      }
      return true;
    };
    return Group;
  }();

  /**
   *
   */
  var Interpolation = {
    Linear: function Linear(v, k) {
      var m = v.length - 1;
      var f = m * k;
      var i = Math.floor(f);
      var fn = Interpolation.Utils.Linear;
      if (k < 0) {
        return fn(v[0], v[1], f);
      }
      if (k > 1) {
        return fn(v[m], v[m - 1], m - f);
      }
      return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function Bezier(v, k) {
      var b = 0;
      var n = v.length - 1;
      var pw = Math.pow;
      var bn = Interpolation.Utils.Bernstein;
      for (var i = 0; i <= n; i++) {
        b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
      }
      return b;
    },
    CatmullRom: function CatmullRom(v, k) {
      var m = v.length - 1;
      var f = m * k;
      var i = Math.floor(f);
      var fn = Interpolation.Utils.CatmullRom;
      if (v[0] === v[m]) {
        if (k < 0) {
          i = Math.floor(f = m * (1 + k));
        }
        return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
      } else {
        if (k < 0) {
          return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
        }
        if (k > 1) {
          return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }
        return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
      }
    },
    Utils: {
      Linear: function Linear(p0, p1, t) {
        return (p1 - p0) * t + p0;
      },
      Bernstein: function Bernstein(n, i) {
        var fc = Interpolation.Utils.Factorial;
        return fc(n) / fc(i) / fc(n - i);
      },
      Factorial: function () {
        var a = [1];
        return function (n) {
          var s = 1;
          if (a[n]) {
            return a[n];
          }
          for (var i = n; i > 1; i--) {
            s *= i;
          }
          a[n] = s;
          return s;
        };
      }(),
      CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    }
  };

  /**
   * Utils
   */
  var Sequence = /** @class */function () {
    function Sequence() {}
    Sequence.nextId = function () {
      return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
  }();
  var mainGroup = new Group();

  /**
   * Tween.js - Licensed under the MIT license
   * https://github.com/tweenjs/tween.js
   * ----------------------------------------------
   *
   * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
   * Thank you all, you're awesome!
   */
  var Tween = /** @class */function () {
    function Tween(_object, _group) {
      if (_group === void 0) {
        _group = mainGroup;
      }
      this._object = _object;
      this._group = _group;
      this._isPaused = false;
      this._pauseStart = 0;
      this._valuesStart = {};
      this._valuesEnd = {};
      this._valuesStartRepeat = {};
      this._duration = 1000;
      this._initialRepeat = 0;
      this._repeat = 0;
      this._yoyo = false;
      this._isPlaying = false;
      this._reversed = false;
      this._delayTime = 0;
      this._startTime = 0;
      this._easingFunction = Easing.Linear.None;
      this._interpolationFunction = Interpolation.Linear;
      this._chainedTweens = [];
      this._onStartCallbackFired = false;
      this._id = Sequence.nextId();
      this._isChainStopped = false;
      this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
      return this._id;
    };
    Tween.prototype.isPlaying = function () {
      return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
      return this._isPaused;
    };
    Tween.prototype.to = function (properties, duration) {
      // TODO? restore this, then update the 07_dynamic_to example to set fox
      // tween's to on each update. That way the behavior is opt-in (there's
      // currently no opt-out).
      // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
      this._valuesEnd = Object.create(properties);
      if (duration !== undefined) {
        this._duration = duration;
      }
      return this;
    };
    Tween.prototype.duration = function (d) {
      this._duration = d;
      return this;
    };
    Tween.prototype.start = function (time) {
      if (this._isPlaying) {
        return this;
      }
      // eslint-disable-next-line
      this._group && this._group.add(this);
      this._repeat = this._initialRepeat;
      if (this._reversed) {
        // If we were reversed (f.e. using the yoyo feature) then we need to
        // flip the tween direction back to forward.
        this._reversed = false;
        for (var property in this._valuesStartRepeat) {
          this._swapEndStartRepeatValues(property);
          this._valuesStart[property] = this._valuesStartRepeat[property];
        }
      }
      this._isPlaying = true;
      this._isPaused = false;
      this._onStartCallbackFired = false;
      this._isChainStopped = false;
      this._startTime = time !== undefined ? typeof time === 'string' ? now$1() + parseFloat(time) : time : now$1();
      this._startTime += this._delayTime;
      this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
      return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
      for (var property in _valuesEnd) {
        var startValue = _object[property];
        var startValueIsArray = Array.isArray(startValue);
        var propType = startValueIsArray ? 'array' : _typeof(startValue);
        var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
        // If `to()` specifies a property that doesn't exist in the source object,
        // we should not set that property in the object
        if (propType === 'undefined' || propType === 'function') {
          continue;
        }
        // Check if an Array was provided as property value
        if (isInterpolationList) {
          var endValues = _valuesEnd[property];
          if (endValues.length === 0) {
            continue;
          }
          // handle an array of relative values
          endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
          // Create a local copy of the Array with the start value at the front
          _valuesEnd[property] = [startValue].concat(endValues);
        }
        // handle the deepness of the values
        if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
          _valuesStart[property] = startValueIsArray ? [] : {};
          // eslint-disable-next-line
          for (var prop in startValue) {
            // eslint-disable-next-line
            // @ts-ignore FIXME?
            _valuesStart[property][prop] = startValue[prop];
          }
          _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
          // eslint-disable-next-line
          // @ts-ignore FIXME?
          this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
        } else {
          // Save the starting value, but only once.
          if (typeof _valuesStart[property] === 'undefined') {
            _valuesStart[property] = startValue;
          }
          if (!startValueIsArray) {
            // eslint-disable-next-line
            // @ts-ignore FIXME?
            _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
          }

          if (isInterpolationList) {
            // eslint-disable-next-line
            // @ts-ignore FIXME?
            _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
          } else {
            _valuesStartRepeat[property] = _valuesStart[property] || 0;
          }
        }
      }
    };
    Tween.prototype.stop = function () {
      if (!this._isChainStopped) {
        this._isChainStopped = true;
        this.stopChainedTweens();
      }
      if (!this._isPlaying) {
        return this;
      }
      // eslint-disable-next-line
      this._group && this._group.remove(this);
      this._isPlaying = false;
      this._isPaused = false;
      if (this._onStopCallback) {
        this._onStopCallback(this._object);
      }
      return this;
    };
    Tween.prototype.end = function () {
      this._goToEnd = true;
      this.update(Infinity);
      return this;
    };
    Tween.prototype.pause = function (time) {
      if (time === void 0) {
        time = now$1();
      }
      if (this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = true;
      this._pauseStart = time;
      // eslint-disable-next-line
      this._group && this._group.remove(this);
      return this;
    };
    Tween.prototype.resume = function (time) {
      if (time === void 0) {
        time = now$1();
      }
      if (!this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = false;
      this._startTime += time - this._pauseStart;
      this._pauseStart = 0;
      // eslint-disable-next-line
      this._group && this._group.add(this);
      return this;
    };
    Tween.prototype.stopChainedTweens = function () {
      for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
        this._chainedTweens[i].stop();
      }
      return this;
    };
    Tween.prototype.group = function (group) {
      this._group = group;
      return this;
    };
    Tween.prototype.delay = function (amount) {
      this._delayTime = amount;
      return this;
    };
    Tween.prototype.repeat = function (times) {
      this._initialRepeat = times;
      this._repeat = times;
      return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
      this._repeatDelayTime = amount;
      return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
      this._yoyo = yoyo;
      return this;
    };
    Tween.prototype.easing = function (easingFunction) {
      this._easingFunction = easingFunction;
      return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
      this._interpolationFunction = interpolationFunction;
      return this;
    };
    Tween.prototype.chain = function () {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      this._chainedTweens = tweens;
      return this;
    };
    Tween.prototype.onStart = function (callback) {
      this._onStartCallback = callback;
      return this;
    };
    Tween.prototype.onUpdate = function (callback) {
      this._onUpdateCallback = callback;
      return this;
    };
    Tween.prototype.onRepeat = function (callback) {
      this._onRepeatCallback = callback;
      return this;
    };
    Tween.prototype.onComplete = function (callback) {
      this._onCompleteCallback = callback;
      return this;
    };
    Tween.prototype.onStop = function (callback) {
      this._onStopCallback = callback;
      return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
      if (time === void 0) {
        time = now$1();
      }
      if (autoStart === void 0) {
        autoStart = true;
      }
      if (this._isPaused) return true;
      var property;
      var elapsed;
      var endTime = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (time > endTime) return false;
        if (autoStart) this.start(time);
      }
      this._goToEnd = false;
      if (time < this._startTime) {
        return true;
      }
      if (this._onStartCallbackFired === false) {
        if (this._onStartCallback) {
          this._onStartCallback(this._object);
        }
        this._onStartCallbackFired = true;
      }
      elapsed = (time - this._startTime) / this._duration;
      elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
      var value = this._easingFunction(elapsed);
      // properties transformations
      this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
      if (this._onUpdateCallback) {
        this._onUpdateCallback(this._object, elapsed);
      }
      if (elapsed === 1) {
        if (this._repeat > 0) {
          if (isFinite(this._repeat)) {
            this._repeat--;
          }
          // Reassign starting values, restart by making startTime = now
          for (property in this._valuesStartRepeat) {
            if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
              this._valuesStartRepeat[property] =
              // eslint-disable-next-line
              // @ts-ignore FIXME?
              this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
            }
            if (this._yoyo) {
              this._swapEndStartRepeatValues(property);
            }
            this._valuesStart[property] = this._valuesStartRepeat[property];
          }
          if (this._yoyo) {
            this._reversed = !this._reversed;
          }
          if (this._repeatDelayTime !== undefined) {
            this._startTime = time + this._repeatDelayTime;
          } else {
            this._startTime = time + this._delayTime;
          }
          if (this._onRepeatCallback) {
            this._onRepeatCallback(this._object);
          }
          return true;
        } else {
          if (this._onCompleteCallback) {
            this._onCompleteCallback(this._object);
          }
          for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            // Make the chained tweens start exactly at the time they should,
            // even if the `update()` method was called way past the duration of the tween
            this._chainedTweens[i].start(this._startTime + this._duration);
          }
          this._isPlaying = false;
          return false;
        }
      }
      return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
      for (var property in _valuesEnd) {
        // Don't update properties that do not exist in the source object
        if (_valuesStart[property] === undefined) {
          continue;
        }
        var start = _valuesStart[property] || 0;
        var end = _valuesEnd[property];
        var startIsArray = Array.isArray(_object[property]);
        var endIsArray = Array.isArray(end);
        var isInterpolationList = !startIsArray && endIsArray;
        if (isInterpolationList) {
          _object[property] = this._interpolationFunction(end, value);
        } else if (_typeof(end) === 'object' && end) {
          // eslint-disable-next-line
          // @ts-ignore FIXME?
          this._updateProperties(_object[property], start, end, value);
        } else {
          // Parses relative end values with start as base (e.g.: +10, -3)
          end = this._handleRelativeValue(start, end);
          // Protect against non numeric properties.
          if (typeof end === 'number') {
            // eslint-disable-next-line
            // @ts-ignore FIXME?
            _object[property] = start + (end - start) * value;
          }
        }
      }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
      if (typeof end !== 'string') {
        return end;
      }
      if (end.charAt(0) === '+' || end.charAt(0) === '-') {
        return start + parseFloat(end);
      } else {
        return parseFloat(end);
      }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
      var tmp = this._valuesStartRepeat[property];
      var endValue = this._valuesEnd[property];
      if (typeof endValue === 'string') {
        this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
      } else {
        this._valuesStartRepeat[property] = this._valuesEnd[property];
      }
      this._valuesEnd[property] = tmp;
    };
    return Tween;
  }();

  /**
   * Tween.js - Licensed under the MIT license
   * https://github.com/tweenjs/tween.js
   * ----------------------------------------------
   *
   * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
   * Thank you all, you're awesome!
   */
  Sequence.nextId;
  /**
   * Controlling groups of tweens
   *
   * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
   * In these cases, you may want to create your own smaller groups of tweens.
   */
  var TWEEN = mainGroup;
  // This is the best way to export things in a way that's compatible with both ES
  // Modules and CommonJS, without build hacks, and so as not to break the
  // existing API.
  // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
  TWEEN.getAll.bind(TWEEN);
  TWEEN.removeAll.bind(TWEEN);
  TWEEN.add.bind(TWEEN);
  TWEEN.remove.bind(TWEEN);
  var update = TWEEN.update.bind(TWEEN);

  /*
  用于定位飞行
   */
  function flyTo(_ref) {
    var globe = _ref.globe,
      destination = _ref.destination,
      orientation = _ref.orientation,
      distance = _ref.distance,
      time = _ref.time,
      _ref$minHeight = _ref.minHeight,
      minHeight = _ref$minHeight === void 0 ? 500 : _ref$minHeight,
      onComplete = _ref.onComplete;
    if (!defined$1(destination)) {
      throw new Error('destination必传！');
    }
    var targetLon = defaultValue$1(destination.lon, 0);
    var targetLat = defaultValue$1(destination.lat, 0);
    var targetHeight = defaultValue$1(destination.height, 0);
    orientation = defaultValue$1(orientation, defaultValue$1.EMPTY_OBJECT);
    //heading跟roll与cesium相反，做个调整
    var heading = defaultValue$1(orientation.heading, 0);
    var pitch = defaultValue$1(orientation.pitch, 0);
    defaultValue$1(orientation.roll, 0);
    time = defaultValue$1(time, 5000);
    var complete = defaultValue$1(onComplete, function () {
      globe.refresh(true, false);
      console.log('飞行完成');
    });
    // globe.setHeadingAngle(0);//设置正北显示
    // globe.refresh(false, false);
    var firstTime = time * 0.5;
    var secondTime = time * 0.5;
    var camera = globe.getWorldCamera();
    var cameraPosition = camera.getCameraPosition();

    //计算目标的世界坐标
    var targetWorldPosition = globe.geoToWorld([targetLon, targetLat], targetHeight);
    var srcToTargetVector = targetWorldPosition.sub(cameraPosition);
    var length = srcToTargetVector.length();
    var center = camera.getLookAtCenter();
    var spatialReference = globe.getSpatialReference(); //创建WebMercator坐标系统对象
    var srcPoint = new PIEVector2(center.x, center.y);
    var desPoint = spatialReference.inverse(srcPoint); //投影坐标点转换为经纬度坐标

    var lon = desPoint.x;
    var lat = desPoint.y;

    //计算经纬度差异小于某一个值
    var offsetLon = targetLon - lon <= 180 ? targetLon - lon : 360 - (targetLon - lon);
    var offsetLat = targetLat - lat;
    var lengthGeo = Math.pow(offsetLon, 2) + Math.pow(offsetLat, 2);
    var midLon = (lon + targetLon) / 2;
    var midLat = (lat + targetLat) / 2;

    //转换为屏幕坐标

    var deviceTarget = globe.worldToDevice(targetWorldPosition);
    var worldCamera = globe.getWorldCamera();
    var cameraDistance = worldCamera.getDistance();
    var midHeight = Math.max(cameraDistance, distance, length, minHeight);
    var mapCenter = globe.getCenter();
    var currentHeading = globe.getHeadingAngle();
    var pitchAngle = globe.getPitchAngle();
    var spatialRef = globe.getSpatialReference();
    var current = {
      x: mapCenter.x,
      y: mapCenter.y,
      z: cameraDistance,
      distance: cameraDistance,
      heading: currentHeading,
      pitch: pitchAngle,
      roll: 0
    };
    var midPoint = spatialRef.forward([midLon, midLat]);
    var targetHeading = getTargetHeading(currentHeading, heading);
    var midPitch = pitchAngle + (pitch - pitchAngle) / 2;
    var midTarget = {
      x: midPoint[0],
      y: midPoint[1],
      z: 0,
      distance: midHeight,
      heading: currentHeading + (targetHeading - currentHeading) / 2,
      pitch: midPitch,
      roll: 0
    };
    if (deviceTarget.x < window.innerWidth && deviceTarget.x > 0 && deviceTarget.y > 0 && deviceTarget.y < window.innerHeight && lengthGeo < 100) {
      firstTime = 0;
      secondTime = time;
      midTarget = current;
    }
    var targetPoint = spatialRef.forward([targetLon, targetLat]);

    //根据经纬度计算世界坐标
    var target = {
      x: targetPoint[0],
      y: targetPoint[1],
      z: 0,
      distance: distance,
      heading: targetHeading,
      pitch: pitch,
      roll: 0
    };
    var tween0 = fromFlyTo(globe, current, midTarget, Easing.Quadratic.Out, firstTime, null);
    var tween1 = fromFlyTo(globe, midTarget, target, Easing.Quadratic.Out, secondTime, complete);
    tween0.chain(tween1);
    tween0.start();

    // globe.setHeadingAngle(0); //设置正北显示
    globe.refresh(false, false);
  }
  function getTargetHeading(currentHeading, heading) {
    if (heading - currentHeading > 180) {
      heading -= 360;
    } else if (heading - currentHeading < -180) {
      heading += 360;
    }
    return heading % 360;
  }
  function fromFlyTo(globe, current, target, ease, duration, complete) {
    var worldCamera = globe.getWorldCamera();
    var tween = new Tween(current);
    tween.to(target, duration).easing(ease).onUpdate(function (object) {
      worldCamera.setLookAt([object.x, object.y, object.z], object.distance, object.heading, object.pitch, object.roll);
      globe.refresh(false, false);
    }).onComplete(function (object) {
      if (complete) {
        complete(object);
      }
    });
    return tween;
  }

  var radianToDegree = function radianToDegree(value) {
    return value * 180 / Math.PI;
  };

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * @class Camera
   * 相机，由位置、方向和视场定义
   */
  var Camera = /*#__PURE__*/function () {
    function Camera() {
      _classCallCheck(this, Camera);
      _defineProperty(this, "_position", void 0);
      _defineProperty(this, "_heading", void 0);
      _defineProperty(this, "_pitch", void 0);
      _defineProperty(this, "_roll", void 0);
      _defineProperty(this, "_scene", void 0);
      _defineProperty(this, "_pieGlobe", void 0);
      this._roll = 0;
    }
    /** 
     * 获取相机观察方向与正北方向之间的夹角
     * @returns {Number}
     */
    _createClass(Camera, [{
      key: "heading",
      get: function get() {
        this._heading = this._pieGlobe.getHeadingAngle();
        return this._heading;
      }
      /**
       * 设置相机观察方向与正北方向之间的夹角
       * @param {Number} value
       */,
      set: function set(value) {
        this._pieGlobe.setHeadingAngle(value);
      }
      /**
       * 获取相机观察方向与水平方向之间的夹角
       * @returns {Number}
       */
    }, {
      key: "pitch",
      get: function get() {
        this._pitch = this._pieGlobe.getPitchAngle();
        return this._pitch;
      }
      /**
       * 设置相机观察方向与水平方向之间的夹角
       * @param {Number} value
       */,
      set: function set(value) {
        this._pieGlobe.setPitchAngle(value);
      }
      /**
       * 获取相机绕其自身的观察方向旋转的角度
       * @returns {Number}
       */
    }, {
      key: "roll",
      get: function get() {
        return this._roll;
      }
      /**
       * 获取相机所处的位置
       * @returns {Cartesian3}
       */
    }, {
      key: "position",
      get: function get() {
        var pos = this._pieGlobe.getWorldCamera().getCameraPosition();
        var v = [pos.x, pos.y, pos.z];
        this._position = Cartesian3.fromArray(v);
        return this._position;
      }

      // set position(value) {
      //   this._position = value;
      // }
      /**
       * 获取相机的视野大小或放大倍数
       * @returns {Number}
       */
    }, {
      key: "zoom",
      get: function get() {
        return this._pieGlobe.getZoom();
      }
      /**
       * 设置相机的视野大小或放大倍数
       * @param {Number} value
       */,
      set: function set(value) {
        var maxZoom = this._pieGlobe.getMaxZoom();
        var minZoom = this._pieGlobe.getMinZoom();
        if (value >= maxZoom) {
          value = maxZoom;
        }
        if (value <= minZoom) {
          value = minZoom;
        }
        this._pieGlobe.setZoom(value);
        this._pieGlobe.refresh(false, false);
      }
      /**
       * 沿相方向缩放相机的视角向量 
       */
    }, {
      key: "zoomIn",
      value: function zoomIn() {
        var currentZoom = this._pieGlobe.getZoom();
        var maxZoom = this._pieGlobe.getMaxZoom();
        if (currentZoom < maxZoom) {
          this._pieGlobe.setZoom(currentZoom + 1);
        }
        this._pieGlobe.refresh(false, false);
      }
      /**
       * 沿相反方向缩放相机的视角向量  
       */
    }, {
      key: "zoomOut",
      value: function zoomOut() {
        var currentZoom = this._pieGlobe.getZoom();
        var minZoom = this._pieGlobe.getMinZoom();
        if (currentZoom > minZoom) {
          this._pieGlobe.setZoom(currentZoom - 1);
        }
        this._pieGlobe.refresh(false, false);
      }
    }, {
      key: "move",
      value: function move() {}
      /**
       * 将相机飞到主视图
       * @param {Number} duration -飞行持续时间（以秒为单位）
       */
    }, {
      key: "flyHome",
      value: function flyHome(duration) {
        this.flyTo({
          destination: Cartesian3.fromDegrees(116.4, 39.9, 11000000),
          duration: defaultValue$1(duration, 5)
        });
      }
      /**
       * 将相机从当前位置移动到新位置
       * @param {Object} options
       * @param {Cartesian3 | Rectangle} options.destination -相机在WGS84（世界）坐标中的最终位置或从上向下视图中可见的矩形。
       * @param {Object} options.orientation -包含方向和向上属性或航向，俯仰和横滚属性的对象。默认情况下，方向将指向在3D中朝向帧中心，在哥伦布视图中沿负z方向。向上方向将指向3D局部正北哥伦布视图中的y方向。在无限滚动模式下，二维不使用方向。
       * @param {Number} options.duration -飞行持续时间（以秒为单位）。
       * @param {Camera~FlightCompleteCallback} options.complete -飞行结束后执行的功能
       * 
       * @example
       *         viewer.camera.flyTo({
              destination: Earth.Cartesian3.fromDegrees(108, 34, 15000.0),
              orientation: {
                heading: Earth.Math.toRadians(60),
                pitch: Earth.Math.toRadians(0),
                roll: 0.0,
              },
              duration: 2,
              complete: () => {
                console.log('complete');
              },
            });
       */
    }, {
      key: "flyTo",
      value: function flyTo$1(options) {
        options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
        var destination = Cartographic.fromCartesian(options.destination);
        destination.longitude = radianToDegree(destination.longitude);
        destination.latitude = radianToDegree(destination.latitude);
        var pieDestination = {
          lon: destination.longitude,
          lat: destination.latitude,
          height: destination.height
        };
        if (defined$1(options.orientation)) {
          if (defined$1(options.orientation.heading)) {
            options.orientation.heading = CesiumMath.toDegrees(options.orientation.heading);
          }
          if (defined$1(options.orientation.pitch)) {
            options.orientation.pitch = CesiumMath.toDegrees(options.orientation.pitch);
          }
          if (defined$1(options.orientation.roll)) {
            options.orientation.roll = CesiumMath.toDegrees(options.orientation.roll);
          }
        } else {
          options.orientation = {
            heading: 0,
            pitch: 0,
            roll: 0
          };
        }
        if (!defined$1(options.duration)) {
          options.duration = 5000;
        } else {
          options.duration *= 1000;
          if (options.duration < 0) {
            options.duration = 5000;
          }
        }
        flyTo({
          globe: this._pieGlobe,
          destination: pieDestination,
          orientation: options.orientation,
          distance: defaultValue$1(destination.height, 500),
          time: options.duration,
          minHeight: 500,
          onComplete: options.complete
        });
      }

      // setView(options) {
      //   options = defaultValue(options, defaultValue.EMPTY_OBJECT);
      //   let destination = Cartographic.fromCartesian(options.destination);
      //   destination.longitude = radianToDegree(destination.longitude);
      //   destination.latitude = radianToDegree(destination.latitude);

      //   if (defined(options.orientation)) {
      //     if (defined(options.orientation.heading)) {
      //       options.orientation.heading = CesiumMath.toDegrees(
      //         options.orientation.heading
      //       );
      //     }
      //     if (defined(options.orientation.pitch)) {
      //       options.orientation.pitch = CesiumMath.toDegrees(
      //         options.orientation.pitch
      //       );
      //     }
      //     if (defined(options.orientation.roll)) {
      //       options.orientation.roll = CesiumMath.toDegrees(
      //         options.orientation.roll
      //       );
      //     }
      //   } else {
      //     options.orientation = {
      //       heading: 0,
      //       pitch: 0,
      //       roll: 0,
      //     };
      //   }
      //   let globe = this._pieGlobe;
      //   var spatialRef = globe.getSpatialReference();
      //   var center = spatialRef.forward([
      //     destination.longitude,
      //     destination.latitude,
      //   ]);
      //   globe.setCenter(center);
      //   globe.getWorldCamera().setDistance(destination.height);
      //   globe.setHeadingAngle(options.orientation.heading);
      //   globe.setPitchAngle(options.orientation.pitch);
      //   globe.refresh(true, false);
      // }
    }, {
      key: "cameraToWorldCoordinates",
      value: function cameraToWorldCoordinates() {}
    }, {
      key: "worldToCameraCoordinates",
      value: function worldToCameraCoordinates() {}
    }, {
      key: "cancelFlight",
      value: function cancelFlight() {}
    }, {
      key: "computeViewRectangle",
      value: function computeViewRectangle() {}
    }, {
      key: "look",
      value: function look() {}
      /**
       * 使用目标和偏移量设置相机的位置和方向。
       * @param {Cartesian3} target -世界坐标中的目标位置
       * @param {Cartesian3 | HeadingPitchRange} offset -在局部东北朝上的参考框中，距目标的偏移量
       */
    }, {
      key: "lookAt",
      value: function lookAt(target, offset) {
        // if (!defined(offset.heading)) {
        //   throw new DeveloperError('暂时只支持offset为HeadingPitchRange的参数.');
        // }
        var options = defaultValue$1(target, defaultValue$1.EMPTY_OBJECT);
        var destination = Cartographic.fromCartesian(options);
        destination.longitude = radianToDegree(destination.longitude);
        destination.latitude = radianToDegree(destination.latitude);
        var targetLon = destination.longitude;
        var targetLat = destination.latitude;
        var targetHeight = destination.height;
        var spatialRef = this._pieGlobe.getSpatialReference();
        var targetPoint = spatialRef.forward([targetLon, targetLat]);
        var center = [targetPoint[0], targetPoint[1], targetHeight];
        var heading = radianToDegree(offset.heading);
        var pitch = radianToDegree(offset.pitch);
        var distance = offset.range;
        this._pieGlobe.getWorldCamera().setLookAt(center, distance, heading, pitch, 0);
        this._pieGlobe.refresh(true, true);
      }
    }, {
      key: "rotate",
      value: function rotate() {}
    }]);
    return Camera;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 场景的视角类型
   *
   * @enum {Number}
   * @see Scene#mode
   */
  var SceneMode = {
    // /**
    //  * Morphing between mode, e.g., 3D to 2D.
    //  *
    //  * @type {Number}
    //  * @constant
    //  */
    // MORPHING: 0,

    // /**
    //  * Columbus View mode.  A 2.5D perspective view where the map is laid out
    //  * flat and objects with non-zero height are drawn above it.
    //  *
    //  * @type {Number}
    //  * @constant
    //  */
    // COLUMBUS_VIEW: 1,

    /**
     * 2D模式。使用正交投影从上至下查看地图。
     *
     * @type {Number}
     * @constant
     */
    SCENE2D: 2,
    /**
     * 3D模式。地球的一个传统3D透视图。
     *
     * @type {Number}
     * @constant
     */
    SCENE3D: 3
  };

  /**
   * Returns the morph time for the given scene mode.
   *
   * @param {SceneMode} value The scene mode
   * @returns {Number} The morph time
   */
  // SceneMode.getMorphTime = function(value) {
  //   if (value === SceneMode.SCENE3D) {
  //     return 1.0;
  //   } else if (value === SceneMode.MORPHING) {
  //     return undefined;
  //   }
  //   return 0.0;
  // };
  var SceneMode$1 = Object.freeze(SceneMode);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 
   * @class SkyAtmosphere
   * 在提供的椭球体的周围绘制一个大气层。
   *
   */
  var SkyAtmosphere = /*#__PURE__*/function () {
    function SkyAtmosphere() {
      _classCallCheck(this, SkyAtmosphere);
      _defineProperty(this, "_pieGlobe", void 0);
    }
    /**
     * 设置是否将显示大气层
     * @param {Boolean} value
     */
    _createClass(SkyAtmosphere, [{
      key: "show",
      get:
      /**
       * 获取是否将显示大气层
       * @returns {Boolean}
       */
      function get() {
        return this._pieGlobe.getAtmosphere().isVisible();
      },
      set: function set(value) {
        this._pieGlobe.getAtmosphere().setVisible(value);
      }
    }]);
    return SkyAtmosphere;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 
   * @class SkyBox
   * 在场景周围绘制星星的天空盒。天空盒使用真赤道平均赤道（TEME）轴定义，只支持3D模式。
   *
   */
  var SkyBox = /*#__PURE__*/function () {
    function SkyBox() {
      _classCallCheck(this, SkyBox);
      _defineProperty(this, "_pieGlobe", void 0);
    }
    /**
     * 设置是否将显示天空盒
     * @param {Boolean} value
     */
    _createClass(SkyBox, [{
      key: "show",
      get:
      /**
       * 获取是否将显示天空盒
       * @returns {Boolean}
       */
      function get() {
        return this._pieGlobe.getSkyDome().isVisible();
      },
      set: function set(value) {
        this._pieGlobe.getSkyDome().setVisible(value);
      }
    }]);
    return SkyBox;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 
   * @class Sun
   * 绘制一个太阳广告牌。
   *
   */
  var Sun = /*#__PURE__*/function () {
    function Sun() {
      _classCallCheck(this, Sun);
      _defineProperty(this, "_pieGlobe", void 0);
    }
    /**
     * 设置是否将显示太阳
     * @param {Boolean} value
     */
    _createClass(Sun, [{
      key: "show",
      get:
      /**
       * 获取是否将显示太阳
       * @returns {Boolean}
       */
      function get() {
        return this._pieGlobe.getSunLight().isVisible();
      },
      set: function set(value) {
        this._pieGlobe.getSunLight().setVisible(value);
      }
    }]);
    return Sun;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * @class Fog
   * 将大气与远离相机的几何体融合在一起，以获取地平线视图。
   */
  var Fog = /*#__PURE__*/function () {
    function Fog() {
      _classCallCheck(this, Fog);
      _defineProperty(this, "_pieGlobe", void 0);
    }
    /**
     * 设置是否启用雾
     * @param {Boolean} value
     */
    _createClass(Fog, [{
      key: "enabled",
      get:
      /**
       * 获取是否启用雾
       * @returns {Boolean}
       */
      function get() {
        return this._pieGlobe.getWorldCamera().isEnableFog();
      },
      set: function set(value) {
        this._pieGlobe.getWorldCamera().setEnableFog(value);
      }
    }]);
    return Fog;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * @class Scene
   * 虚拟场景中所有3D图形对象和状态的容器
   */
  var _initEvent = /*#__PURE__*/new WeakSet();
  var Scene = /*#__PURE__*/function () {
    // moon;

    //事件  preUpdate >>  postUpdate  >> preRender  >>  postRender
    //todo
    //todo

    //二三维切换

    function Scene() {
      _classCallCheck(this, Scene);
      _classPrivateMethodInitSpec(this, _initEvent);
      _defineProperty(this, "_pieGlobe", void 0);
      _defineProperty(this, "_pieGlobeControl", void 0);
      _defineProperty(this, "_globe", void 0);
      _defineProperty(this, "skyAtmosphere", void 0);
      _defineProperty(this, "skyBox", void 0);
      _defineProperty(this, "sun", void 0);
      _defineProperty(this, "fog", void 0);
      _defineProperty(this, "_camera", void 0);
      _defineProperty(this, "_preUpdate", new Event());
      _defineProperty(this, "_postUpdate", new Event());
      _defineProperty(this, "_preRender", new Event());
      _defineProperty(this, "_postRender", new Event());
      _defineProperty(this, "_mode", void 0);
      _defineProperty(this, "_entities", void 0);
      _defineProperty(this, "_threeCamera", void 0);
      _defineProperty(this, "_primitiveCollection", void 0);
      this._globe = new Globe();
      this._camera = new Camera();
      this.skyAtmosphere = new SkyAtmosphere();
      this.skyBox = new SkyBox();
      this.sun = new Sun();
      this.fog = new Fog();

      // this.moon = new Moon();
    }
    _createClass(Scene, [{
      key: "primitives",
      get: function get() {
        return this._primitiveCollection;
      },
      set: function set(value) {
        this._primitiveCollection = value;
      }

      /*
       * 获取画布
       * @memberof Scene
       * @returns {Canvas}
       */
    }, {
      key: "canvas",
      get: function get() {
        return this._pieGlobeControl.canvas;
      }
      /**
       * 设置三维场景控制器
       * @memberof Scene
       * @param {PieGlobeControl} value
       */
    }, {
      key: "pieGlobeControl",
      set: function set(value) {
        this._pieGlobeControl = value;
        this._pieGlobe = value.getGlobe();
        this._camera._pieGlobe = this._pieGlobe;
        _classPrivateMethodGet(this, _initEvent, _initEvent2).call(this);
        this._globe._pieGlobe = this._pieGlobe;
        this._globe.pieGlobeControl = this._pieGlobeControl;
        this.skyAtmosphere._pieGlobe = this._pieGlobe;
        this.skyBox._pieGlobe = this._pieGlobe;
        this.sun._pieGlobe = this._pieGlobe;
        this.fog._pieGlobe = this._pieGlobe;
        // this.moon._pieGlobe = this._pieGlobe;
      }
      /**
       * 获取场景中的球体
       * @memberof Scene
       * @returns {Globe}
       */
    }, {
      key: "globe",
      get: function get() {
        return this._globe;
      }
      /**
       * 获取相机
       * @memberof Scene
       * @returns {Camera}
       */
    }, {
      key: "camera",
      get: function get() {
        return this._camera;
      }
      /**
       * 获取场景更新之前执行的操作或事件
       * @memberof Scene
       * @returns {Event}
       */
    }, {
      key: "preUpdate",
      get: function get() {
        return this._preUpdate;
      }
      /**
       * 获取场景更新之后执行的操作或事件
       * @memberof Scene
       * @returns {Event}
       */
    }, {
      key: "postUpdate",
      get: function get() {
        return this._postUpdate;
      }
      /**
       * 获取渲染场景之前执行的操作或事件
       * @memberof Scene
       * @returns {Event}
       */
    }, {
      key: "preRender",
      get: function get() {
        return this._preRender;
      }
    }, {
      key: "render",
      value: function render() {}

      /**
       * 获取渲染场景之后执行的操作或事件
       * @memberof Scene
       * @returns {Event}
       */
    }, {
      key: "postRender",
      get: function get() {
        return this._postRender;
      }

      // set camera(camera) {
      //   this.camera = camera;
      // }
      /**
       * 获取场景模式
       * @memberof Scene
       * @returns {Number}
       */
    }, {
      key: "mode",
      get: function get() {
        return this._mode;
      }
      /**
       * 设置场景模式
       * @memberof Scene
       * @param {Number} value
       */,
      set: function set(value) {
        if (value === SceneMode$1.SCENE2D) {
          this._pieGlobeControl.setSceneMode(PIESceneMode.Plane);
          // this._pieGlobe.setMaxPitchAngle(0);
          //禁用中键事件
        } else if (value === SceneMode$1.SCENE3D) {
          this._pieGlobeControl.setSceneMode(PIESceneMode.Sphere);
          // this._pieGlobe.setMaxPitchAngle(90);
        }
        // else if (value === SceneMode.COLUMBUS_VIEW) {
        //   this._pieGlobeControl.setSceneMode(PIESceneMode.Plane);
        //   this._pieGlobe.setMaxPitchAngle(90);
        // }
        else {
          throw new DeveloperError$1('value must be a valid SceneMode enumeration.');
        }
        this._mode = value;
      }

      //windowPosition 相对canvas的位置坐标
      /**
       * 该函数返回一个包含primitive属性的对象，该属性包含特定窗口坐标处场景中第一个（顶部）图元，如果该位置没有任何内容，则返回未定义。根据图元的类型，可能会设置其他属性，并可用于进一步识别选定的对象
       * @memberof Scene
       * @param {Cartesian2} windowPosition 窗口坐标
       * @param {Number} width 拾取矩形的宽度
       * @param {Number} height 拾取矩形的高度
       * @returns {Object} -包含所选图元的对象
       */
    }, {
      key: "pick",
      value: function pick(windowPosition, width, height) {
        var _getMousePosition = getMousePosition(this, windowPosition),
          _getMousePosition2 = _slicedToArray(_getMousePosition, 2),
          x = _getMousePosition2[0],
          y = _getMousePosition2[1];
        var globeControl = this._pieGlobeControl;
        var mapPos = this._pieGlobe.deviceToMap([x, y]);
        var _width = defaultValue$1(width, 1.0);
        var _height = defaultValue$1(height, 1.0);
        var tolerance = Math.min(_width, _height);
        var res = globeControl.hitTestPoint([x, y], [mapPos.x, mapPos.y], tolerance, false, false);
        // const rect = [];
        // const res = globeControl.hitTestRect(rect, false, false);
        if (res) {
          //从entities的layer中查找选中的
          var entityChilds = ['point', 'polyline', 'polygon', 'plot', 'label', 'billboard', 'overlayImage', 'rectangle', 'ellipse'];
          var layer = this._entities._renderableLayer;
          var select = layer.getSelection();
          select.getSize();
          var id = select.getAt(0);
          return getEntityByID(this._entities, entityChilds, id);
          // globeEditor.clearEditObject();
        }
        //three拾取
        var camera = this._threeCamera;
        // var vector = new Vector2(
        //   (event.clientX / window.innerWidth) * 2 - 1,
        //   -(event.clientY / window.innerHeight) * 2 + 1
        // );
        var vector = new Vector2(x / window.innerWidth * 2 - 1, -(y / window.innerHeight) * 2 + 1);
        var raycaster = new Raycaster();
        raycaster.setFromCamera(vector, camera);

        //需要选取所有的scene中的物体
        var children = this._entities._threelayer.parent.children;
        var intersects = raycaster.intersectObjects(children);
        if (intersects.length > 0) {
          for (var i = 0; i < intersects.length; i++) {
            var selectObject = intersects[i].object;
            if (selectObject.parent instanceof PrimitiveInstance) {
              var _id = selectObject.id;
              var _entityChilds = ['box', 'ellipsoid', 'plane', 'circle', 'cone', 'polygon'];
              return getEntityByID(this._entities, _entityChilds, _id);
              // alert(selectObject.parent.userData.title);
            }

            if (selectObject instanceof Mesh) {
              var _id2 = selectObject.parent.parent.id;
              var _entityChilds2 = ['model'];
              var entity = getEntityByID(this._entities, _entityChilds2, _id2);
              if (entity) {
                return entity;
              } else {
                return selectObject;
              }
            }
          }
        }
      }

      // morphTo2D() {}

      /**
       * 返回给定地理位置处场景几何体的高度，如果没有场景几何体可用于采样高度，则返回未定义。
       * @memberof Scene
       * @param {Cartographic} position 地图坐标到采样高度的起点
       * @returns {Number} -返回高度。如果没有场景几何体可用于采样高度，则可能为未定义。
       */
    }, {
      key: "sampleHeight",
      value: function sampleHeight(position) {
        var globe = this._pieGlobe;
        //1.经纬度转屏幕坐标
        if (position instanceof Cartographic) {
          var lon = position.longitude / Math.PI * 180;
          var lat = position.latitude / Math.PI * 180;
          var pieSpatialReference = globe.getSpatialReference();
          var devicePoint = globe.mapToDevice(pieSpatialReference.forward([lon, lat]));
          if (defined$1(devicePoint)) {
            var height;
            //2.屏幕坐标高度拾取
            var worldPosition = globe.deviceToWorldEx([devicePoint.x, devicePoint.y]);
            if (worldPosition.length() == 0) {
              return undefined;
            }
            if (globe.getSceneMode() == PIESceneMode.Sphere) {
              height = worldPosition.length() - PIEMath.EARTH_RADIUS;
            } else {
              height = worldPosition.z;
            }
            height = Number(height.toFixed(4));
            return height;
          } else {
            return undefined;
          }
        } else {
          throw new DeveloperError$1('position must be a Cartographic.');
        }
      }
    }]);
    return Scene;
  }();
  /**
   * 获取鼠标位置
   * @memberof Scene
   * @param {Scene} scene 场景
   * @param {Event} e 鼠标事件对象
   * @returns {Array} -返回位置坐标
   */
  function _initEvent2() {
    var _this = this;
    this._pieGlobeControl.getPreRender().addEventListener(function () {
      _this._preRender.raiseEvent(_this);
    });
    this._pieGlobeControl.getPostRender().addEventListener(function () {
      _this._postRender.raiseEvent(_this);
    });

    // const globeEditor = this._pieGlobeControl.getGlobeEditor(); //获取场景编辑器
    // /**回调函数，获取绘制几何对象的信息**/
    // globeEditor.getSelectedGeometryEvent().addEventListener(function(layers) {
    //   for (let layer of layers) {
    //     if ('getSelection' in layer) {
    //       let selection = layer.getSelection();
    //       let id = selection.getAt(0);
    //       //从实体中查找id所对应的entity
    //     }
    //   }
    // });
  }

  function getMousePosition(scene, e) {
    scene.canvas.getBoundingClientRect();
    // const x = (e.clientX - rect.left) * (this._ctx.container.width / rect.width);
    // const y = (e.clientY - rect.top) * (this._ctx.container.height / rect.height);
    var x = e.x * scene._pieGlobeControl.getPixelRatio();
    var y = e.y * scene._pieGlobeControl.getPixelRatio();
    return [x, y];
  }
  function getEntityByID(entities, entityChilds, id) {
    for (var j = 0; j < entities.values.length; j++) {
      var element = entities.values[j];
      for (var k = 0; k < entityChilds.length; k++) {
        var childName = entityChilds[k];
        if (element[childName] != undefined && id == element[childName].id) {
          return element;
        }
      }
    }
  }

  var EarthCamera = /*#__PURE__*/function (_PerspectiveCamera) {
    _inherits(EarthCamera, _PerspectiveCamera);
    var _super = _createSuper(EarthCamera);
    function EarthCamera(globeControl) {
      var _this;
      var fov = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
      var aspect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var near = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;
      var far = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2000;
      _classCallCheck(this, EarthCamera);
      _this = _super.call(this, fov, aspect, near, far);
      _this.type = 'EarthCamera';
      _this.globeControl = globeControl;
      _this.globe = globeControl.getGlobe();
      _this.worldCamera = _this.globe.getWorldCamera();
      _this.referenceCenter = _this.worldCamera.getReferenceCenter();
      return _this;
    }
    _createClass(EarthCamera, [{
      key: "copy",
      value: function copy(source, recursive) {
        _get(_getPrototypeOf(EarthCamera.prototype), "copy", this).call(this, source, recursive);
        return this;
      }
    }, {
      key: "update",
      value: function update() {
        this.worldCamera.refresh();
        var fov = this.worldCamera.getFov();
        var aspect = this.worldCamera.getAspect();
        var nearClipDistance = this.worldCamera.getNearClipDistance();
        var farClipDistance = this.worldCamera.getFarClipDistance();
        var relativeViewMatrix = this.worldCamera.getRelativeViewMatrix();
        var matrixView = new Matrix4$1();
        matrixView.fromArray(relativeViewMatrix.toArray());
        matrixView.invert();
        var position = new Vector3();
        var quaternion = new Quaternion();
        var scale = new Vector3(1, 1, 1);
        matrixView.decompose(position, quaternion, scale);
        this.position.x = position.x;
        this.position.y = position.y;
        this.position.z = position.z;
        this.scale.x = scale.x;
        this.scale.y = scale.y;
        this.scale.z = scale.z;
        this.quaternion.x = quaternion.x;
        this.quaternion.y = quaternion.y;
        this.quaternion.z = quaternion.z;
        this.quaternion.w = quaternion.w;
        this.updateMatrixWorld(true);
        this.fov = fov;
        this.aspect = aspect;
        this.near = nearClipDistance;
        this.far = farClipDistance;
        this.updateProjectionMatrix();
        this.referenceCenter = this.worldCamera.getReferenceCenter();
      }
    }, {
      key: "computeWorldPosition",
      value: function computeWorldPosition(lon, lat, height) {
        var DTOR = 3.141592653 / 180.0;
        var position = PIEVector3.sphericalToCartesian(lon * DTOR, lat * DTOR, 6378137 + height);
        return position;
      }
    }, {
      key: "computeWorldMatrix",
      value: function computeWorldMatrix(lon, lat, height) {
        var DTOR = 3.141592653 / 180.0;
        var position = PIEVector3.sphericalToCartesian(lon * DTOR, lat * DTOR, 6378137 + height);
        var rotationX = new Matrix4$1();
        rotationX.makeRotationX(-lat * DTOR);
        var rotationY = new Matrix4$1();
        rotationY.makeRotationY(lon * DTOR);
        var rotationXY = new Matrix4$1();
        rotationXY.multiplyMatrices(rotationY, rotationX);
        var translation = new Matrix4$1();
        translation.makeTranslation(position.x, position.y, position.z);
        var worldMatrix = new Matrix4$1();
        worldMatrix.multiplyMatrices(translation, rotationXY);
        return worldMatrix;
      }
    }, {
      key: "updateWorldPosition",
      value: function updateWorldPosition(object, position) {
        if (object != null && object.position != null) {
          object.position.x = position.x - this.referenceCenter.x;
          object.position.y = position.y - this.referenceCenter.y;
          object.position.z = position.z - this.referenceCenter.z;
        }
      }
    }, {
      key: "updateWorldMatrix",
      value: function updateWorldMatrix(object, matrix) {
        // 不需要再逐个更新矩阵
        // object.applyMatrix(matrix);
        if (object != null && object.position != null && object.scale != null && object.quaternion != null) {
          object.matrix = matrix;
          var translation = new Matrix4$1();
          // translation.makeTranslation(-this.referenceCenter.x, -this.referenceCenter.y, -this.referenceCenter.z);
          var worldMatrix = new Matrix4$1();
          worldMatrix.multiplyMatrices(translation, matrix);
          var position = new Vector3();
          var quaternion = new Quaternion();
          var scale = new Vector3(1, 1, 1);
          matrix.decompose(position, quaternion, scale);
          object.position.x = position.x;
          object.position.y = position.y;
          object.position.z = position.z;
          object.scale.x = scale.x;
          object.scale.y = scale.y;
          object.scale.z = scale.z;
          object.quaternion.x = quaternion.x;
          object.quaternion.y = quaternion.y;
          object.quaternion.z = quaternion.z;
          object.quaternion.w = quaternion.w;
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _get(_getPrototypeOf(EarthCamera.prototype), "toJSON", this).call(this, meta);
        return data;
      }
    }]);
    return EarthCamera;
  }(PerspectiveCamera);
  EarthCamera.prototype.isPerspectiveCamera = true;

  function EarthRenderer(globeControl, parameters) {
    this.globeControl = globeControl;
    this.globe = globeControl.getGlobe();
    WebGLRenderer.call(this, parameters);
    this.setSizeSaved = this.setSize;
    this.setSize = function (width, height, updateStyle) {
      this.globeControl.onSizeChanged(width, height, false);
      this.setSizeSaved(width, height, updateStyle);
      this.setViewport(0, 0, width, height);
    };
    this.setRenderTargetSaved = this.setRenderTarget;
    this.setRenderTarget = function (renderTarget) {
      var activeCubeFace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var activeMipmapLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (renderTarget != null) {
        this.globeControl.onSizeChanged(renderTarget.viewport.z, renderTarget.viewport.w, false);
      }
      this.setRenderTargetSaved(renderTarget, activeCubeFace, activeMipmapLevel);
    };
    this.renderSaved = this.render;
    this.render = function (scene, camera) {
      this.renderSaved(scene, camera);
    };
  }
  EarthRenderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {});

  var Earth3D = /*#__PURE__*/function (_ImmediateRenderObjec) {
    _inherits(Earth3D, _ImmediateRenderObjec);
    var _super = _createSuper(Earth3D);
    function Earth3D(renderer, globeControl) {
      var _this;
      _classCallCheck(this, Earth3D);
      var material = new MeshLambertMaterial({
        color: 0x000000,
        side: DoubleSide$1
      });
      _this = _super.call(this, material);
      _this.type = 'Earth3D';
      _this.autoUpdate = true;
      _this.renderer = renderer;
      _this.globeControl = globeControl;
      _this.context = globeControl.getContext();
      _this.renderDepth = false;
      _this.onBeforeRender = function (renderer) {};
      _this.onAfterRender = function (renderer) {};
      _this.render = function () {
        if (this.renderer.visibleEarth == null || this.renderer.visibleEarth) {
          this.resetState();
          if (this.renderDepth) {
            this.globeControl.onRenderDepth();
          } else {
            this.globeControl.onRender();
          }
          this.resetState();
        }
      };
      _this.resetState = function () {
        var gl = this.context;
        gl.enable(gl.BLEND);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.disable(gl.SCISSOR_TEST);
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ZERO);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.clearDepth(1);
        gl.stencilMask(0xffffffff);
        gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        gl.clearStencil(0);
        gl.cullFace(gl.BACK);
        gl.frontFace(gl.CCW);
        gl.polygonOffset(0, 0);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        var state = this.renderer.state;
        state.disable(gl.DEPTH_TEST);
        //state.setBlending(NormalBlending, null, null, null, null, null, null, false);
        state.useProgram(null);
      };
      return _this;
    }
    _createClass(Earth3D, [{
      key: "copy",
      value: function copy(source, recursive) {
        _get(_getPrototypeOf(Earth3D.prototype), "copy", this).call(this, source, recursive);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _get(_getPrototypeOf(Earth3D.prototype), "toJSON", this).call(this, meta);
        return data;
      }
    }]);
    return Earth3D;
  }(ImmediateRenderObject);
  Earth3D.prototype.isImmediateRenderObject = true;

  var EarthSky = /*#__PURE__*/function (_Mesh) {
    _inherits(EarthSky, _Mesh);
    var _super = _createSuper(EarthSky);
    function EarthSky(options) {
      var _this;
      _classCallCheck(this, EarthSky);
      var shader = EarthSky.SkyShader;
      var material = new ShaderMaterial({
        name: 'EarthSkyShader',
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: UniformsUtils.clone(shader.uniforms),
        side: BackSide,
        depthTest: false,
        depthWrite: false
      });
      _this = _super.call(this, new BoxGeometry(1000000, 1000000, 1000000), material);
      _this.camera = options.camera;
      _this.distance = options.distance != null ? options.distance : 150000;
      var skyUniforms = _this.material.uniforms;
      skyUniforms['turbidity'].value = 10;
      skyUniforms['rayleigh'].value = 2;
      skyUniforms['mieCoefficient'].value = 0.005;
      skyUniforms['mieDirectionalG'].value = 0.8;
      _this.onBeforeRender = function (renderer) {
        var DTOR = 3.141592653 / 180.0;
        var globe = this.camera.globe;
        var geoCenter = globe.getGeoCenter();

        //var normal = PIE.Vector3.sphericalToCartesian(116.39 * DTOR, 39.9 * DTOR, 1).normalized();
        //skyUniforms[ 'up' ].value = new Vector3(normal.x, normal.y, normal.z);

        var rotationX = new Matrix4$1();
        rotationX.makeRotationX(-geoCenter.y * DTOR);
        var rotationY = new Matrix4$1();
        rotationY.makeRotationY(geoCenter.x * DTOR);
        var rotationXY = new Matrix4$1();
        rotationXY.multiplyMatrices(rotationY, rotationX);
        var dir = new Vector3(0, 0, 1);
        dir = dir.transformDirection(rotationXY);
        this.material.uniforms['up'].value = new Vector3(dir.x, dir.y, dir.z).normalize();
        var visibleGlobe = false;
        var distance = this.camera.worldCamera.getDistance();
        if (distance > this.distance) {
          this.scale.set(0, 0, 0);
          visibleGlobe = true;
        } else {
          this.scale.set(1, 1, 1);
          visibleGlobe = false;
        }
        globe.setEnableBkgColor(visibleGlobe);
        globe.getSkyDome().setVisible(visibleGlobe);
        globe.getAtmosphere().setVisible(visibleGlobe);
        globe.getStar().setVisible(visibleGlobe);
      };
      return _this;
    }
    return _createClass(EarthSky);
  }(Mesh);
  EarthSky.prototype.isEarthSky = true;
  EarthSky.SkyShader = {
    uniforms: {
      'turbidity': {
        value: 2
      },
      'rayleigh': {
        value: 1
      },
      'mieCoefficient': {
        value: 0.005
      },
      'mieDirectionalG': {
        value: 0.8
      },
      'sunPosition': {
        value: new Vector3()
      },
      'up': {
        value: new Vector3(0, 1, 0)
      }
    },
    vertexShader: /* glsl */"\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",
    fragmentShader: /* glsl */"\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\t\t\t//vec3 direction = normalize( vWorldPosition );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"
  };

  var EarthBackground = /*#__PURE__*/function (_Mesh) {
    _inherits(EarthBackground, _Mesh);
    var _super = _createSuper(EarthBackground);
    function EarthBackground(options) {
      var _this;
      _classCallCheck(this, EarthBackground);
      var material = new ShaderMaterial({
        name: 'EarthBackgroundMaterial',
        uniforms: EarthBackground.BackgroundShader.uniforms,
        vertexShader: EarthBackground.BackgroundShader.vertexShader,
        fragmentShader: EarthBackground.BackgroundShader.fragmentShader,
        side: BackSide,
        depthTest: false,
        depthWrite: false,
        fog: false
      });
      var geometry = new BoxGeometry(10000000, 10000000, 10000000);
      geometry.deleteAttribute('normal');
      geometry.deleteAttribute('uv');
      _this = _super.call(this, geometry, material);
      material.uniforms.envMap.value = options.envMap;
      material.uniforms.flipEnvMap.value = _this.isCubeTexture && _this.isRenderTargetTexture === false ? -1 : 1;
      _this.camera = options.camera;
      _this.distance = options.distance != null ? options.distance : 150000;
      Object.defineProperty(material, 'envMap', {
        get: function get() {
          return this.uniforms.envMap.value;
        }
      });
      _this.onBeforeRender = function (renderer) {
        var DTOR = 3.141592653 / 180.0;
        var globe = this.camera.globe;
        var geoCenter = globe.getGeoCenter();
        var rotationMatrix = new Matrix4$1();
        rotationMatrix.makeRotationX(-90 * DTOR);
        this.material.uniforms.cubeTransform.value = rotationMatrix;
        var worldMatrix = this.camera.computeWorldMatrix(geoCenter.x, geoCenter.y, 0);
        this.camera.updateWorldMatrix(this, worldMatrix);
        var visibleGlobe = false;
        var distance = this.camera.worldCamera.getDistance();
        if (distance > this.distance) {
          this.scale.set(0, 0, 0);
          visibleGlobe = true;
        } else {
          this.scale.set(1, 1, 1);
          visibleGlobe = false;
        }
        var globe = this.camera.globe;
        globe.setEnableBkgColor(visibleGlobe);
        globe.getSkyDome().setVisible(visibleGlobe);
        globe.getAtmosphere().setVisible(visibleGlobe);
        globe.getStar().setVisible(visibleGlobe);
      };
      return _this;
    }
    return _createClass(EarthBackground);
  }(Mesh);
  EarthBackground.prototype.isEarthBackground = true;
  EarthBackground.BackgroundShader = {
    uniforms: {
      envMap: {
        value: null
      },
      flipEnvMap: {
        value: -1
      },
      reflectivity: {
        value: 1.0
      },
      // basic, lambert, phong
      ior: {
        value: 1.5
      },
      // standard, physical
      refractionRatio: {
        value: 0.98
      },
      maxMipLevel: {
        value: 10
      },
      opacity: {
        value: 1.0
      },
      cubeTransform: {
        value: new Matrix4$1()
      }
    },
    vertexShader: /* glsl */"\n\t\tuniform mat4 cubeTransform;\n        varying vec3 vWorldDirection;\n\n        vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n            return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n        }\n\n        void main() {\n            //vWorldDirection = transformDirection( position, modelMatrix );\n            vec4 worldPosition = vec4( position, 1.0 );\n            worldPosition = cubeTransform * worldPosition;\n            vWorldDirection = normalize(worldPosition.xyz);\n\n            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n            gl_Position = projectionMatrix * mvPosition;\n            gl_Position.z = gl_Position.w; // set z to camera.far\n        }",
    fragmentShader: /* glsl */"\n\t\t#include <envmap_common_pars_fragment>\n        uniform float opacity;\n\n        varying vec3 vWorldDirection;\n\n        #include <cube_uv_reflection_fragment>\n\n        void main() {\n\n            vec3 vReflect = vWorldDirection;\n            #include <envmap_fragment>\n\n            gl_FragColor = envColor;\n            gl_FragColor.a *= opacity;\n\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n\n        }"
  };

  var Pass = /*#__PURE__*/function () {
    function Pass() {
      _classCallCheck(this, Pass);
      // if set to true, the pass is processed by the composer
      this.enabled = true;

      // if set to true, the pass indicates to swap read and write buffer after rendering
      this.needsSwap = true;

      // if set to true, the pass clears its buffer before rendering
      this.clear = false;

      // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
      this.renderToScreen = false;
    }
    _createClass(Pass, [{
      key: "setSize",
      value: function setSize( /* width, height */) {}
    }, {
      key: "render",
      value: function render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */
      ) {
        console.error('THREE.Pass: .render() must be implemented in derived pass.');
      }
    }]);
    return Pass;
  }(); // Helper for passes that need to fill the viewport with a single quad.
  var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);

  // https://github.com/mrdoob/three.js/pull/21358

  var _geometry$1 = new BufferGeometry();
  _geometry$1.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
  _geometry$1.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  var FullScreenQuad = /*#__PURE__*/function () {
    function FullScreenQuad(material) {
      _classCallCheck(this, FullScreenQuad);
      this._mesh = new Mesh(_geometry$1, material);
    }
    _createClass(FullScreenQuad, [{
      key: "dispose",
      value: function dispose() {
        this._mesh.geometry.dispose();
      }
    }, {
      key: "render",
      value: function render(renderer) {
        renderer.render(this._mesh, _camera);
      }
    }, {
      key: "material",
      get: function get() {
        return this._mesh.material;
      },
      set: function set(value) {
        this._mesh.material = value;
      }
    }]);
    return FullScreenQuad;
  }();

  var RenderPass = /*#__PURE__*/function (_Pass) {
    _inherits(RenderPass, _Pass);
    var _super = _createSuper(RenderPass);
    function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {
      var _this;
      _classCallCheck(this, RenderPass);
      _this = _super.call(this);
      _this.scene = scene;
      _this.camera = camera;
      _this.overrideMaterial = overrideMaterial;
      _this.clearColor = clearColor;
      _this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
      _this.clear = true;
      _this.clearDepth = false;
      _this.needsSwap = false;
      _this._oldClearColor = new Color$2();
      return _this;
    }
    _createClass(RenderPass, [{
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
        var oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        var oldClearAlpha, oldOverrideMaterial;
        if (this.overrideMaterial !== undefined) {
          oldOverrideMaterial = this.scene.overrideMaterial;
          this.scene.overrideMaterial = this.overrideMaterial;
        }
        if (this.clearColor) {
          renderer.getClearColor(this._oldClearColor);
          oldClearAlpha = renderer.getClearAlpha();
          renderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (this.clearDepth) {
          renderer.clearDepth();
        }
        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);

        // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
        if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        renderer.render(this.scene, this.camera);
        if (this.clearColor) {
          renderer.setClearColor(this._oldClearColor, oldClearAlpha);
        }
        if (this.overrideMaterial !== undefined) {
          this.scene.overrideMaterial = oldOverrideMaterial;
        }
        renderer.autoClear = oldAutoClear;
      }
    }]);
    return RenderPass;
  }(Pass);

  var PostProcessStage = {
    Bloom: 1,
    Rain: 2,
    Snow: 3,
    Thunder: 4,
    Fog: 5,
    SandStorm: 6
  };

  /**
   * Full-screen textured quad shader
   */

  var CopyShader = {
    uniforms: {
      'tDiffuse': {
        value: null
      },
      'opacity': {
        value: 1.0
      }
    },
    vertexShader: /* glsl */"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: /* glsl */"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"
  };

  var ShaderPass = /*#__PURE__*/function (_Pass) {
    _inherits(ShaderPass, _Pass);
    var _super = _createSuper(ShaderPass);
    function ShaderPass(shader, textureID) {
      var _this;
      _classCallCheck(this, ShaderPass);
      _this = _super.call(this);
      _this.textureID = textureID !== undefined ? textureID : 'tDiffuse';
      if (shader instanceof ShaderMaterial) {
        _this.uniforms = shader.uniforms;
        _this.material = shader;
      } else if (shader) {
        _this.uniforms = UniformsUtils.clone(shader.uniforms);
        _this.material = new ShaderMaterial({
          defines: Object.assign({}, shader.defines),
          uniforms: _this.uniforms,
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        });
      }
      _this.fsQuad = new FullScreenQuad(_this.material);
      return _this;
    }
    _createClass(ShaderPass, [{
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
        if (this.uniforms[this.textureID]) {
          this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        if (this.renderToScreen) {
          renderer.setRenderTarget(null);
          this.fsQuad.render(renderer);
        } else {
          renderer.setRenderTarget(writeBuffer);
          // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
          if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
          this.fsQuad.render(renderer);
        }
      }
    }]);
    return ShaderPass;
  }(Pass);

  var MaskPass = /*#__PURE__*/function (_Pass) {
    _inherits(MaskPass, _Pass);
    var _super = _createSuper(MaskPass);
    function MaskPass(scene, camera) {
      var _this;
      _classCallCheck(this, MaskPass);
      _this = _super.call(this);
      _this.scene = scene;
      _this.camera = camera;
      _this.clear = true;
      _this.needsSwap = false;
      _this.inverse = false;
      return _this;
    }
    _createClass(MaskPass, [{
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
        var context = renderer.getContext();
        var state = renderer.state;

        // don't update color or depth

        state.buffers.color.setMask(false);
        state.buffers.depth.setMask(false);

        // lock buffers

        state.buffers.color.setLocked(true);
        state.buffers.depth.setLocked(true);

        // set up stencil

        var writeValue, clearValue;
        if (this.inverse) {
          writeValue = 0;
          clearValue = 1;
        } else {
          writeValue = 1;
          clearValue = 0;
        }
        state.buffers.stencil.setTest(true);
        state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
        state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
        state.buffers.stencil.setClear(clearValue);
        state.buffers.stencil.setLocked(true);

        // draw into the stencil buffer

        renderer.setRenderTarget(readBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(writeBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);

        // unlock color and depth buffer for subsequent rendering

        state.buffers.color.setLocked(false);
        state.buffers.depth.setLocked(false);

        // only render where stencil is set to 1

        state.buffers.stencil.setLocked(false);
        state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
        state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
        state.buffers.stencil.setLocked(true);
      }
    }]);
    return MaskPass;
  }(Pass);
  var ClearMaskPass = /*#__PURE__*/function (_Pass2) {
    _inherits(ClearMaskPass, _Pass2);
    var _super2 = _createSuper(ClearMaskPass);
    function ClearMaskPass() {
      var _this2;
      _classCallCheck(this, ClearMaskPass);
      _this2 = _super2.call(this);
      _this2.needsSwap = false;
      return _this2;
    }
    _createClass(ClearMaskPass, [{
      key: "render",
      value: function render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {
        renderer.state.buffers.stencil.setLocked(false);
        renderer.state.buffers.stencil.setTest(false);
      }
    }]);
    return ClearMaskPass;
  }(Pass);

  var EffectComposer = /*#__PURE__*/function () {
    function EffectComposer(renderer, renderTarget) {
      _classCallCheck(this, EffectComposer);
      this.renderer = renderer;
      if (renderTarget === undefined) {
        var parameters = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat
        };
        var size = renderer.getSize(new Vector2());
        this._pixelRatio = renderer.getPixelRatio();
        this._width = size.width;
        this._height = size.height;
        renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
        renderTarget.texture.name = 'EffectComposer.rt1';
      } else {
        this._pixelRatio = 1;
        this._width = renderTarget.width;
        this._height = renderTarget.height;
      }
      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();
      this.renderTarget2.texture.name = 'EffectComposer.rt2';
      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;
      this.renderToScreen = true;
      this.passes = [];

      // dependencies

      if (CopyShader === undefined) {
        console.error('THREE.EffectComposer relies on CopyShader');
      }
      if (ShaderPass === undefined) {
        console.error('THREE.EffectComposer relies on ShaderPass');
      }
      this.copyPass = new ShaderPass(CopyShader);
      this.clock = new Clock();
    }
    _createClass(EffectComposer, [{
      key: "swapBuffers",
      value: function swapBuffers() {
        var tmp = this.readBuffer;
        this.readBuffer = this.writeBuffer;
        this.writeBuffer = tmp;
      }
    }, {
      key: "addPass",
      value: function addPass(pass) {
        this.passes.push(pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
    }, {
      key: "insertPass",
      value: function insertPass(pass, index) {
        this.passes.splice(index, 0, pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
    }, {
      key: "removePass",
      value: function removePass(pass) {
        var index = this.passes.indexOf(pass);
        if (index !== -1) {
          this.passes.splice(index, 1);
        }
      }
    }, {
      key: "isLastEnabledPass",
      value: function isLastEnabledPass(passIndex) {
        for (var i = passIndex + 1; i < this.passes.length; i++) {
          if (this.passes[i].enabled) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "render",
      value: function render(deltaTime) {
        // deltaTime value is in seconds

        if (deltaTime === undefined) {
          deltaTime = this.clock.getDelta();
        }
        var currentRenderTarget = this.renderer.getRenderTarget();
        var maskActive = false;
        for (var i = 0, il = this.passes.length; i < il; i++) {
          var pass = this.passes[i];
          if (pass.enabled === false) continue;
          pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
          pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
          if (pass.needsSwap) {
            if (maskActive) {
              var context = this.renderer.getContext();
              var stencil = this.renderer.state.buffers.stencil;

              //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
              stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
              this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);

              //context.stencilFunc( context.EQUAL, 1, 0xffffffff );
              stencil.setFunc(context.EQUAL, 1, 0xffffffff);
            }
            this.swapBuffers();
          }
          if (MaskPass !== undefined) {
            if (pass instanceof MaskPass) {
              maskActive = true;
            } else if (pass instanceof ClearMaskPass) {
              maskActive = false;
            }
          }
        }
        this.renderer.setRenderTarget(currentRenderTarget);
      }
    }, {
      key: "reset",
      value: function reset(renderTarget) {
        if (renderTarget === undefined) {
          var size = this.renderer.getSize(new Vector2());
          this._pixelRatio = this.renderer.getPixelRatio();
          this._width = size.width;
          this._height = size.height;
          renderTarget = this.renderTarget1.clone();
          renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        this.renderTarget1.dispose();
        this.renderTarget2.dispose();
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this._width = width;
        this._height = height;
        var effectiveWidth = this._width * this._pixelRatio;
        var effectiveHeight = this._height * this._pixelRatio;
        this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
        this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
        for (var i = 0; i < this.passes.length; i++) {
          this.passes[i].setSize(effectiveWidth, effectiveHeight);
        }
      }
    }, {
      key: "setPixelRatio",
      value: function setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        this.setSize(this._width, this._height);
      }
    }]);
    return EffectComposer;
  }();
  new OrthographicCamera(-1, 1, 1, -1, 0, 1);

  // https://github.com/mrdoob/three.js/pull/21358

  var _geometry = new BufferGeometry();
  _geometry.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
  _geometry.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));

  /**
   * Luminosity
   * http://en.wikipedia.org/wiki/Luminosity
   */

  var LuminosityHighPassShader = {
    shaderID: 'luminosityHighPass',
    uniforms: {
      'tDiffuse': {
        value: null
      },
      'luminosityThreshold': {
        value: 1.0
      },
      'smoothWidth': {
        value: 1.0
      },
      'defaultColor': {
        value: new Color$2(0x000000)
      },
      'defaultOpacity': {
        value: 0.0
      }
    },
    vertexShader: /* glsl */"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: /* glsl */"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"
  };

  /**
   * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
   * mip map chain of bloom textures and blurs them with different radii. Because
   * of the weighted combination of mips, and because larger blurs are done on
   * higher mips, this effect provides good quality and performance.
   *
   * Reference:
   * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
   */
  var UnrealBloomPass = /*#__PURE__*/function (_Pass) {
    _inherits(UnrealBloomPass, _Pass);
    var _super = _createSuper(UnrealBloomPass);
    function UnrealBloomPass(resolution, strength, radius, threshold) {
      var _this;
      _classCallCheck(this, UnrealBloomPass);
      _this = _super.call(this);
      _this.strength = strength !== undefined ? strength : 1;
      _this.radius = radius;
      _this.threshold = threshold;
      _this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);

      // create color only once here, reuse it later inside the render function
      _this.clearColor = new Color$2(0, 0, 0);

      // render targets
      var pars = {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      };
      _this.renderTargetsHorizontal = [];
      _this.renderTargetsVertical = [];
      _this.nMips = 5;
      var resx = Math.round(_this.resolution.x / 2);
      var resy = Math.round(_this.resolution.y / 2);
      _this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);
      _this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';
      _this.renderTargetBright.texture.generateMipmaps = false;
      for (var i = 0; i < _this.nMips; i++) {
        var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);
        renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;
        renderTargetHorizonal.texture.generateMipmaps = false;
        _this.renderTargetsHorizontal.push(renderTargetHorizonal);
        var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);
        renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
        renderTargetVertical.texture.generateMipmaps = false;
        _this.renderTargetsVertical.push(renderTargetVertical);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
      }

      // luminosity high pass material

      if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');
      var highPassShader = LuminosityHighPassShader;
      _this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
      _this.highPassUniforms['luminosityThreshold'].value = threshold;
      _this.highPassUniforms['smoothWidth'].value = 0.01;
      _this.materialHighPassFilter = new ShaderMaterial({
        uniforms: _this.highPassUniforms,
        vertexShader: highPassShader.vertexShader,
        fragmentShader: highPassShader.fragmentShader,
        defines: {}
      });

      // Gaussian Blur Materials
      _this.separableBlurMaterials = [];
      var kernelSizeArray = [3, 5, 7, 9, 11];
      resx = Math.round(_this.resolution.x / 2);
      resy = Math.round(_this.resolution.y / 2);
      for (var _i = 0; _i < _this.nMips; _i++) {
        _this.separableBlurMaterials.push(_this.getSeperableBlurMaterial(kernelSizeArray[_i]));
        _this.separableBlurMaterials[_i].uniforms['texSize'].value = new Vector2(resx, resy);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
      }

      // Composite material
      _this.compositeMaterial = _this.getCompositeMaterial(_this.nMips);
      _this.compositeMaterial.uniforms['blurTexture1'].value = _this.renderTargetsVertical[0].texture;
      _this.compositeMaterial.uniforms['blurTexture2'].value = _this.renderTargetsVertical[1].texture;
      _this.compositeMaterial.uniforms['blurTexture3'].value = _this.renderTargetsVertical[2].texture;
      _this.compositeMaterial.uniforms['blurTexture4'].value = _this.renderTargetsVertical[3].texture;
      _this.compositeMaterial.uniforms['blurTexture5'].value = _this.renderTargetsVertical[4].texture;
      _this.compositeMaterial.uniforms['bloomStrength'].value = strength;
      _this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;
      _this.compositeMaterial.needsUpdate = true;
      var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
      _this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;
      _this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
      _this.compositeMaterial.uniforms['bloomTintColors'].value = _this.bloomTintColors;

      // copy material
      if (CopyShader === undefined) {
        console.error('THREE.UnrealBloomPass relies on CopyShader');
      }
      var copyShader = CopyShader;
      _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
      _this.copyUniforms['opacity'].value = 1.0;
      _this.materialCopy = new ShaderMaterial({
        uniforms: _this.copyUniforms,
        vertexShader: copyShader.vertexShader,
        fragmentShader: copyShader.fragmentShader,
        blending: AdditiveBlending,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
      _this.enabled = true;
      _this.needsSwap = false;
      _this._oldClearColor = new Color$2();
      _this.oldClearAlpha = 1;
      _this.basic = new MeshBasicMaterial$1();
      _this.fsQuad = new FullScreenQuad(null);
      return _this;
    }
    _createClass(UnrealBloomPass, [{
      key: "dispose",
      value: function dispose() {
        for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {
          this.renderTargetsHorizontal[i].dispose();
        }
        for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {
          this.renderTargetsVertical[_i2].dispose();
        }
        this.renderTargetBright.dispose();
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var resx = Math.round(width / 2);
        var resy = Math.round(height / 2);
        this.renderTargetBright.setSize(resx, resy);
        for (var i = 0; i < this.nMips; i++) {
          this.renderTargetsHorizontal[i].setSize(resx, resy);
          this.renderTargetsVertical[i].setSize(resx, resy);
          this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);
          resx = Math.round(resx / 2);
          resy = Math.round(resy / 2);
        }
      }
    }, {
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
        renderer.getClearColor(this._oldClearColor);
        this.oldClearAlpha = renderer.getClearAlpha();
        var oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        renderer.setClearColor(this.clearColor, 0);
        if (maskActive) renderer.state.buffers.stencil.setTest(false);

        // Render input to screen

        if (this.renderToScreen) {
          this.fsQuad.material = this.basic;
          this.basic.map = readBuffer.texture;
          renderer.setRenderTarget(null);
          renderer.clear();
          this.fsQuad.render(renderer);
        }

        // 1. Extract Bright Areas

        this.highPassUniforms['tDiffuse'].value = readBuffer.texture;
        this.highPassUniforms['luminosityThreshold'].value = this.threshold;
        this.fsQuad.material = this.materialHighPassFilter;
        renderer.setRenderTarget(this.renderTargetBright);
        renderer.clear();
        this.fsQuad.render(renderer);

        // 2. Blur All the mips progressively

        var inputRenderTarget = this.renderTargetBright;
        for (var i = 0; i < this.nMips; i++) {
          this.fsQuad.material = this.separableBlurMaterials[i];
          this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;
          this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;
          renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
          renderer.clear();
          this.fsQuad.render(renderer);
          this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;
          this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;
          renderer.setRenderTarget(this.renderTargetsVertical[i]);
          renderer.clear();
          this.fsQuad.render(renderer);
          inputRenderTarget = this.renderTargetsVertical[i];
        }

        // Composite All the mips

        this.fsQuad.material = this.compositeMaterial;
        this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;
        this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;
        this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;
        renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
        renderer.clear();
        this.fsQuad.render(renderer);

        // Blend it additively over the input texture

        this.fsQuad.material = this.materialCopy;
        this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;
        if (maskActive) renderer.state.buffers.stencil.setTest(true);
        if (this.renderToScreen) {
          renderer.setRenderTarget(null);
          this.fsQuad.render(renderer);
        } else {
          renderer.setRenderTarget(readBuffer);
          this.fsQuad.render(renderer);
        }

        // Restore renderer settings

        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
        renderer.autoClear = oldAutoClear;
      }
    }, {
      key: "getSeperableBlurMaterial",
      value: function getSeperableBlurMaterial(kernelRadius) {
        return new ShaderMaterial({
          defines: {
            'KERNEL_RADIUS': kernelRadius,
            'SIGMA': kernelRadius
          },
          uniforms: {
            'colorTexture': {
              value: null
            },
            'texSize': {
              value: new Vector2(0.5, 0.5)
            },
            'direction': {
              value: new Vector2(0.5, 0.5)
            }
          },
          vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
          fragmentShader: "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
        });
      }
    }, {
      key: "getCompositeMaterial",
      value: function getCompositeMaterial(nMips) {
        return new ShaderMaterial({
          defines: {
            'NUM_MIPS': nMips
          },
          uniforms: {
            'blurTexture1': {
              value: null
            },
            'blurTexture2': {
              value: null
            },
            'blurTexture3': {
              value: null
            },
            'blurTexture4': {
              value: null
            },
            'blurTexture5': {
              value: null
            },
            'dirtTexture': {
              value: null
            },
            'bloomStrength': {
              value: 1.0
            },
            'bloomFactors': {
              value: null
            },
            'bloomTintColors': {
              value: null
            },
            'bloomRadius': {
              value: 0.0
            }
          },
          vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
          fragmentShader: "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"
        });
      }
    }]);
    return UnrealBloomPass;
  }(Pass);
  UnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);
  UnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);

  var BloomPass = /*#__PURE__*/function (_UnrealBloomPass) {
    _inherits(BloomPass, _UnrealBloomPass);
    var _super = _createSuper(BloomPass);
    function BloomPass(canvas, _ref) {
      var threshold = _ref.threshold,
        strength = _ref.strength,
        radius = _ref.radius;
      _classCallCheck(this, BloomPass);
      return _super.call(this, new Vector2(canvas.clientWidth, canvas.clientHeight), strength, radius, threshold);
    }
    return _createClass(BloomPass);
  }(UnrealBloomPass);

  var FogPass = /*#__PURE__*/function (_Pass) {
    _inherits(FogPass, _Pass);
    var _super = _createSuper(FogPass);
    function FogPass(scene, camera, options) {
      var _this;
      _classCallCheck(this, FogPass);
      _this = _super.call(this);
      _this.scene = scene;
      _this.camera = camera;
      // this.width = canvas.clientWidth
      // this.height = canvas.clientHeight
      _this.clearColor = new Color$2(0, 0, 0);
      _this._visibilityCache = new Map();
      var depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      // 法线材质着色器

      _this.normalMaterial = new MeshNormalMaterial();
      _this.normalMaterial.blending = NoBlending;

      // 创建法线渲染目标

      _this.normalRenderTarget = new WebGLRenderTarget(_this.width, _this.height, {
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        format: RGBAFormat,
        depthTexture: depthTexture
      });

      //创建深度渲染目标，目的是读取深度
      _this.depthRenderMaterial = new ShaderMaterial({
        defines: Object.assign({}, {
          'PERSPECTIVE_CAMERA': 1
        }),
        uniforms: UniformsUtils.clone({
          'tDepth': {
            value: null
          },
          'cameraNear': {
            value: null
          },
          'cameraFar': {
            value: null
          },
          'colorTexture': {
            value: null
          },
          'cameraDistance': {
            value: null
          },
          'fogFactor': {
            value: options.fogFactor || 1.0
          },
          'color': {
            value: options.color || new Color$2(0.7, 0.7, 0.7)
          },
          'frameNumber': {
            value: 0
          }
        }),
        vertexShader: /*glsl*/"varying vec2 vUv;\n        void main() {\n\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }",
        fragmentShader: /*glsl*/"uniform sampler2D tDepth;\n\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float cameraDistance;\n        uniform sampler2D colorTexture;\n        uniform vec3 color;\n        uniform float frameNumber;\n        uniform float fogFactor;\n      \n        varying vec2 vUv;\n\n        #include <packing>\n\n        float getLinearDepth( const in vec2 screenPosition ) {\n\n          #if PERSPECTIVE_CAMERA == 1\n\n            float fragCoordZ = texture2D( tDepth, screenPosition ).x;\n            float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraNear+cameraDistance );\n            return viewZToOrthographicDepth( viewZ, cameraNear,  cameraNear+cameraDistance);\n\n          #else\n\n            return texture2D( tDepth, screenPosition ).x;\n\n          #endif\n\n        }\n\n        void main() {\n          float depth = getLinearDepth( vUv );\n          float factor=0.0;\n          vec4 depthColor=texture2D(tDepth,vUv);\n          if(depth>0.95){\n            factor=1.0;\n          }else{\n             factor=min(depth/fogFactor,fogFactor);\n          }\n         \n         \n          vec4 origcolor=texture2D(colorTexture, vUv);\n          // vec3 color=vec4(0.7,0.7,0.7);\n          // vec4 sandColor=vec4(206.0/255.0,152.0/255.0,115.0/255.0,0.5);\n          if(cameraDistance>10000.0){\n            gl_FragColor=origcolor;\n          }else{\n            gl_FragColor =vec4(mix(origcolor.rgb,color,factor),1.0);\n          }\n          //  gl_FragColor =vec4(mix(origcolor.rgb,fogcolor.rgb,factor),1.0);\n        }",
        blending: NoBlending
      });
      _this.fsQuad = new FullScreenQuad(null);
      _this.originalClearColor = new Color$2(0xffffff);
      return _this;
    }
    _createClass(FogPass, [{
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
        //使用法向材质渲染方式渲染到normalRenderTarget帧缓冲
        this.overrideVisibility();
        this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);
        this.restoreVisibility();
        this.depthRenderMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;
        this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;
        this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far;
        this.depthRenderMaterial.uniforms['colorTexture'].value = readBuffer.texture;
        this.depthRenderMaterial.uniforms['cameraDistance'].value = this.camera.position.distanceTo(new Vector3(0, 0, 0));
        this.depthRenderMaterial.uniforms.frameNumber.value++;
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        // this.renderPass(renderer, this.depthRenderMaterial, null);
        renderer.clearDepth();
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.normalRenderTarget.dispose();
        this.normalMaterial.dispose();
        this.depthRenderMaterial.dispose();
        this.fsQuad.dispose();
      }

      /**
      * 只渲染屏幕四边形
      * @param {*} renderer 
      * @param {*} passMaterial 
      * @param {*} renderTarget 
      * @param {*} clearColor 
      * @param {*} clearAlpha 
      */
    }, {
      key: "renderPass",
      value: function renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
        // save original state
        renderer.getClearColor(this.originalClearColor);
        var originalClearAlpha = renderer.getClearAlpha();
        var originalAutoClear = renderer.autoClear;
        renderer.setRenderTarget(renderTarget);

        // setup pass state
        renderer.autoClear = false;
        if (clearColor !== undefined && clearColor !== null) {
          renderer.setClearColor(clearColor);
          renderer.setClearAlpha(clearAlpha || 0.0);
          renderer.clear();
        }
        this.fsQuad.material = passMaterial;
        this.fsQuad.render(renderer);

        // restore original state
        renderer.autoClear = originalAutoClear;
        renderer.setClearColor(this.originalClearColor);
        renderer.setClearAlpha(originalClearAlpha);
      }

      /**
       * 渲染场景中的所有选中物体到renderTarget
       * @param {*} renderer 
       * @param {*} overrideMaterial 
       * @param {*} renderTarget 
       * @param {*} clearColor 
       * @param {*} clearAlpha 
       */
    }, {
      key: "renderOverride",
      value: function renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
        renderer.getClearColor(this.originalClearColor);
        var originalClearAlpha = renderer.getClearAlpha();
        var originalAutoClear = renderer.autoClear;
        renderer.setRenderTarget(renderTarget);
        renderer.autoClear = false;
        clearColor = overrideMaterial.clearColor || clearColor;
        clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
        if (clearColor !== undefined && clearColor !== null) {
          renderer.setClearColor(clearColor);
          renderer.setClearAlpha(clearAlpha || 0.0);
          renderer.clear();
        }
        this.scene.overrideMaterial = overrideMaterial;
        renderer.render(this.scene, this.camera);
        this.scene.overrideMaterial = null;

        // restore original state

        renderer.autoClear = originalAutoClear;
        renderer.setClearColor(this.originalClearColor);
        renderer.setClearAlpha(originalClearAlpha);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.width = width;
        this.height = height;

        // this.beautyRenderTarget.setSize(width, height);
        // this.ssaoRenderTarget.setSize(width, height);
        // this.normalRenderTarget.setSize(width, height);
        this.normalRenderTarget.setSize(width, height);
        // this.blurRenderTarget.setSize(width, height);

        // this.ssaoMaterial.uniforms['resolution'].value.set(width, height);
        // this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);
        // this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);

        // this.blurMaterial.uniforms['resolution'].value.set(width, height);
      }

      /**
       * 不需要渲染的不让显示
       */
    }, {
      key: "overrideVisibility",
      value: function overrideVisibility() {
        var scene = this.scene;
        var cache = this._visibilityCache;
        scene.traverse(function (object) {
          cache.set(object, object.visible);
          if (object.isPoints || object.isLine) object.visible = false;
        });
      }

      /**
       * 恢复原状态
       */
    }, {
      key: "restoreVisibility",
      value: function restoreVisibility() {
        var scene = this.scene;
        var cache = this._visibilityCache;
        scene.traverse(function (object) {
          var visible = cache.get(object);
          object.visible = visible;
        });
        cache.clear();
      }
    }]);
    return FogPass;
  }(Pass);

  var RainPass = /*#__PURE__*/function (_ShaderPass) {
    _inherits(RainPass, _ShaderPass);
    var _super = _createSuper(RainPass);
    function RainPass(canvas) {
      _classCallCheck(this, RainPass);
      var material = new ShaderMaterial({
        uniforms: {
          baseTexture: {
            value: null
          },
          resolution: {
            value: new Vector2(canvas.clientWidth, canvas.clientHeight)
          },
          frameNumber: {
            value: 0
          }
        },
        vertexShader: /*glsl*/"\tvarying vec2 vUv;\n          void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n          }",
        // fragmentShader: document.getElementById('fragmentshader').textContent,
        fragmentShader: /*glsl*/"\t\n          uniform sampler2D baseTexture;\n          uniform vec2 resolution;\n          uniform float frameNumber;\n          varying vec2 vUv;\n        float hash(float x){\n         return fract(sin(x*23.3)*13.13);\n        }\n        void main(){\n            float time = frameNumber / 60.0;\n            vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n            vec3 c=vec3(.6,.7,.8);\n            float a=-.4;\n            float si=sin(a),co=cos(a);\n            uv*=mat2(co,-si,si,co);\n            uv*=length(uv+vec2(0,4.9))*.3+1.;\n            float v=1.-sin(hash(floor(uv.x*100.))*2.);\n            float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\n            c*=v*b;\n            gl_FragColor = mix(texture2D(baseTexture, vUv), vec4(c, 1), 0.2);\n        }",
        defines: {}
      });
      return _super.call(this, material, "baseTexture");
    }
    _createClass(RainPass, [{
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
        this.material.uniforms.frameNumber.value++;
        _get(_getPrototypeOf(RainPass.prototype), "render", this).call(this, renderer, writeBuffer, readBuffer);
      }
    }]);
    return RainPass;
  }(ShaderPass);

  var SnowPass = /*#__PURE__*/function (_ShaderPass) {
    _inherits(SnowPass, _ShaderPass);
    var _super = _createSuper(SnowPass);
    function SnowPass(canvas) {
      _classCallCheck(this, SnowPass);
      var material = new ShaderMaterial({
        uniforms: {
          baseTexture: {
            value: null
          },
          resolution: {
            value: new Vector2(canvas.clientWidth, canvas.clientHeight)
          },
          frameNumber: {
            value: 0
          }
        },
        vertexShader: /*glsl*/"\tvarying vec2 vUv;\n          void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n          }",
        // fragmentShader: document.getElementById('fragmentshader').textContent,
        fragmentShader: /*glsl*/"\t\n          uniform sampler2D baseTexture;\n          uniform vec2 resolution;\n          uniform float frameNumber;\n          varying vec2 vUv;\n          // uniform sampler2D colorTexture;\n        // varying vec2 v_textureCoordinates;\n        float snow(vec2 uv,float scale){\n            float time = frameNumber / 80.0;\n            float w=smoothstep(2.,0.,-uv.y*(scale/10.));\n            if(w<.1)return 0.;\n            uv+=time/scale;\n            uv.y+=time*2./scale;\n            uv.x+=sin(uv.y+time*.5)/scale;\n            uv*=scale;\n            vec2 s=floor(uv),f=fract(uv),p;\n            float k=3.,d;\n            p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;\n            d=length(p);\n            k=min(d,k);\n            k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n            return k*w;\n        }\n        \n        void main(){\n            // vec2 resolution = czm_viewport.zw;\n            vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n            vec3 finalColor=vec3(0);\n            float c = 0.0;\n            c+=snow(uv,30.)*.0;\n            c+=snow(uv,20.)*.0;\n            c+=snow(uv,15.)*.0;\n            c+=snow(uv,10.);\n            c+=snow(uv,8.);\n            c+=snow(uv,6.);\n            c+=snow(uv,5.);\n            finalColor=(vec3(c));\n            gl_FragColor = mix(texture2D(baseTexture, vUv), vec4(finalColor,1), 0.3);\n            \n        }",
        defines: {}
      });
      return _super.call(this, material, "baseTexture");
    }
    _createClass(SnowPass, [{
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
        this.material.uniforms.frameNumber.value++;
        _get(_getPrototypeOf(SnowPass.prototype), "render", this).call(this, renderer, writeBuffer, readBuffer);
      }
    }]);
    return SnowPass;
  }(ShaderPass);

  var ThanderPass = /*#__PURE__*/function (_ShaderPass) {
    _inherits(ThanderPass, _ShaderPass);
    var _super = _createSuper(ThanderPass);
    function ThanderPass(canvas) {
      _classCallCheck(this, ThanderPass);
      var material = new ShaderMaterial({
        uniforms: {
          baseTexture: {
            value: null
          },
          resolution: {
            value: new Vector2(canvas.clientWidth, canvas.clientHeight)
          },
          frameNumber: {
            value: 0
          },
          mix_factor: {
            value: 0.5
          },
          //混合系数0-1之间的数
          fall_interval: {
            value: 0.7
          } //0-1之间的数
        },

        vertexShader: /*glsl*/"\tvarying vec2 vUv;\n          void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n          }",
        // fragmentShader: document.getElementById('fragmentshader').textContent,
        fragmentShader: /*glsl*/"\n        float hash(float x)\n        {\n          return fract(21654.6512 * sin(385.51 * x));\n        }\n        float hash(vec2 p)\n        {\n          return fract(1654.65157 * sin(15.5134763 * p.x + 45.5173247 * p.y + 5.21789));\n        }\n        vec2 hash2(vec2 p)\n        {\n          return vec2(hash(p * .754), hash(1.5743 * p + 4.5476351));\n        }\n        vec2 add = vec2(1.0, 0.0);\n        vec2 noise2(vec2 x)\n        {\n          vec2 p = floor(x);\n          vec2 f = fract(x);\n            f = f * f * (3.0 - 2.0 * f);\n          vec2 res = mix(mix(hash2(p),\n          hash2(p + add.xy), f.x),\n          mix(hash2(p + add.yx), hash2(p + add.xx), f.x), f.y);\n          return res;\n        }\n        vec2 fbm2(vec2 x)\n        {\n          vec2 r = vec2(0.0);\n          float a = 1.0;\n          for (int i = 0; i < 8; i++)\n          {\n          r += noise2(x) * a;\n          x *= 2.;\n          a *= .5;\n          }\n          return r;\n        }\n        float dseg(vec2 ba, vec2 pa)\n        {\n          float h = clamp(dot(pa, ba) / dot(ba, ba), -0.2, 1.);\n          return length(pa - ba * h);\n        }\n        uniform sampler2D baseTexture;\n        uniform vec2 resolution;\n        uniform float frameNumber;\n        varying vec2 vUv;\n        uniform float fall_interval; \n        uniform float mix_factor; \n        void main(void){\n          vec2 uv = gl_FragCoord.xy; \n          float iTime = frameNumber * fall_interval * clamp(fall_interval * 0.1, 0.01, 0.1); \n          vec2 p = uv / resolution; \n          vec2 d; \n          vec2 tgt = vec2(1., -1.); \n          float c = 0.; \n          if (p.y >= 0.) \n            c = (1. - (fbm2((p + .2) * p.y + .1 * iTime)).x) * p.y; \n          else \n            c = (1. - (fbm2(p + .2 + .1 * iTime)).x) * p.y * p.y; \n          vec3 col = vec3(0.); \n\n          vec3 col1 = c * vec3(.3, .5, 1.); \n          float mdist = 100000.; \n          float t = hash(floor(5. * iTime)); \n          tgt += 4. * hash2(tgt + t) - 1.5; \n          if (hash(t + 2.3) > .6) {\n            for (int i = 0; i < 100; i++) {\n              vec2 dtgt = tgt - p; \n              d = .05 * (vec2(-.5, -1.) + hash2(vec2(float(i), t))); \n\n              float dist = dseg(d, dtgt); \n\n              mdist = min(mdist, dist); \n              tgt -= d; \n              c = exp(-1.2 * dist) + exp(-55. * mdist); \n              col = c * vec3(.7, .8, 1.); \n            } \n          }\n          col += col1; \n          gl_FragColor = mix(texture2D(baseTexture, vUv), vec4(col, 0.0), mix_factor); \n} \n",
        defines: {}
      });
      return _super.call(this, material, "baseTexture");
    }
    _createClass(ThanderPass, [{
      key: "render",
      value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
        this.material.uniforms.frameNumber.value++;
        _get(_getPrototypeOf(ThanderPass.prototype), "render", this).call(this, renderer, writeBuffer, readBuffer);
      }
    }]);
    return ThanderPass;
  }(ShaderPass);

  var SandStormPass = /*#__PURE__*/function (_FogPass) {
    _inherits(SandStormPass, _FogPass);
    var _super = _createSuper(SandStormPass);
    function SandStormPass(scene, camera, options) {
      _classCallCheck(this, SandStormPass);
      return _super.call(this, scene, camera, {
        fogFactor: options.sandFactor,
        color: new Color$2(206.0 / 255.0, 152.0 / 255.0, 115.0 / 255.0)
      });
    }
    return _createClass(SandStormPass);
  }(FogPass);

  var PostProcessStageCollection = /*#__PURE__*/function (_EffectComposer) {
    _inherits(PostProcessStageCollection, _EffectComposer);
    var _super = _createSuper(PostProcessStageCollection);
    function PostProcessStageCollection(threeViewer) {
      var _this;
      _classCallCheck(this, PostProcessStageCollection);
      _this = _super.call(this, threeViewer.renderer);
      _this._renderer = threeViewer.renderer;
      _this._renderPass = threeViewer.renderPass;
      _this._canvas = threeViewer.canvas;
      _this._camera = threeViewer.camera;
      _this._threeViewer = threeViewer;
      _this._renderPass = new RenderPass(threeViewer, _this._camera);
      _this.addPass(_this._renderPass);
      return _this;
    }
    _createClass(PostProcessStageCollection, [{
      key: "add",
      value: function add(postProcessStageType) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        switch (postProcessStageType) {
          case PostProcessStage.Bloom:
            {
              if (!this.existsPass(this._bloomPass)) {
                this._bloomPass = new BloomPass(this._canvas, options);
                this.addPass(this._bloomPass);
              }
              break;
            }
          case PostProcessStage.Rain:
            {
              if (!this.existsPass(this._rainPass)) {
                this._rainPass = new RainPass(this._canvas);
                this.addPass(this._rainPass);
              }
              break;
            }
          case PostProcessStage.Snow:
            {
              if (!this.existsPass(this._snowPass)) {
                this._snowPass = new SnowPass(this._canvas);
                this.addPass(this._snowPass);
              }
              break;
            }
          case PostProcessStage.Thunder:
            {
              if (!this.existsPass(this._thunderPass)) {
                this._thunderPass = new ThanderPass(this._canvas);
                this.addPass(this._thunderPass);
              }
              break;
            }
          case PostProcessStage.Fog:
            {
              if (!this.existsPass(this._fogPass)) {
                this._fogPass = new FogPass(this._threeViewer, this._camera, options);
                this.addPass(this._fogPass);
              }
              break;
            }
          case PostProcessStage.SandStorm:
            {
              if (!this.existsPass(this._sandStormPass)) {
                this._sandStormPass = new SandStormPass(this._threeViewer, this._camera, options);
                this.addPass(this._sandStormPass);
              }
              break;
            }
        }
      }
    }, {
      key: "remove",
      value: function remove(postProcessStageType) {
        switch (postProcessStageType) {
          case PostProcessStage.Bloom:
            {
              this.removePass(this._bloomPass);
              this._bloomPass.dispose();
              break;
            }
          case PostProcessStage.Rain:
            {
              this.removePass(this._rainPass);
              break;
            }
          case PostProcessStage.Snow:
            {
              this.removePass(this._snowPass);
              break;
            }
          case PostProcessStage.Thunder:
            {
              this.removePass(this._thunderPass);
              break;
            }
          case PostProcessStage.Fog:
            {
              this.removePass(this._fogPass);
              break;
            }
          case PostProcessStage.SandStorm:
            {
              this.removePass(this._sandStormPass);
              break;
            }
        }
        // this.setSize(this._canvas.clientWidth, this._canvas.clientHeight)
      }
    }, {
      key: "existsPass",
      value: function existsPass(pass) {
        return this.passes.find(function (item) {
          return item == pass;
        });
      }
    }]);
    return PostProcessStageCollection;
  }(EffectComposer);

  /**
   * 实体图层
   */
  var PrimitiveCollection = /*#__PURE__*/function (_Group) {
    _inherits(PrimitiveCollection, _Group);
    var _super = _createSuper(PrimitiveCollection);
    /**
     * 构造函数
     */
    function PrimitiveCollection() {
      _classCallCheck(this, PrimitiveCollection);
      return _super.call(this);
    }
    _createClass(PrimitiveCollection, [{
      key: "getObjectById",
      value: function getObjectById(id) {
        return this.children.find(function (instance) {
          return instance.id = id;
        });
      }
    }, {
      key: "add",
      value: function add(entity) {
        _get(_getPrototypeOf(PrimitiveCollection.prototype), "add", this).call(this, entity);
        //获取id
      }

      /**
       * 更新图层
       * @param globe globe对象
       */
    }, {
      key: "update",
      value: function update(frameState) {
        if (this.children.length > 0) {
          for (var i = 0; i < this.children.length; i++) {
            this.children[i].update(frameState);
          }
        }
      }
    }]);
    return PrimitiveCollection;
  }(Group$1);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   *
   * @class ThreeViewer
   * 创建一个Three场景
   * @extends Scene
   *
   */
  var ThreeViewer = /*#__PURE__*/function (_Scene) {
    _inherits(ThreeViewer, _Scene);
    var _super = _createSuper(ThreeViewer);
    /**
     * ThreeViewer类的构造函数
     * @param {GlobeControl} globeControl
     */
    function ThreeViewer(globeControl) {
      var _this;
      _classCallCheck(this, ThreeViewer);
      _this = _super.call(this);
      _this._globeControl = globeControl;
      _this.globe = globeControl.getGlobe();
      _this.worldCamera = _this.globe.getWorldCamera();
      _this._threeLayer = new PrimitiveCollection();
      _this.add(_this._threeLayer);
      _this.init();
      return _this;
    }
    /**
     * 初始化
     */
    _createClass(ThreeViewer, [{
      key: "init",
      value: function init() {
        var canvas = this._globeControl.getCanvas();
        var context = this._globeControl.getContext();
        this.camera = new EarthCamera(this._globeControl, 45, canvas.clientWidth / canvas.clientHeight, 100, 200000000);
        //camera.position.set(0, 0, 6378137 * 2);
        this.add(this.camera);

        //renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );
        var renderer = new EarthRenderer(this._globeControl, {
          canvas: canvas,
          context: context
        });
        renderer.autoClearColor = false;
        renderer.autoClearDepth = false;
        renderer.autoClearStencil = false;
        renderer.autoClear = false;
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        // renderer.toneMapping = ReinhardToneMapping;
        //renderer.toneMappingExposure = Math.pow( 8, 4.0 );

        this.add(new AmbientLight(0xffffff, 1.0));
        var pointLight = new PointLight(0xffffff, 1);
        this.camera.add(pointLight);
        this._earth3D = new Earth3D(renderer, this._globeControl);
        this.add(this._earth3D);
        this._uniforms = {
          relativeViewMatrix: null
        };

        //设置帧状态
        this._frameState = {
          time: new Date(),
          frameNumber: 0,
          threeEarth: this.camera,
          uniformStates: this._uniforms
        };
        this._renderer = renderer;
        this._canvas = canvas;

        //后期处理
        this._postProcessStageCollection = new PostProcessStageCollection(this);
      }

      /**
       * 获取three图层
       * @returns {PrimitiveCollection}
       */
    }, {
      key: "threeLayer",
      get: function get() {
        return this._threeLayer;
      }

      /**
       * 获取后处理阶段集合
       * @returns {PostProcessStageCollection}
       */
    }, {
      key: "postProcessStageCollection",
      get: function get() {
        return this._postProcessStageCollection;
      }

      /**
       * 获取画布
       * @returns {String}
       */
    }, {
      key: "canvas",
      get: function get() {
        return this._canvas;
      }

      /**
       * 获取三维球
       * @returns {Earth3D}
       */
    }, {
      key: "earth3D",
      get: function get() {
        return this._earth3D;
      }

      /**
       * 获取相机
       * @returns {String}
       */
    }, {
      key: "camera",
      get: function get() {
        return this._camera;
      }
      /**
       * 设置相机
       * @param {Camera}
       */,
      set: function set(value) {
        this._camera = value;
      }
      /**
       * 获取渲染器
       * @returns {EarthRenderer}
       */
    }, {
      key: "renderer",
      get: function get() {
        return this._renderer;
      }
      /**
       * 设置渲染器
       * @param {EarthRenderer}
       */,
      set: function set(value) {
        this._renderer = value;
      }

      /**
       * 更新
       */
    }, {
      key: "updateUniforms",
      value: function updateUniforms() {
        var relativeViewMatrix = this.worldCamera.getRelativeViewMatrix();
        var matrixView = new Matrix4$1();
        matrixView.fromArray(relativeViewMatrix.toArray());
        this._uniforms.relativeViewMatrix = matrixView;
      }
    }, {
      key: "update",
      value: function update() {
        //更新帧状态
        this._frameState.frameNumber++;
        this._frameState.time = new Date();
        //更新各种矩阵参数
        this.updateUniforms();
        //同步相机
        this.camera.update();

        //保持three场景与Earth同步,即将three坐标系原点放在地球球心
        this.camera.updateWorldPosition(this._threeLayer, new Vector3(0, 0, 0));
        var children = this.children;
        //遍历更新所有的three中的Object3D
        for (var i = 0; i < children.length; i++) {
          if (children[i] instanceof PrimitiveCollection || children[i] instanceof PixelLinePrimitive) {
            children[i].update(this._frameState);
          }
        }
        // window.onresize=(()=>{
        //解决three引入导致的resize事件无法响应的问题
        // this.renderer.setSize(window.innerWidth, window.innerHeight);
        // this._camera.aspect = window.innerWidth / window.innerHeight;
        // this._camera.updateProjectionMatrix();
        // });
        //后期处理更新

        this._postProcessStageCollection.render();
        this.reSize(this.renderer);
        this.renderer.resetState();
      }
      // 让canvas 像素尺寸随css 尺寸同步更新的方法
      /**
       * 是否需要调整渲染器的大小
       * @param {EarthRenderer} renderer
       * @returns {Boolean}
       */
    }, {
      key: "reSize",
      value: function reSize(renderer) {
        var _renderer$domElement = renderer.domElement,
          width = _renderer$domElement.width,
          height = _renderer$domElement.height,
          clientWidth = _renderer$domElement.clientWidth,
          clientHeight = _renderer$domElement.clientHeight;
        if (renderer.domElement.id) {
          document.getElementById(renderer.domElement.id).style.width = '100%';
          document.getElementById(renderer.domElement.id).style.height = '100%';
        }
        var needResize = width !== clientWidth || height !== clientHeight;
        renderer.setSize(clientWidth, clientHeight, false);
        // // 如果
        // if (needResize) {
        //   renderer.setSize(clientWidth, clientHeight, false);

        // }
        return needResize;
      }
    }]);
    return ThreeViewer;
  }(Scene$1);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class UrlTemplateImageryProvider
   * url模板图层类
   * @extends ImageryProvider
   *
   */
  var UrlTemplateImageryProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(UrlTemplateImageryProvider, _ImageryProvider);
    var _super = _createSuper(UrlTemplateImageryProvider);
    /**
     * UrlTemplateImageryProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url 数据的Url
     */
    function UrlTemplateImageryProvider(options) {
      var _this;
      _classCallCheck(this, UrlTemplateImageryProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('options.url is required.');
      }
      _this._options = options;
      return _this;
    }
    return _createClass(UrlTemplateImageryProvider);
  }(ImageryProvider);

  /**
   *  符号基类操作函数
   * @name Symbol
   */
  var _Symbol = /*#__PURE__*/function () {
    function _Symbol(handle) {
      _classCallCheck(this, _Symbol);
      _defineProperty(this, "_Symbol", void 0);
      if (handle != null) {
        this._Symbol = handle;
      }
    }
    _createClass(_Symbol, [{
      key: "handle",
      get: function get() {
        return this._Symbol;
      }
      /**
       * 释放符号对象
       * @memberOf Symbol#
       */
    }, {
      key: "dispose",
      value: function dispose() {
        return this._Symbol.dispose();
      }
      /**
       * 获取符号的类型
       *
       * @memberOf Symbol#
       * @returns {PIESymbolType} 成功返回类型
       */
    }, {
      key: "type",
      get: function get() {
        return this._Symbol.getType();
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._Symbol.getType();
      }
      /**
       * 设置符号的ID
       * @param {Number} id -符号ID
       *
       * @memberOf Symbol#
       */
    }, {
      key: "ID",
      get: function get() {
        return this._Symbol.getID();
      },
      set: function set(id) {
        this._Symbol.setID(id);
      }
    }, {
      key: "getID",
      value: function getID() {
        return this._Symbol.getID();
      }
      /**
       * 获取符号的名称
       *
       * @memberOf Symbol#
       * @returns {String} 返回符号名称
       */
    }, {
      key: "name",
      get: function get() {
        return this._Symbol.getName();
      },
      set:
      /**
       * 设置符号的名称
       * @param {String} name -符号名称
       * @memberOf Symbol#
       *
       */
      function set(value) {
        this._Symbol.setName(value);
      }
      /**
       * 获取符号的类别
       * @memberOf Symbol#
       * @returns {String} 返回符号类别
       */
    }, {
      key: "getName",
      value: function getName() {
        return this._Symbol.getName();
      }
    }, {
      key: "category",
      get: function get() {
        return this._Symbol.getCategory();
      }

      /**
       * 设置符号的类别
       * @param {String} category 符号类别
       * @memberOf Symbol#
       */,
      set: function set(category) {
        this._Symbol.setCategory(category);
      }
    }]);
    return _Symbol;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 符号组操作函数
   * @name SymbolGroup
   */
  var SymbolGroup = /*#__PURE__*/function () {
    function SymbolGroup(handle) {
      _classCallCheck(this, SymbolGroup);
      _defineProperty(this, "_SymbolGroup", void 0);
      // if (options == null) {
      //     //this._SymbolGroup = new PIESymbolGroup();
      // } else {
      //     if (handle != null) {
      //         this._SymbolGroup = handle;
      //     } else {
      //         //this._SymbolGroup = new PIESymbolGroup();
      //     }
      // }
      if (handle != null) {
        this._SymbolGroup = handle;
      } else {
        DeveloperError$1.throwInstantiationError();
      }
    }
    /**
     * 获取符号数量
     *
     * @memberOf SymbolGroup#
     * @returns {Number} 如果获取成功，返回符号数量
     *
     */
    _createClass(SymbolGroup, [{
      key: "count",
      get: function get() {
        return this._SymbolGroup.getCount();
      }
      /**
       * 添加符号对象
       * @param {Symbol} symbol -符号对象
       *
       * @memberOf SymbolGroup#
       * @returns {Boolean} 如果添加成功，返回true，否则返回false
       *
       */
    }, {
      key: "add",
      value: function add(symbol) {
        // return Boolean(Module._SymbolGroup_Add(this.handle, symbol.getHandle()));
        return Boolean(this._SymbolGroup.add(symbol.handle));
      }
      /**
       * 通过ID获取符号对象
       * @param {Number} id -符号ID
       *
       * @memberOf SymbolGroup#
       * @returns {Symbol} 如果获取成功，返回符号对象，否则返回空
       *
       */
    }, {
      key: "getByID",
      value: function getByID(id) {
        return new _Symbol(this._SymbolGroup.getByID(id));
      }
      /**
       * 根据符号组的索引号获取符号对象
       * @param {Number} index -索引号
       *
       * @memberOf SymbolGroup#
       * @returns {Symbol} 如果获取成功，返回符号对象，否则返回空
       *
       */
    }, {
      key: "getAt",
      value: function getAt(index) {
        return new _Symbol(this._SymbolGroup.getAt(index));
      }
      /**
       * 通过ID移除符号对象
       * @param {Number} id -符号ID
       *
       * @memberOf SymbolGroup#
       */
    }, {
      key: "removeByID",
      value: function removeByID(id) {
        this._SymbolGroup.removeByID(id);
      }
      /**
       * 根据符号组的索引号移除符号对象
       * @param {Number} index -索引号
       *
       * @memberOf SymbolGroup#
       */
    }, {
      key: "removeAt",
      value: function removeAt(index) {
        this._SymbolGroup.removeAt(index);
      }
      /**
       * 移除所有的符号对象
       * @memberOf SymbolGroup#
       */
    }, {
      key: "removeAll",
      value: function removeAll() {
        this._SymbolGroup.removeAll();
      }
    }]);
    return SymbolGroup;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 符号库操作函数（id:1~100,内部资源ID请勿使用）
   * @name SymbolLib
   */
  var SymbolLib = /*#__PURE__*/function () {
    function SymbolLib(handle) {
      _classCallCheck(this, SymbolLib);
      _defineProperty(this, "_SymbolLib", void 0);
      // if (options == null) {
      //     //this._SymbolLib = new PIESymbolLib();
      // } else {
      //     if (options.handle != null) {
      //         this._SymbolLib = options.handle;
      //     } else {
      //         //this._SymbolLib = new PIESymbolLib();
      //     }
      // }
      if (handle != null) {
        this._SymbolLib = handle;
      } else {
        //this._SymbolLib = new PIESymbolLib();
        DeveloperError$1.throwInstantiationError();
      }
    }

    // /**
    //  * 打开符号库
    //  * @param {String} path -符号库路径
    //  *
    //  * @memberOf SymbolLib#
    //  * @returns {Boolean} 打开成功返回true，失败返回false
    //  */
    _createClass(SymbolLib, [{
      key: "open",
      value: function open(path) {
        return this._SymbolLib.open(path);
      }
      // /**
      //  * 关闭符号库
      //  *
      //  * @memberOf SymbolLib#
      //  * @returns {Boolean} 关闭成功返回true，失败返回false
      //  */
    }, {
      key: "close",
      value: function close() {
        return this._SymbolLib.close();
      }
      /**
       * 获取符号组对象
       * @param {PIESymbolGroupType} groupType -符号组类型
       *
       * @memberOf SymbolLib#
       * @returns {SymbolGroup} 如果获取成功，返回符号组,获取失败返回NULL
       */
    }, {
      key: "getGroup",
      value: function getGroup(groupType) {
        var group = this._SymbolLib.getGroup(groupType);
        return new SymbolGroup(group);
      }
    }]);
    return SymbolLib;
  }();

  // import SymbolGroup from '../Symbol/SymbolGroup.js';
  // import SymbolGroupType from '../Symbol/SymbolGroupType.js'
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */

  /**
   * @class Viewer
   * 场景视图容器操作函数
   */
  var Viewer = /*#__PURE__*/function () {
    // event;

    /**
     * 创建场景视图容器
     * @param {Element | String} container 
     * @param {Object} options
     * @param {String} options.canvas 画布(必填)
     * @param {Boolean} options.cameraSmooth <code>optional</code> 是否需要相机缓冲效果(默认为false)
     * @param {DimensionMode} options.dimensionMode <code>optional</code> 维度模式(DimensionMode.D3D)
     * @param {PIESceneMode} options.sceneMode <code>optional</code> 场景模式(默认为SceneMode.Sphere)
     * @param {Boolean} options.autoProjection <code>optional</code> 是否自动转换地图投影(默认为true)
     * @param {Array} options.center <code>optional</code> 中心点 默认值（116.4, 39.9）
     * @param {Number} options.zoom <code>optional</code> 缩放层级(0-22)
     * @param {Number} options.scale <code>optional</code> 比例尺
     * @param {TerrainProvider} options.terrainProvider <code>optional</code> 要使用的地形
     * @param {UrlTemplateImageryProvider} options.imageryProvider <code>optional</code> 要使用的影像
     * @param {ImageryLayerCollection} options.imageryLayers <code>optional</code> 影像图层
     * @param {Layer3DCollection} options.layer3Ds <code>optional</code> 3D图层
     * @param {VectorTileLayerCollection} options.vectorTileLayers <code>optional</code> 矢量瓦片图层
     * @example
     * const viewer = new Earth.Viewer('earthContainer', {
            sceneMode: Earth.SceneMode.SCENE3D, //Earth.SceneMode.SCENE2D
            center: [102.7219, 30.8161], //初始中心点
            zoom: 4, //初始层级
            cameraSmooth: false, //是否开启相机缓冲效果
            imageryProvider: new Earth.UrlTemplateImageryProvider({
              url:
                'https://webst03.is.autonavi.com/appmaptile?style=6&z={z}&y={y}&x={x}',
            }),
            terrainProvider: new Earth.EngineTerrainProvider({
              url:
                'https://pie-engine-test.s3.cn-northwest-1.amazonaws.com.cn/earthdata/mapdata/sichuandem/_alllayers/{z}/{y}/{x}.terrain',
            }),
          });
     */
    function Viewer(container, options) {
      var _sceneMode,
        _options$center,
        _options$zoom,
        _options$cameraSmooth,
        _options$imageryProvi,
        _this = this;
      _classCallCheck(this, Viewer);
      _defineProperty(this, "_entities", void 0);
      _defineProperty(this, "_dataSources", void 0);
      _defineProperty(this, "_terrainProvider", void 0);
      _defineProperty(this, "terrianLayerProvider", void 0);
      _defineProperty(this, "imageLayerProvider", void 0);
      _defineProperty(this, "_imageryLayers", void 0);
      _defineProperty(this, "_layer3Ds", void 0);
      _defineProperty(this, "_vectorTileLayers", void 0);
      _defineProperty(this, "_viewer", void 0);
      _defineProperty(this, "_pieGlobe", void 0);
      _defineProperty(this, "_pieGlobeControl", void 0);
      _defineProperty(this, "_globe", void 0);
      _defineProperty(this, "_scene", void 0);
      _defineProperty(this, "_camera", void 0);
      _defineProperty(this, "container", void 0);
      _defineProperty(this, "shadows", void 0);
      _defineProperty(this, "_screenSpaceEventHandler", void 0);
      _defineProperty(this, "_symbolLib", void 0);
      _defineProperty(this, "_isDestroyed", void 0);
      if (!defined$1(container)) {
        throw new DeveloperError$1('container is required.');
      }
      if (typeof container === 'string') {
        var foundElement = document.getElementById(container);
        if (foundElement === null) {
          throw new DeveloperError$1("Element with id \"".concat(container, "\" does not exist in the document."));
        }
        container = foundElement;
      }
      this.container = container;
      options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
      var sceneMode = options.sceneMode;
      sceneMode = (_sceneMode = sceneMode) !== null && _sceneMode !== void 0 ? _sceneMode : SceneMode$1.SCENE3D;
      var viewer = new PIEGlobeViewer({
        autoProjection: options.autoProjection,
        center: (_options$center = options.center) !== null && _options$center !== void 0 ? _options$center : [102.7219, 30.8161],
        sceneMode: sceneMode === SceneMode$1.SCENE3D ? PIESceneMode.Sphere : PIESceneMode.Plane,
        dimensionMode: PIEDimensionMode.D3D,
        //不开放D2D
        zoom: (_options$zoom = options.zoom) !== null && _options$zoom !== void 0 ? _options$zoom : 4,
        scale: options.scale,
        webgl2: true,
        //体积云需要webgl2支持
        //   rasterDataSource: {
        //     server:
        //       'https://webst03.is.autonavi.com/appmaptile?style=6&z={z}&y={y}&x={x}',
        //     alias: 'initImageryLayer',
        //   }, //影像瓦片数据源地址

        // rasterDataSource: {
        //   server:
        //     "https://t4.tianditu.gov.cn/img_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}&tk=26049619cf625385e5d593271fc5b895",
        //   alias: "worldimage",
        //   epsg: 4490,
        //   // levelOffset: -1,
        // },
        visibleGlobeImage: true,
        canvas: container.id,
        cameraSmooth: (_options$cameraSmooth = options.cameraSmooth) !== null && _options$cameraSmooth !== void 0 ? _options$cameraSmooth : false,
        useRenderLoop: false //不使用Earth内部渲染循环
      });

      this._isDestroyed = false;
      var pieGlobeControl = viewer.getGlobeControl();
      var pieGlobe = pieGlobeControl.getGlobe(); //获取场景
      this._pieGlobe = pieGlobe;
      this._pieGlobeControl = pieGlobeControl;
      this._viewer = viewer;
      // window.viewer = viewer;
      window.globe = pieGlobe;
      // window.globeControl = globeControl;

      this._terrainProvider = options.terrainProvider || new EllipsoidTerrainProvider();
      this._terrainProvider.pieGlobe = pieGlobe;

      //顺序:影像图层>>3D图层>>矢量瓦片图层>>数据源图层>>实体图层
      this._imageryLayers = options.imageryLayers || new ImageryLayerCollection();
      this._imageryLayers.pieGlobe = pieGlobe;
      this._layer3Ds = options.layer3Ds || new Layer3DCollection();
      this._layer3Ds.pieGlobe = pieGlobe;
      this._vectorTileLayers = options.vectorTileLayers || new VectorTileLayerCollection();
      this._vectorTileLayers.pieGlobe = pieGlobe;
      this._dataSources = new DataSourceCollection();
      this._dataSources.pieGlobe = pieGlobe;
      this._dataSources.pieGlobeControl = pieGlobeControl;
      this._threeViewer = this.initThreeViewer();
      this._entities = new EntityCollection({
        camera: this._threeViewer.camera,
        threeLayer: this._threeViewer.threeLayer
      });
      this._entities.pieGlobe = pieGlobe;
      this._entities.pieGlobeControl = pieGlobeControl;
      //给dataSources赋值
      this._dataSources.threeLayer = this._threeViewer.threeLayer;
      this._dataSources.camera = this._threeViewer.camera;
      this._webLayer = [];
      this._entities.initWebLayer(this._webLayer);
      this._scene = new Scene();
      this._scene._mode = sceneMode;
      this._scene.pieGlobe = pieGlobe;
      this._scene.pieGlobeControl = pieGlobeControl;
      this._scene._entities = this._entities;
      this._scene._threeCamera = this._threeViewer._camera;
      this._scene.primitives = this._threeViewer.threeLayer;

      // const eventListener = () => {
      //   update();
      // };
      // this._pieGlobeControl.getPreRender().addEventListener(eventListener);
      this._screenSpaceEventHandler = new ScreenSpaceEventHandler(container);

      //添加默认影像图层
      this.imageryLayers.addImageryProvider((_options$imageryProvi = options.imageryProvider) !== null && _options$imageryProvi !== void 0 ? _options$imageryProvi : new UrlTemplateImageryProvider({
        url: 'https://webst03.is.autonavi.com/appmaptile?style=6&z={z}&y={y}&x={x}'
      }));
      this._symbolLib = new SymbolLib(pieGlobe.getDocument().getSymbolLib());
      this._isRender = true;
      this._render = function () {
        if (!_this._isRender) {
          return;
        }
        //threeViewer刷新
        _this._threeViewer.update();
        //tween.js刷新
        update();
        //webUi刷新
        _this._webLayer.forEach(function (ele) {
          ele.update();
        });
        requestAnimationFrame(_this._render);
      };
      this._render();
    }
    _createClass(Viewer, [{
      key: "initThreeViewer",
      value: function initThreeViewer() {
        return new ThreeViewer(this._pieGlobeControl);
      }
    }, {
      key: "postProcessStages",
      get: function get() {
        return this._threeViewer.postProcessStageCollection;
      }

      // set entities () {

      // }
    }, {
      key: "entities",
      get: function get() {
        return this._entities;
      }
      /**
       * 获取数据源图层
       * @memberof Viewer
       * @return {DataSourceCollection} 返回DataSource实例集
       */
    }, {
      key: "dataSources",
      get: function get() {
        return this._dataSources;
      }
      /**
       * 设置数据源图层
       * @param {DataSourceCollection} value
       * @memberof Viewer
       */,
      set: function set(value) {
        value.pieGlobe = this._pieGlobe;
        this._dataSources = value;
      }
      /**
       * 获取3D图层
       * @memberof Viewer
       * @return {Layer3DCollection} 返回3D图层
       */
    }, {
      key: "layer3Ds",
      get: function get() {
        return this._layer3Ds;
      }
      /**
       * 设置3D图层
       * @param {Layer3DCollection} value
       * @memberof Viewer
       */,
      set: function set(value) {
        value.pieGlobe = this._pieGlobe;
        this._layer3Ds = value;
      }
      /**
       * 获取地形
       * @memberof Viewer
       * @return {EllipsoidTerrainProvider} 返回椭球体地形
       */
    }, {
      key: "terrainProvider",
      get: function get() {
        return this._terrainProvider;
      }
      /**
       * 设置地形
       * @param {EllipsoidTerrainProvider} TerrainProvider
       * @memberof Viewer
       */,
      set: function set(TerrainProvider) {
        this._terrainProvider = TerrainProvider;
        this._terrainProvider.pieGlobe = this._pieGlobe;
      }
      /**
       * 获取影像图层
       * @memberof Viewer
       * @return {ImageryLayerCollection} 返回影像图层
       */
    }, {
      key: "imageryLayers",
      get: function get() {
        return this._imageryLayers;
      }
      /**
       * 获取矢量瓦片图层
       * @memberof Viewer
       * @return {VectorTileLayerCollection} 返回矢量瓦片图层
       */
    }, {
      key: "vectorTileLayers",
      get: function get() {
        return this._vectorTileLayers;
      }
      /**
       * 获取用户输入事件
       * @memberof Viewer
       * @return {ScreenSpaceEventHandler} 返回用户输入事件
       */
    }, {
      key: "screenSpaceEventHandler",
      get: function get() {
        return this._screenSpaceEventHandler;
      }

      /**
       * 获取场景
       * @memberof Viewer
       * @return {Scene} 返回场景
       */
    }, {
      key: "scene",
      get: function get() {
        return this._scene;
      }

      /**
       * 获取三维场景
       * @memberof Viewer
       * @return {Globe} 返回三维场景
       */
    }, {
      key: "globe",
      get: function get() {
        return this.scene.globe;
      }

      /**
       * 获取三维相机
       * @memberof Viewer
       * @return {Camera} 返回三维场景
       */
    }, {
      key: "camera",
      get: function get() {
        return this.scene.camera;
      }

      /**
       * 获取符号库
       * @memberof Viewer
       * @return {SymbolLib} 返回符号库
       */
    }, {
      key: "symbolLib",
      get: function get() {
        return this._symbolLib;
      }

      /**
       * 获取canvas
       * @memberof Viewer
       * @return {HTMLCanvasElement} 返回地图canvas
       */
    }, {
      key: "canvas",
      get: function get() {
        return this._pieGlobeControl.canvas;
      }
      /**
       * 将相机移到提供的一个或多个实体或数据源
       * @memberof Viewer
       * @param {Entity | Array.< Entity > | EntityCollection | DataSource | ImageryLayer } target
       * @param {Object} options
       */
    }, {
      key: "flyTo",
      value: function flyTo(target, options) {
        options = defaultValue$1(options, {});
        if (target instanceof Entity) {
          if (defined$1(target.position)) {
            //飞到点
            this.camera.flyTo({
              destination: target.position,
              duration: defaultValue$1(options.duration, 3.0)
            });
          }
        }
      }
    }, {
      key: "zoomTo",
      value: function zoomTo() {}
      /**
       * 调整窗口小部件的大小以匹配容器的大小。除非将 useDefaultRenderLoop 设置为 false，否则将自动根据需要调用此函数。
       */
    }, {
      key: "resize",
      value: function resize() {
        this._pieGlobeControl.onSize();
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._viewer.dispose();
        this._isRender = false;
        cancelAnimationFrame(this._render);
        // this._threeViewer.dispose();
      }
      /**
       * 销毁小部件。如果永久从布局中移除小部件，则应调用此方法。
       */
    }, {
      key: "destroy",
      value: function destroy() {
        this._viewer.dispose();
        this._isRender = false;
        cancelAnimationFrame(this._render);
        this._isDestroyed = true;
      }
      /**
       * 对象是否销毁
       * @returns {Boolean} 如果对象已销毁，则为true，否则为false。
       */
    }, {
      key: "isDestroyed",
      value: function isDestroyed() {
        return this._isDestroyed;
      }
    }]);
    return Viewer;
  }();

  var EngineTerrainProvider = /*#__PURE__*/function (_TerrainProvider) {
    _inherits(EngineTerrainProvider, _TerrainProvider);
    var _super = _createSuper(EngineTerrainProvider);
    function EngineTerrainProvider(options) {
      var _this;
      _classCallCheck(this, EngineTerrainProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_pieGlobe", void 0);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      _this._options = options;
      return _this;
    }
    _createClass(EngineTerrainProvider, [{
      key: "pieGlobe",
      get: function get() {
        return this._pieGlobe;
      },
      set: function set(pieGlobe) {
        this._pieGlobe = pieGlobe;
        var dataSource, globeElevationLayer;
        var workspace = this._pieGlobe.getDocument();
        var globeModel = this._pieGlobe.getGlobeModel();
        if (this._options && this._options.url) {
          dataSource = new PIEMapTerrainDataSource();
          dataSource.create({
            alias: 'terrain',
            server: this._options.url,
            levelOffset: this._options.levelOffset || 0,
            epsg: this._options.epsg || 3857,
            tms: this._options.tms || false
          });
          globeElevationLayer = new PIEGlobeElevationLayer();
          globeElevationLayer.setDataSource(dataSource);
        }
        dataSource && workspace.getDataSourceManager().addDataSource(dataSource);
        globeModel.removeAllLayers(); // cesium仅添加一个地形
        globeElevationLayer && globeModel.addLayer(globeElevationLayer, true);
        this._pieGlobe.refresh(false, false);
      }
    }]);
    return EngineTerrainProvider;
  }(TerrainProvider);

  var ShpDataSource = /*#__PURE__*/function (_FeatureDataSource) {
    _inherits(ShpDataSource, _FeatureDataSource);
    var _super = _createSuper(ShpDataSource);
    function ShpDataSource() {
      var _this;
      _classCallCheck(this, ShpDataSource);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_symbol", void 0);
      return _this;
    }
    _createClass(ShpDataSource, [{
      key: "load",
      value: function load(data, options) {
        var _this2 = this;
        if (!defined$1(data)) {
          throw new DeveloperError$1('data is required.');
        }
        return new Promise(function (reslove, reject) {
          options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
          var renderer = defaultValue$1(options.renderer, new SimpleFeatureRenderer());
          var style = defaultValue$1(options.style, null);
          var shpOptions = {
            url: data
          };
          var vectorStyleOPtions = {
            fillColor: defaultValue$1(getColorToBytes(options.fill), [0, 0, 255, 255]),
            lineColor: defaultValue$1(getColorToBytes(options.stroke), [0, 0, 255, 255]),
            lineWidth: defaultValue$1(options.strokeWidth, 1),
            pointType: defaultValue$1(options.markerType, PIEPointType.Null),
            pointStyle: defaultValue$1(options.markerSymbol, null),
            // 待判断赋值
            pointSize: defaultValue$1(options.markerSize ? [options.markerSize.x, options.markerSize.y] : null, [50, 50]),
            pointColor: defaultValue$1(getColorToBytes(options.markerColor), [255, 0, 0, 255]),
            pointAlign: defaultValue$1(options.markerAlign, PointAlignType$1.Center),
            altitudeMode: options.altitudeMode,
            classifyMode: options.classifyMode
          };
          var dataSource = new PIEShpDataSource$1();
          dataSource.load(shpOptions).then( /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value) {
              var iconSymbol, vectorStyle_s, symbolStyle, vectorStyle_c, featureLayer;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!(value.getDataset().getType() === PIEDatasetType.Point)) {
                      _context.next = 11;
                      break;
                    }
                    if (!(options.markerType === PIEPointType.Icon)) {
                      _context.next = 11;
                      break;
                    }
                    if (!options.markerSymbol) {
                      _context.next = 10;
                      break;
                    }
                    vectorStyleOPtions.pointStyle = options.markerSymbol.id;
                    iconSymbol = new PIEIconSymbol();
                    _context.next = 7;
                    return iconSymbol.load(options.markerSymbol);
                  case 7:
                    _this2._symbol = _context.sent;
                    _context.next = 11;
                    break;
                  case 10:
                    throw new DeveloperError$1('markerSymbol is required.');
                  case 11:
                    _context.t0 = renderer.type;
                    _context.next = _context.t0 === FeatureRenderType$1.Null ? 14 : _context.t0 === FeatureRenderType$1.Simple ? 15 : _context.t0 === FeatureRenderType$1.ThemeRange ? 18 : _context.t0 === FeatureRenderType$1.ThemeLabel ? 19 : _context.t0 === FeatureRenderType$1.ThemeUnique ? 23 : _context.t0 === FeatureRenderType$1.Classify ? 24 : _context.t0 === FeatureRenderType$1.SMS ? 27 : _context.t0 === FeatureRenderType$1.Seamap ? 28 : 29;
                    break;
                  case 14:
                    return _context.abrupt("break", 30);
                  case 15:
                    // 简单矢量渲染器
                    vectorStyle_s = new PIEVectorStyle(vectorStyleOPtions);
                    renderer.handle.setStyle(vectorStyle_s);
                    return _context.abrupt("break", 30);
                  case 18:
                    return _context.abrupt("break", 30);
                  case 19:
                    // 标签专题图
                    symbolStyle = new PIESymbolStyle();
                    symbolStyle.setTextStyle(style.handle);
                    renderer.handle.setStyle(symbolStyle);
                    return _context.abrupt("break", 30);
                  case 23:
                    return _context.abrupt("break", 30);
                  case 24:
                    // 分类渲染器
                    vectorStyle_c = new PIEVectorStyle(vectorStyleOPtions);
                    renderer.handle.setStyle(vectorStyle_c);
                    return _context.abrupt("break", 30);
                  case 27:
                    return _context.abrupt("break", 30);
                  case 28:
                    return _context.abrupt("break", 30);
                  case 29:
                    return _context.abrupt("break", 30);
                  case 30:
                    featureLayer = new PIEGlobeFeatureLayer();
                    featureLayer.setRenderer(renderer.handle);
                    _this2._source = value;
                    _this2._layer = featureLayer;
                    reslove(_this2);
                  case 35:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x) {
              return _ref.apply(this, arguments);
            };
          }());
        });
      }
    }], [{
      key: "load",
      value: function load(data, options) {
        return new ShpDataSource().load(data, options);
      }
    }]);
    return ShpDataSource;
  }(FeatureDataSource);
  function getColorToBytes(value) {
    if (value) {
      return value.toBytes();
    }
    return null;
  }

  var SMSDataSource = /*#__PURE__*/function (_FeatureDataSource) {
    _inherits(SMSDataSource, _FeatureDataSource);
    var _super = _createSuper(SMSDataSource);
    function SMSDataSource() {
      _classCallCheck(this, SMSDataSource);
      return _super.call(this);
    }
    _createClass(SMSDataSource, [{
      key: "load",
      value: function load(data, options) {
        if (!defined$1(data)) {
          throw new DeveloperError$1('data is required.');
        }
        var that = this;
        return new Promise(function (reslove, reject) {
          var dataSource = new PIESMSDataSource();
          var featureMapLayer = new PIEGlobeFeatureMapLayer();
          var smsOptions = {
            SMSUrl: data.SMSUrl,
            filters: data.filters
          };
          dataSource.load(smsOptions).then(function (value) {
            var count = dataSource.getDatasetCount();
            for (var i = 0; i < count; ++i) {
              var dataset = dataSource.getDatasetAt(i);
              var featureLayer = new PIEGlobeFeatureLayer();
              featureLayer.setDataset(dataset);
              var smsRender = new PIESMSFeatureRenderer();
              smsRender.makeDefault(dataset);
              featureLayer.setRenderer(smsRender);
              featureMapLayer.addLayer(featureLayer, true);
            }
            that._source = value;
            that._layer = featureMapLayer;
            reslove(that);
          });
        });
      }
    }], [{
      key: "load",
      value: function load(data, options) {
        return new SMSDataSource().load(data, options);
      }
    }]);
    return SMSDataSource;
  }(FeatureDataSource);

  var FieldInfo = /*#__PURE__*/function () {
    function FieldInfo(options) {
      _classCallCheck(this, FieldInfo);
      _defineProperty(this, "_pieFieldInfo", void 0);
      if (options.handle != null) {
        this._pieFieldInfo = options.handle;
      } else {
        this._pieFieldInfo = new PIEFieldInfo(options);
      }
      if (options.isSystem != null) {
        this.IsSystem = options.isSystem;
      }
      if (options.isRequired != null) {
        this.IsRequired = options.isRequired;
      }
      if (options.type != null) {
        this.FieldType = options.type;
      }
      if (options.size != null) {
        this.FieldSize = options.size;
      }
      if (options.name != null) {
        this.FieldName = options.name;
      }
      if (options.alias != null) {
        this.ForeignName = options.alias;
      }
      if (options.defaultValue != null) {
        this.DefaultValue = options.defaultValue;
      }
    }
    _createClass(FieldInfo, [{
      key: "handle",
      get: function get() {
        return this._pieFieldInfo;
      }
    }, {
      key: "isSystem",
      get: function get() {
        return this._pieFieldInfo.getIsSystem();
      },
      set: function set(value) {
        this._pieFieldInfo.setIsSystem(value);
      }
    }, {
      key: "setIsSystem",
      value: function setIsSystem(value) {
        this._pieFieldInfo.setIsSystem(value);
      }
    }, {
      key: "isRequired",
      get: function get() {
        return this._pieFieldInfo.getIsRequired();
      },
      set: function set(value) {
        this._pieFieldInfo.setIsRequired(value);
      }
    }, {
      key: "setIsRequired",
      value: function setIsRequired(value) {
        this._pieFieldInfo.setIsRequired(value);
      }
    }, {
      key: "fieldType",
      get: function get() {
        return this._pieFieldInfo.getFieldType();
      },
      set: function set(value) {
        this._pieFieldInfo.setFieldType(value);
      }
    }, {
      key: "setFieldType",
      value: function setFieldType(value) {
        this._pieFieldInfo.setFieldType(value);
      }
    }, {
      key: "fieldSize",
      get: function get() {
        return this._pieFieldInfo.getFieldSize();
      },
      set: function set(value) {
        this._pieFieldInfo.setFieldType(value);
      }
    }, {
      key: "setFieldSize",
      value: function setFieldSize(value) {
        this._pieFieldInfo.setFieldType(value);
      }
    }, {
      key: "fieldName",
      get: function get() {
        return this._pieFieldInfo.getFieldName();
      },
      set: function set(value) {
        this._pieFieldInfo.setFieldName(value);
      }
    }, {
      key: "setFieldName",
      value: function setFieldName(value) {
        this._pieFieldInfo.setFieldName(value);
      }
    }, {
      key: "foreignName",
      get: function get() {
        return this._pieFieldInfo.getForeignName();
      },
      set: function set(value) {
        this._pieFieldInfo.ForeignName(value);
      }
    }, {
      key: "setForeignName",
      value: function setForeignName(value) {
        this._pieFieldInfo.ForeignName(value);
      }
    }, {
      key: "defaultValue",
      get: function get() {
        return this._pieFieldInfo.getDefaultValue();
      },
      set: function set(value) {
        this._pieFieldInfo.setDefaultValue(value);
      }
    }, {
      key: "setDefaultValue",
      value: function setDefaultValue(value) {
        this._pieFieldInfo.setDefaultValue(value);
      }
    }]);
    return FieldInfo;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class Feature
   * 几何要素类操作函数
   */
  var Feature = /*#__PURE__*/function () {
    function Feature(options) {
      _classCallCheck(this, Feature);
      _defineProperty(this, "_pieFeature", void 0);
      if (options && options.handle != null) {
        this._pieFeature = options.handle;
      } else {
        this._pieFeature = new PIEFeature();
      }
    }
    _createClass(Feature, [{
      key: "handle",
      get: function get() {
        return this._pieFeature;
      }
    }, {
      key: "feature",
      get: function get() {
        return this._pieFeature;
      },
      set: function set(value) {
        this._pieFeature = value;
      }
    }, {
      key: "ID",
      get: function get() {
        return this._pieFeature.getId();
      },
      set: function set(value) {
        this._pieFeature.setId(value);
      }
    }, {
      key: "geometry",
      get: function get() {
        var geometry = this._pieFeature.getGeometry();
        return GeometryFactory.CreateInstance(geometry);
      },
      set: function set(value) {
        this._pieFeature.setGeometry(value.handle);
      }
    }, {
      key: "isAutoReleaseGeometry",
      get: function get() {
        return this._pieFeature.isAutoReleaseGeometry();
      },
      set: function set(value) {
        this._pieFeature.setAutoReleaseGeometry(value);
      }
    }, {
      key: "charset",
      get: function get() {
        return this._pieFeature.getCharset();
      },
      set: function set(value) {
        return this._pieFeature.setCharset(value);
      }
    }, {
      key: "addField",
      value: function addField(fieldInfo) {
        this._pieFeature.addField(fieldInfo._pieFieldInfo);
      }
    }, {
      key: "getBoolAt",
      value: function getBoolAt(fieldIndex) {
        return this._pieFeature.getBoolAt(fieldIndex);
      }
    }, {
      key: "setBoolAt",
      value: function setBoolAt(fieldIndex, value) {
        this._pieFeature.setBoolAt(fieldIndex, value);
      }
    }, {
      key: "getBool",
      value: function getBool(fieldName) {
        return this._pieFeature.getBool(fieldName);
      }
    }, {
      key: "setBool",
      value: function setBool(fieldName, value) {
        this._pieFeature.setBool(fieldName, value);
      }
    }, {
      key: "getByteAt",
      value: function getByteAt(fieldIndex) {
        return this._pieFeature.getByteAt(fieldIndex);
      }
    }, {
      key: "setByteAt",
      value: function setByteAt(fieldIndex, value) {
        this._pieFeature.setByteAt(fieldIndex, value);
      }
    }, {
      key: "getByte",
      value: function getByte(fieldName) {
        return this._pieFeature.getByte(fieldName);
      }
    }, {
      key: "setByte",
      value: function setByte(fieldName, value) {
        this._pieFeature.setByte(fieldName, value);
      }
    }, {
      key: "getINT16At",
      value: function getINT16At(fieldIndex) {
        return this._pieFeature.getINT16At(fieldIndex);
      }
    }, {
      key: "setINT16At",
      value: function setINT16At(fieldIndex, value) {
        this._pieFeature.setINT16At(fieldIndex, value);
      }
    }, {
      key: "getINT16",
      value: function getINT16(fieldName) {
        return this._pieFeature.getINT16(fieldName);
      }
    }, {
      key: "setINT16",
      value: function setINT16(fieldName, value) {
        this._pieFeature.setINT16(fieldName, value);
      }
    }, {
      key: "getINT32At",
      value: function getINT32At(fieldIndex) {
        return this._pieFeature.getINT32At(fieldIndex);
      }
    }, {
      key: "setINT32At",
      value: function setINT32At(fieldIndex, value) {
        this._pieFeature.setINT32At(fieldIndex, value);
      }
    }, {
      key: "getINT32",
      value: function getINT32(fieldName) {
        return this._pieFeature.getINT32(fieldName);
      }
    }, {
      key: "setINT32",
      value: function setINT32(fieldName, value) {
        this._pieFeature.setINT32(fieldName, value);
      }
    }, {
      key: "getINT64At",
      value: function getINT64At(fieldIndex) {
        return this._pieFeature.getINT64At(fieldIndex);
      }
    }, {
      key: "setINT64At",
      value: function setINT64At(fieldIndex, value) {
        this._pieFeature.setINT64At(fieldIndex, value);
      }
    }, {
      key: "getINT64",
      value: function getINT64(fieldName) {
        return this._pieFeature.getINT64(fieldName);
      }
    }, {
      key: "setINT64",
      value: function setINT64(fieldName, value) {
        this._pieFeature.setINT64(fieldName, value);
      }
    }, {
      key: "getFloatAt",
      value: function getFloatAt(fieldIndex) {
        return this._pieFeature.getFloatAt(fieldIndex);
      }
    }, {
      key: "setFloatAt",
      value: function setFloatAt(fieldIndex, value) {
        this._pieFeature.setFloatAt(fieldIndex, value);
      }
    }, {
      key: "getFloat",
      value: function getFloat(fieldName) {
        return this._pieFeature.getFloat(fieldName);
      }
    }, {
      key: "setFloat",
      value: function setFloat(fieldName, value) {
        this._pieFeature.setFloat(fieldName, value);
      }
    }, {
      key: "getDoubleAt",
      value: function getDoubleAt(fieldIndex) {
        return this._pieFeature.getDoubleAt(fieldIndex);
      }
    }, {
      key: "setDoubleAt",
      value: function setDoubleAt(fieldIndex, value) {
        this._pieFeature.setDoubleAt(fieldIndex, value);
      }
    }, {
      key: "getDouble",
      value: function getDouble(fieldName) {
        return this._pieFeature.getDouble(fieldName);
      }
    }, {
      key: "setDouble",
      value: function setDouble(fieldName, value) {
        this._pieFeature.setDouble(fieldName, value);
      }
    }, {
      key: "getTimeAt",
      value: function getTimeAt(fieldIndex) {
        return this._pieFeature.getTimeAt(fieldIndex);
      }
    }, {
      key: "setTimeAt",
      value: function setTimeAt(fieldIndex, value) {
        this._pieFeature.setTimeAt(fieldIndex, value);
      }
    }, {
      key: "getTime",
      value: function getTime(fieldName) {
        return this._pieFeature.getTime(fieldName);
      }
    }, {
      key: "setTime",
      value: function setTime(fieldName, value) {
        this._pieFeature.setTime(fieldName, value);
      }
    }, {
      key: "getDateAt",
      value: function getDateAt(fieldIndex) {
        return this._pieFeature.getDateAt(fieldIndex);
      }
    }, {
      key: "setDateAt",
      value: function setDateAt(fieldIndex, value) {
        this._pieFeature.setDateAt(fieldIndex, value);
      }
    }, {
      key: "getDate",
      value: function getDate(fieldName) {
        return this._pieFeature.getDate(fieldName);
      }
    }, {
      key: "setDate",
      value: function setDate(fieldName, value) {
        this._pieFeature.setDate(fieldName, value);
      }
    }, {
      key: "getBinaryAt",
      value: function getBinaryAt(fieldIndex) {
        return this._pieFeature.getBinaryAt(fieldIndex);
      }
    }, {
      key: "setBinaryAt",
      value: function setBinaryAt(fieldIndex, value) {
        this._pieFeature.setBinaryAt(fieldIndex, value);
      }
    }, {
      key: "getBinary",
      value: function getBinary(fieldName) {
        return this._pieFeature.getBinary(fieldName);
      }
    }, {
      key: "setBinary",
      value: function setBinary(fieldName, value) {
        this._pieFeature.setBinary(fieldName, value);
      }
    }, {
      key: "getStringAt",
      value: function getStringAt(fieldIndex) {
        return this._pieFeature.getStringAt(fieldIndex);
      }
    }, {
      key: "setStringAt",
      value: function setStringAt(fieldIndex, value) {
        this._pieFeature.setStringAt(fieldIndex, value);
      }
    }, {
      key: "getString",
      value: function getString(fieldName) {
        return this._pieFeature.getString(fieldName);
      }
    }, {
      key: "setString",
      value: function setString(fieldName, value) {
        this._pieFeature.setString(fieldName, value);
      }
    }, {
      key: "getFieldCount",
      value: function getFieldCount() {
        return this._pieFeature.getFieldCount();
      }
    }, {
      key: "getFieldInfoAt",
      value: function getFieldInfoAt(index) {
        var handle = this._pieFeature.getFieldInfoAt(index);
        return new FieldInfo({
          handle: handle
        });
      }
    }, {
      key: "toGeoJSON",
      value: function toGeoJSON(spatialReference) {
        var properties = {};
        var fieldCount = this._pieFeature.getFieldCount();
        for (var i = 0; i < fieldCount; i++) {
          var fieldInfo = this._pieFeature.getFieldInfoAt(i);
          var name = fieldInfo.getFieldName();
          var value = "";
          if (fieldInfo.getFieldType() == FieldType$1.INT16) {
            value = this._pieFeature.getINT16(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.INT32) {
            value = this._pieFeature.getINT32(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.INT64) {
            value = this._pieFeature.getINT64(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.Text) {
            value = this._pieFeature.getString(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.Float) {
            value = this._pieFeature.getFloat(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.Double) {
            value = this._pieFeature.getDouble(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.Boolean) {
            value = this._pieFeature.getBool(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.Date) {
            value = this._pieFeature.getDate(name);
          } else if (fieldInfo.getFieldType() == FieldType$1.Time) {
            value = this._pieFeature.getTime(name);
          }
          properties[name] = value;
        }
        var geoPoints = [];
        if (this._pieFeature.getGeometry()) {
          var geometry = this._pieFeature.getGeometry();
          if (this._pieFeature.getGeometry().getType() == GeometryType.Point) {
            var point = geometry.getPoint();
            if (spatialReference == null || spatialReference.getType() == SpatialRefType$1.GEOGRAPHIC) {
              geoPoints.push(point.x);
              geoPoints.push(point.y);
            } else {
              var temppoint = spatialReference.inverse(point);
              geoPoints.push(temppoint.x);
              geoPoints.push(temppoint.y);
            }
            return {
              "type": "FeatureCollection",
              "features": [{
                "type": "Feature",
                "properties": properties,
                "geometry": {
                  "type": "Point",
                  "coordinates": geoPoints
                }
              }]
            };
          } else if (this._pieFeature.getGeometry().getType() == GeometryType.Line) {
            var subCount = geometry.getSubCount();
            for (var subIndex = 0; subIndex < subCount; subIndex++) {
              var points = geometry.getPoints(subIndex);
              var subPointCount = geometry.getSubPointCount(subIndex);
              for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
                if (spatialReference == null || spatialReference.getType() == SpatialRefType$1.GEOGRAPHIC) {
                  var Point = [];
                  Point.push(points[numIndex].x);
                  Point.push(points[numIndex].y);
                  geoPoints.push(Point);
                } else {
                  var temppoint = spatialReference.inverse(points[numIndex]);
                  var _Point = [];
                  _Point.push(temppoint.x);
                  _Point.push(temppoint.y);
                  geoPoints.push(_Point);
                }
              }
            }
            return {
              "type": "FeatureCollection",
              "features": [{
                "type": "Feature",
                "properties": properties,
                "geometry": {
                  "type": "LineString",
                  "coordinates": geoPoints
                }
              }]
            };
          } else if (this._pieFeature.getGeometry().getType() == GeometryType.Region) {
            var subCount = geometry.getSubCount();
            var subpoint = [];
            for (var subIndex = 0; subIndex < subCount; subIndex++) {
              var points = geometry.getPoints(subIndex);
              var subPointCount = geometry.getSubPointCount(subIndex);
              for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
                if (spatialReference == null || spatialReference.getType() == SpatialRefType$1.GEOGRAPHIC) {
                  var _Point2 = [];
                  _Point2.push(points[numIndex].x);
                  _Point2.push(points[numIndex].y);
                  subpoint.push(_Point2);
                } else {
                  var temppoint = spatialReference.inverse(points[numIndex]);
                  var _Point3 = [];
                  _Point3.push(temppoint.x);
                  _Point3.push(temppoint.y);
                  subpoint.push(_Point3);
                }
              }
            }
            geoPoints.push(subpoint);
            return {
              "type": "FeatureCollection",
              "features": [{
                "type": "Feature",
                "properties": properties,
                "geometry": {
                  "type": "Polygon",
                  "coordinates": geoPoints
                }
              }]
            };
          }
          if (this._pieFeature.getGeometry().getType() == GeometryType.Point3D) {
            var point = geometry.getPoint();
            if (spatialReference == null || spatialReference.getType() == SpatialRefType$1.GEOGRAPHIC) {
              geoPoints.push(point.x);
              geoPoints.push(point.y);
              geoPoints.push(point.z);
            } else {
              var pointsrc = [];
              pointsrc.push(point.x);
              pointsrc.push(point.y);
              var temppoint = spatialReference.inverse(pointsrc);
              geoPoints.push(temppoint[0]);
              geoPoints.push(temppoint[1]);
              geoPoints.push(point.z);
            }
            return {
              "type": "FeatureCollection",
              "features": [{
                "type": "Feature",
                "properties": properties,
                "geometry": {
                  "type": "Point3D",
                  "coordinates": geoPoints
                }
              }]
            };
          } else if (this._pieFeature.getGeometry().getType() == GeometryType.Line3D) {
            var subCount = geometry.getSubCount();
            for (var subIndex = 0; subIndex < subCount; subIndex++) {
              var points = geometry.getPoints(subIndex);
              var subPointCount = geometry.getSubPointCount(subIndex);
              for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
                if (spatialReference == null || spatialReference.getType() == SpatialRefType$1.GEOGRAPHIC) {
                  var _Point4 = [];
                  _Point4.push(points[numIndex].x);
                  _Point4.push(points[numIndex].y);
                  _Point4.push(points[numIndex].z);
                  geoPoints.push(_Point4);
                } else {
                  var temppoint = spatialReference.inverse(points[numIndex]);
                  var _Point5 = [];
                  _Point5.push(temppoint.x);
                  _Point5.push(temppoint.y);
                  _Point5.push(temppoint.z);
                  geoPoints.push(_Point5);
                }
              }
            }
            return {
              "type": "FeatureCollection",
              "features": [{
                "type": "Feature",
                "properties": properties,
                "geometry": {
                  "type": "LineString3D",
                  "coordinates": geoPoints
                }
              }]
            };
          } else if (this._pieFeature.getGeometry().getType() == GeometryType.Region3D) {
            var subCount = geometry.getSubCount();
            var subpoint = [];
            for (var subIndex = 0; subIndex < subCount; subIndex++) {
              var points = geometry.getPoints(subIndex);
              var subPointCount = geometry.getSubPointCount(subIndex);
              for (var numIndex = 0; numIndex < subPointCount; numIndex++) {
                if (spatialReference == null || spatialReference.getType() == SpatialRefType$1.GEOGRAPHIC) {
                  var _Point6 = [];
                  _Point6.push(points[numIndex].x);
                  _Point6.push(points[numIndex].y);
                  _Point6.push(points[numIndex].z);
                  subpoint.push(_Point6);
                } else {
                  var temppoint = spatialReference.inverse(points[numIndex]);
                  var _Point7 = [];
                  _Point7.push(temppoint.x);
                  _Point7.push(temppoint.y);
                  _Point7.push(temppoint.z);
                  subpoint.push(_Point7);
                }
              }
            }
            geoPoints.push(subpoint);
            return {
              "type": "FeatureCollection",
              "features": [{
                "type": "Feature",
                "properties": properties,
                "geometry": {
                  "type": "Polygon3D",
                  "coordinates": geoPoints
                }
              }]
            };
          } else {
            return {
              "type": "Feature",
              "geometry": {
                "type": "UnKnow"
              }
            };
          }
        } else {
          return null;
        }
      }
    }]);
    return Feature;
  }();

  var FeatureSet = /*#__PURE__*/function () {
    function FeatureSet(options) {
      _classCallCheck(this, FeatureSet);
      _defineProperty(this, "_pieFeatureSet", void 0);
      //DeveloperError.throwInstantiationError();
      if (options != null) {
        if (options.handle != null) {
          this._pieFeatureSet = options.handle;
        }
      }
    }
    _createClass(FeatureSet, [{
      key: "handle",
      get: function get() {
        return this._pieFeatureSet;
      }
    }, {
      key: "isEOF",
      value: function isEOF() {
        return this._pieFeatureSet.isEOF();
      }
    }, {
      key: "moveFirst",
      value: function moveFirst() {
        return this._pieFeatureSet.moveFirst();
      }
    }, {
      key: "moveNext",
      value: function moveNext() {
        return this._pieFeatureSet.moveNext();
      }
    }, {
      key: "moveLast",
      value: function moveLast() {
        return this._pieFeatureSet.moveLast();
      }
    }, {
      key: "moveTo",
      value: function moveTo(value) {
        return this._pieFeatureSet.moveTo(value);
      }
    }, {
      key: "featureCount",
      get: function get() {
        return this._pieFeatureSet.getFeatureCount();
      }
    }, {
      key: "iD",
      get: function get() {
        return this._pieFeatureSet.getID();
      }
    }, {
      key: "geometry",
      get: function get() {
        var geometry = this._pieFeatureSet.getGeometry();
        if (geometry) {
          return GeometryFactory.CreateInstance(geometry);
        }
        return null;
      },
      set: function set(geometry) {
        this._pieFeatureSet.setGeometry(geometry.handle);
      }
    }, {
      key: "addNew",
      value: function addNew(geometry) {
        this._pieFeatureSet.addNew(geometry.handle);
      }
    }, {
      key: "delete",
      value: function _delete() {
        return this._pieFeatureSet["delete"]();
      }
    }, {
      key: "deleteAll",
      value: function deleteAll() {
        return this._pieFeatureSet.deleteAll();
      }
    }, {
      key: "edit",
      value: function edit() {
        return this._pieFeatureSet.edit();
      }
    }, {
      key: "update",
      value: function update() {
        return this._pieFeatureSet.update();
      }
    }, {
      key: "dataset",
      get: function get() {
        var hDataset = this._pieFeatureSet.getDataset();
        return DatasetFactory.CreateInstance(hDataset);
      }
    }, {
      key: "feature",
      get: function get() {
        var handle = this._pieFeatureSet.getFeature();
        return new Feature({
          handle: handle
        });
      }
    }, {
      key: "fieldCount",
      get: function get() {
        return this._pieFeatureSet.getFieldCount();
      }
    }, {
      key: "getFieldValueBool",
      value: function getFieldValueBool(value) {
        return this._pieFeatureSet.getFieldValueBool(value);
      }
    }, {
      key: "setFieldValueBool",
      value: function setFieldValueBool(name, val) {
        return this._pieFeatureSet.setFieldValueBool(name, val);
      }
    }, {
      key: "getFieldValueByte",
      value: function getFieldValueByte(value) {
        return this._pieFeatureSet.getFieldValueByte(value);
      }
    }, {
      key: "setFieldValueByte",
      value: function setFieldValueByte(name, val) {
        return this._pieFeatureSet.setFieldValueByte(name, val);
      }
    }, {
      key: "getFieldValueInt16",
      value: function getFieldValueInt16(name) {
        return this._pieFeatureSet.getFieldValueInt16(name);
      }
    }, {
      key: "setFieldValueInt16",
      value: function setFieldValueInt16(name, val) {
        return this._pieFeatureSet.setFieldValueInt16(name, val);
      }
    }, {
      key: "getFieldValueInt32",
      value: function getFieldValueInt32(name) {
        return this._pieFeatureSet.getFieldValueInt32(name);
      }
    }, {
      key: "setFieldValueInt32",
      value: function setFieldValueInt32(name, val) {
        return this._pieFeatureSet.setFieldValueInt32(name, val);
      }
    }, {
      key: "getFieldValueInt64",
      value: function getFieldValueInt64(name) {
        return this._pieFeatureSet.getFieldValueInt64(name);
      }
    }, {
      key: "setFieldValueInt64",
      value: function setFieldValueInt64(name, val) {
        return this._pieFeatureSet.setFieldValueInt64(name, val);
      }
    }, {
      key: "getFieldValueDouble",
      value: function getFieldValueDouble(name) {
        return this._pieFeatureSet.getFieldValueDouble(name);
      }
    }, {
      key: "setFieldValueDouble",
      value: function setFieldValueDouble(name, val) {
        return this._pieFeatureSet.setFieldValueDouble(name, val);
      }
    }, {
      key: "getFieldValueFloat",
      value: function getFieldValueFloat(name) {
        return this._pieFeatureSet.getFieldValueFloat(name);
      }
    }, {
      key: "setFieldValueFloat",
      value: function setFieldValueFloat(name, val) {
        return this._pieFeatureSet.setFieldValueFloat(name, val);
      }
    }, {
      key: "getFieldValueString",
      value: function getFieldValueString(name, length) {
        return this._pieFeatureSet.getFieldValueString(name, length);
      }
    }, {
      key: "setFieldValueString",
      value: function setFieldValueString(name, val) {
        return this._pieFeatureSet.setFieldValueString(name, val);
      }
      //不可用
    }, {
      key: "fromGeojson",
      value: function fromGeojson(featureDatasetJson) {
        this._pieFeatureSet.fromGeojson(featureDatasetJson);
      }
      //不可用
    }, {
      key: "toGeoJSON",
      value: function toGeoJSON(spatialReference) {
        return this._pieFeatureSet.toGeoJSON(spatialReference.handle);
      }
    }]);
    return FeatureSet;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 字段类型
   * @readonly
   * @enum {number}
   */
  var FieldType = {
    /** 无效的字段类型*/
    UnKnown: 0,
    /**布尔值，单字节，true,false */
    Boolean: 1,
    /**无符号单字节，0-255 */
    Byte: 2,
    /**短整型，2字节 */
    INT16: 3,
    /**长整型，4字节 */
    INT32: 4,
    /**长整型，8字节 */
    INT64: 16,
    /**单精度浮点型，4字节 */
    Float: 6,
    /**双精度浮点型，8字节 */
    Double: 7,
    /**日期型，年、月、日，不带时间 */
    Date: 8,
    /**不定长字符串型 */
    Text: 10,
    /**不定长二进制类型 */
    Binary: 11,
    /**定长字符串型，需指定长度 */
    Char: 18,
    /**时间戳型，年、月、日、小时、分、秒 */
    Time: 23,
    /**宽字节不定长字符串类型 */
    NText: 127,
    /**几何数据类型 */
    Geometry: 128
  };
  var FieldType$1 = Object.freeze(FieldType);

  var Dataset = /*#__PURE__*/function () {
    function Dataset() {
      _classCallCheck(this, Dataset);
      _defineProperty(this, "_dataset", void 0);
    }
    _createClass(Dataset, [{
      key: "handle",
      get: function get() {
        return this._dataset;
      }
    }, {
      key: "open",
      value: function open() {
        return this._dataset.open();
      }
    }, {
      key: "isOpen",
      value: function isOpen() {
        return this._dataset.isOpen();
      }
    }, {
      key: "close",
      value: function close() {
        this._dataset.close();
      }
    }, {
      key: "type",
      get: function get() {
        return this._dataset.getType();
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._dataset.getType();
      }
    }, {
      key: "readOnly",
      get: function get() {
        return this._dataset.isReadOnly();
      }
    }, {
      key: "name",
      get: function get() {
        return this._dataset.getName();
      },
      set: function set(dataSetName) {
        this._dataset.rename(dataSetName);
      }
    }, {
      key: "isVector",
      get: function get() {
        return this._dataset.isVector();
      }
    }, {
      key: "isRaster",
      get: function get() {
        return this._dataset.isRaster();
      }
    }, {
      key: "isTile",
      get: function get() {
        return this._dataset.isTile();
      }
    }, {
      key: "bounds",
      get: function get() {
        var bounds = this._dataset.getBounds();
        return Cartesian4.fromElements(bounds.left, bounds.top, bounds.right, bounds.bottom);
      }
    }, {
      key: "spatialReference",
      get: function get() {
        var spatialReference = this._dataset.getSpatialReference().getHandle();
        return new SpatialReference(spatialReference);
      },
      set: function set(spatialReference) {
        this._dataset.setSpatialReference(spatialReference._SpatialReference);
      }

      // get dataSource() {
      // 	let dataSource = this._dataset.getDataSource();
      // 	return DataSourceFactory.CreateInstance(dataSource);
      // }
    }]);
    return Dataset;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class FeatureDataset
   * 矢量数据集操作函数
   * @extends Dataset
   */
  var FeatureDataset = /*#__PURE__*/function (_Dataset) {
    _inherits(FeatureDataset, _Dataset);
    var _super = _createSuper(FeatureDataset);
    function FeatureDataset(options) {
      var _this;
      _classCallCheck(this, FeatureDataset);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_dataset", void 0);
      if (options != null) {
        if (options.handle != null) {
          _this._dataset = options;
        }
      }
      return _this;
    }
    _createClass(FeatureDataset, [{
      key: "handle",
      get: function get() {
        return this._dataset;
      }
    }, {
      key: "getHandle",
      value: function getHandle() {
        return this._dataset;
      }
    }, {
      key: "type",
      get: function get() {
        return this._dataset.getType();
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._dataset.getType();
      }
      /**
       * 获取数据集中要素对象个数
       * @memberof FeatureDataset
       *
       * @returns {Number} 返回对象个数
       */
    }, {
      key: "getObjectCount",
      value: function getObjectCount() {
        return this._dataset.getObjectCount();
      }
      /**
       * 获取数据集中字段个数
       *
       * @memberOf FeatureDataset#
       * @returns {Number} 返回字段个数
       */
    }, {
      key: "getFieldCount",
      value: function getFieldCount() {
        return this._dataset.getFieldCount();
      }
      /**
       * 根据索引获取数据集字段信息
       * @param {Number} index -字段索引
       * @memberOf FeatureDataset#
       * @returns {PIEFieldInfo} 返回字段信息对象(返回的是目标字段对象的拷贝，使用完成需要调用dispose自行释放，否则会造成内存泄漏)
       */
    }, {
      key: "getFieldInfoAt",
      value: function getFieldInfoAt(index) {
        var handle = this._dataset.getFieldInfoAt(index);
        return new FieldInfo({
          handle: handle
        });
      }
    }, {
      key: "createField",
      value: function createField(field) {
        return this._dataset.createField(field._pieFieldInfo);
      }
    }, {
      key: "deleteField",
      value: function deleteField(name) {
        return this._dataset.deleteField(name);
      }
    }, {
      key: "deleteFieldByIndex",
      value: function deleteFieldByIndex(index) {
        return this._dataset.deleteFieldByIndex(index);
      }
      /**
       * 通过指定ID数组查询要素集
       * @param {Array} IDs -查询时的ID数组
       *
       * @memberOf FeatureDataset#
       * @returns {PIEFeatureSet} 如果查询成功返回要素集对象，否则返回null
       */
    }, {
      key: "queryByIDs",
      value: function queryByIDs(IDs) {
        var handle = this._dataset.queryByIDs(IDs);
        return new FeatureSet({
          handle: handle
        });
      }
      /**
       * 通过属性数据查询条件查询要素集
       * @param {String} filter -属性数据查询条件
       *
       * @memberOf FeatureDataset#
       * @returns {PIEFeatureSet} 如果查询成功返回要素集对象，否则返回null
       */
    }, {
      key: "queryByGeneral",
      value: function queryByGeneral(filter) {
        var handle = this._dataset.queryByGeneral(filter);
        return new FeatureSet({
          handle: handle
        });
      }
    }, {
      key: "queryByBounds",
      value: function queryByBounds(bounds) {
        var handle = this._dataset.queryByBounds([bounds.x, bounds.y, bounds.z, bounds.w]);
        return new FeatureSet({
          handle: handle
        });
      }
      /**
       * 通过要素集对象释放要素集内存空间
       * @param {PIEFeatureSet} featureSet -矢量要素集对象
       *
       * @memberOf FeatureDataset#
       * @returns {Boolean} 如果释放成功返回true，否则返回false
       */
    }, {
      key: "releaseFeatureSet",
      value: function releaseFeatureSet(featureSet) {
        return this._dataset.releaseFeatureSet(featureSet.handle);
      }
      /**
       * 根据索引设置数据集字段别名
       * @param {Number} index -索引值
       * @param {String} name -字段别名
       *
       * @memberOf FeatureDataset#
       * @returns {Boolean} 如果设置成功返回true，否则返回false
       */
    }, {
      key: "setFieldForignNameAt",
      value: function setFieldForignNameAt(index, name) {
        return this._dataset.setFieldForignNameAt(index, name);
      }
      // /**
      //  * 同一参考系正转换(椭球体相同，地理坐标到投影坐标)
      //  * @param {PIESpatialReference} spatialReference -空间参考坐标系
      //  *
      //  * @memberOf FeatureDataset#
      //  * @returns {Boolean} 如果转换成功返回true，否则返回false
      //  */
    }, {
      key: "forward",
      value: function forward(spatialReference) {
        return this._dataset.forWard(spatialReference.handle);
      }
      // /**
      //  * 同一参考系反转换(椭球体相同，投影坐标到地理坐标)
      //  * @param {PIESpatialReference} spatialReference -空间参考坐标系
      //  *
      //  * @memberOf FeatureDataset#
      //  * @returns {Boolean} 如果转换成功返回true，否则返回false
      //  */
    }, {
      key: "inverse",
      value: function inverse(spatialReference) {
        return this._dataset.inverse(spatialReference.handle);
      }
      // /**
      //  * 不同空间参考系转换
      //  * @param {PIEReferenceTranslator} refTranslator -参考系转换器
      //  *
      //  * @memberOf FeatureDataset#
      //  * @returns {Boolean} 如果转换成功返回true，否则返回false
      //  */
    }, {
      key: "convert",
      value: function convert(refTranslator) {
        return this._dataset.convert(refTranslator.handle);
      }
    }, {
      key: "spatialReference",
      get: function get() {
        var handle = this._dataset.getSpatialReference();
        return new SpatialReference(handle);
      }
    }, {
      key: "charset",
      get: function get() {
        return this._dataset.getCharset();
      },
      set: function set(value) {
        return this._dataset.setCharset(value);
      }
    }, {
      key: "fromGeojson",
      value: function fromGeojson(featureDatasetJson) {
        // let handle = this._dataset.fromGeojson(featureDatasetJson);
        // return new FeatureSet({ handle: handle });
        return this._dataset.fromGeojson(featureDatasetJson);
      }
    }, {
      key: "toGeoJSON",
      value: function toGeoJSON() {
        return this._dataset.toGeoJSON();
      }
    }]);
    return FeatureDataset;
  }(Dataset);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 编码格式
   * @readonly
   * @enum {number}
   */
  var CharsetType = {
    /** Default编码 */
    Default: 1,
    /** GB18030编码*/
    GB18030: 134,
    /** UTF8编码*/
    UTF8: 250,
    /** Windows默认的Unicode编码*/
    UTF16LE: 251,
    /** UCS2BE编码*/
    UTF16BE: 252,
    /** Windows1252编码*/
    Windows1252: 137,
    /** UTF32编码*/
    UTF32LE: 8,
    /** UTF32BE编码*/
    UTF32BE: 9
  };
  var CharsetType$1 = Object.freeze(CharsetType);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 支持SMS搭配条件的值的类型枚举
   * @readonly
   * @enum {Number}
   */
  var VarType = {
    /**未定义的类型*/
    Null: 0,
    /**单字节类型*/
    Byte: 1,
    /**双字节整型类型*/
    Short: 2,
    /**四字节整型类型*/
    Integer: 3,
    /**八字节整型类型*/
    Long: 4,
    /**四字节浮点类型*/
    Float: 5,
    /**八字节浮点类型*/
    Double: 6,
    /**时间类型*/
    Time: 7,
    /**二进制类型*/
    Binary: 8,
    /**字符串*/
    String: 9,
    /**日期类型*/
    Date: 10,
    /**时间戳类型*/
    TimeStamp: 11,
    /**布尔类型*/
    Boolean: 12
  };
  var VarType$1 = Object.freeze(VarType);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 矢量渲染模块
   * ---
   */
  /**
   * @class ClassifyFeatureRenderer
   * 分类矢量渲染器操作函数
   * @extends SimpleFeatureRenderer
   */
  var ClassifyFeatureRenderer = /*#__PURE__*/function (_SimpleFeatureRendere) {
    _inherits(ClassifyFeatureRenderer, _SimpleFeatureRendere);
    var _super = _createSuper(ClassifyFeatureRenderer);
    /**
     * ClassifyFeatureRenderer类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {PIEClassifyFeatureRenderer} options.handle 
     * 
     */
    function ClassifyFeatureRenderer(options) {
      var _this;
      _classCallCheck(this, ClassifyFeatureRenderer);
      _this = _super.call(this);
      if (options != null) {
        _this._render = options.handle;
      } else {
        _this._render = new PIEClassifyFeatureRenderer();
      }
      return _this;
    }
    /**
     *设置渲染器的底部字段名称
     * @memberof ClassifyFeatureRenderer
     * @param {String} strField -字段名称
     */
    _createClass(ClassifyFeatureRenderer, [{
      key: "bottomField",
      get:
      /**
       *获取渲染器的底部字段名称
       * @memberof ClassifyFeatureRenderer
       * @returns {String} 返回字段名称
       */
      function get() {
        return this._render.getBottomField(strField);
      }
      /**
       *设置渲染器的顶部字段名称
       * @memberof ClassifyFeatureRenderer
       * @param {String} field -字段名称
       */,
      set: function set(strField) {
        this._render.setBottomField(strField);
      }
    }, {
      key: "topField",
      get:
      /**
       *获取渲染器的顶部字段名称
       * @memberof ClassifyFeatureRenderer
       * @returns {String} 返回字段名称
       */
      function get() {
        return this._render.getTopField(strField);
      },
      set: function set(strField) {
        this._render.setTopField(strField);
      }
    }]);
    return ClassifyFeatureRenderer;
  }(SimpleFeatureRenderer);

  var ThemeLabelFeatureRenderer = /*#__PURE__*/function (_FeatureRenderer) {
    _inherits(ThemeLabelFeatureRenderer, _FeatureRenderer);
    var _super = _createSuper(ThemeLabelFeatureRenderer);
    function ThemeLabelFeatureRenderer(options) {
      var _this;
      _classCallCheck(this, ThemeLabelFeatureRenderer);
      _this = _super.call(this);
      if (options && options.handle) {
        _this._render = options.handle;
      } else {
        _this._render = new PIEThemeLabelFeatureRenderer();
        options && options.textExpression && _this._render.setTextExpression(options.textExpression);
        options && options["default"] && _this._render.makeDefault(options["default"]);
        options && options.style && _this._render.setStyle(options.style.handle);
      }
      return _this;
    }
    _createClass(ThemeLabelFeatureRenderer, [{
      key: "makeDefault",
      value: function makeDefault(featureDataSource) {
        return this._render.makeDefault(featureDataSource._source);
      }
    }, {
      key: "textExpression",
      get: function get() {
        return this._render.getTextExpression();
      },
      set: function set(expression) {
        this._render.setTextExpression(expression);
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {
        var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this._render.setStyle(style._pieStyle, clone);
      }
    }, {
      key: "style",
      get: function get() {
        var style = this._render.getStyle();
        return StyleFactory$1.CreateInstance(style);
      }
    }]);
    return ThemeLabelFeatureRenderer;
  }(FeatureRenderer);

  var RangeItem = /*#__PURE__*/function () {
    function RangeItem(options) {
      _classCallCheck(this, RangeItem);
      _defineProperty(this, "_rangeItem", void 0);
      if (options != null) {
        this._rangeItem = options.handle;
      } else {
        this._rangeItem = new PIERangeItem();
      }
    }
    _createClass(RangeItem, [{
      key: "handle",
      get: function get() {
        return this._rangeItem;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._rangeItem.dispose();
      }
    }, {
      key: "visible",
      get: function get() {
        return this._rangeItem.isVisible();
      },
      set: function set(visible) {
        this._rangeItem.setVisible(visible);
      }
    }, {
      key: "caption",
      get: function get() {
        return this._rangeItem.getCaption();
      },
      set: function set(caption) {
        this._rangeItem.setCaption(caption);
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {
        var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this._rangeItem.setStyle(style._pieStyle, clone);
      }
    }, {
      key: "style",
      get: function get() {
        var style = this._rangeItem.getStyle();
        return StyleFactory$1.CreateInstance(style);
      }
    }]);
    return RangeItem;
  }();

  var ThemeRangeFeatureRenderer = /*#__PURE__*/function (_FeatureRenderer) {
    _inherits(ThemeRangeFeatureRenderer, _FeatureRenderer);
    var _super = _createSuper(ThemeRangeFeatureRenderer);
    function ThemeRangeFeatureRenderer(options) {
      var _this;
      _classCallCheck(this, ThemeRangeFeatureRenderer);
      _this = _super.call(this);
      if (options && options.handle) {
        _this._render = options.handle;
      } else {
        _this._render = new PIEThemeRangeFeatureRenderer();
        options && options.rangeExpression && _this._render.setRangeExpression(options.rangeExpression);
        options && options.rangeValues && _this._render.setRangeValues(options.rangeValues);
        options && options.rangeItems && _this._render.setRangeItems(options.rangeItems.map(function (ent) {
          return ent.handle;
        }));
      }
      return _this;
    }
    _createClass(ThemeRangeFeatureRenderer, [{
      key: "makeDefault",
      value: function makeDefault(dataSource, count) {
        return this._render.makeDefault(dataSource._source, count);
      }
    }, {
      key: "queryExtremes",
      value: function queryExtremes(dataset, expression) {
        return this._render.queryExtremes(dataset._dataset, expression);
      }
    }, {
      key: "rangeExpression",
      get: function get() {
        return this._render.getRangeExpression();
      },
      set: function set(expression) {
        this._render.setRangeExpression(expression);
      }
    }, {
      key: "isDescending",
      get: function get() {
        return this._render.isDescending();
      }
    }, {
      key: "descending",
      set: function set(descending) {
        this._render.setDescending(descending);
      }
    }, {
      key: "rangeValueCount",
      get: function get() {
        return this._render.getRangeValueCount();
      }
    }, {
      key: "rangeValues",
      get: function get() {
        return this._render.getRangeValues();
      },
      set: function set(RangeValueArray) {
        this._render.setRangeValues(RangeValueArray);
      }
    }, {
      key: "rangeItems",
      get: function get() {
        var rangeItems = this._render.getRangeItems();
        rangeItems = rangeItems.map(function (ent) {
          return new RangeItem({
            handle: ent
          });
        });
        return rangeItems;
      },
      set: function set(rangeItems) {
        rangeItems = rangeItems.map(function (ent) {
          return ent.handle;
        });
        this._render.setRangeItems(rangeItems);
      }
    }, {
      key: "rangeItemCount",
      get: function get() {
        return this._render.getRangeItemCount();
      }
    }, {
      key: "getRangeValueAt",
      value: function getRangeValueAt(index) {
        return this._render.getRangeValueAt(index);
      }
    }, {
      key: "setRangeValueAt",
      value: function setRangeValueAt(index, value) {
        this._render.setRangeValueAt(index, value);
      }
    }, {
      key: "getRangeItemAt",
      value: function getRangeItemAt(index) {
        var rangeItem = this._render.getRangeItemAt(index);
        return new RangeItem({
          handle: rangeItem
        });
      }
    }, {
      key: "setRangeItemAt",
      value: function setRangeItemAt(index, rangeItem) {
        this._render.setRangeItemAt(index, rangeItem.handle);
      }
    }, {
      key: "findRangeItem",
      value: function findRangeItem(value) {
        var rangeItem = this._render.findRangeItem(value);
        return new RangeItem({
          handle: rangeItem
        });
      }
    }]);
    return ThemeRangeFeatureRenderer;
  }(FeatureRenderer);

  var SMSMatchCondition = /*#__PURE__*/function () {
    function SMSMatchCondition(options) {
      _classCallCheck(this, SMSMatchCondition);
      if (options != null) {
        this._matchCondition = options.handle;
      }
    }
    _createClass(SMSMatchCondition, [{
      key: "handle",
      get: function get() {
        return this._matchCondition;
      }
    }, {
      key: "delete",
      value: function _delete() {
        this._matchCondition["delete"]();
      }
    }, {
      key: "conditionType",
      get: function get() {
        return this._matchCondition.getConditionType();
      }
    }, {
      key: "valueType",
      get: function get() {
        return this._matchCondition.getValueType();
      }
    }, {
      key: "isMatch",
      value: function isMatch(value) {
        return this._matchCondition.isMatch(value);
      }
    }]);
    return SMSMatchCondition;
  }();

  var SMSSubLayer = /*#__PURE__*/function () {
    function SMSSubLayer(options) {
      _classCallCheck(this, SMSSubLayer);
      _defineProperty(this, "_subLayer", void 0);
      if (options != null) {
        this._subLayer = options.handle;
      } else {
        this._subLayer = new PIESMSSubLayer();
      }
    }
    _createClass(SMSSubLayer, [{
      key: "handle",
      get: function get() {
        return this._subLayer;
      }
    }, {
      key: "delete",
      value: function _delete() {
        this._subLayer["delete"]();
      }
    }, {
      key: "matchCondition",
      get: function get() {
        var matchCondition = this._subLayer.getMatchCondition();
        return new SMSMatchCondition({
          handle: matchCondition
        });
      },
      set: function set(matchCondition) {
        this._subLayer.setMatchCondition(matchCondition.handle);
      }
    }, {
      key: "name",
      get: function get() {
        return this._subLayer.getName();
      },
      set: function set(name) {
        this._subLayer.setName(name);
      }
    }, {
      key: "visible",
      get: function get() {
        return this._subLayer.isVisible();
      },
      set: function set(visible) {
        this._subLayer.setVisible(visible);
      }
    }, {
      key: "symbolMaxVisibleScale",
      get: function get() {
        return this._subLayer.getSymbolMaxVisibleScale();
      },
      set: function set(maxVisibleScale) {
        this._subLayer.setSymbolMaxVisibleScale(maxVisibleScale);
      }
    }, {
      key: "symbolMinVisibleScale",
      get: function get() {
        return this._subLayer.getSymbolMinVisibleScale();
      },
      set: function set(minVisibleScale) {
        this._subLayer.setSymbolMinVisibleScale(minVisibleScale);
      }
    }, {
      key: "annoMaxVisibleScale",
      get: function get() {
        return this._subLayer.getAnnoMaxVisibleScale();
      },
      set: function set(maxVisibleScale) {
        this._subLayer.setAnnoMaxVisibleScale(maxVisibleScale);
      }
    }, {
      key: "annoMinVisibleScale",
      get: function get() {
        return this._subLayer.getAnnoMinVisibleScale();
      },
      set: function set(minVisibleScale) {
        this._subLayer.setAnnoMinVisibleScale(minVisibleScale);
      }
    }, {
      key: "annoFieldName",
      get: function get() {
        return this._subLayer.getAnnoFieldName();
      },
      set: function set(fieldName) {
        this._subLayer.setAnnoFieldName(fieldName);
      }
    }, {
      key: "setAnnoTextStyle",
      value: function setAnnoTextStyle(style, clone) {
        this._subLayer.setAnnoTextStyle(style.handle, clone);
      }
    }, {
      key: "annoTextStyle",
      get: function get() {
        var style = this._subLayer.getAnnoTextStyle();
        return StyleFactory$1.CreateInstance(style);
      }
    }]);
    return SMSSubLayer;
  }();

  var SMSSubLayerManager = /*#__PURE__*/function () {
    function SMSSubLayerManager(options) {
      _classCallCheck(this, SMSSubLayerManager);
      _defineProperty(this, "_smsSubLayerManager", void 0);
      this._smsSubLayerManager = options.handle;
    }
    _createClass(SMSSubLayerManager, [{
      key: "findSubLayer",
      value: function findSubLayer(value) {
        var subLayer = this._smsSubLayerManager.findSubLayer(value);
        return new SMSSubLayer({
          handle: subLayer
        });
      }
    }, {
      key: "subLayerCount",
      get: function get() {
        return this._smsSubLayerManager.getSubLayerCount();
      }
    }, {
      key: "getSubLayerAt",
      value: function getSubLayerAt(index) {
        var subLayer = this._smsSubLayerManager.getSubLayerAt(index);
        return new SMSSubLayer({
          handle: subLayer
        });
      }
    }, {
      key: "setSubLayerAt",
      value: function setSubLayerAt(index, subLayer) {
        this._smsSubLayerManager.setSubLayerAt(index, subLayer.handle);
      }
    }, {
      key: "addSubLayer",
      value: function addSubLayer(subLayer) {
        this._smsSubLayerManager.addSubLayer(subLayer.handle);
      }
    }, {
      key: "removeSubLayer",
      value: function removeSubLayer(subLayer) {
        this._smsSubLayerManager.removeSubLayer(subLayer.handle);
      }
    }]);
    return SMSSubLayerManager;
  }();

  var SMSFeatureRenderer = /*#__PURE__*/function (_FeatureRenderer) {
    _inherits(SMSFeatureRenderer, _FeatureRenderer);
    var _super = _createSuper(SMSFeatureRenderer);
    function SMSFeatureRenderer(options) {
      var _this;
      _classCallCheck(this, SMSFeatureRenderer);
      _this = _super.call(this);
      if (options != null) {
        _this._render = options.handle;
      } else {
        _this._render = new PIESMSFeatureRenderer();
      }
      return _this;
    }
    _createClass(SMSFeatureRenderer, [{
      key: "handle",
      get: function get() {
        return this._render;
      }
    }, {
      key: "makeDefault",
      value: function makeDefault(dataset, mapScale) {
        return this._render.makeDefault(dataset.handle, mapScale);
      }
    }, {
      key: "subLayerManager",
      get: function get() {
        var subLayerManager = this._render.getSubLayerManager();
        return new SMSSubLayerManager({
          handle: subLayerManager
        });
      }
    }, {
      key: "maxVisibleScale",
      get: function get() {
        return this._render.getMaxVisibleScale();
      }
    }, {
      key: "minVisibleScale",
      get: function get() {
        return this._render.getMinVisibleScale();
      }
    }]);
    return SMSFeatureRenderer;
  }(FeatureRenderer);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 创建SMS范围搭配条件对象
   * @name SMSRangeMatchCondition
   * @class SMSRangeMatchCondition
   * SMS范围搭配条件操作函数
   *
   * @extends SMSMatchCondition
   */
  function PIESMSRangeMatchCondition(handle, autoRelease) {
    if (handle == null) {
      handle = Module._SMSRangeMatchCondition_Create();
    }
    PIESMSMatchCondition(this, handle);
  }
  PIESMSRangeMatchCondition.prototype = Object.assign(Object.create(PIESMSMatchCondition.prototype), {
    /**
     * 设置SMS范围搭配条件最大值
     * @param {Number} maxValue -搭配条件最大值
     * @memberOf SMSRangeMatchCondition#
     */
    setMaxValue: function setMaxValue(maxValue) {
      Module._SMSRangeMatchCondition_SetMaxValue(this.handle, maxValue);
    },
    /**
     * 获取SMS范围搭配条件最大值
     *
     * @memberOf SMSRangeMatchCondition#
     * @returns {Number} 返回搭配条件最大值
     */
    getMaxValue: function getMaxValue() {
      return Module._SMSRangeMatchCondition_GetMaxValue(this.handle);
    },
    /**
     * 设置SMS范围搭配条件是否等于最大值
     * @param {Boolean} maxEQ -是否等于最大值
     * @memberOf SMSRangeMatchCondition#
     */
    setMaxEQ: function setMaxEQ(maxEQ) {
      Module._SMSRangeMatchCondition_SetMaxEQ(this.handle, maxEQ);
    },
    /**
     * 获取SMS范围搭配条件是否等于最大值
     *
     * @memberOf SMSRangeMatchCondition#
     * @returns {Boolean} 返回是否等于最大值
     */
    isMaxEQ: function isMaxEQ() {
      return Module._SMSRangeMatchCondition_IsMaxEQ(this.handle);
    },
    /**
     * 设置SMS范围搭配条件最小值
     * @param {Number} minValue -搭配条件最小值
     * @memberOf SMSRangeMatchCondition#
     */
    setMinValue: function setMinValue(minValue) {
      Module._SMSRangeMatchCondition_SetMinValue(this.handle, minValue);
    },
    /**
     * 获取SMS范围搭配条件最小值
     *
     * @memberOf SMSRangeMatchCondition#
     * @returns {Number} 返回搭配条件最小值
     */
    getMinValue: function getMinValue() {
      return Module._SMSRangeMatchCondition_GetMinValue(this.handle);
    },
    /**
     * 设置SMS范围搭配条件是否等于最小值
     * @param {Boolean} minEQ -是否等于最小值
     * @memberOf SMSRangeMatchCondition#
     */
    setMinEQ: function setMinEQ(minEQ) {
      Module._SMSRangeMatchCondition_SetMinEQ(this.handle, minEQ);
    },
    /**
     * 获取SMS范围搭配条件是否等于最小值
     *
     * @memberOf SMSRangeMatchCondition#
     * @returns {Boolean} 返回是否等于最小值
     */
    isMinEQ: function isMinEQ() {
      return Module._SMSRangeMatchCondition_IsMinEQ(this.handle);
    }
  });

  var SMSRangeMatchCondition = /*#__PURE__*/function (_SMSMatchCondition) {
    _inherits(SMSRangeMatchCondition, _SMSMatchCondition);
    var _super = _createSuper(SMSRangeMatchCondition);
    function SMSRangeMatchCondition(options) {
      var _this;
      _classCallCheck(this, SMSRangeMatchCondition);
      _this = _super.call(this);
      if (options != null) {
        _this._matchCondition = options.handle;
      } else {
        _this._matchCondition = new PIESMSRangeMatchCondition();
      }
      return _this;
    }
    _createClass(SMSRangeMatchCondition, [{
      key: "maxValue",
      get: function get() {
        return this._matchCondition.getMaxValue();
      },
      set: function set(maxValue) {
        this._matchCondition.setMaxValue(maxValue);
      }
    }, {
      key: "maxEQ",
      set: function set(maxEQ) {
        this._matchCondition.setMaxEQ(maxEQ);
      }
    }, {
      key: "isMaxEQ",
      get: function get() {
        return this._matchCondition.isMaxEQ();
      }
    }, {
      key: "minValue",
      get: function get() {
        return this._matchCondition.getMinValue();
      },
      set: function set(minValue) {
        this._matchCondition.setMinValue(minValue);
      }
    }, {
      key: "minEQ",
      set: function set(minEQ) {
        this._matchCondition.setMinEQ(minEQ);
      }
    }, {
      key: "isMinEQ",
      get: function get() {
        return this._matchCondition.isMinEQ();
      }
    }]);
    return SMSRangeMatchCondition;
  }(SMSMatchCondition);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 矢量渲染模块
   * ---
   */

  /**
   * 创建SMS值搭配条件对象
   * @name SMSValueMatchCondition
   * @class SMSValueMatchCondition
   * SMS值搭配条件操作函数
   * @extends SMSMatchCondition
   */
  function PIESMSValueMatchCondition(handle, autoRelease) {
    if (handle == null) {
      handle = Module._SMSValueMatchCondition_Create();
    }
    PIESMSMatchCondition(this, handle);
  }
  PIESMSValueMatchCondition.prototype = Object.assign(Object.create(PIESMSMatchCondition.prototype), {
    /**
     * 设置SMS值搭配条件值
     * @param {Number} value -搭配条件值
     * @memberOf SMSValueMatchCondition#
     */
    setValue: function setValue(value) {
      Module._SMSValueMatchCondition_SetValue(this.handle, value);
    },
    /**
     * 获取SMS值搭配条件值
     *
     * @memberOf SMSValueMatchCondition#
     * @return {Number} 返回搭配条件值
     */
    getValue: function getValue() {
      return Module._SMSValueMatchCondition_GetValue(this.handle);
    }
  });

  var SMSValueMatchCondition = /*#__PURE__*/function (_SMSMatchCondition) {
    _inherits(SMSValueMatchCondition, _SMSMatchCondition);
    var _super = _createSuper(SMSValueMatchCondition);
    function SMSValueMatchCondition(options) {
      var _this;
      _classCallCheck(this, SMSValueMatchCondition);
      _this = _super.call(this);
      if (options != null) {
        _this._matchCondition = options.handle;
      } else {
        _this._matchCondition = new PIESMSValueMatchCondition();
      }
      return _this;
    }
    _createClass(SMSValueMatchCondition, [{
      key: "value",
      get: function get() {
        return this._matchCondition.getValue(value);
      },
      set: function set(value) {
        this._matchCondition.setValue(value);
      }
    }]);
    return SMSValueMatchCondition;
  }(SMSMatchCondition);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class ArcGisMapServerImageryProvider
   * ArcGIS图层类
   * @extends ImageryProvider
   * 
   */
  var ArcGisMapServerImageryProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(ArcGisMapServerImageryProvider, _ImageryProvider);
    var _super = _createSuper(ArcGisMapServerImageryProvider);
    /**
     * ArcGisMapServerImageryProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url 数据的Url
     */
    function ArcGisMapServerImageryProvider(options) {
      var _this;
      _classCallCheck(this, ArcGisMapServerImageryProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('options.url is required.');
      }
      _this._options = options;
      return _this;
    }
    return _createClass(ArcGisMapServerImageryProvider);
  }(ImageryProvider);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * @class WebMapTileServiceImageryProvider
   * WMTS图层类
   * @extends ImageryProvider
   */
  var WebMapTileServiceImageryProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(WebMapTileServiceImageryProvider, _ImageryProvider);
    var _super = _createSuper(WebMapTileServiceImageryProvider);
    /**
     * WebMapTileServiceImageryProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url 数据的Url
     */
    function WebMapTileServiceImageryProvider(options) {
      var _this;
      _classCallCheck(this, WebMapTileServiceImageryProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('options.url is required.');
      }
      _this._options = options;
      return _this;
    }
    return _createClass(WebMapTileServiceImageryProvider);
  }(ImageryProvider);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * @class GoogleEarthEnterpriseMapsProvider
   * GoogleEarth图层类
   */
  var GoogleEarthEnterpriseMapsProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(GoogleEarthEnterpriseMapsProvider, _ImageryProvider);
    var _super = _createSuper(GoogleEarthEnterpriseMapsProvider);
    /**
     * GoogleEarthEnterpriseMapsProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Resource | String} options.url Google Earth服务器托管影像的url
     * @param {String} options.levelOffset 指定地图缩放级别的偏移量
     * @param {String} options.epsg 地图上的坐标系
     */
    function GoogleEarthEnterpriseMapsProvider(options) {
      var _this;
      _classCallCheck(this, GoogleEarthEnterpriseMapsProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('options.url is required.');
      }
      options.levelOffset = -1;
      options.epsg = 4326;
      _this._options = options;
      return _this;
    }
    return _createClass(GoogleEarthEnterpriseMapsProvider);
  }(ImageryProvider);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * 
   * @class MapboxImageryProvider
   * Mapbox图层类
   * @extends ImageryProvider
   */
  var MapboxImageryProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(MapboxImageryProvider, _ImageryProvider);
    var _super = _createSuper(MapboxImageryProvider);
    /**
     * MapboxImageryProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url  Mapbox服务器的url
     */
    function MapboxImageryProvider(options) {
      var _this;
      _classCallCheck(this, MapboxImageryProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('options.url is required.');
      }
      _this._options = options;
      return _this;
    }
    return _createClass(MapboxImageryProvider);
  }(ImageryProvider);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class TileMapServiceImageryProvider
   * TMS图层类
   * @extends ImageryProvider
   *
   */
  var TileMapServiceImageryProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(TileMapServiceImageryProvider, _ImageryProvider);
    var _super = _createSuper(TileMapServiceImageryProvider);
    /**
     * TileMapServiceImageryProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url 数据的Url
     */
    function TileMapServiceImageryProvider(options) {
      var _this;
      _classCallCheck(this, TileMapServiceImageryProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('options.url is required.');
      }
      _this._options = options;
      return _this;
    }
    return _createClass(TileMapServiceImageryProvider);
  }(ImageryProvider);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * @class WebMapServiceImageryProvider
   * WMS图层类
   * @extends ImageryProvider
   */
  var WebMapServiceImageryProvider = /*#__PURE__*/function (_ImageryProvider) {
    _inherits(WebMapServiceImageryProvider, _ImageryProvider);
    var _super = _createSuper(WebMapServiceImageryProvider);
    /**
     * WebMapServiceImageryProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url  数据的Url
     */
    function WebMapServiceImageryProvider(options) {
      var _this;
      _classCallCheck(this, WebMapServiceImageryProvider);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_options", void 0);
      if (!defined$1(options.url)) {
        throw new DeveloperError$1('options.url is required.');
      }
      _this._options = options;
      return _this;
    }
    return _createClass(WebMapServiceImageryProvider);
  }(ImageryProvider);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * 对象相对于原点的水平位置
   * @enum {Number}
   *
   */
  var HorizontalOrigin = {
    /**
     * 原点位于对象的水平中心。
     *
     * @type {Number}
     * @constant
     */
    CENTER: 0,
    /**
     * 原点在对象的左侧。
     *
     * @type {Number}
     * @constant
     */
    LEFT: 1,
    /**
     * 原点在对象的右侧。
     *
     * @type {Number}
     * @constant
     */
    RIGHT: -1
  };
  var HorizontalOrigin$1 = Object.freeze(HorizontalOrigin);

  /**
   * 对象相对于原点的垂直位置
   * @enum {Number}
   */
  var VerticalOrigin = {
    /**
     * 
     * 原点位于 BASELINE 和 TOP 之间的垂直中心。
     * @type {Number}
     * @constant
     */
    CENTER: 0,
    /**
     * 原点位于对象的底部。
     *
     * @type {Number}
     * @constant
     */
    BOTTOM: 1,
    /**
     * If the object contains text, the origin is at the baseline of the text, else the origin is at the bottom of the object.
     *
     * @type {Number}
     * @constant
     */
    // BASELINE: 2,

    /**
     * 原点在对象的顶部。
     *
     * @type {Number}
     * @constant
     */
    TOP: -1
  };
  var VerticalOrigin$1 = Object.freeze(VerticalOrigin);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class Layer3D
   * 3D图层
   */
  var Layer3D = /*#__PURE__*/function () {
    function Layer3D() {
      _classCallCheck(this, Layer3D);
      _defineProperty(this, "_source", void 0);
      _defineProperty(this, "_layer", void 0);
    } // DeveloperError.throwInstantiationError();
    _createClass(Layer3D, [{
      key: "position",
      get:
      /**
       * 获取位置
       * @returns {Cartesian3}
       */
      function get() {
        var pos = this._source.getDataset().getPosition();
        return Cartesian3.fromDegrees(pos.x, pos.y, pos.z);
      }
      /**
       * 设置高度
       * @param {Number} height
       */,
      set: function set(otpions) {
        var dataSet = this._source.getDataset();
        dataSet.setPosition(options);
      }
    }, {
      key: "height",
      get:
      /**
       * 获取高度
       * @returns {Number}
       */
      function get() {
        return this._source.getDataset().getPosition().z;
      },
      set: function set(height) {
        this._source.getDataset().setHeight(height);
      }
    }]);
    return Layer3D;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class Tileset3DLayer
   * 3DTiles图层
   * @extends Layer3D
   */
  var Tileset3DLayer = /*#__PURE__*/function (_Layer3D) {
    _inherits(Tileset3DLayer, _Layer3D);
    var _super = _createSuper(Tileset3DLayer);
    // _source;
    // _layer;
    /**
     * Tileset3DLayer类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url  指定3DTiles图层的URL。
     */
    function Tileset3DLayer(options) {
      var _this;
      _classCallCheck(this, Tileset3DLayer);
      _this = _super.call(this);
      if (!defined$1(options)) {
        throw new DeveloperError$1('options is required.');
      }
      options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
      var dataSource = new PIETiles3DDataSource$1();
      dataSource.open({
        database: options.url
      });
      var tiles3DLayer = new PIEGlobeTiles3DModelLayer();
      tiles3DLayer.setDataSource(dataSource);
      _this._source = dataSource;
      _this._layer = tiles3DLayer;
      return _this;
    }
    return _createClass(Tileset3DLayer);
  }(Layer3D);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class OSGB3DLayer
   * OSGB3D图层
   * @extends Layer3D
   */
  var OSGB3DLayer = /*#__PURE__*/function (_Layer3D) {
    _inherits(OSGB3DLayer, _Layer3D);
    var _super = _createSuper(OSGB3DLayer);
    // _source;
    // _layer;
    /**
     * OSGB3DLayer类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {String} options.url  指定OSGB3D图层的URL。
     */
    function OSGB3DLayer(options) {
      var _this;
      _classCallCheck(this, OSGB3DLayer);
      _this = _super.call(this);
      if (!defined$1(options)) {
        throw new DeveloperError$1('options is required.');
      }
      options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
      var dataSource = new PIEOSGBDataSource();
      dataSource.open({
        database: options.url
      });
      var layer = new PIEGlobeOSGBModelLayer();
      layer.setDataSource(dataSource);
      _this._source = dataSource;
      _this._layer = layer;
      return _this;
    }
    return _createClass(OSGB3DLayer);
  }(Layer3D);

  var GE3DLayer = /*#__PURE__*/_createClass(function GE3DLayer(options) {
    _classCallCheck(this, GE3DLayer);
    if (!defined$1(options)) {
      throw new DeveloperError$1('options is required.');
    }
    options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
    var dataSource = new PIEGEDataSource$1();
    dataSource.open({
      database: './data/geData/geData.ge',
      server: options.url,
      alias: options.alias
    });
    var layer = new PIEGlobeTileGEDataLayer();
    layer.setDataSource(dataSource);
    this._source = dataSource;
    this._layer = layer;
  });

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */
  /**
   * 
   * @class MapboxVectorTileProvider
   * Mapbox矢量瓦片类
   */
  var MapboxVectorTileProvider = /*#__PURE__*/function () {
    /**
     * MapboxVectorTileProvider类的构造函数
     * @param {Object} options 具有以下属性的对象:
     * @param {Object} options.mapUrl <code>optional</code> 地图的Url
     * @param {Object} options.sourceUrl <code>optional</code> 资源的Url
     * @param {Object} options.tileUrl <code>optional</code> 瓦片的Url
     */
    function MapboxVectorTileProvider(options) {
      _classCallCheck(this, MapboxVectorTileProvider);
      _defineProperty(this, "_mapboxVectorTileLayer", void 0);
      _defineProperty(this, "_urlArray", []);
      options = defaultValue$1(options, defaultValue$1.EMPTY_OBJECT);
      if (!defined$1(options.mapUrl)) {
        throw new DeveloperError('mapUrl is required.');
      }
      if (!defined$1(options.sourceUrl)) {
        throw new DeveloperError('sourceUrl is required.');
      }
      if (!defined$1(options.tileUrl)) {
        throw new DeveloperError('tileUrl is required.');
      }
      this._mapboxVectorTileLayer = new PIEGlobeMVTLayer();
      this.urlArray.push(options.mapUrl, options.sourceUrl, options.tileUrl);
    }
    /**
     * 获取Mapbox矢量瓦片图层
     * @returns {GlobeMVTLayer}
     */
    _createClass(MapboxVectorTileProvider, [{
      key: "value",
      get: function get() {
        return this._mapboxVectorTileLayer;
      }
      /**
       * 获取url数组
       * @returns {Array}
       */
    }, {
      key: "urlArray",
      get: function get() {
        return this._urlArray;
      }
    }]);
    return MapboxVectorTileProvider;
  }();

  /**
   * A two dimensional region specified as longitude and latitude coordinates.
   *
   * @alias Bounds
   * @constructor
   *
   * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].
   * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].
   * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].
   * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].
   *
   * @see Packable
   */
  function Bounds(west, south, east, north) {
    /**
     * The westernmost longitude in radians in the range [-Pi, Pi].
     *
     * @type {Number}
     * @default 0.0
     */
    this.west = defaultValue$1(west, 0.0);

    /**
     * The southernmost latitude in radians in the range [-Pi/2, Pi/2].
     *
     * @type {Number}
     * @default 0.0
     */
    this.south = defaultValue$1(south, 0.0);

    /**
     * The easternmost longitude in radians in the range [-Pi, Pi].
     *
     * @type {Number}
     * @default 0.0
     */
    this.east = defaultValue$1(east, 0.0);

    /**
     * The northernmost latitude in radians in the range [-Pi/2, Pi/2].
     *
     * @type {Number}
     * @default 0.0
     */
    this.north = defaultValue$1(north, 0.0);
  }
  Object.defineProperties(Bounds.prototype, {
    /**
     * Gets the width of the bounds in radians.
     * @memberof Bounds.prototype
     * @type {Number}
     * @readonly
     */
    width: {
      get: function get() {
        return Bounds.computeWidth(this);
      }
    },
    /**
     * Gets the height of the bounds in radians.
     * @memberof Bounds.prototype
     * @type {Number}
     * @readonly
     */
    height: {
      get: function get() {
        return Bounds.computeHeight(this);
      }
    }
  });

  /**
   * The number of elements used to pack the object into an array.
   * @type {Number}
   */
  Bounds.packedLength = 4;

  /**
   * Stores the provided instance into the provided array.
   *
   * @param {Bounds} value The value to pack.
   * @param {Number[]} array The array to pack into.
   * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
   *
   * @returns {Number[]} The array that was packed into
   */
  Bounds.pack = function (value, array, startingIndex) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    array[startingIndex++] = value.west;
    array[startingIndex++] = value.south;
    array[startingIndex++] = value.east;
    array[startingIndex] = value.north;
    return array;
  };

  /**
   * Retrieves an instance from a packed array.
   *
   * @param {Number[]} array The packed array.
   * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
   * @param {Bounds} [result] The object into which to store the result.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if one was not provided.
   */
  Bounds.unpack = function (array, startingIndex, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('array', array);
    //>>includeEnd('debug');

    startingIndex = defaultValue$1(startingIndex, 0);
    if (!defined$1(result)) {
      result = new Bounds();
    }
    result.west = array[startingIndex++];
    result.south = array[startingIndex++];
    result.east = array[startingIndex++];
    result.north = array[startingIndex];
    return result;
  };

  /**
   * Computes the width of a bounds in radians.
   * @param {Bounds} bounds The bounds to compute the width of.
   * @returns {Number} The width.
   */
  Bounds.computeWidth = function (bounds) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');
    var east = bounds.east;
    var west = bounds.west;
    if (east < west) {
      east += CesiumMath.TWO_PI;
    }
    return east - west;
  };

  /**
   * Computes the height of a bounds in radians.
   * @param {Bounds} bounds The bounds to compute the height of.
   * @returns {Number} The height.
   */
  Bounds.computeHeight = function (bounds) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');
    return bounds.north - bounds.south;
  };

  /**
   * Creates a bounds given the boundary longitude and latitude in degrees.
   *
   * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].
   * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].
   * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].
   * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].
   * @param {Bounds} [result] The object onto which to store the result, or undefined if a new instance should be created.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided.
   *
   * @example
   * const bounds = Cesium.Bounds.fromDegrees(0.0, 20.0, 10.0, 30.0);
   */
  Bounds.fromDegrees = function (west, south, east, north, result) {
    west = CesiumMath.toRadians(defaultValue$1(west, 0.0));
    south = CesiumMath.toRadians(defaultValue$1(south, 0.0));
    east = CesiumMath.toRadians(defaultValue$1(east, 0.0));
    north = CesiumMath.toRadians(defaultValue$1(north, 0.0));
    if (!defined$1(result)) {
      return new Bounds(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };

  /**
   * Creates a bounds given the boundary longitude and latitude in radians.
   *
   * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].
   * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
   * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].
   * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
   * @param {Bounds} [result] The object onto which to store the result, or undefined if a new instance should be created.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided.
   *
   * @example
   * const bounds = Cesium.Bounds.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);
   */
  Bounds.fromRadians = function (west, south, east, north, result) {
    if (!defined$1(result)) {
      return new Bounds(west, south, east, north);
    }
    result.west = defaultValue$1(west, 0.0);
    result.south = defaultValue$1(south, 0.0);
    result.east = defaultValue$1(east, 0.0);
    result.north = defaultValue$1(north, 0.0);
    return result;
  };

  /**
   * Creates the smallest possible Bounds that encloses all positions in the provided array.
   *
   * @param {Cartographic[]} cartographics The list of Cartographic instances.
   * @param {Bounds} [result] The object onto which to store the result, or undefined if a new instance should be created.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided.
   */
  Bounds.fromCartographicArray = function (cartographics, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('cartographics', cartographics);
    //>>includeEnd('debug');

    var west = Number.MAX_VALUE;
    var east = -Number.MAX_VALUE;
    var westOverIDL = Number.MAX_VALUE;
    var eastOverIDL = -Number.MAX_VALUE;
    var south = Number.MAX_VALUE;
    var north = -Number.MAX_VALUE;
    for (var i = 0, len = cartographics.length; i < len; i++) {
      var position = cartographics[i];
      west = Math.min(west, position.longitude);
      east = Math.max(east, position.longitude);
      south = Math.min(south, position.latitude);
      north = Math.max(north, position.latitude);
      var lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;
      westOverIDL = Math.min(westOverIDL, lonAdjusted);
      eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
    }
    if (east - west > eastOverIDL - westOverIDL) {
      west = westOverIDL;
      east = eastOverIDL;
      if (east > CesiumMath.PI) {
        east = east - CesiumMath.TWO_PI;
      }
      if (west > CesiumMath.PI) {
        west = west - CesiumMath.TWO_PI;
      }
    }
    if (!defined$1(result)) {
      return new Bounds(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };

  /**
   * Creates the smallest possible Bounds that encloses all positions in the provided array.
   *
   * @param {Cartesian3[]} cartesians The list of Cartesian instances.
   * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.
   * @param {Bounds} [result] The object onto which to store the result, or undefined if a new instance should be created.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided.
   */
  Bounds.fromCartesianArray = function (cartesians, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.defined('cartesians', cartesians);
    //>>includeEnd('debug');
    ellipsoid = defaultValue$1(ellipsoid, Ellipsoid$1.WGS84);
    var west = Number.MAX_VALUE;
    var east = -Number.MAX_VALUE;
    var westOverIDL = Number.MAX_VALUE;
    var eastOverIDL = -Number.MAX_VALUE;
    var south = Number.MAX_VALUE;
    var north = -Number.MAX_VALUE;
    for (var i = 0, len = cartesians.length; i < len; i++) {
      var position = ellipsoid.cartesianToCartographic(cartesians[i]);
      west = Math.min(west, position.longitude);
      east = Math.max(east, position.longitude);
      south = Math.min(south, position.latitude);
      north = Math.max(north, position.latitude);
      var lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;
      westOverIDL = Math.min(westOverIDL, lonAdjusted);
      eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
    }
    if (east - west > eastOverIDL - westOverIDL) {
      west = westOverIDL;
      east = eastOverIDL;
      if (east > CesiumMath.PI) {
        east = east - CesiumMath.TWO_PI;
      }
      if (west > CesiumMath.PI) {
        west = west - CesiumMath.TWO_PI;
      }
    }
    if (!defined$1(result)) {
      return new Bounds(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };

  /**
   * Duplicates a Bounds.
   *
   * @param {Bounds} bounds The bounds to clone.
   * @param {Bounds} [result] The object onto which to store the result, or undefined if a new instance should be created.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided. (Returns undefined if bounds is undefined)
   */
  Bounds.clone = function (bounds, result) {
    if (!defined$1(bounds)) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Bounds(bounds.west, bounds.south, bounds.east, bounds.north);
    }
    result.west = bounds.west;
    result.south = bounds.south;
    result.east = bounds.east;
    result.north = bounds.north;
    return result;
  };

  /**
   * Compares the provided Rectangles componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   *
   * @param {Bounds} [left] The first Bounds.
   * @param {Bounds} [right] The second Bounds.
   * @param {Number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.
   * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  Bounds.equalsEpsilon = function (left, right, absoluteEpsilon) {
    absoluteEpsilon = defaultValue$1(absoluteEpsilon, 0);
    return left === right || defined$1(left) && defined$1(right) && Math.abs(left.west - right.west) <= absoluteEpsilon && Math.abs(left.south - right.south) <= absoluteEpsilon && Math.abs(left.east - right.east) <= absoluteEpsilon && Math.abs(left.north - right.north) <= absoluteEpsilon;
  };

  /**
   * Duplicates this Bounds.
   *
   * @param {Bounds} [result] The object onto which to store the result.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided.
   */
  Bounds.prototype.clone = function (result) {
    return Bounds.clone(this, result);
  };

  /**
   * Compares the provided Bounds with this Bounds componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {Bounds} [other] The Bounds to compare.
   * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.
   */
  Bounds.prototype.equals = function (other) {
    return Bounds.equals(this, other);
  };

  /**
   * Compares the provided rectangles and returns <code>true</code> if they are equal,
   * <code>false</code> otherwise.
   *
   * @param {Bounds} [left] The first Bounds.
   * @param {Bounds} [right] The second Bounds.
   * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.
   */
  Bounds.equals = function (left, right) {
    return left === right || defined$1(left) && defined$1(right) && left.west === right.west && left.south === right.south && left.east === right.east && left.north === right.north;
  };

  /**
   * Compares the provided Bounds with this Bounds componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   *
   * @param {Bounds} [other] The Bounds to compare.
   * @param {Number} [epsilon=0] The epsilon to use for equality testing.
   * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.
   */
  Bounds.prototype.equalsEpsilon = function (other, epsilon) {
    return Bounds.equalsEpsilon(this, other, epsilon);
  };

  /**
   * Checks a Bounds's properties and throws if they are not in valid ranges.
   *
   * @param {Bounds} bounds The bounds to validate
   *
   * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
   * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
   * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
   * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
   */
  Bounds.validate = function (bounds) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    var north = bounds.north;
    Check.typeOf.number.greaterThanOrEquals('north', north, -CesiumMath.PI_OVER_TWO);
    Check.typeOf.number.lessThanOrEquals('north', north, CesiumMath.PI_OVER_TWO);
    var south = bounds.south;
    Check.typeOf.number.greaterThanOrEquals('south', south, -CesiumMath.PI_OVER_TWO);
    Check.typeOf.number.lessThanOrEquals('south', south, CesiumMath.PI_OVER_TWO);
    var west = bounds.west;
    Check.typeOf.number.greaterThanOrEquals('west', west, -Math.PI);
    Check.typeOf.number.lessThanOrEquals('west', west, Math.PI);
    var east = bounds.east;
    Check.typeOf.number.greaterThanOrEquals('east', east, -Math.PI);
    Check.typeOf.number.lessThanOrEquals('east', east, Math.PI);
    //>>includeEnd('debug');
  };

  /**
   * Computes the southwest corner of a bounds.
   *
   * @param {Bounds} bounds The bounds for which to find the corner
   * @param {Cartographic} [result] The object onto which to store the result.
   * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
   */
  Bounds.southwest = function (bounds, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Cartographic(bounds.west, bounds.south);
    }
    result.longitude = bounds.west;
    result.latitude = bounds.south;
    result.height = 0.0;
    return result;
  };

  /**
   * Computes the northwest corner of a bounds.
   *
   * @param {Bounds} bounds The bounds for which to find the corner
   * @param {Cartographic} [result] The object onto which to store the result.
   * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
   */
  Bounds.northwest = function (bounds, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Cartographic(bounds.west, bounds.north);
    }
    result.longitude = bounds.west;
    result.latitude = bounds.north;
    result.height = 0.0;
    return result;
  };

  /**
   * Computes the northeast corner of a bounds.
   *
   * @param {Bounds} bounds The bounds for which to find the corner
   * @param {Cartographic} [result] The object onto which to store the result.
   * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
   */
  Bounds.northeast = function (bounds, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Cartographic(bounds.east, bounds.north);
    }
    result.longitude = bounds.east;
    result.latitude = bounds.north;
    result.height = 0.0;
    return result;
  };

  /**
   * Computes the southeast corner of a bounds.
   *
   * @param {Bounds} bounds The bounds for which to find the corner
   * @param {Cartographic} [result] The object onto which to store the result.
   * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
   */
  Bounds.southeast = function (bounds, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      return new Cartographic(bounds.east, bounds.south);
    }
    result.longitude = bounds.east;
    result.latitude = bounds.south;
    result.height = 0.0;
    return result;
  };

  /**
   * Computes the center of a bounds.
   *
   * @param {Bounds} bounds The bounds for which to find the center
   * @param {Cartographic} [result] The object onto which to store the result.
   * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
   */
  Bounds.center = function (bounds, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');

    var east = bounds.east;
    var west = bounds.west;
    if (east < west) {
      east += CesiumMath.TWO_PI;
    }
    var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);
    var latitude = (bounds.south + bounds.north) * 0.5;
    if (!defined$1(result)) {
      return new Cartographic(longitude, latitude);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = 0.0;
    return result;
  };

  /**
   * Computes the intersection of two rectangles.  This function assumes that the bounds's coordinates are
   * latitude and longitude in radians and produces a correct intersection, taking into account the fact that
   * the same angle can be represented with multiple values as well as the wrapping of longitude at the
   * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected
   * coordinates, see {@link Bounds.simpleIntersection}.
   *
   * @param {Bounds} bounds On bounds to find an intersection
   * @param {Bounds} otherRectangle Another bounds to find an intersection
   * @param {Bounds} [result] The object onto which to store the result.
   * @returns {Bounds|undefined} The modified result parameter, a new Bounds instance if none was provided or undefined if there is no intersection.
   */
  Bounds.intersection = function (bounds, otherRectangle, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    Check.typeOf.object('otherRectangle', otherRectangle);
    //>>includeEnd('debug');

    var rectangleEast = bounds.east;
    var rectangleWest = bounds.west;
    var otherRectangleEast = otherRectangle.east;
    var otherRectangleWest = otherRectangle.west;
    if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {
      rectangleEast += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {
      otherRectangleEast += CesiumMath.TWO_PI;
    }
    if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {
      otherRectangleWest += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {
      rectangleWest += CesiumMath.TWO_PI;
    }
    var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));
    var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));
    if ((bounds.west < bounds.east || otherRectangle.west < otherRectangle.east) && east <= west) {
      return undefined;
    }
    var south = Math.max(bounds.south, otherRectangle.south);
    var north = Math.min(bounds.north, otherRectangle.north);
    if (south >= north) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Bounds(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };

  /**
   * Computes a simple intersection of two rectangles.  Unlike {@link Bounds.intersection}, this function
   * does not attempt to put the angular coordinates into a consistent range or to account for crossing the
   * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude
   * and longitude (i.e. projected coordinates).
   *
   * @param {Bounds} bounds On bounds to find an intersection
   * @param {Bounds} otherRectangle Another bounds to find an intersection
   * @param {Bounds} [result] The object onto which to store the result.
   * @returns {Bounds|undefined} The modified result parameter, a new Bounds instance if none was provided or undefined if there is no intersection.
   */
  Bounds.simpleIntersection = function (bounds, otherRectangle, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    Check.typeOf.object('otherRectangle', otherRectangle);
    //>>includeEnd('debug');

    var west = Math.max(bounds.west, otherRectangle.west);
    var south = Math.max(bounds.south, otherRectangle.south);
    var east = Math.min(bounds.east, otherRectangle.east);
    var north = Math.min(bounds.north, otherRectangle.north);
    if (south >= north || west >= east) {
      return undefined;
    }
    if (!defined$1(result)) {
      return new Bounds(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };

  /**
   * Computes a bounds that is the union of two rectangles.
   *
   * @param {Bounds} bounds A bounds to enclose in bounds.
   * @param {Bounds} otherRectangle A bounds to enclose in a bounds.
   * @param {Bounds} [result] The object onto which to store the result.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided.
   */
  Bounds.union = function (bounds, otherRectangle, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    Check.typeOf.object('otherRectangle', otherRectangle);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Bounds();
    }
    var rectangleEast = bounds.east;
    var rectangleWest = bounds.west;
    var otherRectangleEast = otherRectangle.east;
    var otherRectangleWest = otherRectangle.west;
    if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {
      rectangleEast += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {
      otherRectangleEast += CesiumMath.TWO_PI;
    }
    if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {
      otherRectangleWest += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {
      rectangleWest += CesiumMath.TWO_PI;
    }
    var west = CesiumMath.negativePiToPi(Math.min(rectangleWest, otherRectangleWest));
    var east = CesiumMath.negativePiToPi(Math.max(rectangleEast, otherRectangleEast));
    result.west = west;
    result.south = Math.min(bounds.south, otherRectangle.south);
    result.east = east;
    result.north = Math.max(bounds.north, otherRectangle.north);
    return result;
  };

  /**
   * Computes a bounds by enlarging the provided bounds until it contains the provided cartographic.
   *
   * @param {Bounds} bounds A bounds to expand.
   * @param {Cartographic} cartographic A cartographic to enclose in a bounds.
   * @param {Bounds} [result] The object onto which to store the result.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if one was not provided.
   */
  Bounds.expand = function (bounds, cartographic, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    Check.typeOf.object('cartographic', cartographic);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Bounds();
    }
    result.west = Math.min(bounds.west, cartographic.longitude);
    result.south = Math.min(bounds.south, cartographic.latitude);
    result.east = Math.max(bounds.east, cartographic.longitude);
    result.north = Math.max(bounds.north, cartographic.latitude);
    return result;
  };

  /**
   * Returns true if the cartographic is on or inside the bounds, false otherwise.
   *
   * @param {Bounds} bounds The bounds
   * @param {Cartographic} cartographic The cartographic to test.
   * @returns {Boolean} true if the provided cartographic is inside the bounds, false otherwise.
   */
  Bounds.contains = function (bounds, cartographic) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    Check.typeOf.object('cartographic', cartographic);
    //>>includeEnd('debug');

    var longitude = cartographic.longitude;
    var latitude = cartographic.latitude;
    var west = bounds.west;
    var east = bounds.east;
    if (east < west) {
      east += CesiumMath.TWO_PI;
      if (longitude < 0.0) {
        longitude += CesiumMath.TWO_PI;
      }
    }
    return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) && (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) && latitude >= bounds.south && latitude <= bounds.north;
  };
  var subsampleLlaScratch = new Cartographic();
  /**
   * Samples a bounds so that it includes a list of Cartesian points suitable for passing to
   * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account
   * for rectangles that cover the poles or cross the equator.
   *
   * @param {Bounds} bounds The bounds to subsample.
   * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.
   * @param {Number} [surfaceHeight=0.0] The height of the bounds above the ellipsoid.
   * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.
   * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.
   */
  Bounds.subsample = function (bounds, ellipsoid, surfaceHeight, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    //>>includeEnd('debug');

    ellipsoid = defaultValue$1(ellipsoid, Ellipsoid$1.WGS84);
    surfaceHeight = defaultValue$1(surfaceHeight, 0.0);
    if (!defined$1(result)) {
      result = [];
    }
    var length = 0;
    var north = bounds.north;
    var south = bounds.south;
    var east = bounds.east;
    var west = bounds.west;
    var lla = subsampleLlaScratch;
    lla.height = surfaceHeight;
    lla.longitude = west;
    lla.latitude = north;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.longitude = east;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.latitude = south;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.longitude = west;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    if (north < 0.0) {
      lla.latitude = north;
    } else if (south > 0.0) {
      lla.latitude = south;
    } else {
      lla.latitude = 0.0;
    }
    for (var i = 1; i < 8; ++i) {
      lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;
      if (Bounds.contains(bounds, lla)) {
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;
      }
    }
    if (lla.latitude === 0.0) {
      lla.longitude = west;
      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
      length++;
      lla.longitude = east;
      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
      length++;
    }
    result.length = length;
    return result;
  };

  /**
   * Computes a subsection of a bounds from normalized coordinates in the range [0.0, 1.0].
   *
   * @param {Bounds} bounds The bounds to subsection.
   * @param {Number} westLerp The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.
   * @param {Number} southLerp The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.
   * @param {Number} eastLerp The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.
   * @param {Number} northLerp The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.
   * @param {Bounds} [result] The object onto which to store the result.
   * @returns {Bounds} The modified result parameter or a new Bounds instance if none was provided.
   */
  Bounds.subsection = function (bounds, westLerp, southLerp, eastLerp, northLerp, result) {
    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.object('bounds', bounds);
    Check.typeOf.number.greaterThanOrEquals('westLerp', westLerp, 0.0);
    Check.typeOf.number.lessThanOrEquals('westLerp', westLerp, 1.0);
    Check.typeOf.number.greaterThanOrEquals('southLerp', southLerp, 0.0);
    Check.typeOf.number.lessThanOrEquals('southLerp', southLerp, 1.0);
    Check.typeOf.number.greaterThanOrEquals('eastLerp', eastLerp, 0.0);
    Check.typeOf.number.lessThanOrEquals('eastLerp', eastLerp, 1.0);
    Check.typeOf.number.greaterThanOrEquals('northLerp', northLerp, 0.0);
    Check.typeOf.number.lessThanOrEquals('northLerp', northLerp, 1.0);
    Check.typeOf.number.lessThanOrEquals('westLerp', westLerp, eastLerp);
    Check.typeOf.number.lessThanOrEquals('southLerp', southLerp, northLerp);
    //>>includeEnd('debug');

    if (!defined$1(result)) {
      result = new Bounds();
    }

    // This function doesn't use CesiumMath.lerp because it has floating point precision problems
    // when the start and end values are the same but the t changes.

    if (bounds.west <= bounds.east) {
      var width = bounds.east - bounds.west;
      result.west = bounds.west + westLerp * width;
      result.east = bounds.west + eastLerp * width;
    } else {
      var _width = CesiumMath.TWO_PI + bounds.east - bounds.west;
      result.west = CesiumMath.negativePiToPi(bounds.west + westLerp * _width);
      result.east = CesiumMath.negativePiToPi(bounds.west + eastLerp * _width);
    }
    var height = bounds.north - bounds.south;
    result.south = bounds.south + southLerp * height;
    result.north = bounds.south + northLerp * height;

    // Fix floating point precision problems when t = 1
    if (westLerp === 1.0) {
      result.west = bounds.east;
    }
    if (eastLerp === 1.0) {
      result.east = bounds.east;
    }
    if (southLerp === 1.0) {
      result.south = bounds.north;
    }
    if (northLerp === 1.0) {
      result.north = bounds.north;
    }
    return result;
  };

  /**
   * The largest possible bounds.
   *
   * @type {Bounds}
   * @constant
   */
  Bounds.MAX_VALUE = Object.freeze(new Bounds(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建纹理对象
   * @name GeoTexture
   * @class GeoTexture
   * 纹理对象操作函数
   *
   * @param {Object} options
   * @param {Number} options.texture -纹理编号
   * @param {Array|Cartesian2}  options.point -纹理对象的定位点
   * @param {Array|Cartesian2} options.size -纹理的尺寸，宽和高
   * @param {Number} options.color -纹理的颜色
   * @param {Number} options.angle -纹理旋转角度
   *
   * @extends Geometry3D
   * @example
   * 
   var lons = [73.33, 135.05];
   var lats = [3.51, 53.33];
   var x = Math.random() * (lons[1] - lons[0] + 1) + lons[0];
   var y = Math.random() * (lats[1] - lats[0] + 1) + lats[0];

   var point = spatialReference.forward([x, y]);
   var geoTexture = new Earth.GeoTexture({
  			texture: 11800,
  			point: point,
  			size: [32, 32],
  			color: [255, 0, 0, 255],
  			angle: 60
  	});
   *
   */
  var GeoTexture = /*#__PURE__*/function (_Geometry3D) {
    _inherits(GeoTexture, _Geometry3D);
    var _super = _createSuper(GeoTexture);
    function GeoTexture(options) {
      var _this;
      _classCallCheck(this, GeoTexture);
      _this = _super.call(this);
      if (!defined$1(options)) {
        throw new DeveloperError$1('options is required');
      }
      if (options.handle) {
        _this._pieGeoTexture = options.handle;
      } else {
        var texture = options.texture,
          point = options.point,
          size = options.size,
          color = options.color,
          angle = options.angle;
        if (!defined$1(texture)) {
          throw new DeveloperError$1('options.texture is required');
        }
        if (!defined$1(point)) {
          throw new DeveloperError$1('options.point is required');
        }
        size = defaultValue$1(size, [32, 32]);
        color = defaultValue$1(color, [255, 0, 0, 255]);
        angle = defaultValue$1(angle, 0);
        if (point instanceof Array) ; else if (point instanceof Cartesian2) {
          point = [point.x, point.y];
        }
        if (size instanceof Array) ; else if (size instanceof Cartesian2) {
          size = [size.x, size.y];
        }
        if (color instanceof Array) ; else if (color instanceof Color$1) {
          color = color.toBytes();
        }
        _this._pieGeoTexture = new PIEGeoTexture({
          texture: texture,
          point: point,
          size: size,
          color: color,
          angle: angle
        });
      }
      return _this;
    }
    /**
     * 获取点纹理对象的定位点坐标
     * @memberOf GeoTexture
     * @returns {Cartesian2} 返回纹理对象的定位点
     */
    _createClass(GeoTexture, [{
      key: "getPoint",
      value: function getPoint() {
        var pieVec = this._pieGeoTexture.getPoint();
        return new Cartesian2(pieVec[0], pieVec[1]);
      }
      /**
       * 设置点纹理对象的定位点坐标
       * @param {Array|Cartesian2} point -纹理对象的定位点坐标
       * @memberOf GeoTexture
       */
    }, {
      key: "setPoint",
      value: function setPoint(point) {
        if (point instanceof Array) {
          this._pieGeoTexture.setPoint(point);
        } else if (point instanceof Cartesian2) {
          this._pieGeoTexture.setPoint([point.x, point.y]);
        } else {
          throw new DeveloperError$1('point must be Array or Cartesian2');
        }
      }
    }]);
    return GeoTexture;
  }(Geometry3D);

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 几何对象模块
   * ---
   */

  /**
   * 创建动态对象
   * @name DynamicFeature
   * @class DynamicFeature
   * 动态对象操作函数
   *
   * @param {Object} options -
   * @param {Number} options.id -动态对象ID
   * @param {Array | Cartesian2} options.position 对象定位点
   * @param {Geometry} options.geometry 几何对象
   * @param {Number} options.blinkType <code>optional</code> 闪烁类型,默认值0
   * @param {Number} options.plotType <code>optional</code> 军标类型,默认值0
   * @example
  var point = patialReference.forward([x, y]);
  var geoTexture = new Earth.GeoTexture({
      texture: 11800,
      point: point,
      size: [32, 32],
      color: [255, 0, 0, 255],
      angle: 60
  });

  var featurePos = [point[0], point[1]];
  var dynamicFeature = new Earth.DynamicFeature({
      id: 3,
      position: featurePos,
      geometry: geoTexture,
      blinkType: 0,
      plotType: 0
  });
   */
  var DynamicFeature = /*#__PURE__*/function () {
    function DynamicFeature(options) {
      _classCallCheck(this, DynamicFeature);
      if (!defined$1(options)) {
        throw new DeveloperError$1('options is required');
      }
      if (options.handle) {
        this._pieDynamicFeature = options.handle;
      } else {
        var id = options.id,
          position = options.position,
          geometry = options.geometry,
          blinkType = options.blinkType,
          plotType = options.plotType;
        if (!defined$1(id)) {
          throw new DeveloperError$1('options.id is required');
        }
        if (!defined$1(position)) {
          throw new DeveloperError$1('options.position is required');
        }
        blinkType = defaultValue$1(blinkType, 0);
        plotType = defaultValue$1(plotType, 0);
        if (position) {
          if (position instanceof Cartesian2) {
            this._pieDynamicFeature = new PIEDynamicFeature({
              id: id,
              position: [position.x, position.y],
              geometry: geometry._pieGeoTexture,
              blinkType: blinkType,
              plotType: plotType
            });
          } else if (position instanceof Array) {
            this._pieDynamicFeature = new PIEDynamicFeature({
              id: id,
              position: position,
              geometry: geometry._pieGeoTexture,
              blinkType: blinkType,
              plotType: plotType
            });
          }
        }
      }
    }
    _createClass(DynamicFeature, [{
      key: "handle",
      get: function get() {
        return this._pieDynamicFeature;
      }
      /**
       * 删除动态对象
       * @memberOf DynamicFeature
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this._pieDynamicFeature.dispose();
      }
      /**
       * 获取动态对象的ID
       *
       * @memberOf DynamicFeature
       * @returns {Number} 返回动态对象的ID
       *
       */
    }, {
      key: "getID",
      value: function getID() {
        this._pieDynamicFeature.getID();
      }
      /**
       * 设置动态对象的ID
       * @param {Number} id -输入的ID
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setID",
      value: function setID(id) {
        this._pieDynamicFeature.setID(id);
      }
      /**
       * 获取动态对象的定位点
       *
       * @memberOf DynamicFeature
       * @returns {Cartesian3} 返回对象定位点
       *
       */
    }, {
      key: "getPosition",
      value: function getPosition() {
        var pieVec3 = this._pieDynamicFeature.getPosition();
        return new Cartesian3(pieVec3.x, pieVec3.y, pieVec3.z);
      }
      /**
       * 设置动态对象的定位点
       * @param {(Array|Catesian3)} position -定位点
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setPosition",
      value: function setPosition(position) {
        if (position instanceof Array) {
          this._pieDynamicFeature.setPosition(position);
        } else if (position instanceof Cartesian3) {
          this._pieDynamicFeature.setPosition([position.x, position.y, position.z]);
        } else {
          throw new DeveloperError$1('position must be Array or Cartesian3');
        }
      }
      /**
       * 获取动态对象的纹理ID
       *
       * @memberOf DynamicFeature
       * @returns {Number} 返回对象纹理ID
       *
       */
    }, {
      key: "getTexture",
      value: function getTexture() {
        return this._pieDynamicFeature.getTexture();
      }
      /**
       * 设置动态对象的纹理ID
       * @param {Number} textureId -纹理ID
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setTexture",
      value: function setTexture(textureId) {
        this._pieDynamicFeature.setTexture(textureId);
      }
      /**
       *获取动态对象的旋转角度
       *
       * @memberOf DynamicFeature
       * @returns {Number} 返回动态对象的旋转角度
       *
       */
    }, {
      key: "getRotation",
      value: function getRotation() {
        return this._pieDynamicFeature.getRotation();
      }
      /**
       * 设置动态对象的旋转角度
       * @param {Number} rotation -旋转角度
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setRotation",
      value: function setRotation(rotation) {
        this._pieDynamicFeature.setRotation(rotation);
      }
      /**
       * 设置动态对象是否可见
       * @param {Boolean} visible -是否可见
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        this._pieDynamicFeature.setVisible(visible);
      }
      /**
       * 获取动态对象是否可见
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否可见(true-可见，false-不可见)
       *
       */
    }, {
      key: "isVisible",
      value: function isVisible() {
        return this._pieDynamicFeature.isVisible();
      }
      /**
       * 设置动态对象是否可选
       * @param {Boolean} selectable -是否可选
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setSelectable",
      value: function setSelectable(selectable) {
        this._pieDynamicFeature.setSelectable(selectable);
      }
      /**
       * 设置动态对象是否闪烁
       * @param {Boolean} visible -是否闪烁
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setVisibleBlink",
      value: function setVisibleBlink(visible) {
        this._pieDynamicFeature.setVisibleBlink(visible);
      }
      /**
       * 获取动态对象是否可选
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} -返回是否可选(true-可选，false-不可选)
       *
       */
    }, {
      key: "isSelectable",
      value: function isSelectable() {
        return this._pieDynamicFeature.isSelectable();
      }
      /**
       * 设置动态对象是否颜色闪烁
       * @param {Boolean} colorBlink -是否颜色闪烁
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setColorBlink",
      value: function setColorBlink(colorBlink) {
        this._pieDynamicFeature.setColorBlink(colorBlink);
      }
      /**
       * 获取动态对象是否颜色闪烁
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} -返回是否颜色闪烁(true-闪烁，false-不闪烁)
       *
       */
    }, {
      key: "isColorBlink",
      value: function isColorBlink() {
        return this._pieDynamicFeature.isColorBlink();
      }
      /**
       *设置动态对象是否执行动画
       * @param {Boolean} animation -是否执行动画
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setAnimation",
      value: function setAnimation(animation) {
        this._pieDynamicFeature.setAnimation(animation);
      }
      /**
       *获取动态对象是否执行动画
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否执行动画(true-执行，false-不执行)
       *
       */
    }, {
      key: "isAnimation",
      value: function isAnimation() {
        return this._pieDynamicFeature.isAnimation();
      }
      /**
       *设置闪烁图标
       * @param {Number} iconIds -图标ID
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setBlinkIcons",
      value: function setBlinkIcons(iconIds) {
        this._pieDynamicFeature.setBlinkIcons(iconIds);
      }
      /**
       *设置动态对象是否显示轨迹
       * @param {Boolean} visible -是否显示轨迹
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setLocusVisible",
      value: function setLocusVisible(visible) {
        this._pieDynamicFeature.setLocusVisible(visible);
      }
      /**
       *获取动态对象是否显示轨迹
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否显示轨迹(true-显示，false-不显示)
       *
       */
    }, {
      key: "isLocusVisible",
      value: function isLocusVisible() {
        return this._pieDynamicFeature.isLocusVisible();
      }
      /**
       *设置是否渲染尾迹
       *
       * @param {Boolean} bWake -是否渲染尾迹
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setWakeVisible",
      value: function setWakeVisible(bWake) {
        this._pieDynamicFeature.setWakeVisible(bWake);
      }
      /**
       *获取是否渲染尾迹
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否渲染尾迹(true-渲染，false-不渲染)
       *
       */
    }, {
      key: "isWakeVisible",
      value: function isWakeVisible() {
        return this._pieDynamicFeature.isWakeVisible();
      }
      /**
       *设置尾迹线起始点
       * @param {Number} nWakeStartPixel -距离图标起始点像素坐标位置
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setWakeStartPixel",
      value: function setWakeStartPixel(nWakeStartPixel) {
        this._pieDynamicFeature.setWakeStartPixel(nWakeStartPixel);
      }
      /**
       *获取尾迹线起始点
       *
       * @memberOf DynamicFeature
       * @returns {Number} 距离图标起始点像素坐标位置
       *
       */
    }, {
      key: "getWakeStartPixel",
      value: function getWakeStartPixel() {
        return this._pieDynamicFeature.getWakeStartPixel();
      }
      /**
       *设置尾迹线终止点
       * @param {Number} nWakeEndPixel -距离图标终止点像素坐标位置
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setWakeEndPixel",
      value: function setWakeEndPixel(nWakeEndPixel) {
        this._pieDynamicFeature.setWakeEndPixel(nWakeEndPixel);
      }
      /**
       *获取尾迹线终止点
       *
       * @memberOf DynamicFeature
       * @returns {Number} 距离图标终止点像素坐标位置
       *
       */
    }, {
      key: "getWakeEndPixel",
      value: function getWakeEndPixel() {
        return this._pieDynamicFeature.getWakeEndPixel();
      }
      /**
       *设置尾迹线宽
       * @param {Number} nWakeWidth -尾迹线宽
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setWakeLineWidth",
      value: function setWakeLineWidth(nWakeWidth) {
        this._pieDynamicFeature.setWakeLineWidth(nWakeWidth);
      }
      /**
       *获取尾迹线终止点
       *
       * @memberOf DynamicFeature
       * @returns {Number} 返回尾迹线宽
       *
       */
    }, {
      key: "getWakeLineWidth",
      value: function getWakeLineWidth() {
        return this._pieDynamicFeature.getWakeLineWidth();
      }
      /**
       *设置尾迹线色
       * @param {(Color|Array)} color -尾迹线色
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setWakeLineColor",
      value: function setWakeLineColor(color) {
        if (color instanceof Color$1) {
          this._pieDynamicFeature.setWakeLineColor(color.toBytes());
        } else if (color instanceof Array) {
          this._pieDynamicFeature.setWakeLineColor(color);
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       *获取尾迹线色
       *
       * @memberOf DynamicFeature
       * @returns {Color} 尾迹线色
       *
       */
    }, {
      key: "getWakeLineColor",
      value: function getWakeLineColor() {
        var pieColor = this._pieDynamicFeature.getWakeLineColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }
      /**
       *设置是否启用点画轨迹
       * @param {Boolean} bPoint -是否启用
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setLocusPointsMode",
      value: function setLocusPointsMode(bPoint) {
        this._pieDynamicFeature.setLocusPointsMode();
      }
      /**
       *获取是否启用点画轨迹
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否启用点画轨迹(true-启用点画轨迹，false-不启用点画轨迹)
       *
       */
    }, {
      key: "isLocusPointsMode",
      value: function isLocusPointsMode() {
        return this._pieDynamicFeature.isLocusPointsMode();
      }
      /**
       *设置是否启用虚线模式
       * @param {Boolean} bStipple -是否启用
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setLocusStippleMode",
      value: function setLocusStippleMode(bStipple) {
        this._pieDynamicFeature.setLocusStippleMode(bStipple);
      }
      /**
       *获取是否启用虚线模式
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否启用虚线模式(true-启用，false-不启用)
       *
       */
    }, {
      key: "isLocusStippleMode",
      value:
      /**
       *设置点的大小或线的宽度
       * @param {Number} nWidth -点的大小或线的宽度
       * @memberOf DynamicFeature
       *
       */
      function isLocusStippleMode(nWidth) {
        return this._pieDynamicFeature.isLocusStippleMode(nWidth);
      }
      /**
       *获取点的大小或线的宽度
       *
       * @memberOf DynamicFeature
       *@returns {Number} 返回点的大小或线的宽度
       *
       */
    }, {
      key: "getLineWidth",
      value: function getLineWidth() {
        return this._pieDynamicFeature.getLineWidth();
      }
      /**
       *设置虚线点画模式
       *@param {Number} pattern 轨迹点画模式
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setLinePattern",
      value: function setLinePattern(pattern) {
        this._pieDynamicFeature.setLinePattern(pattern);
      }
      /**
       *设置虚线点画模式
       *@param {Number} nFactor -轨迹点画模式重复系数
       *@param {Number} pattern -轨迹点画模式
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setLinePatternWithFactor",
      value: function setLinePatternWithFactor(nFactor, pattern) {
        this._pieDynamicFeature.setLinePatternWithFactor(nFactor, pattern);
      }
      /**
       *设置点或线的颜色
       *@param {(Color|Array)} Color -颜色值
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setLocusLineColor",
      value: function setLocusLineColor(color) {
        if (color instanceof Color$1) {
          this._pieDynamicFeature.setLocusLineColor(color.toBytes());
        } else if (color instanceof Array) {
          this._pieDynamicFeature.setLocusLineColor(color);
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       *删除动态对象
       *
       * @memberOf DynamicFeature
       */
    }, {
      key: "delete",
      value: function _delete() {
        this._pieDynamicFeature["delete"]();
      }
      /**
       *向集合中添加角度不变对象
       *@param {Number} code -添加对象
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "addKeepAngleSet",
      value: function addKeepAngleSet(code) {
        this._pieDynamicFeature.addKeepAngleSet(code);
      }
      /**
       *设置是否显示广告牌
       *@param {Boolean} billBoard -是否显示广告牌
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setEnableBillboard",
      value: function setEnableBillboard(billBoard) {
        this._pieDynamicFeature.setEnableBillboard(billBoard);
      }
      /**
       *获取是否显示广告牌
       *
       * @memberOf DynamicFeature
       *@returns {Boolean} 返回是否显示广告牌(true-显示广告牌，false-不显示广告牌)
       *
       */
    }, {
      key: "isEnableBillboard",
      value: function isEnableBillboard() {
        return this._pieDynamicFeature.isEnableBillboard();
      }

      /**
       * 设置广告牌边框颜色
       * @param {(Color|Array)} color -颜色值
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setBillboardLineColor",
      value: function setBillboardLineColor(color) {
        if (color instanceof Color$1) {
          this._pieDynamicFeature.setBillboardLineColor(color.toBytes());
        } else if (color instanceof Array) {
          this._pieDynamicFeature.setBillboardLineColor(color);
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       *获取广告牌边框颜色
       *
       * @memberOf DynamicFeature
       *@returns {Color} 返回广告牌边框颜色
       *
       */
    }, {
      key: "getBillboardLineColor",
      value: function getBillboardLineColor() {
        var pieColor = this._pieDynamicFeature.getBillboardLineColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }
      /**
       *设置广告牌填充颜色
       *@param {(Color|Array)} color -颜色值
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setBillboardFillColor",
      value: function setBillboardFillColor(color) {
        if (color instanceof Color$1) {
          this._pieDynamicFeature.setBillboardFillColor(color.toBytes());
        } else if (color instanceof Array) {
          this._pieDynamicFeature.setBillboardFillColor(color);
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       *获取广告牌填充颜色
       *
       * @memberOf DynamicFeature
       * @returns {Color} 返回广告牌填充颜色
       *
       */
    }, {
      key: "getBillboardFillColor",
      value: function getBillboardFillColor() {
        var pieColor = this._pieDynamicFeature.getBillboardFillColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }
      /**
       *设置广告牌文本颜色
       * @param {(Color|Array)} color -颜色值
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setBillboardTextColor",
      value: function setBillboardTextColor(color) {
        if (color instanceof Color$1) {
          this._pieDynamicFeature.setBillboardTextColor(color.toBytes());
        } else if (color instanceof Array) {
          this._pieDynamicFeature.setBillboardTextColor(color);
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       *获取广告牌文本颜色
       *
       * @memberOf DynamicFeature
       * @returns {Color} 返回广告牌文本颜色
       *
       */
    }, {
      key: "getBillboardTextColor",
      value: function getBillboardTextColor() {
        var pieColor = this._pieDynamicFeature.getBillboardTextColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }
      /**
       *设置广告牌内容
       *@param {Number} nAlign -点的对齐方式
       *@param {String} pText -广告牌的内容
       * @memberOf DynamicFeature
       */
    }, {
      key: "setBillboardText",
      value: function setBillboardText(nAlign, pText) {
        this._pieDynamicFeature.setBillboardText(nAlign, pText);
      }
      /**
       *获取广告牌内容
       *
       * @memberOf DynamicFeature
       *@returns {String} 返回广告牌的内容
       */
    }, {
      key: "getBillboardText",
      value: function getBillboardText() {
        return this._pieDynamicFeature.getBillboardText();
      }
      /**
       *添加标牌文字
       *
       * @param {PointAlignType} alignType -指定的标牌对齐方式
       * @param {String} text -指定的标牌内容
       * @memberOf DynamicFeature
       *
       * @returns {Boolean} 是否添加成功
       */
    }, {
      key: "addBillboardText",
      value: function addBillboardText(alignType, text) {
        this._pieDynamicFeature.addBillboardText(alignType, text);
      }
      /**
       *获取标牌文字
       *
       * @param {Number} nAlignType -指定的标牌对齐方式
       * @memberOf DynamicFeature
       *
       * @returns {String} 返回指定的标牌文字
       */
    }, {
      key: "getBillboardTextEx",
      value: function getBillboardTextEx(nAlignType) {
        return this._pieDynamicFeature.getBillboardTextEx(nAlignType);
      }
      /**
       *改变标牌文字
       * @param {Number} nAlignType -指定的标牌对齐方式
       * @param {String} pText -指定的标牌内容
       * @memberOf DynamicFeature
       *
       * @returns {Boolean} 是否设置成功
       */
    }, {
      key: "changeBillboardText",
      value: function changeBillboardText(nAlignType, pText) {
        return this._pieDynamicFeature.changeBillboardText(nAlignType, pText);
      }
      /**
       *移除标牌文字
       * @param {Number} nAlignType -指定的标牌对齐方式
       * @memberOf DynamicFeature
       *
       * @returns {Boolean} 是否移除成功
       */
    }, {
      key: "removeBillboardText",
      value: function removeBillboardText(nAlignType) {
        return this._pieDynamicFeature.removeBillboardText(nAlignType);
      }
      /**
       *设置标牌聚合后的文字
       * @param {Number} nAlignType -指定的标牌对齐方式
       * @param {String} pText -指定的标牌牌聚合后的文字
       * @memberOf DynamicFeature
       *
       * @returns {Boolean} 是否添加成功
       */
    }, {
      key: "setBillboardPolyText",
      value: function setBillboardPolyText(nAlignType, pText) {
        return this._pieDynamicFeature.setBillboardPolyText(nAlignType, pText);
      }
      /**
       *获取标牌文字
       * @param {Number} nAlignType -指定的标牌对齐方式
       * @memberOf DynamicFeature
       *
       * @returns {String} 指定的标牌文字
       */
    }, {
      key: "getBillboardPolyText",
      value: function getBillboardPolyText(nAlignType) {
        return this._pieDynamicFeature.getBillboardPolyText(nAlignType);
      }
      /**
       *设置聚合后的纹理
       * @param {Number} pText -聚合后的纹理
       * @memberOf DynamicFeature
       *
       * @returns {Boolean} 是否设置成功
       */
    }, {
      key: "setBillboardPolyTexture",
      value: function setBillboardPolyTexture(pText) {
        return this._pieDynamicFeature.setBillboardPolyTexture(pText);
      }
      /**
       *获取聚合后的纹理
       *
       * @memberOf DynamicFeature
       * @returns {Number} 聚合后的纹理
       */
    }, {
      key: "getBillboardPolyTexture",
      value: function getBillboardPolyTexture() {
        return this._pieDynamicFeature.getBillboardPolyTexture();
      }
      /**
       *显示隐藏标牌文字
       * @param {Number} nAlign -指定的标牌对齐方式
       * @param {Boolean} bShow -是否显示
       * @memberOf DynamicFeature
       *
       * @returns {Boolean} 是否成功显示
       */
    }, {
      key: "showBillboardText",
      value: function showBillboardText(nAlign, bShow) {
        return this._pieDynamicFeature.getBillboardPolyTexture(nAlign, bShow);
      }
      /**
       *标牌文字是否显示
       * @param {Number} nAlign -指定的标牌对齐方式
       * @memberOf DynamicFeature
       *
       *@returns {Boolean} 是否显示标牌文字
       */
    }, {
      key: "isBillboardTextShown",
      value: function isBillboardTextShown(nAlign) {
        return this._pieDynamicFeature.isBillboardTextShown(nAlign);
      }
      /**
       *从集合中移除角度不变对象
       *
       * @param {Number} code -移除对象
       * @memberOf DynamicFeature
       */
    }, {
      key: "removeCode",
      value: function removeCode(code) {
        this._pieDynamicFeature.removeCode();
      }
      /**
       *设置布告板的显示模式
       * @param {BillBoardModeType} modeType -布告板的显示模式(只能设置BillBoardModeType.ScreenAlignMode或者BillBoardModeType.AngleFixedMode)
       * @memberOf DynamicFeature
       */
    }, {
      key: "setBillboardMode",
      value: function setBillboardMode(modeType) {
        this._pieDynamicFeature.setBillboardMode(modeType);
      }

      /**
       * 获取布告板的显示模式
       * @memberOf DynamicFeature
       * @returns {BillBoardModeType} 返回布告板的显示模式
       */
    }, {
      key: "getBillboardMode",
      value: function getBillboardMode() {
        return this._pieDynamicFeature.getBillboardMode();
      }

      /**
       *设置标牌文字的大小
       * @param {(Array|Cartesian2)} size -文字大小
       * @memberOf DynamicFeature
       */
    }, {
      key: "setBillboardTextSize",
      value: function setBillboardTextSize(size) {
        if (size instanceof Array) {
          this._pieDynamicFeature.setBillboardTextSize(size);
        } else if (size instanceof Cartesian2) {
          this._pieDynamicFeature.setBillboardTextSize([size.x, size.y]);
        } else {
          throw new DeveloperError$1('size must be Array or Cartesian2');
        }
      }
      /**
       *设置渲染是否聚合
       * @param {Boolean} bRenderPolymerization -是否聚合
       * @memberOf DynamicFeature
       */
    }, {
      key: "setRenderPolymerization",
      value: function setRenderPolymerization(bRenderPolymerization) {
        this._pieDynamicFeature.setRenderPolymerization(bRenderPolymerization);
      }
      /**
       *判断是否渲染聚合
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否聚合
       */
    }, {
      key: "isIsRenderPolymerization",
      value: function isIsRenderPolymerization() {
        return this._pieDynamicFeature.isIsRenderPolymerization();
      }

      /**
       * 设置动态对象是否闪烁颜色
       * @param {Boolean} colorBlink -是否闪烁
       * @memberOf DynamicFeature
       */
    }, {
      key: "setBlinkColor",
      value: function setBlinkColor(colorBlink) {
        this._pieDynamicFeature.setBlinkColor(colorBlink);
      }

      /**
       * 获取动态对象是否闪烁颜色
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回动态对象是否闪烁颜色
       */
    }, {
      key: "isBlinkColor",
      value: function isBlinkColor() {
        return this._pieDynamicFeature.isBlinkColor();
      }

      /**
       * 获取选中对象个数
       *
       * @memberOf DynamicFeature
       * @return {Number} 返回选中对象个数
       */
    }, {
      key: "getPolymerizationCount",
      value: function getPolymerizationCount() {
        return this._pieDynamicFeature.getPolymerizationCount();
      }

      /**
       * 获取选中聚合对象中所有的对象
       * @param {Array} polymerizedObjects -聚合对象中所有的对象
       *
       * @memberOf DynamicFeature
       * @return {Boolean} 是否返回选中聚合对象中所有的对象
       */
    }, {
      key: "getPolymerizedObjects",
      value: function getPolymerizedObjects(polymerizedObjects) {
        return this._pieDynamicFeature.getPolymerizedObjects(polymerizedObjects);
      }
    }, {
      key: "addCutomPlotCode",
      value: function addCutomPlotCode(desPlotCode, srcPlotCode) {
        this._pieDynamicFeature.addCutomPlotCode(desPlotCode, srcPlotCode);
      }
    }, {
      key: "removeCustomPlotCode",
      value: function removeCustomPlotCode(desPlotCode, srcPlotCode) {
        this._pieDynamicFeature.removeCustomPlotCode(desPlotCode, srcPlotCode);
      }
    }, {
      key: "removeCustomPlots",
      value: function removeCustomPlots(desPlotCode) {
        this._pieDynamicFeature.removeCustomPlots(desPlotCode);
      }
    }, {
      key: "removeAllCustomPlotCodes",
      value: function removeAllCustomPlotCodes() {
        this._pieDynamicFeature.removeAllCustomPlotCodes();
      }
    }, {
      key: "addDefaultPlotCode",
      value: function addDefaultPlotCode(plotType, plotCode) {
        this._pieDynamicFeature.addDefaultPlotCode(plotType, plotCode);
      }
    }, {
      key: "removeDefaultPlotCode",
      value: function removeDefaultPlotCode(plotType) {
        this._pieDynamicFeature.removeDefaultPlotCode(plotType);
      }
    }, {
      key: "removeAllDefaultPlotCode",
      value: function removeAllDefaultPlotCode() {
        this._pieDynamicFeature.removeAllDefaultPlotCode();
      }
    }, {
      key: "findPolymerizationCode",
      value: function findPolymerizationCode(plotCode) {
        this._pieDynamicFeature.findPolymerizationCode(plotCode);
      }
    }, {
      key: "findDefaultPolymerizationCode",
      value: function findDefaultPolymerizationCode(plotType) {
        this._pieDynamicFeature.findDefaultPolymerizationCode(plotType);
      }

      /**
       * 获取风格颜色
       *
       * @memberOf DynamicFeature
       * @returns {Color} 返回风格颜色
       */
    }, {
      key: "getStyleColor",
      value: function getStyleColor() {
        var pieColor = this._pieDynamicFeature.getStyleColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }

      /**
       * 设置风格颜色
       * @param {(Color|Array)} color -风格颜色
       * @memberOf DynamicFeature
       */
    }, {
      key: "setStyleColor",
      value: function setStyleColor(color) {
        if (color instanceof Color$1) {
          this._pieDynamicFeature.setStyleColor(color.toBytes());
        } else if (color instanceof Array) {
          this._pieDynamicFeature.setStyleColor(color);
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }

      /**
       * 获取风格高度
       *
       * @memberOf DynamicFeature
       * @returns {Number} 返回风格高度
       */
    }, {
      key: "getStyleHeight",
      value: function getStyleHeight() {
        return this._pieDynamicFeature.getStyleHeight();
      }

      /**
       * 设置风格高度
       * @param {Number} height -风格高度
       *
       * @memberOf DynamicFeature
       * @returns {Boolean} 返回是否设置成功
       */
    }, {
      key: "setStyleHeight",
      value: function setStyleHeight(height) {
        return this._pieDynamicFeature.setStyleHeight(height);
      }

      /**
       * 获取风格宽度
       *
       * @memberOf DynamicFeature
       * @returns {Number} 返回风格宽度
       */
    }, {
      key: "getStyleWidth",
      value: function getStyleWidth() {
        return this._pieDynamicFeature.getStyleWidth();
      }

      /**
       * 设置风格宽度
       * @param {Number} width -风格宽度
       * @memberOf DynamicFeature
       *
       * @returns {Boolean} 返回是否设置成功
       */
    }, {
      key: "setStyleWidth",
      value: function setStyleWidth(width) {
        return this._pieDynamicFeature.setStyleWidth(width);
      }

      /**
       * 获取轨迹数组
       * @memberOf DynamicFeature
       *
       * @returns {Array} 返回轨迹数组
       */
    }, {
      key: "getLocusPoints",
      value: function getLocusPoints() {
        return this._pieDynamicFeature.getLocusPoints();
      }

      /**
       * 设置轨迹数组
       * @param {Array} pLocusPoints -轨迹数组点
       * @param {Number} count -点个数
       * @memberOf DynamicFeature
       *
       */
    }, {
      key: "setLocusPoints",
      value: function setLocusPoints(pLocusPoints, count) {
        this._pieDynamicFeature.setLocusPoints(pLocusPoints, count);
      }
    }]);
    return DynamicFeature;
  }();

  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 数据源模块
   * ---
   */

  /**
   * @class DynamicDataSource
   * 动态层数据源操作函数
   * @extends DataSource
   *
   * @example
   * let dataSource = new Earth.DynamicDataSource()
   */
  var DynamicDataSource = /*#__PURE__*/function (_DataSource) {
    _inherits(DynamicDataSource, _DataSource);
    var _super = _createSuper(DynamicDataSource);
    function DynamicDataSource(options) {
      var _this;
      _classCallCheck(this, DynamicDataSource);
      _this = _super.call(this);
      if (options !== null && options !== void 0 && options.handle) {
        _this._layer = options.handle;
      } else {
        _this._layer = new PIEGlobeDynamicLayer();
      }
      return _this;
    }

    /**
     * 获取动态层个数
     * @memberof DynamicDataSource
     * @return {Number} 返回动态层个数
     */
    _createClass(DynamicDataSource, [{
      key: "count",
      get: function get() {
        return this._layer.getCount();
      }
      /**
       * 向图层中添加几何对象
       * @param {DynamicFeature} dynamicFeature - 几何对象
       * @memberOf DynamicDataSource
       * @returns {Boolean} 是否添加成功
       */
    }, {
      key: "add",
      value: function add(dynamicFeature) {
        return this._layer.add(dynamicFeature._pieDynamicFeature);
      }
      /**
       * 获取指定索引的对象
       * @param {Number} iD -几何对象索引
       * @memberOf DynamicDataSource
       * @returns {DynamicFeature} 返回动态层图层对象
       *
       */
    }, {
      key: "get",
      value: function get(iD) {
        return new DynamicFeature({
          handle: this._layer.get(iD)
        });
      }
      /**
       * 移除指定索引的对象
       * @param {Number} iD -几何对象索引
       * @memberOf DynamicDataSource
       * @returns {Boolean} 返回是否移除成功
       *
       */
    }, {
      key: "remove",
      value: function remove(iD) {
        return this._layer.remove(iD);
      }
      /**
       * 移除所有索引的对象
       * @memberOf DynamicDataSource
       */
    }, {
      key: "removeAll",
      value: function removeAll() {
        this._layer.removeAll(iD);
      }
      /**
       * 设置是否聚合显示
       * @param {Boolean} polymerization 是否聚合显示
       * @memberOf DynamicDataSource
       */
    }, {
      key: "setPolymerization",
      value: function setPolymerization(polymerization) {
        this._layer.setPolymerization(polymerization);
      }
      /**
       * 获取是否聚合显示
       * @memberOf DynamicDataSource
       * @returns {Boolean} 返回是否聚合显示
       */
    }, {
      key: "getPolymerization",
      value: function getPolymerization() {
        return this._layer.getPolymerization();
      }
      /**
       * 设置广告牌边框颜色
       * @param {(Color|Array)} color -颜色值
       * @memberOf DynamicDataSource
       */
    }, {
      key: "setBillboardLineColor",
      value: function setBillboardLineColor(color) {
        if (color instanceof Array) {
          this._layer.setBillboardLineColor(color);
        } else if (color instanceof Color$1) {
          this._layer.setBillboardLineColor(color.toBytes());
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       * 获取广告牌边框颜色
       *
       * @memberOf DynamicDataSource
       * @returns {Color} 返回广告牌边框颜色
       *
       */
    }, {
      key: "getBillboardLineColor",
      value: function getBillboardLineColor() {
        var pieColor = this._layer.getBillboardLineColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }
      /**
       * 设置广告牌填充颜色
       * @param {(Color | Array)} color -颜色值
       * @memberOf DynamicDataSource
       *
       */
    }, {
      key: "setBillboardFillColor",
      value: function setBillboardFillColor(color) {
        if (color instanceof Array) {
          this._layer.setBillboardFillColor(color);
        } else if (color instanceof Color$1) {
          this._layer.setBillboardFillColor(color.toBytes());
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       * 获取广告牌填充颜色
       *
       * @memberOf DynamicDataSource
       * @returns {Color} 广告牌填充颜色
       *
       */
    }, {
      key: "getBillboardFillColor",
      value: function getBillboardFillColor() {
        var pieColor = this._layer.getBillboardFillColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }
      /**
       * 设置广告牌文本颜色
       * @param {(Color | Array)} color -广告牌填充颜色
       * @memberOf DynamicDataSource
       *
       */
    }, {
      key: "setBillboardTextColor",
      value: function setBillboardTextColor(color) {
        if (color instanceof Array) {
          this._layer.setBillboardTextColor(color);
        } else if (color instanceof Color$1) {
          this._layer.setBillboardTextColor(color.toBytes());
        } else {
          throw new DeveloperError$1('color must be Array or Color');
        }
      }
      /**
       * 获取广告牌文本颜色
       *
       * @memberOf DynamicDataSource
       * @returns {Color} 广告牌文本颜色
       *
       */
    }, {
      key: "getBillboardTextColor",
      value: function getBillboardTextColor() {
        var pieColor = this._layer.getBillboardTextColor();
        return Color$1.fromBytes(pieColor.r, pieColor.g, pieColor.b, pieColor.a);
      }
      /**
       * 设置聚合容限
       * @param {Number} value -聚合容限
       * @memberOf DynamicDataSource
       *
       */
    }, {
      key: "setDistanceThreshold",
      value: function setDistanceThreshold(value) {
        this._layer.setDistanceThreshold(value);
      }
      /**
       * 获取聚合容限
       *
       * @memberOf DynamicDataSource
       * @returns {Number} 返回聚合容限
       *
       */
    }, {
      key: "getDistanceThreshold",
      value: function getDistanceThreshold() {
        return this._layer.getDistanceThreshold();
      }
      /**
       * 创建一个自定义聚合组
       *
       * @memberOf DynamicDataSource
       * @returns {Number} 返回自定义聚合组的ID
       *
       */
    }, {
      key: "createGroup",
      value: function createGroup() {
        return this._layer.createGroup();
      }
      /**
       * 销毁一个自定义聚合组
       * @param {Number} groupID -自定义聚合组的ID
       * @memberOf DynamicDataSource
       *
       */
    }, {
      key: "destroyGroup",
      value: function destroyGroup(groupID) {
        this._layer.destroyGroup(groupID);
      }
      /**
       * 获取自定义聚合组数目
       * @memberOf DynamicDataSource
       * @returns {Number} 返回自定义聚合组数目
       */
    }, {
      key: "getGroupCount",
      value: function getGroupCount() {
        return this._layer.getGroupCount();
      }
      /**
       * 将一个动态对象添加到自定义聚合组
       * @param {Number} groupID -自定义聚合组的ID
       * @param {DynamicFeature} dynamicFeature -需要添加到自定义聚合组的动态对象
       * @memberOf DynamicDataSource
       *
       */
    }, {
      key: "addFeatureToGroup",
      value: function addFeatureToGroup(groupID, dynamicFeature) {
        this._layer.addFeatureToGroup(groupID, dynamicFeature._pieDynamicFeature);
      }
      /**
       * 将一个动态对象从自定义聚合组中删除
       * @param {Number} groupID -自定义聚合组的ID
       * @param {DynamicFeature} dynamicFeature -需要从自定义聚合组删除的动态对象
       * @memberOf DynamicDataSource
       * @returns {Boolean} 成功返回true，失败返回false
       *
       */
    }, {
      key: "removeFeatureFromGroup",
      value: function removeFeatureFromGroup(groupID, dynamicFeature) {
        return this._layer.removeFeatureFromGroup(groupID, dynamicFeature._pieDynamicFeature);
      }
      /**
       * 获取自定义聚合组的成员数目
       * @param {Number} groupID -自定义聚合组的ID
       *
       * @memberOf DynamicDataSource
       *@returns {Number} 返回自定义聚合组的数目
       *
       */
    }, {
      key: "getGroupFeatureCount",
      value: function getGroupFeatureCount(groupID) {
        return this._layer.getGroupFeatureCount(groupID);
      }
      /**
       * 获取自定义聚合组的成员
       * @param {Number} groupID -自定义聚合组的ID
       *@param {Number} index -动态对象的索引
       *
       * @memberOf DynamicDataSource
       * @returns {PIEDynamicFeature} 返回自定义聚合组的成员
       *
       */
    }, {
      key: "getGroupFeature",
      value: function getGroupFeature(groupID, index) {
        return this._layer.getGroupFeature(groupID, index);
      }
      /**
       * 启用自定义聚合组
       * @param {Number} groupID -自定义聚合组的ID
       * @memberOf DynamicDataSource
       */
    }, {
      key: "enableGroup",
      value: function enableGroup(groupID) {
        this._layer.enableGroup(groupID);
      }
      /**
       * 禁用自定义聚合组
       * @param {Number} groupID -自定义聚合组的ID
       * @memberOf DynamicDataSource
       */
    }, {
      key: "disableGroup",
      value: function disableGroup(groupID) {
        this._layer.disableGroup(groupID);
      }
      /**
       * 判断自定义聚合组是否已经启用
       * @param {Number} groupID -自定义聚合组的ID
       *
       * @memberOf DynamicDataSource
       * @returns {Boolean} 返回自定义聚合组是否已经启用
       *
       */
    }, {
      key: "isGroupEnabled",
      value: function isGroupEnabled(groupID) {
        return this._layer.isGroupEnabled(groupID);
      }
      /**
       * 根据聚合类别向聚合目标字典添加对象ID
       * @param {Number} plotCode -标绘的ID
       * @param {Number} iD -对象ID
       * @memberOf DynamicDataSource
       */
    }, {
      key: "addTagFeature",
      value: function addTagFeature(plotCode, iD) {
        return this._layer.addTagFeature(plotCode, iD);
      }
      /**
       * 设置是否可选择
       * @param {Boolean} bSelectable -是否可选择
       * @memberOf DynamicDataSource
       */
    }, {
      key: "setSelectable",
      value: function setSelectable(bSelectable) {
        this._layer.setSelectable(bSelectable);
      }
      /**
       * 判断是否可选择
       * @memberOf DynamicDataSource
       * @returns {Boolean} 返回是否可选择
       */
    }, {
      key: "isSelectable",
      value: function isSelectable() {
        return this._layer.isSelectable();
      }

      /**
       * 获取图层选择集
       *
       * @memberOf DynamicDataSource
       * @returns {Selection} 成功返回selection对象，失败返回null
       */
    }, {
      key: "getSelection",
      value: function getSelection() {
        var handle = this._layer.getSelection();
        return new Selection({
          handle: handle
        });
      }

      /**
       * 查询布告板范围
       * @param {Cartesian2|Array} screenPoint -像素坐标
       * @memberOf DynamicDataSource
       * @returns {Object} 返回查询结果(id为动态对象id，rect为布告板像素范围)
       */
    }, {
      key: "queryBillboard",
      value: function queryBillboard(screenPoint) {
        var pointArray;
        if (screenPoint instanceof Cartesian2) {
          pointArray = [screenPoint.x, screenPoint.y];
        } else if (screenPoint instanceof Array) {
          pointArray = screenPoint;
        } else {
          throw new DeveloperError$1('screenPoint must be Array or Cartesian2');
        }
        return this._layer.queryBillboard(pointArray);
      }
    }]);
    return DynamicDataSource;
  }(DataSource$1);

  /**
   * Defines a heading angle, pitch angle, and range in a local frame.
   * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
   * Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch
   * angles are below the plane. Range is the distance from the center of the frame.
   * @alias HeadingPitchRange
   * @constructor
   *
   * @param {Number} [heading=0.0] The heading angle in radians.
   * @param {Number} [pitch=0.0] The pitch angle in radians.
   * @param {Number} [range=0.0] The distance from the center in meters.
   */
  function HeadingPitchRange(heading, pitch, range) {
    /**
     * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
     * @type {Number}
     * @default 0.0
     */
    this.heading = defaultValue$1(heading, 0.0);

    /**
     * Pitch is the rotation from the local xy-plane. Positive pitch angles
     * are above the plane. Negative pitch angles are below the plane.
     * @type {Number}
     * @default 0.0
     */
    this.pitch = defaultValue$1(pitch, 0.0);

    /**
     * Range is the distance from the center of the local frame.
     * @type {Number}
     * @default 0.0
     */
    this.range = defaultValue$1(range, 0.0);
  }

  /**
   * Duplicates a HeadingPitchRange instance.
   *
   * @param {HeadingPitchRange} hpr The HeadingPitchRange to duplicate.
   * @param {HeadingPitchRange} [result] The object onto which to store the result.
   * @returns {HeadingPitchRange} The modified result parameter or a new HeadingPitchRange instance if one was not provided. (Returns undefined if hpr is undefined)
   */
  HeadingPitchRange.clone = function (hpr, result) {
    if (!defined$1(hpr)) {
      return undefined;
    }
    if (!defined$1(result)) {
      result = new HeadingPitchRange();
    }
    result.heading = hpr.heading;
    result.pitch = hpr.pitch;
    result.range = hpr.range;
    return result;
  };

  var defaultDimensions = new Cartesian3(1.0, 1.0, 1.0);
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * @class BoxEmitter
   * 在箱子内发射粒子的粒子发射器。粒子将随机放置在盒子中，并且具有从盒子中心发出的初始速度。
   * @constructor
   *
   * @param {Cartesian3} dimensions -盒子的宽度，高度和深度尺寸。
   */
  function BoxEmitter(dimensions) {
    dimensions = defaultValue$1(dimensions, defaultDimensions);

    //>>includeStart('debug', pragmas.debug);
    Check.defined("dimensions", dimensions);
    Check.typeOf.number.greaterThanOrEquals("dimensions.x", dimensions.x, 0.0);
    Check.typeOf.number.greaterThanOrEquals("dimensions.y", dimensions.y, 0.0);
    Check.typeOf.number.greaterThanOrEquals("dimensions.z", dimensions.z, 0.0);
    //>>includeEnd('debug');

    this._dimensions = Cartesian3.clone(dimensions);
  }
  Object.defineProperties(BoxEmitter.prototype, {
    /**
     * 盒子的宽度，高度和深度尺寸（以米为单位）。
     * @memberof BoxEmitter.prototype
     * @type {Cartesian3}
     * @default new Cartesian3(1.0, 1.0, 1.0)
     */
    dimensions: {
      get: function get() {
        return this._dimensions;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.defined("value", value);
        Check.typeOf.number.greaterThanOrEquals("value.x", value.x, 0.0);
        Check.typeOf.number.greaterThanOrEquals("value.y", value.y, 0.0);
        Check.typeOf.number.greaterThanOrEquals("value.z", value.z, 0.0);
        //>>includeEnd('debug');
        Cartesian3.clone(value, this._dimensions);
      }
    }
  });
  var scratchHalfDim = new Cartesian3();

  /**
   * 初始化给定的{粒子}设置它的位置和速度
   *
   * @private
   * @param {Particle} particle -要初始化的粒子
   */
  BoxEmitter.prototype.emit = function (particle) {
    var dim = this._dimensions;
    var halfDim = Cartesian3.multiplyByScalar(dim, 0.5, scratchHalfDim);
    var x = CesiumMath.randomBetween(-halfDim.x, halfDim.x);
    var y = CesiumMath.randomBetween(-halfDim.y, halfDim.y);
    var z = CesiumMath.randomBetween(-halfDim.z, halfDim.z);
    particle.position = Cartesian3.fromElements(x, y, z, particle.position);
    particle.velocity = Cartesian3.normalize(particle.position, particle.velocity);
  };

  var defaultAngle = CesiumMath.toRadians(30.0);
  /**
   * @vuepress
   *
   * ---
   * title: Earth SDK
   * headline: 三维场景模块
   * ---
   */
  /**
   * @class ConeEmitter
   * 在圆锥体内发射粒子的粒子发射器。粒子将位于圆锥体的尖端，并且初始速度朝向底部。
   * @constructor
   *
   * @param {Number} [angle=Cesium.Math.toRadians(30.0)] 圆锥角（以弧度为单位）
   */
  function ConeEmitter(angle) {
    this._angle = defaultValue$1(angle, defaultAngle);
  }
  Object.defineProperties(ConeEmitter.prototype, {
    /**
     * 圆锥角（以弧度为单位）
     * @memberof CircleEmitter.prototype
     * @type {Number}
     * @default Cesium.Math.toRadians(30.0)
     */
    angle: {
      get: function get() {
        return this._angle;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number("value", value);
        //>>includeEnd('debug');
        this._angle = value;
      }
    }
  });

  /**
   * Initializes the given {Particle} by setting it's position and velocity.
   *
   * @private
   * @param {Particle} particle The particle to initialize
   */
  ConeEmitter.prototype.emit = function (particle) {
    var radius = Math.tan(this._angle);

    // Compute a random point on the cone's base
    var theta = CesiumMath.randomBetween(0.0, CesiumMath.TWO_PI);
    var rad = CesiumMath.randomBetween(0.0, radius);
    var x = rad * Math.cos(theta);
    var y = rad * Math.sin(theta);
    var z = 1.0;
    particle.velocity = Cartesian3.fromElements(x, y, z, particle.velocity);
    Cartesian3.normalize(particle.velocity, particle.velocity);
    particle.position = Cartesian3.clone(Cartesian3.ZERO, particle.position);
  };

  /**
   * @class SphereEmitter
   * 在球体内发射粒子的粒子发射器。
   * @constructor
   *
   * @param {Number} [radius=1.0] 球面的半径，以米为单位。
   */
  function SphereEmitter(radius) {
    radius = defaultValue$1(radius, 1.0);

    //>>includeStart('debug', pragmas.debug);
    Check.typeOf.number.greaterThan("radius", radius, 0.0);
    //>>includeEnd('debug');

    this._radius = defaultValue$1(radius, 1.0);
  }
  Object.defineProperties(SphereEmitter.prototype, {
    /**
     * 球面的半径，以米为单位。
     * @memberof SphereEmitter.prototype
     * @type {Number}
     * @default 1.0
     */
    radius: {
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.number.greaterThan("value", value, 0.0);
        //>>includeEnd('debug');
        this._radius = value;
      }
    }
  });

  /**
   * Initializes the given {Particle} by setting it's position and velocity.
   *
   * @private
   * @param {Particle} particle The particle to initialize
   */
  SphereEmitter.prototype.emit = function (particle) {
    var theta = CesiumMath.randomBetween(0.0, CesiumMath.TWO_PI);
    var phi = CesiumMath.randomBetween(0.0, CesiumMath.PI);
    var rad = CesiumMath.randomBetween(0.0, this._radius);
    var x = rad * Math.cos(theta) * Math.sin(phi);
    var y = rad * Math.sin(theta) * Math.sin(phi);
    var z = rad * Math.cos(phi);
    particle.position = Cartesian3.fromElements(x, y, z, particle.position);
    particle.velocity = Cartesian3.normalize(particle.position, particle.velocity);
  };

  /*
   * @FilePath: GlobeToolType.js
   * @Author: chenqian
   * @Date: 2023-02-17 15:41:40
   * @LastEditors: cheniqan
   * @LastEditTime: 2023-02-17 17:52:01
   * @Descripttion:场景工具类型枚举
   */

  var GlobeToolType = {
    /** 场景平移  */
    Pan: 'PanGlobeTool',
    /** 场景选择  */
    Select: 'SelectGlobeTool',
    /** 场景编辑  */
    Edit: 'EditGlobeTool',
    /** 新建点  */
    CreatePoint: 'CreatePointGlobeTool',
    /** 新建多段线  */
    CreatePolyline: 'CreatePolylineGlobeTool',
    /** 新建多边形  */
    CreatePolygon: 'CreatePolygonGlobeTool',
    /** 新建自由线  */
    CreateFreeLine: 'CreateFreeLineGlobeTool',
    /** 新建自由多边形  */
    CreateFreePolygon: 'CreateFreePolygonGlobeTool',
    /** 新建矩形 */
    CreateRectangle: 'CreateRectangleGlobeTool',
    /** 新建圆  */
    CreateCircle: 'CreateCircleGlobeTool',
    // /** 新建椭圆  */
    //CreateEllipse: 'CreateEllipseGlobeTool',
    /** 新建扇形  */
    CreateSector: 'CreateSectorGlobeTool',
    /** 新建标绘  */
    CreatePlot: 'CreatePlotGlobeTool',
    /** 模型编辑  */
    EditModel: 'EditModelGlobeTool',
    /** 模型水平移动 **/
    EditPan: 'EditPanGlobeTool',
    /** 模型垂直移动 **/
    EditHeight: 'EditHeightGlobeTool',
    /** 模型缩放 **/
    EditScale: 'EditScaleGlobeTool',
    /** 模型旋转 **/
    EditRotate: 'EditRotateGlobeTool',
    /** 长度测量  */
    MeasureLength: 'MeasureLengthGlobeTool',
    /** 面积测量  */
    MeasureArea: 'MeasureAreaGlobeTool',
    /** 角度测量  */
    MeasureAngle: 'MeasureAngleGlobeTool',
    // /** DEM分析  */
    // AnalyseDEM: 'AnalyseDEMTool',
    /** 剖面分析  */
    Profile: 'ProfileGlobeTool',
    /** 挖填方分析  */
    AnalyseExcavation: 'AnalyseExcavationTool',
    /** 雷达分析  */
    AnalysisRadar: 'AnalysisRadarTool',
    /** 天际线分析  */
    Analyse3DSkyline: 'Analyse3DSkylineTool',
    /** 日照分析  */
    Analyse3DSunshine: 'Analyse3DSunshineTool',
    /**模型点线通视*/
    Analyse3DVisibleLine: 'Analyse3DVisibleLineTool',
    /**模型点面通视*/
    Analyse3DVisibleRegion: 'Analyse3DVisibleRegionTool',
    /**地形点线通视*/
    AnalyseVisibleLine: 'AnalyseVisibleLineTool',
    /**地形点面通视*/
    AnalyseVisibleRegion: 'AnalyseVisibleRegionTool',
    /** 空间角度测量  */
    Measure3DAngle: 'Measure3DAngleGlobeTool',
    /** 空间面积测量  */
    Measure3DArea: 'Measure3DAreaGlobeTool',
    /** 空间高度测量 */
    Measure3DHeight: 'Measure3DHeightGlobeTool',
    /** 空间长度测量  */
    Measure3DLength: 'Measure3DLengthGlobeTool',
    /** 淹没分析  */
    AnalyseVisibleFlood: 'AnalyseVisibleFloodTool',
    // /** 新建模型  */
    // CreateModel: 'CreateModelGlobeTool',
    /** 方位角  */
    MeasureAzimuthAngle: 'MeasureAzimuthAngleTool',
    /** 坡度坡向  */
    SlopeAspect: 'SlopeAspectTool',
    /** 三维绘制面  */
    CreatePolygon3D: 'CreatePolygon3DGlobeTool',
    /** 三维绘制线  */
    CreatePolyline3D: 'CreatePolyline3DGlobeTool',
    /** 三维绘制点  */
    CreatePoint3D: 'CreatePoint3DGlobeTool',
    /** 新建文本  */
    CreateText: 'CreateTextGlobeTool',
    /** 贝赛尔曲线 */
    CreateBezier: 'CreateBezierGlobeTool',
    /** 单体化选择 **/
    Picking: 'PickingGlobeTool'
  };

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 依地模式
   * @readonly
   * @enum {number}
   */
  var AltitudeMode = {
    /** 依地形*/
    ClampToGround: 0,
    /** 相对地形*/
    RelativeToGround: 1,
    /** 绝对高度*/
    AbsoluteAltitude: 2,
    /** 依模型*/
    ClampToModel: 3
  };
  var AltitudeMode$1 = Object.freeze(AltitudeMode);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 分类显示模式
   * @readonly
   * @enum {number}
   */
  var ClassifyMode = {
    /**所有类型分类*/
    ClassifyAll: 0,
    /**地形分类*/
    ClassifyGround: 1,
    /** 模型分类*/
    ClassifyModel: 2
  };
  var ClassifyMode$1 = Object.freeze(ClassifyMode);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 填充效果枚举
   * @readonly
   * @enum {Number}
   */
  var FillEffect = {
    /**缺省效果*/
    Default: 0,
    /**无类型*/
    Lake: 1,
    /**河流效果*/
    River: 2,
    /**水面效果*/
    Water: 3,
    /**溪流效果*/
    StreamRiver: 4
  };
  var FillEffect$1 = Object.freeze(FillEffect);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  // /**
  //  *  填充渐变类型枚举
  //  *  @readonly
  //  *  @enum {Number}
  //  */

  var FillGradientType = {
    /**无类型*/
    None: 0,
    /**线性*/
    Linear: 10,
    /**放射*/
    Radial: 11,
    /**圆锥*/
    Conical: 12,
    /**方形*/
    Square: 13
  };
  var FillGradientType$1 = Object.freeze(FillGradientType);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 填充符号类型
   * @readonly
   * @enum {number}
   */
  var FillType = {
    /** 空类型*/
    Null: 0,
    /**符号库类型*/
    Fill: 5
  };
  var FillType$1 = Object.freeze(FillType);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  // /**
  //  * 线段端口类型枚举
  //  * @readonly
  //  * @enum {Number}
  //  */
  var LineCapStyle = {
    /** 端口为圆形 */
    LineCapRound: 0,
    /** 端口为正方形 */
    LineCapSquare: 1,
    /** 端口为平的 */
    LineCapFlat: 2
  };
  var LineCapStyle$1 = Object.freeze(LineCapStyle);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  // /**
  //  * 线段连接类型枚举
  //  * @readonly
  //  * @enum {Number}
  //  */
  var LineJoinStyle = {
    /** 以圆角方式相交 */
    LineJoinRound: 0,
    /** 以平角方式相交 */
    LineJoinBevel: 1,
    /** 以尖角方式相交 */
    LineJoinMiter: 2
  };
  var LineJoinStyle$1 = Object.freeze(LineJoinStyle);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 线符号类型
   * @readonly
   * @enum {number}
   */
  var LineType = {
    /** 空类型*/
    Null: 0,
    /** 符号库类型*/
    Line: 3
  };
  var LineType$1 = Object.freeze(LineType);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   *  点符号类型
   * @readonly
   * @enum {number}
   */
  var PointType = {
    /** 空类型*/
    Null: 0,
    // /**符号库类型*/
    // Marker: 1,
    /**图标类型*/
    Icon: 16
  };
  var PointType$1 = Object.freeze(PointType);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 文本对齐方式枚举
   * @readonly
   * @enum {Number}
   */
  var TextAlignType = {
    /**左上对齐*/
    LeftTop: 0,
    /**中上对齐*/
    TopCenter: 1,
    /**右上对齐*/
    RightTop: 2,
    /**左下对齐*/
    LeftBottom: 3,
    /**中下对齐*/
    BottomCenter: 4,
    /**右下对齐*/
    RightBottom: 5,
    /**左中对齐*/
    LeftCenter: 6,
    /**中心对齐*/
    Center: 7,
    /**右中对齐*/
    RightCenter: 8
  };
  var TextAlignType$1 = Object.freeze(TextAlignType);

  var ModelStyle = /*#__PURE__*/function (_Style) {
    _inherits(ModelStyle, _Style);
    var _super = _createSuper(ModelStyle);
    function ModelStyle(options) {
      var _this;
      _classCallCheck(this, ModelStyle);
      _this = _super.call(this);
      if (options == null) {
        _this._pieStyle = new PIEModelStyle();
      } else {
        if (options.handle != null) {
          _this._pieStyle = options.handle;
        } else {
          _this._pieStyle = new PIEModelStyle();
        }
      }
      return _this;
    }
    _createClass(ModelStyle, [{
      key: "modelType",
      get: function get() {
        return this._pieStyle.getModelType();
      },
      set: function set(value) {
        this._pieStyle.setModelType(value);
      }
    }, {
      key: "modelStyle",
      get: function get() {
        return this._pieStyle.getModelStyle();
      },
      set: function set(value) {
        this._pieStyle.setModelStyle(value);
      }
    }, {
      key: "rotation",
      get: function get() {
        var rotation = this._pieStyle.getRotation();
        return Cartesian3.fromElements(rotation.x, rotation.y, rotation.z);
      },
      set: function set(value) {
        this._pieStyle.setRotation([value.x, value.y, value.z]);
      }
    }, {
      key: "scale",
      get: function get() {
        var scale = this._pieStyle.getScale();
        return Cartesian3.fromElements(scale.x, scale.y, scale.z);
      },
      set: function set(value) {
        this._pieStyle.setScale([value.x, value.y, value.z]);
      }
    }, {
      key: "translation",
      get: function get() {
        var translation = this._pieStyle.getTranslation();
        return Cartesian3.fromElements(translation.x, translation.y, translation.z);
      },
      set: function set(value) {
        this._pieStyle.setTranslation([value.x, value.y, value.z]);
      }
    }, {
      key: "altitudeMode",
      get: function get() {
        return this._pieStyle.getAltitudeMode();
      },
      set: function set(value) {
        this._pieStyle.setAltitudeMode(value);
      }
    }, {
      key: "isSizeFixed",
      get: function get() {
        return this._pieStyle.isSizeFixed();
      },
      set: function set(value) {
        this._pieStyle.setSizeFixed(value);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new ModelStyle({
          handle: this
        });
      }
    }]);
    return ModelStyle;
  }(Style);

  /**
   * @vuepress
   *
   * ---
   * title: -Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
  * 符号类型枚举
  * @readonly
  * @enum {number}
  */
  var SymbolType = {
    /**空类型*/
    Null: 0,
    // /**点符号类型*/
    // Marker : 1,
    // /**线符号类型*/
    // Line : 3,
    // /**面符号类型*/
    // Fill : 5,
    /**图标符号类型*/
    Icon: 16
    // /**模型符号类型*/
    // Model : 32
  };

  var SymbolType$1 = Object.freeze(SymbolType);

  /**
   * @vuepress
   *
   * ---
   * title: PIE-Earth SDK
   * headline: 符号库模块
   * ---
   */

  /**
   * 创建图标符号对象
   * @name IconSymbol
   * @class IconSymbol
   * 图标符号操作函数
   *
   * @extends Symbol
   * @example
   *
   * let iconSymbol = new PIE.IconSymbol();
   *
   */
  var IconSymbol = /*#__PURE__*/function (_Symbol2) {
    _inherits(IconSymbol, _Symbol2);
    var _super = _createSuper(IconSymbol);
    function IconSymbol(options) {
      var _this;
      _classCallCheck(this, IconSymbol);
      _this = _super.call(this);
      if (options == null) {
        _this._Symbol = new PIEIconSymbol();
      } else {
        if (options.handle != null) {
          _this._Symbol = options.handle;
        } else {
          _this._Symbol = new PIEIconSymbol();
        }
      }
      return _this;
    }
    _createClass(IconSymbol, [{
      key: "path",
      get: function get() {
        return this._Symbol.getPath();
      }
      // /**
      //  * 设置符号的路径
      //  * @param {String} path -符号路径
      //  *
      //  * @memberOf IconSymbol#
      //  *
      //  */
      ,
      set: function set(path) {
        this._Symbol.setPath(path);
      }
    }, {
      key: "load",
      value: function load(options) {
        var _this2 = this;
        // return  new Promise(this._Symbol.load(options));
        return new Promise(function (resolve, reject) {
          _this2._Symbol.load(options).then(function () {
            resolve(_this2);
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }]);
    return IconSymbol;
  }(_Symbol);

  var Element = /*#__PURE__*/function () {
    function Element() {
      _classCallCheck(this, Element);
      _defineProperty(this, "_pieElement", void 0);
    } // DeveloperError.throwInstantiationError();
    _createClass(Element, [{
      key: "type",
      get: function get() {
        return this._pieElement.getType();
      }
    }, {
      key: "id",
      get: function get() {
        return this._pieElement.getID();
      },
      set: function set(id) {
        this._pieElement.setID(id);
      }
    }, {
      key: "isVisible",
      get: function get() {
        return this._pieElement.isVisible();
      },
      set: function set(isVisible) {
        return this._pieElement.setVisible(isVisible);
      }
    }, {
      key: "bounds",
      get: function get() {
        var bounds = this._pieElement.getBounds();
        return Cartesian4.fromElements(bounds.left, bounds.top, bounds.right, bounds.bottom);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        return this._pieElement.dispose();
      }
    }]);
    return Element;
  }();

  var GraphicElement = /*#__PURE__*/function (_Element) {
    _inherits(GraphicElement, _Element);
    var _super = _createSuper(GraphicElement);
    function GraphicElement(options) {
      var _this;
      _classCallCheck(this, GraphicElement);
      _this = _super.call(this);
      if (options != null) {
        if (options.handle != null) {
          _this._pieElement = options.handle;
        } else {
          if (options.geometry) {
            options.geometry = options.geometry && options.geometry._pieGeometry;
          } else {
            options.feature = options.feature && options.feature._pieFeature;
          }
          _this._pieElement = new PIEGlobeFeatureElement(options);
        }
      }
      return _this;
    }
    _createClass(GraphicElement, [{
      key: "feature",
      get: function get() {
        var feature = this._pieElement.getFeature();
        return new Feature({
          handle: feature
        });
      },
      set: function set(feature) {
        this._pieElement.setFeature(feature._pieFeature);
      }
    }]);
    return GraphicElement;
  }(Element);

  var GraphicDataSource = /*#__PURE__*/function (_DataSource) {
    _inherits(GraphicDataSource, _DataSource);
    var _super = _createSuper(GraphicDataSource);
    function GraphicDataSource(options) {
      var _this;
      _classCallCheck(this, GraphicDataSource);
      _this = _super.call(this);
      if (options == null) {
        _this._layer = new PIEGlobeGraphicsLayer();
      } else {
        if (options.handle != null) {
          _this._layer = options.handle;
        } else {
          _this._layer = new PIEGlobeGraphicsLayer();
        }
      }
      return _this;
    }
    _createClass(GraphicDataSource, [{
      key: "count",
      get: function get() {
        return this._layer.getCount();
      }
    }, {
      key: "setSelectable",
      value: function setSelectable(selectable) {
        this._layer.setSelectable(selectable);
      }
    }, {
      key: "getSelection",
      value: function getSelection() {
        return this._layer.getSelection();
      }
    }, {
      key: "add",
      value: function add(globeElement) {
        this._layer.add(globeElement._pieElement);
      }
    }, {
      key: "getAt",
      value: function getAt(index) {
        var result = this._layer.getAt(index);
        return new GraphicElement({
          handle: result
        });
      }
    }, {
      key: "get",
      value: function get(id) {
        var result = this._layer.get(id);
        return new GraphicElement({
          handle: result
        });
      }
    }, {
      key: "remove",
      value: function remove(id) {
        this._layer.remove(id);
      }
    }, {
      key: "removeAt",
      value: function removeAt(index) {
        this._layer.removeAt(index);
      }
    }, {
      key: "removeAll",
      value: function removeAll() {
        this._layer.removeAll();
      }
    }]);
    return GraphicDataSource;
  }(DataSource$1);

  var Renderable = /*#__PURE__*/function () {
    function Renderable() {
      _classCallCheck(this, Renderable);
      this._pieRenderable = undefined;
      // DeveloperError.throwInstantiationError();
    }
    _createClass(Renderable, [{
      key: "id",
      get: function get() {
        return this._pieRenderable.getID();
      },
      set: function set(id) {
        this._pieRenderable.setID(id);
      }
    }, {
      key: "type",
      get: function get() {
        return this._pieRenderable.getType();
      }
    }, {
      key: "visible",
      get: function get() {
        return this._pieRenderable.isVisible();
      },
      set: function set(visible) {
        this._pieRenderable.setVisible(visible);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._pieRenderable.dispose();
      }
    }]);
    return Renderable;
  }();

  var RenderGeometry = /*#__PURE__*/function (_Renderable) {
    _inherits(RenderGeometry, _Renderable);
    var _super = _createSuper(RenderGeometry);
    function RenderGeometry() {
      _classCallCheck(this, RenderGeometry);
      return _super.call(this); // DeveloperError.throwInstantiationError()
    }
    _createClass(RenderGeometry, [{
      key: "feature",
      get: function get() {
        var feature = this._pieRenderable.getFeature();
        return new Feature({
          handle: feature
        });
      },
      set: function set(feature) {
        this._pieRenderable.setFeature(feature._pieFeature);
      }
    }, {
      key: "style",
      get: function get() {
        var style = this._pieRenderable.getStyle();
        return new VectorStyle({
          handle: style
        });
      },
      set: function set(style) {
        this._pieRenderable.setStyle(style._pieStyle);
      }
    }, {
      key: "position",
      get: function get() {
        var pos = this._pieRenderable.getPosition();
        return Cartesian3.fromElements(pos.x, pos.y, pos.z);
      },
      set: function set(pos) {
        this._pieRenderable.setPosition([pos.x, pos.y, pos.z]);
      }
    }, {
      key: "height",
      get: function get() {
        return this._pieRenderable.getHeight();
      },
      set: function set(height) {
        this._pieRenderable.setHeight(height);
      }
    }, {
      key: "rotation",
      get: function get() {
        var rotation = this._pieRenderable.getRotation();
        return Cartesian3.fromElements(rotation.x, rotation.y, rotation.z);
      },
      set: function set(rotation) {
        this._pieRenderable.setRotation([rotation.x, rotation.y, rotation.z]);
      }
    }, {
      key: "dirty",
      get: function get() {
        return this._pieRenderable.getDirty();
      },
      set: function set(dirty) {
        this._pieRenderable.setDirty(dirty);
      }
    }, {
      key: "selected",
      get: function get() {
        return this._pieRenderable.isSelected();
      }

      // runAction(action) {
      //     this._pieRenderable.runAction(action)
      // }

      // startAction(action) {
      //     this._pieRenderable.startAction(action)
      // }

      // stopAction(action) {
      //     this._pieRenderable.stopAction(action)
      // }
      ,
      set: function set(selected) {
        this._pieRenderable.setSelected(selected);
      }
    }, {
      key: "refresh",
      value: function refresh(viewer) {
        this._pieRenderable.refresh(viewer._pieGlobe);
      }
    }]);
    return RenderGeometry;
  }(Renderable);

  var RenderModel = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderModel, _RenderGeometry);
    var _super = _createSuper(RenderModel);
    function RenderModel(options) {
      var _this;
      _classCallCheck(this, RenderModel);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderModel();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.model) opt.model = options.model; // 要修改
          if (options.position) opt.position = options.position;
          if (options.scale) opt.scale = options.scale;
          if (options.rotation) opt.rotation = options.rotation;
          _this._pieRenderable = new PIERenderModel(opt);
        }
      }
      return _this;
    }
    return _createClass(RenderModel);
  }(RenderGeometry);

  var RenderPoint = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderPoint, _RenderGeometry);
    var _super = _createSuper(RenderPoint);
    function RenderPoint(options) {
      var _this;
      _classCallCheck(this, RenderPoint);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderPoint();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.point) opt.point = options.point._pieGeometry;
          if (options.color) opt.color = options.color.toBytes();
          if (options.type) opt.type = options.type;
          if (options.size) opt.size = [options.size, options.size];
          if (options.style) opt.style = options.style;
          if (options.align) opt.align = options.align;
          _this._pieRenderable = new PIERenderPoint(opt);
        }
      }
      return _this;
    }
    return _createClass(RenderPoint);
  }(RenderGeometry);

  var RenderPoint3D = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderPoint3D, _RenderGeometry);
    var _super = _createSuper(RenderPoint3D);
    function RenderPoint3D(options) {
      var _this;
      _classCallCheck(this, RenderPoint3D);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderPoint3D();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.point3D) opt.point3D = options.point3D._pieGeometry3D;
          if (options.color) opt.color = options.color.toBytes();
          if (options.size) opt.size = [options.size, options.size];
          if (options.type) opt.type = options.type;
          if (options.style) opt.style = options.style;
          if (options.align) opt.align = options.align;
          if (options.altitudeMode) opt.altitudeMode = options.altitudeMode;
          _this._pieRenderable = new PIERenderPoint3D(opt);
        }
      }
      return _this;
    }
    return _createClass(RenderPoint3D);
  }(RenderGeometry);

  var RenderPolygon = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderPolygon, _RenderGeometry);
    var _super = _createSuper(RenderPolygon);
    function RenderPolygon(options) {
      var _this;
      _classCallCheck(this, RenderPolygon);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderPolygon();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.polygon) opt.polygon = options.polygon._pieGeometry;
          if (options.color) opt.color = options.color.toBytes();
          _this._pieRenderable = new PIERenderPolygon(opt);
        }
      }
      return _this;
    }
    return _createClass(RenderPolygon);
  }(RenderGeometry);

  var RenderPolygon3D = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderPolygon3D, _RenderGeometry);
    var _super = _createSuper(RenderPolygon3D);
    function RenderPolygon3D(options) {
      var _this;
      _classCallCheck(this, RenderPolygon3D);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderPolygon3D();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.polygon3D) opt.polygon3D = options.polygon3D._pieGeometry3D;
          if (options.color) opt.color = options.color.toBytes();
          if (options.type) opt.type = options.type;
          _this._pieRenderable = new PIERenderPolygon3D(opt);
        }
      }
      return _this;
    }
    return _createClass(RenderPolygon3D);
  }(RenderGeometry);

  var RenderPolyline = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderPolyline, _RenderGeometry);
    var _super = _createSuper(RenderPolyline);
    function RenderPolyline(options) {
      var _this;
      _classCallCheck(this, RenderPolyline);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderPolyline();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.polyline) opt.polyline = options.polyline._pieGeometry;
          if (options.color) opt.color = options.color.toBytes();
          if (options.width) opt.width = options.width;
          _this._pieRenderable = new PIERenderPolyline(opt);
        }
      }
      return _this;
    }
    return _createClass(RenderPolyline);
  }(RenderGeometry);

  var RenderPolyline3D = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderPolyline3D, _RenderGeometry);
    var _super = _createSuper(RenderPolyline3D);
    function RenderPolyline3D(options) {
      var _this;
      _classCallCheck(this, RenderPolyline3D);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderPolyline3D();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          opt.style = 7; // 为了让三维线支持宽度属性，临时添加style=7
          if (options.polyline3D) opt.polyline3D = options.polyline3D._pieGeometry3D;
          if (options.color) opt.color = options.color.toBytes();
          if (options.width) opt.width = options.width;
          if (options.type) opt.type = options.type;
          _this._pieRenderable = new PIERenderPolyline3D(opt);
        }
      }
      return _this;
    }
    return _createClass(RenderPolyline3D);
  }(RenderGeometry);

  var RenderText = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderText, _RenderGeometry);
    var _super = _createSuper(RenderText);
    function RenderText(options) {
      var _this;
      _classCallCheck(this, RenderText);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderText();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.text) opt.text = options.text._pieGeometry;
          if (options.color) opt.color = options.color.toBytes();
          if (options.size) opt.width = opt.height = options.size;
          if (options.align) opt.align = options.align;
          _this._pieRenderable = new PIERenderText(opt);
        }
      }
      return _this;
    }
    _createClass(RenderText, [{
      key: "textStyle",
      get: function get() {
        var style = this._pieRenderable.getTextStyle();
        return new TextStyle({
          handle: style
        });
      },
      set: function set(style) {
        this._pieRenderable.setTextStyle(style._pieStyle);
      }
    }]);
    return RenderText;
  }(RenderGeometry);

  var RenderText3D = /*#__PURE__*/function (_RenderGeometry) {
    _inherits(RenderText3D, _RenderGeometry);
    var _super = _createSuper(RenderText3D);
    function RenderText3D(options) {
      var _this;
      _classCallCheck(this, RenderText3D);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderText3D();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.text3D) opt.text3D = options.text3D._pieGeometry3D;
          if (options.color) opt.color = options.color.toBytes();
          if (options.size) opt.width = opt.height = options.size;
          if (options.align) opt.align = options.align;
          _this._pieRenderable = new PIERenderText3D(opt);
        }
      }
      return _this;
    }
    _createClass(RenderText3D, [{
      key: "textStyle",
      get: function get() {
        var style = this._pieRenderable.getTextStyle();
        return new TextStyle({
          handle: style
        });
      },
      set: function set(style) {
        this._pieRenderable.setTextStyle(style._pieStyle);
      }
    }]);
    return RenderText3D;
  }(RenderGeometry);

  var RenderRiver = /*#__PURE__*/function (_RenderPolygon3D) {
    _inherits(RenderRiver, _RenderPolygon3D);
    var _super = _createSuper(RenderRiver);
    function RenderRiver(options) {
      var _this;
      _classCallCheck(this, RenderRiver);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderRiver();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.normal0Url) opt.normal0Url = options.normal0Url;
          if (options.normal1Url) opt.normal1Url = options.normal1Url;
          if (options.flowUrl) opt.flowUrl = options.flowUrl;
          if (options.blendUrl) opt.blendUrl = options.blendUrl;
          _this._pieRenderable = new PIERenderRiver(opt);
        }
      }
      return _this;
    }
    _createClass(RenderRiver, [{
      key: "riverSpeed",
      get: function get() {
        return this._pieRenderable.getRiverSpeed();
      },
      set: function set(speed) {
        this._pieRenderable.setRiverSpeed(speed);
      }
    }, {
      key: "riverScale",
      get: function get() {
        return this._pieRenderable.getRiverScale();
      },
      set: function set(scale) {
        this._pieRenderable.setRiverScale(scale);
      }
    }, {
      key: "reflectivity",
      get: function get() {
        return this._pieRenderable.getReflectivity();
      },
      set: function set(reflectivity) {
        this._pieRenderable.setReflectivity(reflectivity);
      }
    }, {
      key: "blendScale",
      get: function get() {
        return this._pieRenderable.getBlendScale();
      },
      set: function set(scale) {
        this._pieRenderable.setBlendScale(scale);
      }
    }, {
      key: "waterColor",
      get: function get() {
        return this._pieRenderable.getWaterColor();
      },
      set: function set(color) {
        this._pieRenderable.setWaterColor(color);
      }
    }]);
    return RenderRiver;
  }(RenderPolygon3D);

  var RenderWater = /*#__PURE__*/function (_RenderPolygon3D) {
    _inherits(RenderWater, _RenderPolygon3D);
    var _super = _createSuper(RenderWater);
    function RenderWater(options) {
      var _this;
      _classCallCheck(this, RenderWater);
      _this = _super.call(this);
      if (!options) {
        _this._pieRenderable = new PIERenderWater();
      } else {
        if (options.handle) {
          _this._pieRenderable = options.handle;
        } else {
          var opt = {};
          if (options.file) opt.file = options.file;
          if (options.url) opt.url = options.url;
          if (options.fillEffect) opt.fillEffect = options.fillEffect;
          _this._pieRenderable = new PIERenderWater(opt);
        }
      }
      return _this;
    }
    _createClass(RenderWater, [{
      key: "fillEffect",
      get: function get() {
        return this._pieRenderable.getFillEffect();
      },
      set: function set(effect) {
        this._pieRenderable.setFillEffect(effect);
      }
    }, {
      key: "normalTexture",
      get: function get() {
        return this._pieRenderable.getNormalTexture();
      },
      set: function set(texture) {
        this._pieRenderable.setNormalTexture(texture);
      }
    }, {
      key: "waterScale",
      get: function get() {
        return this._pieRenderable.getWaterScale();
      },
      set: function set(scale) {
        this._pieRenderable.setWaterScale(scale);
      }
    }, {
      key: "waterColor",
      get: function get() {
        return this._pieRenderable.getWaterColor();
      },
      set: function set(color) {
        this._pieRenderable.setWaterColor(color);
      }
    }]);
    return RenderWater;
  }(RenderPolygon3D);

  var RenderableFactory = /*#__PURE__*/function () {
    function RenderableFactory() {
      _classCallCheck(this, RenderableFactory);
    }
    _createClass(RenderableFactory, null, [{
      key: "createInstance",
      value: function createInstance(renderable) {
        var type = renderable.getType();
        if (type == 'RenderModel') return new RenderModel({
          handle: renderable
        });
        if (type == 'RenderPoint') return new RenderPoint({
          handle: renderable
        });
        if (type == 'RenderPoint3D') return new RenderPoint3D({
          handle: renderable
        });
        if (type == 'RenderPolygon') return new RenderPolygon({
          handle: renderable
        });
        if (type == 'RenderPolygon3D') return new RenderPolygon3D({
          handle: renderable
        });
        if (type == 'RenderPolyline') return new RenderPolyline({
          handle: renderable
        });
        if (type == 'RenderPolyline3D') return new RenderPolyline3D({
          handle: renderable
        });
        if (type == 'RenderText') return new RenderText({
          handle: renderable
        });
        if (type == 'RenderText3D') return new RenderText3D({
          handle: renderable
        });
        if (type == 'RenderRiver') return new RenderRiver({
          handle: renderable
        });
        if (type == 'RenderWater') return new RenderWater({
          handle: renderable
        });
      }
    }]);
    return RenderableFactory;
  }();

  var RenderableDataSource = /*#__PURE__*/function (_DataSource) {
    _inherits(RenderableDataSource, _DataSource);
    var _super = _createSuper(RenderableDataSource);
    function RenderableDataSource() {
      var _this;
      _classCallCheck(this, RenderableDataSource);
      _this = _super.call(this);
      _this._layer = new PIEGlobeRenderableLayer();
      return _this;
    }
    _createClass(RenderableDataSource, [{
      key: "count",
      get: function get() {
        return this._layer.getCount();
      }
    }, {
      key: "add",
      value: function add(renderable) {
        return this._layer.add(renderable._pieRenderable);
      }
    }, {
      key: "getAt",
      value: function getAt(index) {
        var renderable = this._layer.getAt(index);
        return RenderableFactory.createInstance(renderable);
      }
    }, {
      key: "get",
      value: function get(id) {
        var renderable = this._layer.get(id);
        return RenderableFactory.createInstance(renderable);
      }
    }, {
      key: "remove",
      value: function remove(id) {
        return this._layer.remove(id);
      }
    }, {
      key: "removeAt",
      value: function removeAt(index) {
        return this._layer.removeAt(index);
      }
    }, {
      key: "removeAll",
      value: function removeAll() {
        return this._layer.removeAll();
      }
    }, {
      key: "getSelection",
      value: function getSelection() {
        return this._layer.getSelection();
      }
    }, {
      key: "clearSelection",
      value: function clearSelection() {
        return this._layer.clearSelection();
      }
    }, {
      key: "setSelectable",
      value: function setSelectable(selectable) {
        return this._layer.setSelectable(selectable);
      }
    }, {
      key: "isSelectable",
      value: function isSelectable() {
        return this._layer.isSelectable();
      }
    }, {
      key: "updateGeometry",
      value: function updateGeometry(geometry) {
        this._layer.updateGeometry(geometry.handle);
      }
    }]);
    return RenderableDataSource;
  }(DataSource$1);

  var DiffusionMaterial = /*#__PURE__*/function (_ShaderMaterial) {
    _inherits(DiffusionMaterial, _ShaderMaterial);
    var _super = _createSuper(DiffusionMaterial);
    function DiffusionMaterial(options) {
      var _this;
      _classCallCheck(this, DiffusionMaterial);
      _this = _super.call(this);
      _this.uniforms = {
        frameNumber: {
          value: 0
        },
        color: {
          value: options === null || options === void 0 ? void 0 : options.color
        }
      };
      _this.vertexShader = /*glsl*/"\n        varying vec2 vUV;\n            varying vec2 vUv;\n            void main()\n            {\n                vUv = uv;\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ";
      _this.fragmentShader = /*glsl*/"\n             uniform vec3 color;\n            uniform float frameNumber;\n      \n      \n            vec3 RadarPing(in vec2 uvToCenter, in float innerWidth,\n                        in float outerWidth, in float timeResetSeconds,\n                        in float speed, in float fadeDistance, float frameNumber)\n            {    \n                //\u8BA1\u7B97\u534A\u5F84 \n                float r = length(uvToCenter);\n                \n                //time\u53D6\u503C0-3\n                float time =mod(frameNumber*0.01, timeResetSeconds) * speed;\n      \n                float circle;\n                \n                //\u6837\u6761\u53D6\u503C\uFF0Ct\u4E3A\u5E73\u79FB\u53D8\u91CF\n                //\u4ECEtime- innerWidth\u5230time\u9010\u6E10\u53D8\u5927\n                circle += smoothstep(time - innerWidth, time, r);\n                  //\u4ECEtime\u5230time + outerWidth\u9010\u6E10\u53D8\u5927\n                circle*= smoothstep(time + outerWidth,time, r);\n                // if(r>time-innerTail&&r<time + frontierBorder){\n                //     circle=1.0;\n                // }\n                // \u6E10\u53D8\uFF0C\u968F\u7740\u534A\u5F84\u53D8\u5316\uFF0C\u989C\u8272\u53D8\u6DE1,r>fadeDistance\u4E3A0\uFF0C0-fadeDistance\u9010\u6E10\u53D8\u5C0F\n                circle *= smoothstep(fadeDistance, 0.0, r); // fade to 0 after fadeDistance\n      \n                return vec3(circle);\n            }\n      \n      \n            varying vec2 vUv;\n            void main(void)\n            {\n                //\u8F6C\u6362\u4E3A\u5230\u76F8\u5BF9\u4E8E\u4E2D\u5FC3\u70B9\u7684\u5750\u6807\n                vec2 uvToCenter = -1.0 + 2.0 *vUv;\n\n                vec3 newColor;\n                float fadeDistance =1.0;\n                float resetTimeSec = 3.0;\n                float speed = 0.2;\n                float innerWidth=0.07;\n                float outerWidth=0.01;\n               \n                newColor += RadarPing(uvToCenter,  innerWidth, outerWidth, resetTimeSec, speed, fadeDistance,frameNumber) * color;\n                newColor += RadarPing(uvToCenter, innerWidth, outerWidth, resetTimeSec, speed, fadeDistance,frameNumber + 200.) * color;\n                newColor += RadarPing(uvToCenter, innerWidth, outerWidth, resetTimeSec, speed, fadeDistance, frameNumber + 400.) * color;\n      \n                gl_FragColor =  vec4(newColor,1.0);\n            }\n        ";
      _this.depthTest = true;
      _this.depthWrite = false;
      _this.side = DoubleSide$1;
      _this.transparent = true;
      _this.blending = AdditiveBlending;
      return _this;
    }
    _createClass(DiffusionMaterial, [{
      key: "getUniforms",
      value: function getUniforms() {
        return this.uniforms;
      }
    }]);
    return DiffusionMaterial;
  }(ShaderMaterial);

  var FlowMaterial = /*#__PURE__*/function (_ShaderMaterial) {
    _inherits(FlowMaterial, _ShaderMaterial);
    var _super = _createSuper(FlowMaterial);
    function FlowMaterial(options) {
      var _this;
      _classCallCheck(this, FlowMaterial);
      _this = _super.call(this);
      options.map.magFilter = NearestFilter;
      options.map.minFilter = NearestFilter;
      _this.uniforms = {
        frameNumber: {
          value: 0
        },
        repeat: {
          value: options.repeat
        },
        flowSpeed: {
          value: options.flowSpeed
        },
        map: {
          value: options.map
        }
      };
      _this.vertexShader = /*glsl*/"varying vec2 vUV;\n            void main(){\n                vUV=uv;\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n            }\n        ";
      _this.fragmentShader = /*glsl*/"\n            uniform sampler2D map;\n            uniform float frameNumber;\n            uniform vec2 repeat;\n            uniform vec2 flowSpeed;\n            varying vec2 vUV;\n            void main(){\n                vec4 color=texture2D(map,fract(vec2(repeat.x*vUV.x-frameNumber*flowSpeed.x,repeat.y*vUV.y-frameNumber*flowSpeed.y)));\n                gl_FragColor=vec4(color.rgb,color.a);\n            }    \n        ";
      _this.depthTest = true;
      _this.depthWrite = false;
      _this.side = DoubleSide$1;
      _this.transparent = true;
      // this.blending = CustomBlending
      // this.blendSrc = OneFactor
      // this.blendDst = OneMinusSrcAlphaFactor
      // this.anisotropy = 0
      // this.magFilter = NearestFilter;
      // this.minFilter = NearestFilter;
      _this.blending = NormalBlending;
      _this.dithering = true;
      _this.alphaTest = 1.0;
      // this.colorWrite = true
      // this.stencilWrite = true
      // this.polygonOffset = true
      // this.polygonOffsetFactor = 100
      // this.dithering =false
      return _this;
    }
    _createClass(FlowMaterial, [{
      key: "getUniforms",
      value: function getUniforms() {
        return this.uniforms;
      }
    }]);
    return FlowMaterial;
  }(ShaderMaterial);

  var IceMaterial = /*#__PURE__*/function (_MeshPhongMaterial) {
    _inherits(IceMaterial, _MeshPhongMaterial);
    var _super = _createSuper(IceMaterial);
    function IceMaterial(_ref) {
      var _this;
      var _ref$textureUrl = _ref.textureUrl,
        textureUrl = _ref$textureUrl === void 0 ? './' : _ref$textureUrl,
        map = _ref.map,
        _ref$refractionRatio = _ref.refractionRatio,
        refractionRatio = _ref$refractionRatio === void 0 ? 0.4 : _ref$refractionRatio,
        _ref$reflectivity = _ref.reflectivity,
        reflectivity = _ref$reflectivity === void 0 ? 0.7 : _ref$reflectivity;
      _classCallCheck(this, IceMaterial);
      _this = _super.call(this);
      var normalMap = new TextureLoader().load(textureUrl + '/textures/normal.jpg');
      var path = textureUrl + '/textures/cube/ice/';
      var format = '.jpg';
      var urls = [path + 'px' + format, path + 'nx' + format, path + 'py' + format, path + 'ny' + format, path + 'pz' + format, path + 'nz' + format];
      var reflectionCube = new CubeTextureLoader().load(urls);
      _this.transparent = true;
      _this.combine = MixOperation;
      // this.emissive = new Color(0xffffff)
      _this.opacity = 1.0;
      _this.map = map || null;
      _this.color = new Color$2(0xffffff);
      _this.normalScale = new Vector2(8.0, 8.0);
      _this.normalMap = normalMap;
      _this.envMap = reflectionCube;
      _this.refractionRatio = refractionRatio;
      _this.reflectivity = reflectivity;
      return _this;
    }
    return _createClass(IceMaterial);
  }(MeshPhongMaterial);

  var MaterialType = {
    Basic: 0,
    Depth: 1,
    Distance: 2,
    Lambert: 3,
    Matcap: 4,
    Normal: 5,
    Phong: 6,
    Physical: 7,
    Standard: 8,
    Toon: 9,
    Custom: 10,
    Diffusion: 101,
    Flow: 102,
    Ice: 103
  };
  var Material = /*#__PURE__*/function () {
    function Material(_ref) {
      var _ref$type = _ref.type,
        type = _ref$type === void 0 ? MaterialType.Basic : _ref$type,
        fabric = _ref.fabric;
      _classCallCheck(this, Material);
      var textureLoader = new TextureLoader();
      for (var key in fabric) {
        if (key.indexOf('map') > -1 || key.indexOf('Map') > -1) {
          //判断是图片，转为纹理     
          fabric[key] = textureLoader.load(fabric[key]);
        } else if (fabric[key] instanceof Color$1) {
          fabric.opacity = fabric[key].alpha;
          fabric[key] = new Color$2(fabric[key].red, fabric[key].green, fabric[key].blue);
        }
      }
      if (type === MaterialType.Custom) {
        var uniforms = fabric.uniforms;
        if (uniforms) {
          for (var _key in uniforms) {
            if (uniforms[_key].value instanceof Color$1) {
              uniforms[_key].value = new Color$2(uniforms[_key].value.red, uniforms[_key].value.green, uniforms[_key].value.blue);
            } else if (_key.indexOf('map') > -1 || _key.indexOf('Map') > -1) {
              //判断是图片，转为纹理     
              uniforms[_key].value = textureLoader.load(uniforms[_key]);
            }
          }
        }
        fabric.uniforms = _objectSpread2(_objectSpread2({}, uniforms), {}, {
          frameNumber: {
            value: 0
          }
        });
      }
      var materialOption = fabric;
      switch (type) {
        case MaterialType.Basic:
          {
            return new MeshBasicMaterial$1(materialOption);
          }
        case MaterialType.Depth:
          {
            return new MeshDepthMaterial(materialOption);
          }
        case MaterialType.Distance:
          {
            return new MeshDistanceMaterial(materialOption);
          }
        case MaterialType.Lambert:
          {
            return new MeshLambertMaterial(materialOption);
          }
        case MaterialType.Matcap:
          {
            return new MeshMatcapMaterial(materialOption);
          }
        case MaterialType.Normal:
          {
            return new MeshNormalMaterial(materialOption);
          }
        case MaterialType.Phong:
          {
            return new MeshPhongMaterial(materialOption);
          }
        case MaterialType.Physical:
          {
            return new MeshPhysicalMaterial(materialOption);
          }
        case MaterialType.Standard:
          {
            return new MeshStandardMaterial(materialOption);
          }
        case MaterialType.Toon:
          {
            return new MeshToonMaterial(materialOption);
          }
        case MaterialType.Diffusion:
          {
            return new DiffusionMaterial(materialOption);
          }
        case MaterialType.Flow:
          {
            return new FlowMaterial(materialOption);
          }
        case MaterialType.Ice:
          {
            return new IceMaterial(materialOption);
          }
        case MaterialType.Custom:
          {
            return new ShaderMaterial(materialOption);
          }
        default:
          {
            throw new Error('请选择材质类型！');
          }
      }
    }
    //判断图片是否存在
    _createClass(Material, [{
      key: "is_img_url",
      value: function is_img_url(imgurl) {
        return new Promise(function (resolve, reject) {
          var ImgObj = new Image(); //判断图片是否存在
          ImgObj.src = imgurl;
          ImgObj.onload = function (res) {
            resolve(res);
          };
          ImgObj.onerror = function (err) {
            reject(err);
          };
        })["catch"](function (e) {}); // 加上这句不会报错（Uncaught (in promise)）
      }
    }]);
    return Material;
  }();

  var quadraticBezierCurve3 = function quadraticBezierCurve3(startPosition, endPosition, maxHeight) {
    var curve = new QuadraticBezierCurve3(new Vector3(startPosition.x, startPosition.y, startPosition.z), new Vector3((startPosition.x + endPosition.x + endPosition.x) / 3, (startPosition.y + endPosition.y + endPosition.y) / 3, maxHeight), new Vector3(endPosition.x, endPosition.y, endPosition.z));
    var points = curve.getPoints(100);
    var positions = [];
    // //百分比
    // var percents: any[] = [];

    // 给每个顶点设置演示 实现渐变
    for (var j = 0; j < points.length; j++) {
      //修改为世界坐标
      var point = PIEVector3.sphericalToCartesian(points[j].x * Math.PI / 180, points[j].y * Math.PI / 180, 6378137 + points[j].z);
      positions.push(new Cartesian3(point.x, point.y, point.z));
    }
    return positions;
  };

  var globals = function globals(defs) {
    defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
    defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
    defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
    defs.WGS84 = defs['EPSG:4326'];
    defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
    defs.GOOGLE = defs['EPSG:3857'];
    defs['EPSG:900913'] = defs['EPSG:3857'];
    defs['EPSG:102113'] = defs['EPSG:3857'];
  };
  var PJD_3PARAM = 1;
  var PJD_7PARAM = 2;
  var PJD_GRIDSHIFT = 3;
  var PJD_WGS84 = 4; // WGS84 or equivalent
  var PJD_NODATUM = 5; // WGS84 or equivalent
  var SRS_WGS84_SEMIMAJOR = 6378137.0; // only used in grid shift transforms
  var SRS_WGS84_SEMIMINOR = 6356752.314; // only used in grid shift transforms
  var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
  var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
  var HALF_PI = Math.PI / 2;
  // ellipoid pj_set_ell.c
  var SIXTH = 0.1666666666666666667;
  /* 1/6 */
  var RA4 = 0.04722222222222222222;
  /* 17/360 */
  var RA6 = 0.02215608465608465608;
  var EPSLN = 1.0e-10;
  // you'd think you could use Number.EPSILON above but that makes
  // Mollweide get into an infinate loop.

  var D2R = 0.01745329251994329577;
  var R2D = 57.29577951308232088;
  var FORTPI = Math.PI / 4;
  var TWO_PI = Math.PI * 2;
  // SPI is slightly greater than Math.PI, so values that exceed the -180..180
  // degree range by a tiny amount don't get wrapped. This prevents points that
  // have drifted from their original location along the 180th meridian (due to
  // floating point error) from changing their sign.
  var SPI = 3.14159265359;
  var exports$1 = {};
  exports$1.greenwich = 0.0; //"0dE",
  exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
  exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
  exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
  exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
  exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
  exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
  exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
  exports$1.ferro = -17.666666666667; //"17d40'W",
  exports$1.brussels = 4.367975; //"4d22'4.71\"E",
  exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
  exports$1.athens = 23.7163375; //"23d42'58.815\"E",
  exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

  var _units = {
    ft: {
      to_meter: 0.3048
    },
    'us-ft': {
      to_meter: 1200 / 3937
    }
  };
  var ignoredChar = /[\s_\-\/\(\)]/g;
  function match(obj, key) {
    if (obj[key]) {
      return obj[key];
    }
    var keys = Object.keys(obj);
    var lkey = key.toLowerCase().replace(ignoredChar, '');
    var i = -1;
    var testkey, processedKey;
    while (++i < keys.length) {
      testkey = keys[i];
      processedKey = testkey.toLowerCase().replace(ignoredChar, '');
      if (processedKey === lkey) {
        return obj[testkey];
      }
    }
  }
  var parseProj = function parseProj(defData) {
    var self = {};
    var paramObj = defData.split('+').map(function (v) {
      return v.trim();
    }).filter(function (a) {
      return a;
    }).reduce(function (p, a) {
      var split = a.split('=');
      split.push(true);
      p[split[0].toLowerCase()] = split[1];
      return p;
    }, {});
    var paramName, paramVal, paramOutname;
    var params = {
      proj: 'projName',
      datum: 'datumCode',
      rf: function rf(v) {
        self.rf = parseFloat(v);
      },
      lat_0: function lat_0(v) {
        self.lat0 = v * D2R;
      },
      lat_1: function lat_1(v) {
        self.lat1 = v * D2R;
      },
      lat_2: function lat_2(v) {
        self.lat2 = v * D2R;
      },
      lat_ts: function lat_ts(v) {
        self.lat_ts = v * D2R;
      },
      lon_0: function lon_0(v) {
        self.long0 = v * D2R;
      },
      lon_1: function lon_1(v) {
        self.long1 = v * D2R;
      },
      lon_2: function lon_2(v) {
        self.long2 = v * D2R;
      },
      alpha: function alpha(v) {
        self.alpha = parseFloat(v) * D2R;
      },
      gamma: function gamma(v) {
        self.rectified_grid_angle = parseFloat(v);
      },
      lonc: function lonc(v) {
        self.longc = v * D2R;
      },
      x_0: function x_0(v) {
        self.x0 = parseFloat(v);
      },
      y_0: function y_0(v) {
        self.y0 = parseFloat(v);
      },
      k_0: function k_0(v) {
        self.k0 = parseFloat(v);
      },
      k: function k(v) {
        self.k0 = parseFloat(v);
      },
      a: function a(v) {
        self.a = parseFloat(v);
      },
      b: function b(v) {
        self.b = parseFloat(v);
      },
      r_a: function r_a() {
        self.R_A = true;
      },
      zone: function zone(v) {
        self.zone = parseInt(v, 10);
      },
      south: function south() {
        self.utmSouth = true;
      },
      towgs84: function towgs84(v) {
        self.datum_params = v.split(",").map(function (a) {
          return parseFloat(a);
        });
      },
      to_meter: function to_meter(v) {
        self.to_meter = parseFloat(v);
      },
      units: function units(v) {
        self.units = v;
        var unit = match(_units, v);
        if (unit) {
          self.to_meter = unit.to_meter;
        }
      },
      from_greenwich: function from_greenwich(v) {
        self.from_greenwich = v * D2R;
      },
      pm: function pm(v) {
        var pm = match(exports$1, v);
        self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
      },
      nadgrids: function nadgrids(v) {
        if (v === '@null') {
          self.datumCode = 'none';
        } else {
          self.nadgrids = v;
        }
      },
      axis: function axis(v) {
        var legalAxis = "ewnsud";
        if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
          self.axis = v;
        }
      },
      approx: function approx() {
        self.approx = true;
      }
    };
    for (paramName in paramObj) {
      paramVal = paramObj[paramName];
      if (paramName in params) {
        paramOutname = params[paramName];
        if (typeof paramOutname === 'function') {
          paramOutname(paramVal);
        } else {
          self[paramOutname] = paramVal;
        }
      } else {
        self[paramName] = paramVal;
      }
    }
    if (typeof self.datumCode === 'string' && self.datumCode !== "WGS84") {
      self.datumCode = self.datumCode.toLowerCase();
    }
    return self;
  };
  var NEUTRAL = 1;
  var KEYWORD = 2;
  var NUMBER = 3;
  var QUOTED = 4;
  var AFTERQUOTE = 5;
  var ENDED = -1;
  var whitespace = /\s/;
  var latin = /[A-Za-z]/;
  var keyword = /[A-Za-z84_]/;
  var endThings = /[,\]]/;
  var digets = /[\d\.E\-\+]/;
  // const ignoredChar = /[\s_\-\/\(\)]/g;
  function Parser(text) {
    if (typeof text !== 'string') {
      throw new Error('not a string');
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
  }
  Parser.prototype.readCharicter = function () {
    var _char = this.text[this.place++];
    if (this.state !== QUOTED) {
      while (whitespace.test(_char)) {
        if (this.place >= this.text.length) {
          return;
        }
        _char = this.text[this.place++];
      }
    }
    switch (this.state) {
      case NEUTRAL:
        return this.neutral(_char);
      case KEYWORD:
        return this.keyword(_char);
      case QUOTED:
        return this.quoted(_char);
      case AFTERQUOTE:
        return this.afterquote(_char);
      case NUMBER:
        return this.number(_char);
      case ENDED:
        return;
    }
  };
  Parser.prototype.afterquote = function (_char2) {
    if (_char2 === '"') {
      this.word += '"';
      this.state = QUOTED;
      return;
    }
    if (endThings.test(_char2)) {
      this.word = this.word.trim();
      this.afterItem(_char2);
      return;
    }
    throw new Error('havn\'t handled "' + _char2 + '" in afterquote yet, index ' + this.place);
  };
  Parser.prototype.afterItem = function (_char3) {
    if (_char3 === ',') {
      if (this.word !== null) {
        this.currentObject.push(this.word);
      }
      this.word = null;
      this.state = NEUTRAL;
      return;
    }
    if (_char3 === ']') {
      this.level--;
      if (this.word !== null) {
        this.currentObject.push(this.word);
        this.word = null;
      }
      this.state = NEUTRAL;
      this.currentObject = this.stack.pop();
      if (!this.currentObject) {
        this.state = ENDED;
      }
      return;
    }
  };
  Parser.prototype.number = function (_char4) {
    if (digets.test(_char4)) {
      this.word += _char4;
      return;
    }
    if (endThings.test(_char4)) {
      this.word = parseFloat(this.word);
      this.afterItem(_char4);
      return;
    }
    throw new Error('havn\'t handled "' + _char4 + '" in number yet, index ' + this.place);
  };
  Parser.prototype.quoted = function (_char5) {
    if (_char5 === '"') {
      this.state = AFTERQUOTE;
      return;
    }
    this.word += _char5;
    return;
  };
  Parser.prototype.keyword = function (_char6) {
    if (keyword.test(_char6)) {
      this.word += _char6;
      return;
    }
    if (_char6 === '[') {
      var newObjects = [];
      newObjects.push(this.word);
      this.level++;
      if (this.root === null) {
        this.root = newObjects;
      } else {
        this.currentObject.push(newObjects);
      }
      this.stack.push(this.currentObject);
      this.currentObject = newObjects;
      this.state = NEUTRAL;
      return;
    }
    if (endThings.test(_char6)) {
      this.afterItem(_char6);
      return;
    }
    throw new Error('havn\'t handled "' + _char6 + '" in keyword yet, index ' + this.place);
  };
  Parser.prototype.neutral = function (_char7) {
    if (latin.test(_char7)) {
      this.word = _char7;
      this.state = KEYWORD;
      return;
    }
    if (_char7 === '"') {
      this.word = '';
      this.state = QUOTED;
      return;
    }
    if (digets.test(_char7)) {
      this.word = _char7;
      this.state = NUMBER;
      return;
    }
    if (endThings.test(_char7)) {
      this.afterItem(_char7);
      return;
    }
    throw new Error('havn\'t handled "' + _char7 + '" in neutral yet, index ' + this.place);
  };
  Parser.prototype.output = function () {
    while (this.place < this.text.length) {
      this.readCharicter();
    }
    if (this.state === ENDED) {
      return this.root;
    }
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
  };
  function parseString(txt) {
    var parser = new Parser(txt);
    return parser.output();
  }
  function mapit(obj, key, value) {
    if (Array.isArray(key)) {
      value.unshift(key);
      key = null;
    }
    var thing = key ? {} : obj;
    var out = value.reduce(function (newObj, item) {
      sExpr(item, newObj);
      return newObj;
    }, thing);
    if (key) {
      obj[key] = out;
    }
  }
  function sExpr(v, obj) {
    if (!Array.isArray(v)) {
      obj[v] = true;
      return;
    }
    var key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
        return;
      }
      obj[key] = v[0];
      return;
    }
    if (!v.length) {
      obj[key] = true;
      return;
    }
    if (key === 'TOWGS84') {
      obj[key] = v;
      return;
    }
    if (key === 'AXIS') {
      if (!(key in obj)) {
        obj[key] = [];
      }
      obj[key].push(v);
      return;
    }
    if (!Array.isArray(key)) {
      obj[key] = {};
    }
    var i;
    switch (key) {
      case 'UNIT':
      case 'PRIMEM':
      case 'VERT_DATUM':
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          sExpr(v[2], obj[key]);
        }
        return;
      case 'SPHEROID':
      case 'ELLIPSOID':
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          sExpr(v[3], obj[key]);
        }
        return;
      case 'PROJECTEDCRS':
      case 'PROJCRS':
      case 'GEOGCS':
      case 'GEOCCS':
      case 'PROJCS':
      case 'LOCAL_CS':
      case 'GEODCRS':
      case 'GEODETICCRS':
      case 'GEODETICDATUM':
      case 'EDATUM':
      case 'ENGINEERINGDATUM':
      case 'VERT_CS':
      case 'VERTCRS':
      case 'VERTICALCRS':
      case 'COMPD_CS':
      case 'COMPOUNDCRS':
      case 'ENGINEERINGCRS':
      case 'ENGCRS':
      case 'FITTED_CS':
      case 'LOCAL_DATUM':
      case 'DATUM':
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
        return;
      default:
        i = -1;
        while (++i < v.length) {
          if (!Array.isArray(v[i])) {
            return sExpr(v, obj[key]);
          }
        }
        return mapit(obj, key, v);
    }
  }
  var D2R$1 = 0.01745329251994329577;
  function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && inName in obj) {
      obj[outName] = obj[inName];
      if (params.length === 3) {
        obj[outName] = params[2](obj[outName]);
      }
    }
  }
  function d2r(input) {
    return input * D2R$1;
  }
  function cleanWKT(wkt) {
    if (wkt.type === 'GEOGCS') {
      wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
      wkt.projName = 'identity';
      wkt.local = true;
    } else {
      if (_typeof(wkt.PROJECTION) === 'object') {
        wkt.projName = Object.keys(wkt.PROJECTION)[0];
      } else {
        wkt.projName = wkt.PROJECTION;
      }
    }
    if (wkt.AXIS) {
      var axisOrder = '';
      for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
        var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
        if (axis[0].indexOf('north') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north') {
          axisOrder += 'n';
        } else if (axis[0].indexOf('south') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south') {
          axisOrder += 's';
        } else if (axis[0].indexOf('east') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east') {
          axisOrder += 'e';
        } else if (axis[0].indexOf('west') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west') {
          axisOrder += 'w';
        }
      }
      if (axisOrder.length === 2) {
        axisOrder += 'u';
      }
      if (axisOrder.length === 3) {
        wkt.axis = axisOrder;
      }
    }
    if (wkt.UNIT) {
      wkt.units = wkt.UNIT.name.toLowerCase();
      if (wkt.units === 'metre') {
        wkt.units = 'meter';
      }
      if (wkt.UNIT.convert) {
        if (wkt.type === 'GEOGCS') {
          if (wkt.DATUM && wkt.DATUM.SPHEROID) {
            wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
          }
        } else {
          wkt.to_meter = wkt.UNIT.convert;
        }
      }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === 'GEOGCS') {
      geogcs = wkt;
    }
    if (geogcs) {
      //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
      //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
      //}
      if (geogcs.DATUM) {
        wkt.datumCode = geogcs.DATUM.name.toLowerCase();
      } else {
        wkt.datumCode = geogcs.name.toLowerCase();
      }
      if (wkt.datumCode.slice(0, 2) === 'd_') {
        wkt.datumCode = wkt.datumCode.slice(2);
      }
      if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
        wkt.datumCode = 'nzgd49';
      }
      if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
        if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
          wkt.sphere = true;
        }
        wkt.datumCode = 'wgs84';
      }
      if (wkt.datumCode.slice(-6) === '_ferro') {
        wkt.datumCode = wkt.datumCode.slice(0, -6);
      }
      if (wkt.datumCode.slice(-8) === '_jakarta') {
        wkt.datumCode = wkt.datumCode.slice(0, -8);
      }
      if (~wkt.datumCode.indexOf('belge')) {
        wkt.datumCode = 'rnb72';
      }
      if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
        wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
        if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
          wkt.ellps = 'intl';
        }
        wkt.a = geogcs.DATUM.SPHEROID.a;
        wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
      }
      if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
        wkt.datum_params = geogcs.DATUM.TOWGS84;
      }
      if (~wkt.datumCode.indexOf('osgb_1936')) {
        wkt.datumCode = 'osgb36';
      }
      if (~wkt.datumCode.indexOf('osni_1952')) {
        wkt.datumCode = 'osni52';
      }
      if (~wkt.datumCode.indexOf('tm65') || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
        wkt.datumCode = 'ire65';
      }
      if (wkt.datumCode === 'ch1903+') {
        wkt.datumCode = 'ch1903';
      }
      if (~wkt.datumCode.indexOf('israel')) {
        wkt.datumCode = 'isr93';
      }
    }
    if (wkt.b && !isFinite(wkt.b)) {
      wkt.b = wkt.a;
    }
    function toMeter(input) {
      var ratio = wkt.to_meter || 1;
      return input * ratio;
    }
    var renamer = function renamer(a) {
      return rename(wkt, a);
    };
    var list = [['standard_parallel_1', 'Standard_Parallel_1'], ['standard_parallel_1', 'Latitude of 1st standard parallel'], ['standard_parallel_2', 'Standard_Parallel_2'], ['standard_parallel_2', 'Latitude of 2nd standard parallel'], ['false_easting', 'False_Easting'], ['false_easting', 'False easting'], ['false-easting', 'Easting at false origin'], ['false_northing', 'False_Northing'], ['false_northing', 'False northing'], ['false_northing', 'Northing at false origin'], ['central_meridian', 'Central_Meridian'], ['central_meridian', 'Longitude of natural origin'], ['central_meridian', 'Longitude of false origin'], ['latitude_of_origin', 'Latitude_Of_Origin'], ['latitude_of_origin', 'Central_Parallel'], ['latitude_of_origin', 'Latitude of natural origin'], ['latitude_of_origin', 'Latitude of false origin'], ['scale_factor', 'Scale_Factor'], ['k0', 'scale_factor'], ['latitude_of_center', 'Latitude_Of_Center'], ['latitude_of_center', 'Latitude_of_center'], ['lat0', 'latitude_of_center', d2r], ['longitude_of_center', 'Longitude_Of_Center'], ['longitude_of_center', 'Longitude_of_center'], ['longc', 'longitude_of_center', d2r], ['x0', 'false_easting', toMeter], ['y0', 'false_northing', toMeter], ['long0', 'central_meridian', d2r], ['lat0', 'latitude_of_origin', d2r], ['lat0', 'standard_parallel_1', d2r], ['lat1', 'standard_parallel_1', d2r], ['lat2', 'standard_parallel_2', d2r], ['azimuth', 'Azimuth'], ['alpha', 'azimuth', d2r], ['srsCode', 'name']];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
      wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
      wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
      wkt.lat_ts = wkt.lat1;
    }
  }
  var wkt = function wkt(_wkt) {
    var lisp = parseString(_wkt);
    var type = lisp.shift();
    var name = lisp.shift();
    lisp.unshift(['name', name]);
    lisp.unshift(['type', type]);
    var obj = {};
    sExpr(lisp, obj);
    cleanWKT(obj);
    return obj;
  };
  function defs(name) {
    /*global console*/
    var that = this;
    if (arguments.length === 2) {
      var def = arguments[1];
      if (typeof def === 'string') {
        if (def.charAt(0) === '+') {
          defs[name] = parseProj(arguments[1]);
        } else {
          defs[name] = wkt(arguments[1]);
        }
      } else {
        defs[name] = def;
      }
    } else if (arguments.length === 1) {
      if (Array.isArray(name)) {
        return name.map(function (v) {
          if (Array.isArray(v)) {
            defs.apply(that, v);
          } else {
            defs(v);
          }
        });
      } else if (typeof name === 'string') {
        if (name in defs) {
          return defs[name];
        }
      } else if ('EPSG' in name) {
        defs['EPSG:' + name.EPSG] = name;
      } else if ('ESRI' in name) {
        defs['ESRI:' + name.ESRI] = name;
      } else if ('IAU2000' in name) {
        defs['IAU2000:' + name.IAU2000] = name;
      } else {
        console.log(name);
      }
      return;
    }
  }
  globals(defs);
  function testObj(code) {
    return typeof code === 'string';
  }
  function testDef(code) {
    return code in defs;
  }
  var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
  function testWKT(code) {
    return codeWords.some(function (word) {
      return code.indexOf(word) > -1;
    });
  }
  var codes = ['3857', '900913', '3785', '102113'];
  function checkMercator(item) {
    var auth = match(item, 'authority');
    if (!auth) {
      return;
    }
    var code = match(auth, 'epsg');
    return code && codes.indexOf(code) > -1;
  }
  function checkProjStr(item) {
    var ext = match(item, 'extension');
    if (!ext) {
      return;
    }
    return match(ext, 'proj4');
  }
  function testProj(code) {
    return code[0] === '+';
  }
  function parse(code) {
    if (testObj(code)) {
      //check to see if this is a WKT string
      if (testDef(code)) {
        return defs[code];
      }
      if (testWKT(code)) {
        var out = wkt(code);
        // test of spetial case, due to this being a very common and often malformed
        if (checkMercator(out)) {
          return defs['EPSG:3857'];
        }
        var maybeProjStr = checkProjStr(out);
        if (maybeProjStr) {
          return parseProj(maybeProjStr);
        }
        return out;
      }
      if (testProj(code)) {
        return parseProj(code);
      }
    } else {
      return code;
    }
  }
  var extend = function extend(destination, source) {
    destination = destination || {};
    var value, property;
    if (!source) {
      return destination;
    }
    for (property in source) {
      value = source[property];
      if (value !== undefined) {
        destination[property] = value;
      }
    }
    return destination;
  };
  var msfnz = function msfnz(eccent, sinphi, cosphi) {
    var con = eccent * sinphi;
    return cosphi / Math.sqrt(1 - con * con);
  };
  var sign$1 = function sign(x) {
    return x < 0 ? -1 : 1;
  };
  var adjust_lon = function adjust_lon(x) {
    return Math.abs(x) <= SPI ? x : x - sign$1(x) * TWO_PI;
  };
  var tsfnz = function tsfnz(eccent, phi, sinphi) {
    var con = eccent * sinphi;
    var com = 0.5 * eccent;
    con = Math.pow((1 - con) / (1 + con), com);
    return Math.tan(0.5 * (HALF_PI - phi)) / con;
  };
  var phi2z = function phi2z(eccent, ts) {
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALF_PI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
      con = eccent * Math.sin(phi);
      dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }
    //console.log("phi2z has NoConvergence");
    return -9999;
  };
  function init() {
    var con = this.b / this.a;
    this.es = 1 - con * con;
    if (!('x0' in this)) {
      this.x0 = 0;
    }
    if (!('y0' in this)) {
      this.y0 = 0;
    }
    this.e = Math.sqrt(this.es);
    if (this.lat_ts) {
      if (this.sphere) {
        this.k0 = Math.cos(this.lat_ts);
      } else {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    } else {
      if (!this.k0) {
        if (this.k) {
          this.k0 = this.k;
        } else {
          this.k0 = 1;
        }
      }
    }
  }

  /* Mercator forward equations--mapping lat,long to x,y
    --------------------------------------------------*/

  function forward(p) {
    var lon = p.x;
    var lat = p.y;
    // convert to radians
    if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
      return null;
    }
    var x, y;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      return null;
    } else {
      if (this.sphere) {
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
      } else {
        var sinphi = Math.sin(lat);
        var ts = tsfnz(this.e, lat, sinphi);
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 - this.a * this.k0 * Math.log(ts);
      }
      p.x = x;
      p.y = y;
      return p;
    }
  }

  /* Mercator inverse equations--mapping x,y to lat/long
    --------------------------------------------------*/
  function inverse(p) {
    var x = p.x - this.x0;
    var y = p.y - this.y0;
    var lon, lat;
    if (this.sphere) {
      lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
    } else {
      var ts = Math.exp(-y / (this.a * this.k0));
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    lon = adjust_lon(this.long0 + x / (this.a * this.k0));
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  var merc = {
    init: init,
    forward: forward,
    inverse: inverse,
    names: names$1
  };
  function init$1() {
    //no-op for longlat
  }
  function identity(pt) {
    return pt;
  }
  var names$2 = ["longlat", "identity"];
  var longlat = {
    init: init$1,
    forward: identity,
    inverse: identity,
    names: names$2
  };
  var projs = [merc, longlat];
  var names = {};
  var projStore = [];
  function add(proj, i) {
    var len = projStore.length;
    if (!proj.names) {
      console.log(i);
      return true;
    }
    projStore[len] = proj;
    proj.names.forEach(function (n) {
      names[n.toLowerCase()] = len;
    });
    return this;
  }
  function get(name) {
    if (!name) {
      return false;
    }
    var n = name.toLowerCase();
    if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
      return projStore[names[n]];
    }
  }
  function start() {
    projs.forEach(add);
  }
  var projections = {
    start: start,
    add: add,
    get: get
  };
  var exports$2 = {};
  exports$2.MERIT = {
    a: 6378137.0,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };
  exports$2.SGS85 = {
    a: 6378136.0,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };
  exports$2.GRS80 = {
    a: 6378137.0,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };
  exports$2.IAU76 = {
    a: 6378140.0,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };
  exports$2.airy = {
    a: 6377563.396,
    b: 6356256.910,
    ellipseName: "Airy 1830"
  };
  exports$2.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };
  exports$2.NWL9D = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };
  exports$2.mod_airy = {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: "Modified Airy"
  };
  exports$2.andrae = {
    a: 6377104.43,
    rf: 300.0,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };
  exports$2.aust_SA = {
    a: 6378160.0,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };
  exports$2.GRS67 = {
    a: 6378160.0,
    rf: 298.2471674270,
    ellipseName: "GRS 67(IUGG 1967)"
  };
  exports$2.bessel = {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };
  exports$2.bess_nam = {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };
  exports$2.clrk66 = {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: "Clarke 1866"
  };
  exports$2.clrk80 = {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };
  exports$2.clrk80ign = {
    a: 6378249.2,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  };
  exports$2.clrk58 = {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };
  exports$2.CPM = {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };
  exports$2.delmbr = {
    a: 6376428.0,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };
  exports$2.engelis = {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };
  exports$2.evrst30 = {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };
  exports$2.evrst48 = {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };
  exports$2.evrst56 = {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };
  exports$2.evrst69 = {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };
  exports$2.evrstSS = {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };
  exports$2.fschr60 = {
    a: 6378166.0,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };
  exports$2.fschr60m = {
    a: 6378155.0,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };
  exports$2.fschr68 = {
    a: 6378150.0,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };
  exports$2.helmert = {
    a: 6378200.0,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };
  exports$2.hough = {
    a: 6378270.0,
    rf: 297.0,
    ellipseName: "Hough"
  };
  exports$2.intl = {
    a: 6378388.0,
    rf: 297.0,
    ellipseName: "International 1909 (Hayford)"
  };
  exports$2.kaula = {
    a: 6378163.0,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };
  exports$2.lerch = {
    a: 6378139.0,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };
  exports$2.mprts = {
    a: 6397300.0,
    rf: 191.0,
    ellipseName: "Maupertius 1738"
  };
  exports$2.new_intl = {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: "New International 1967"
  };
  exports$2.plessis = {
    a: 6376523.0,
    rf: 6355863.0,
    ellipseName: "Plessis 1817 (France)"
  };
  exports$2.krass = {
    a: 6378245.0,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };
  exports$2.SEasia = {
    a: 6378155.0,
    b: 6356773.3205,
    ellipseName: "Southeast Asia"
  };
  exports$2.walbeck = {
    a: 6376896.0,
    b: 6355834.8467,
    ellipseName: "Walbeck"
  };
  exports$2.WGS60 = {
    a: 6378165.0,
    rf: 298.3,
    ellipseName: "WGS 60"
  };
  exports$2.WGS66 = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "WGS 66"
  };
  exports$2.WGS7 = {
    a: 6378135.0,
    rf: 298.26,
    ellipseName: "WGS 72"
  };
  var WGS84 = exports$2.WGS84 = {
    a: 6378137.0,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };
  exports$2.sphere = {
    a: 6370997.0,
    b: 6370997.0,
    ellipseName: "Normal Sphere (r=6370997)"
  };
  function eccentricity(a, b, rf, R_A) {
    var a2 = a * a; // used in geocentric
    var b2 = b * b; // used in geocentric
    var es = (a2 - b2) / a2; // e ^ 2
    var e = 0;
    if (R_A) {
      a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
      a2 = a * a;
      es = 0;
    } else {
      e = Math.sqrt(es); // eccentricity
    }

    var ep2 = (a2 - b2) / b2; // used in geocentric
    return {
      es: es,
      e: e,
      ep2: ep2
    };
  }
  function sphere(a, b, rf, ellps, sphere) {
    if (!a) {
      // do we have an ellipsoid?
      var ellipse = match(exports$2, ellps);
      if (!ellipse) {
        ellipse = WGS84;
      }
      a = ellipse.a;
      b = ellipse.b;
      rf = ellipse.rf;
    }
    if (rf && !b) {
      b = (1.0 - 1.0 / rf) * a;
    }
    if (rf === 0 || Math.abs(a - b) < EPSLN) {
      sphere = true;
      b = a;
    }
    return {
      a: a,
      b: b,
      rf: rf,
      sphere: sphere
    };
  }
  var exports$3 = {};
  exports$3.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  };
  exports$3.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  };
  exports$3.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  };
  exports$3.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  };
  exports$3.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  };
  exports$3.potsdam = {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  };
  exports$3.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  };
  exports$3.hermannskogel = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  };
  exports$3.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  };
  exports$3.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  };
  exports$3.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  };
  exports$3.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  };
  exports$3.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
  };
  exports$3.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
  };
  exports$3.beduaram = {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
  };
  exports$3.gunung_segara = {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
  };
  exports$3.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  };
  function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
    var out = {};
    if (datumCode === undefined || datumCode === 'none') {
      out.datum_type = PJD_NODATUM;
    } else {
      out.datum_type = PJD_WGS84;
    }
    if (datum_params) {
      out.datum_params = datum_params.map(parseFloat);
      if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
        out.datum_type = PJD_3PARAM;
      }
      if (out.datum_params.length > 3) {
        if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
          out.datum_type = PJD_7PARAM;
          out.datum_params[3] *= SEC_TO_RAD;
          out.datum_params[4] *= SEC_TO_RAD;
          out.datum_params[5] *= SEC_TO_RAD;
          out.datum_params[6] = out.datum_params[6] / 1000000.0 + 1.0;
        }
      }
    }
    if (nadgrids) {
      out.datum_type = PJD_GRIDSHIFT;
      out.grids = nadgrids;
    }
    out.a = a; //datum object also uses these values
    out.b = b;
    out.es = es;
    out.ep2 = ep2;
    return out;
  }

  /**
   * Resources for details of NTv2 file formats:
   * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
   * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
   */

  var loadedNadgrids = {};

  /**
   * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
   * as an ArrayBuffer.
   */
  function nadgrid(key, data) {
    var view = new DataView(data);
    var isLittleEndian = detectLittleEndian(view);
    var header = readHeader(view, isLittleEndian);
    if (header.nSubgrids > 1) {
      console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
    }
    var subgrids = readSubgrids(view, header, isLittleEndian);
    var nadgrid = {
      header: header,
      subgrids: subgrids
    };
    loadedNadgrids[key] = nadgrid;
    return nadgrid;
  }

  /**
   * Given a proj4 value for nadgrids, return an array of loaded grids
   */
  function getNadgrids(nadgrids) {
    // Format details: http://proj.maptools.org/gen_parms.html
    if (nadgrids === undefined) {
      return null;
    }
    var grids = nadgrids.split(',');
    return grids.map(parseNadgridString);
  }
  function parseNadgridString(value) {
    if (value.length === 0) {
      return null;
    }
    var optional = value[0] === '@';
    if (optional) {
      value = value.slice(1);
    }
    if (value === 'null') {
      return {
        name: 'null',
        mandatory: !optional,
        grid: null,
        isNull: true
      };
    }
    return {
      name: value,
      mandatory: !optional,
      grid: loadedNadgrids[value] || null,
      isNull: false
    };
  }
  function secondsToRadians(seconds) {
    return seconds / 3600 * Math.PI / 180;
  }
  function detectLittleEndian(view) {
    var nFields = view.getInt32(8, false);
    if (nFields === 11) {
      return false;
    }
    nFields = view.getInt32(8, true);
    if (nFields !== 11) {
      console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
    }
    return true;
  }
  function readHeader(view, isLittleEndian) {
    return {
      nFields: view.getInt32(8, isLittleEndian),
      nSubgridFields: view.getInt32(24, isLittleEndian),
      nSubgrids: view.getInt32(40, isLittleEndian),
      shiftType: decodeString(view, 56, 56 + 8).trim(),
      fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
      fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
      toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
      toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
    };
  }
  function decodeString(view, start, end) {
    return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
  }
  function readSubgrids(view, header, isLittleEndian) {
    var gridOffset = 176;
    var grids = [];
    for (var i = 0; i < header.nSubgrids; i++) {
      var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
      var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
      var lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
      var latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
      // Proj4 operates on radians whereas the coordinates are in seconds in the grid
      grids.push({
        ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
        del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
        lim: [lngColumnCount, latColumnCount],
        count: subHeader.gridNodeCount,
        cvs: mapNodes(nodes)
      });
    }
    return grids;
  }
  function mapNodes(nodes) {
    return nodes.map(function (r) {
      return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
    });
  }
  function readGridHeader(view, offset, isLittleEndian) {
    return {
      name: decodeString(view, offset + 8, offset + 16).trim(),
      parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
      lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
      upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
      lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
      upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
      latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
      longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
      gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
    };
  }
  function readGridNodes(view, offset, gridHeader, isLittleEndian) {
    var nodesOffset = offset + 176;
    var gridRecordLength = 16;
    var gridShiftRecords = [];
    for (var i = 0; i < gridHeader.gridNodeCount; i++) {
      var record = {
        latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
        longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
        latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
        longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
      };
      gridShiftRecords.push(record);
    }
    return gridShiftRecords;
  }
  function Projection(srsCode, callback) {
    if (!(this instanceof Projection)) {
      return new Projection(srsCode);
    }
    callback = callback || function (error) {
      if (error) {
        throw error;
      }
    };
    var json = parse(srsCode);
    if (_typeof(json) !== 'object') {
      callback(srsCode);
      return;
    }
    var ourProj = Projection.projections.get(json.projName);
    if (!ourProj) {
      callback(srsCode);
      return;
    }
    if (json.datumCode && json.datumCode !== 'none') {
      var datumDef = match(exports$3, json.datumCode);
      if (datumDef) {
        json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
        json.ellps = datumDef.ellipse;
        json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
      }
    }
    json.k0 = json.k0 || 1.0;
    json.axis = json.axis || 'enu';
    json.ellps = json.ellps || 'wgs84';
    json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

    var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
    var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
    var nadgrids = getNadgrids(json.nadgrids);
    var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);
    extend(this, json); // transfer everything over from the projection because we don't know what we'll need
    extend(this, ourProj); // transfer all the methods from the projection

    // copy the 4 things over we calculated in deriveConstants.sphere
    this.a = sphere_.a;
    this.b = sphere_.b;
    this.rf = sphere_.rf;
    this.sphere = sphere_.sphere;

    // copy the 3 things we calculated in deriveConstants.eccentricity
    this.es = ecc.es;
    this.e = ecc.e;
    this.ep2 = ecc.ep2;

    // add in the datum object
    this.datum = datumObj;

    // init the projection
    this.init();

    // legecy callback from back in the day when it went to spatialreference.org
    callback(null, this);
  }
  Projection.projections = projections;
  Projection.projections.start();
  function compareDatums(source, dest) {
    if (source.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
      // the tolerance for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    } else if (source.datum_type === PJD_3PARAM) {
      return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
    } else if (source.datum_type === PJD_7PARAM) {
      return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
    } else {
      return true; // datums are equal
    }
  } // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  function geodeticToGeocentric(p, es, a) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied

    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    } else if (Latitude < -HALF_PI) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return {
        x: -Infinity,
        y: -Infinity,
        z: p.z
      };
    } else if (Latitude > HALF_PI) {
      /* Latitude out of range */
      return {
        x: Infinity,
        y: Infinity,
        z: p.z
      };
    }
    if (Longitude > Math.PI) {
      Longitude -= 2 * Math.PI;
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = a / Math.sqrt(1.0e0 - es * Sin2_Lat);
    return {
      x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
      y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
      z: (Rn * (1 - es) + Height) * Sin_Lat
    };
  } // cs_geodetic_to_geocentric()

  function geocentricToGeodetic(p, es, a, b) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = genau * genau;
    var maxiter = 30;
    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;
    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / a < genau) {
      /*  special case, if P=0. (X=0., Y=0.) */
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / a < genau) {
        Latitude = HALF_PI;
        Height = -b;
        return {
          x: p.x,
          y: p.y,
          z: p.z
        };
      }
    } else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
    CPHI0 = ST * (1.0 - es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);
      RK = es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    } while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));
    return {
      x: Longitude,
      y: Latitude,
      z: Height
    };
  } // cs_geocentric_to_geodetic()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)

  /** point object, nothing fancy, just allows values to be
      passed back and forth by reference rather than by value.
      Other point classes may be used as long as they have
      x and y properties, which will get modified in the transform method.
  */
  function geocentricToWgs84(p, datum_type, datum_params) {
    if (datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x + datum_params[0],
        y: p.y + datum_params[1],
        z: p.z + datum_params[2]
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
        y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
        z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
      };
    }
  } // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  function geocentricFromWgs84(p, datum_type, datum_params) {
    if (datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x - datum_params[0],
        y: p.y - datum_params[1],
        z: p.z - datum_params[2]
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      return {
        x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
        y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
        z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
      };
    } //cs_geocentric_from_wgs84()
  }

  function checkParams(type) {
    return type === PJD_3PARAM || type === PJD_7PARAM;
  }
  var datum_transform = function datum_transform(source, dest, point) {
    // Short cut if the datums are identical.
    if (compareDatums(source, dest)) {
      return point; // in this case, zero is sucess,
      // whereas cs_compare_datums returns 1 to indicate TRUE
      // confusing, should fix this
    }

    // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
      return point;
    }

    // If this datum requires grid shifts, then apply it to geodetic coordinates.
    var source_a = source.a;
    var source_es = source.es;
    if (source.datum_type === PJD_GRIDSHIFT) {
      var gridShiftCode = applyGridShift(source, false, point);
      if (gridShiftCode !== 0) {
        return undefined;
      }
      source_a = SRS_WGS84_SEMIMAJOR;
      source_es = SRS_WGS84_ESQUARED;
    }
    var dest_a = dest.a;
    var dest_b = dest.b;
    var dest_es = dest.es;
    if (dest.datum_type === PJD_GRIDSHIFT) {
      dest_a = SRS_WGS84_SEMIMAJOR;
      dest_b = SRS_WGS84_SEMIMINOR;
      dest_es = SRS_WGS84_ESQUARED;
    }

    // Do we need to go through geocentric coordinates?
    if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
      return point;
    }

    // Convert to geocentric coordinates.
    point = geodeticToGeocentric(point, source_es, source_a);
    // Convert between datums
    if (checkParams(source.datum_type)) {
      point = geocentricToWgs84(point, source.datum_type, source.datum_params);
    }
    if (checkParams(dest.datum_type)) {
      point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
    }
    point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
    if (dest.datum_type === PJD_GRIDSHIFT) {
      var destGridShiftResult = applyGridShift(dest, true, point);
      if (destGridShiftResult !== 0) {
        return undefined;
      }
    }
    return point;
  };
  function applyGridShift(source, inverse, point) {
    if (source.grids === null || source.grids.length === 0) {
      console.log('Grid shift grids not found');
      return -1;
    }
    var input = {
      x: -point.x,
      y: point.y
    };
    var output = {
      x: Number.NaN,
      y: Number.NaN
    };
    var attemptedGrids = [];
    for (var i = 0; i < source.grids.length; i++) {
      var grid = source.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrid = grid.grid.subgrids[0];
      // skip tables that don't match our point at all
      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
      var minX = subgrid.ll[0] - epsilon;
      var minY = subgrid.ll[1] - epsilon;
      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
        continue;
      }
      output = applySubgridShift(input, inverse, subgrid);
      if (!isNaN(output.x)) {
        break;
      }
    }
    if (isNaN(output.x)) {
      console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
      return -1;
    }
    point.x = -output.x;
    point.y = output.y;
    return 0;
  }
  function applySubgridShift(pin, inverse, ct) {
    var val = {
      x: Number.NaN,
      y: Number.NaN
    };
    if (isNaN(pin.x)) {
      return val;
    }
    var tb = {
      x: pin.x,
      y: pin.y
    };
    tb.x -= ct.ll[0];
    tb.y -= ct.ll[1];
    tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
    var t = nadInterpolate(tb, ct);
    if (inverse) {
      if (isNaN(t.x)) {
        return val;
      }
      t.x = tb.x - t.x;
      t.y = tb.y - t.y;
      var i = 9,
        tol = 1e-12;
      var dif, del;
      do {
        del = nadInterpolate(t, ct);
        if (isNaN(del.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        dif = {
          x: tb.x - (del.x + t.x),
          y: tb.y - (del.y + t.y)
        };
        t.x += dif.x;
        t.y += dif.y;
      } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
      if (i < 0) {
        console.log("Inverse grid shift iterator failed to converge.");
        return val;
      }
      val.x = adjust_lon(t.x + ct.ll[0]);
      val.y = t.y + ct.ll[1];
    } else {
      if (!isNaN(t.x)) {
        val.x = pin.x + t.x;
        val.y = pin.y + t.y;
      }
    }
    return val;
  }
  function nadInterpolate(pin, ct) {
    var t = {
      x: pin.x / ct.del[0],
      y: pin.y / ct.del[1]
    };
    var indx = {
      x: Math.floor(t.x),
      y: Math.floor(t.y)
    };
    var frct = {
      x: t.x - 1.0 * indx.x,
      y: t.y - 1.0 * indx.y
    };
    var val = {
      x: Number.NaN,
      y: Number.NaN
    };
    var inx;
    if (indx.x < 0 || indx.x >= ct.lim[0]) {
      return val;
    }
    if (indx.y < 0 || indx.y >= ct.lim[1]) {
      return val;
    }
    inx = indx.y * ct.lim[0] + indx.x;
    var f00 = {
      x: ct.cvs[inx][0],
      y: ct.cvs[inx][1]
    };
    inx++;
    var f10 = {
      x: ct.cvs[inx][0],
      y: ct.cvs[inx][1]
    };
    inx += ct.lim[0];
    var f11 = {
      x: ct.cvs[inx][0],
      y: ct.cvs[inx][1]
    };
    inx--;
    var f01 = {
      x: ct.cvs[inx][0],
      y: ct.cvs[inx][1]
    };
    var m11 = frct.x * frct.y,
      m10 = frct.x * (1.0 - frct.y),
      m00 = (1.0 - frct.x) * (1.0 - frct.y),
      m01 = (1.0 - frct.x) * frct.y;
    val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
    val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
    return val;
  }
  var adjust_axis = function adjust_axis(crs, denorm, point) {
    var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
    var v, t, i;
    var out = {};
    for (i = 0; i < 3; i++) {
      if (denorm && i === 2 && point.z === undefined) {
        continue;
      }
      if (i === 0) {
        v = xin;
        if ("ew".indexOf(crs.axis[i]) !== -1) {
          t = 'x';
        } else {
          t = 'y';
        }
      } else if (i === 1) {
        v = yin;
        if ("ns".indexOf(crs.axis[i]) !== -1) {
          t = 'y';
        } else {
          t = 'x';
        }
      } else {
        v = zin;
        t = 'z';
      }
      switch (crs.axis[i]) {
        case 'e':
          out[t] = v;
          break;
        case 'w':
          out[t] = -v;
          break;
        case 'n':
          out[t] = v;
          break;
        case 's':
          out[t] = -v;
          break;
        case 'u':
          if (point[t] !== undefined) {
            out.z = v;
          }
          break;
        case 'd':
          if (point[t] !== undefined) {
            out.z = -v;
          }
          break;
        default:
          //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
          return null;
      }
    }
    return out;
  };
  var toPoint = function toPoint(array) {
    var out = {
      x: array[0],
      y: array[1]
    };
    if (array.length > 2) {
      out.z = array[2];
    }
    if (array.length > 3) {
      out.m = array[3];
    }
    return out;
  };
  var checkSanity = function checkSanity(point) {
    checkCoord(point.x);
    checkCoord(point.y);
  };
  function checkCoord(num) {
    if (typeof Number.isFinite === 'function') {
      if (Number.isFinite(num)) {
        return;
      }
      throw new TypeError('coordinates must be finite numbers');
    }
    if (typeof num !== 'number' || num !== num || !isFinite(num)) {
      throw new TypeError('coordinates must be finite numbers');
    }
  }
  function checkNotWGS(source, dest) {
    return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== 'WGS84';
  }
  function transform(source, dest, point, enforceAxis) {
    var wgs84;
    if (Array.isArray(point)) {
      point = toPoint(point);
    } else {
      // Clone the point object so inputs don't get modified
      point = {
        x: point.x,
        y: point.y,
        z: point.z,
        m: point.m
      };
    }
    var hasZ = point.z !== undefined;
    checkSanity(point);
    // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
    if (source.datum && dest.datum && checkNotWGS(source, dest)) {
      wgs84 = new Projection('WGS84');
      point = transform(source, wgs84, point, enforceAxis);
      source = wgs84;
    }
    // DGR, 2010/11/12
    if (enforceAxis && source.axis !== 'enu') {
      point = adjust_axis(source, false, point);
    }
    // Transform source points to long/lat, if they aren't already.
    if (source.projName === 'longlat') {
      point = {
        x: point.x * D2R,
        y: point.y * D2R,
        z: point.z || 0
      };
    } else {
      if (source.to_meter) {
        point = {
          x: point.x * source.to_meter,
          y: point.y * source.to_meter,
          z: point.z || 0
        };
      }
      point = source.inverse(point); // Convert Cartesian to longlat
      if (!point) {
        return;
      }
    }
    // Adjust for the prime meridian if necessary
    if (source.from_greenwich) {
      point.x += source.from_greenwich;
    }

    // Convert datums if needed, and if possible.
    point = datum_transform(source.datum, dest.datum, point);
    if (!point) {
      return;
    }

    // Adjust for the prime meridian if necessary
    if (dest.from_greenwich) {
      point = {
        x: point.x - dest.from_greenwich,
        y: point.y,
        z: point.z || 0
      };
    }
    if (dest.projName === 'longlat') {
      // convert radians to decimal degrees
      point = {
        x: point.x * R2D,
        y: point.y * R2D,
        z: point.z || 0
      };
    } else {
      // else project
      point = dest.forward(point);
      if (dest.to_meter) {
        point = {
          x: point.x / dest.to_meter,
          y: point.y / dest.to_meter,
          z: point.z || 0
        };
      }
    }

    // DGR, 2010/11/12
    if (enforceAxis && dest.axis !== 'enu') {
      return adjust_axis(dest, true, point);
    }
    if (!hasZ) {
      delete point.z;
    }
    return point;
  }
  var wgs84 = Projection('WGS84');
  function transformer(from, to, coords, enforceAxis) {
    var transformedArray, out, keys;
    if (Array.isArray(coords)) {
      transformedArray = transform(from, to, coords, enforceAxis) || {
        x: NaN,
        y: NaN
      };
      if (coords.length > 2) {
        if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
          if (typeof transformedArray.z === 'number') {
            return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
          } else {
            return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
          }
        } else {
          return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
        }
      } else {
        return [transformedArray.x, transformedArray.y];
      }
    } else {
      out = transform(from, to, coords, enforceAxis);
      keys = Object.keys(coords);
      if (keys.length === 2) {
        return out;
      }
      keys.forEach(function (key) {
        if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
          if (key === 'x' || key === 'y' || key === 'z') {
            return;
          }
        } else {
          if (key === 'x' || key === 'y') {
            return;
          }
        }
        out[key] = coords[key];
      });
      return out;
    }
  }
  function checkProj(item) {
    if (item instanceof Projection) {
      return item;
    }
    if (item.oProj) {
      return item.oProj;
    }
    return Projection(item);
  }
  function proj4$1(fromProj, toProj, coord) {
    fromProj = checkProj(fromProj);
    var single = false;
    var obj;
    if (typeof toProj === 'undefined') {
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
      coord = toProj;
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    }
    toProj = checkProj(toProj);
    if (coord) {
      return transformer(fromProj, toProj, coord);
    } else {
      obj = {
        forward: function forward(coords, enforceAxis) {
          return transformer(fromProj, toProj, coords, enforceAxis);
        },
        inverse: function inverse(coords, enforceAxis) {
          return transformer(toProj, fromProj, coords, enforceAxis);
        }
      };
      if (single) {
        obj.oProj = toProj;
      }
      return obj;
    }
  }

  /**
   * UTM zones are grouped, and assigned to one of a group of 6
   * sets.
   *
   * {int} @private
   */
  var NUM_100K_SETS = 6;

  /**
   * The column letters (for easting) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

  /**
   * The row letters (for northing) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
  var A = 65; // A
  var I = 73; // I
  var O = 79; // O
  var V = 86; // V
  var Z = 90; // Z
  var mgrs = {
    forward: forward$1,
    inverse: inverse$1,
    toPoint: toPoint$1
  };
  /**
   * Conversion of lat/lon to MGRS.
   *
   * @param {object} ll Object literal with lat and lon properties on a
   *     WGS84 ellipsoid.
   * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
   *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
   * @return {string} the MGRS string for the given location and accuracy.
   */
  function forward$1(ll, accuracy) {
    accuracy = accuracy || 5; // default accuracy 1m
    return encode(LLtoUTM({
      lat: ll[1],
      lon: ll[0]
    }), accuracy);
  }

  /**
   * Conversion of MGRS to lat/lon.
   *
   * @param {string} mgrs MGRS string.
   * @return {array} An array with left (longitude), bottom (latitude), right
   *     (longitude) and top (latitude) values in WGS84, representing the
   *     bounding box for the provided MGRS reference.
   */
  function inverse$1(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
    }
    return [bbox.left, bbox.bottom, bbox.right, bbox.top];
  }
  function toPoint$1(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat];
    }
    return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
  }
  /**
   * Conversion from degrees to radians.
   *
   * @private
   * @param {number} deg the angle in degrees.
   * @return {number} the angle in radians.
   */
  function degToRad(deg) {
    return deg * (Math.PI / 180.0);
  }

  /**
   * Conversion from radians to degrees.
   *
   * @private
   * @param {number} rad the angle in radians.
   * @return {number} the angle in degrees.
   */
  function radToDeg(rad) {
    return 180.0 * (rad / Math.PI);
  }

  /**
   * Converts a set of Longitude and Latitude co-ordinates to UTM
   * using the WGS84 ellipsoid.
   *
   * @private
   * @param {object} ll Object literal with lat and lon properties
   *     representing the WGS84 coordinate to be converted.
   * @return {object} Object literal containing the UTM value with easting,
   *     northing, zoneNumber and zoneLetter properties, and an optional
   *     accuracy property in digits. Returns null if the conversion failed.
   */
  function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    // (int)
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;

    //Make sure the longitude 180.00 is in Zone 60
    if (Long === 180) {
      ZoneNumber = 60;
    }

    // Special zone for Norway
    if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
      ZoneNumber = 32;
    }

    // Special zones for Svalbard
    if (Lat >= 72.0 && Lat < 84.0) {
      if (Long >= 0.0 && Long < 9.0) {
        ZoneNumber = 31;
      } else if (Long >= 9.0 && Long < 21.0) {
        ZoneNumber = 33;
      } else if (Long >= 21.0 && Long < 33.0) {
        ZoneNumber = 35;
      } else if (Long >= 33.0 && Long < 42.0) {
        ZoneNumber = 37;
      }
    }
    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
    // in middle of
    // zone
    LongOriginRad = degToRad(LongOrigin);
    eccPrimeSquared = eccSquared / (1 - eccSquared);
    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A = Math.cos(LatRad) * (LongRad - LongOriginRad);
    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
    var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;
    var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));
    if (Lat < 0.0) {
      UTMNorthing += 10000000.0; //10000000 meter offset for
      // southern hemisphere
    }

    return {
      northing: Math.round(UTMNorthing),
      easting: Math.round(UTMEasting),
      zoneNumber: ZoneNumber,
      zoneLetter: getLetterDesignator(Lat)
    };
  }

  /**
   * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
   * class where the Zone can be specified as a single string eg."60N" which
   * is then broken down into the ZoneNumber and ZoneLetter.
   *
   * @private
   * @param {object} utm An object literal with northing, easting, zoneNumber
   *     and zoneLetter properties. If an optional accuracy property is
   *     provided (in meters), a bounding box will be returned instead of
   *     latitude and longitude.
   * @return {object} An object literal containing either lat and lon values
   *     (if no accuracy was provided), or top, right, bottom and left values
   *     for the bounding box calculated according to the provided accuracy.
   *     Returns null if the conversion failed.
   */
  function UTMtoLL(utm) {
    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    // check the ZoneNummber is valid
    if (zoneNumber < 0 || zoneNumber > 60) {
      return null;
    }
    var k0 = 0.9996;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C1, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;

    // remove 500,000 meter offset for longitude
    var x = UTMEasting - 500000.0;
    var y = UTMNorthing;

    // We must know somehow if we are in the Northern or Southern
    // hemisphere, this is the only time we use the letter So even
    // if the Zone letter isn't exactly correct it should indicate
    // the hemisphere correctly
    if (zoneLetter < 'N') {
      y -= 10000000.0; // remove 10,000,000 meter offset used
      // for southern hemisphere
    }

    // There are 60 zones with zone 1 being at West -180 to -174
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
    // in middle of
    // zone

    eccPrimeSquared = eccSquared / (1 - eccSquared);
    M = y / k0;
    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
    // double phi1 = ProjMath.radToDeg(phi1Rad);

    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x / (N1 * k0);
    var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);
    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);
    var result;
    if (utm.accuracy) {
      var topRight = UTMtoLL({
        northing: utm.northing + utm.accuracy,
        easting: utm.easting + utm.accuracy,
        zoneLetter: utm.zoneLetter,
        zoneNumber: utm.zoneNumber
      });
      result = {
        top: topRight.lat,
        right: topRight.lon,
        bottom: lat,
        left: lon
      };
    } else {
      result = {
        lat: lat,
        lon: lon
      };
    }
    return result;
  }

  /**
   * Calculates the MGRS letter designator for the given latitude.
   *
   * @private
   * @param {number} lat The latitude in WGS84 to get the letter designator
   *     for.
   * @return {char} The letter designator.
   */
  function getLetterDesignator(lat) {
    //This is here as an error flag to show that the Latitude is
    //outside MGRS limits
    var LetterDesignator = 'Z';
    if (84 >= lat && lat >= 72) {
      LetterDesignator = 'X';
    } else if (72 > lat && lat >= 64) {
      LetterDesignator = 'W';
    } else if (64 > lat && lat >= 56) {
      LetterDesignator = 'V';
    } else if (56 > lat && lat >= 48) {
      LetterDesignator = 'U';
    } else if (48 > lat && lat >= 40) {
      LetterDesignator = 'T';
    } else if (40 > lat && lat >= 32) {
      LetterDesignator = 'S';
    } else if (32 > lat && lat >= 24) {
      LetterDesignator = 'R';
    } else if (24 > lat && lat >= 16) {
      LetterDesignator = 'Q';
    } else if (16 > lat && lat >= 8) {
      LetterDesignator = 'P';
    } else if (8 > lat && lat >= 0) {
      LetterDesignator = 'N';
    } else if (0 > lat && lat >= -8) {
      LetterDesignator = 'M';
    } else if (-8 > lat && lat >= -16) {
      LetterDesignator = 'L';
    } else if (-16 > lat && lat >= -24) {
      LetterDesignator = 'K';
    } else if (-24 > lat && lat >= -32) {
      LetterDesignator = 'J';
    } else if (-32 > lat && lat >= -40) {
      LetterDesignator = 'H';
    } else if (-40 > lat && lat >= -48) {
      LetterDesignator = 'G';
    } else if (-48 > lat && lat >= -56) {
      LetterDesignator = 'F';
    } else if (-56 > lat && lat >= -64) {
      LetterDesignator = 'E';
    } else if (-64 > lat && lat >= -72) {
      LetterDesignator = 'D';
    } else if (-72 > lat && lat >= -80) {
      LetterDesignator = 'C';
    }
    return LetterDesignator;
  }

  /**
   * Encodes a UTM location as MGRS string.
   *
   * @private
   * @param {object} utm An object literal with easting, northing,
   *     zoneLetter, zoneNumber
   * @param {number} accuracy Accuracy in digits (1-5).
   * @return {string} MGRS string for the given UTM location.
   */
  function encode(utm, accuracy) {
    // prepend with leading zeroes
    var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;
    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
  }

  /**
   * Get the two letter 100k designator for a given UTM easting,
   * northing and zone number value.
   *
   * @private
   * @param {number} easting
   * @param {number} northing
   * @param {number} zoneNumber
   * @return the two letter 100k designator for the given UTM location.
   */
  function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 100000);
    var setRow = Math.floor(northing / 100000) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
  }

  /**
   * Given a UTM zone number, figure out the MGRS 100K set it is in.
   *
   * @private
   * @param {number} i An UTM zone number.
   * @return {number} the 100k set the UTM zone is in.
   */
  function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
      setParm = NUM_100K_SETS;
    }
    return setParm;
  }

  /**
   * Get the two-letter MGRS 100k designator given information
   * translated from the UTM northing, easting and zone number.
   *
   * @private
   * @param {number} column the column index as it relates to the MGRS
   *        100k set spreadsheet, created from the UTM easting.
   *        Values are 1-8.
   * @param {number} row the row index as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM northing value. Values
   *        are from 0-19.
   * @param {number} parm the set block, as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM zone. Values are from
   *        1-60.
   * @return two letter MGRS 100k code.
   */
  function getLetter100kID(column, row, parm) {
    // colOrigin and rowOrigin are the letters at the origin of the set
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

    // colInt and rowInt are the letters to build to return
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;
    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
      rollover = true;
    }
    if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
      colInt++;
    }
    if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
      colInt++;
      if (colInt === I) {
        colInt++;
      }
    }
    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
    }
    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
      rollover = true;
    } else {
      rollover = false;
    }
    if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
      rowInt++;
    }
    if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
      rowInt++;
      if (rowInt === I) {
        rowInt++;
      }
    }
    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
    }
    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
  }

  /**
   * Decode the UTM parameters from a MGRS string.
   *
   * @private
   * @param {string} mgrsString an UPPERCASE coordinate string is expected.
   * @return {object} An object literal with easting, northing, zoneLetter,
   *     zoneNumber and accuracy (in meters) properties.
   */
  function decode(mgrsString) {
    if (mgrsString && mgrsString.length === 0) {
      throw "MGRSPoint coverting from nothing";
    }
    var length = mgrsString.length;
    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;

    // get Zone number
    while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
      if (i >= 2) {
        throw "MGRSPoint bad conversion from: " + mgrsString;
      }
      sb += testChar;
      i++;
    }
    var zoneNumber = parseInt(sb, 10);
    if (i === 0 || i + 3 > length) {
      // A good MGRS string has to be 4-5 digits long,
      // ##AAA/#AAA at least.
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    var zoneLetter = mgrsString.charAt(i++);

    // Should we check the zone letter here? Why not.
    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
      throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
    }
    hunK = mgrsString.substring(i, i += 2);
    var set = get100kSetForZone(zoneNumber);
    var east100k = getEastingFromChar(hunK.charAt(0), set);
    var north100k = getNorthingFromChar(hunK.charAt(1), set);

    // We have a bug where the northing may be 2000000 too low.
    // How
    // do we know when to roll over?

    while (north100k < getMinNorthing(zoneLetter)) {
      north100k += 2000000;
    }

    // calculate the char index for easting/northing separator
    var remainder = length - i;
    if (remainder % 2 !== 0) {
      throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
    }
    var sep = remainder / 2;
    var sepEasting = 0.0;
    var sepNorthing = 0.0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
      accuracyBonus = 100000.0 / Math.pow(10, sep);
      sepEastingString = mgrsString.substring(i, i + sep);
      sepEasting = parseFloat(sepEastingString) * accuracyBonus;
      sepNorthingString = mgrsString.substring(i + sep);
      sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }
    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;
    return {
      easting: easting,
      northing: northing,
      zoneLetter: zoneLetter,
      zoneNumber: zoneNumber,
      accuracy: accuracyBonus
    };
  }

  /**
   * Given the first letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the easting value that
   * should be added to the other, secondary easting value.
   *
   * @private
   * @param {char} e The first letter from a two-letter MGRS 100´k zone.
   * @param {number} set The MGRS table set for the zone number.
   * @return {number} The easting value for the given letter and set.
   */
  function getEastingFromChar(e, set) {
    // colOrigin is the letter at the origin of the set for the
    // column
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
    var eastingValue = 100000.0;
    var rewindMarker = false;
    while (curCol !== e.charCodeAt(0)) {
      curCol++;
      if (curCol === I) {
        curCol++;
      }
      if (curCol === O) {
        curCol++;
      }
      if (curCol > Z) {
        if (rewindMarker) {
          throw "Bad character: " + e;
        }
        curCol = A;
        rewindMarker = true;
      }
      eastingValue += 100000.0;
    }
    return eastingValue;
  }

  /**
   * Given the second letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the northing value that
   * should be added to the other, secondary northing value. You have to
   * remember that Northings are determined from the equator, and the vertical
   * cycle of letters mean a 2000000 additional northing meters. This happens
   * approx. every 18 degrees of latitude. This method does *NOT* count any
   * additional northings. You have to figure out how many 2000000 meters need
   * to be added for the zone letter of the MGRS coordinate.
   *
   * @private
   * @param {char} n Second letter of the MGRS 100k zone
   * @param {number} set The MGRS table set number, which is dependent on the
   *     UTM zone number.
   * @return {number} The northing value for the given letter and set.
   */
  function getNorthingFromChar(n, set) {
    if (n > 'V') {
      throw "MGRSPoint given invalid Northing " + n;
    }

    // rowOrigin is the letter at the origin of the set for the
    // column
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
    var northingValue = 0.0;
    var rewindMarker = false;
    while (curRow !== n.charCodeAt(0)) {
      curRow++;
      if (curRow === I) {
        curRow++;
      }
      if (curRow === O) {
        curRow++;
      }
      // fixing a bug making whole application hang in this loop
      // when 'n' is a wrong character
      if (curRow > V) {
        if (rewindMarker) {
          // making sure that this loop ends
          throw "Bad character: " + n;
        }
        curRow = A;
        rewindMarker = true;
      }
      northingValue += 100000.0;
    }
    return northingValue;
  }

  /**
   * The function getMinNorthing returns the minimum northing value of a MGRS
   * zone.
   *
   * Ported from Geotrans' c Lattitude_Band_Value structure table.
   *
   * @private
   * @param {char} zoneLetter The MGRS zone to get the min northing for.
   * @return {number}
   */
  function getMinNorthing(zoneLetter) {
    var northing;
    switch (zoneLetter) {
      case 'C':
        northing = 1100000.0;
        break;
      case 'D':
        northing = 2000000.0;
        break;
      case 'E':
        northing = 2800000.0;
        break;
      case 'F':
        northing = 3700000.0;
        break;
      case 'G':
        northing = 4600000.0;
        break;
      case 'H':
        northing = 5500000.0;
        break;
      case 'J':
        northing = 6400000.0;
        break;
      case 'K':
        northing = 7300000.0;
        break;
      case 'L':
        northing = 8200000.0;
        break;
      case 'M':
        northing = 9100000.0;
        break;
      case 'N':
        northing = 0.0;
        break;
      case 'P':
        northing = 800000.0;
        break;
      case 'Q':
        northing = 1700000.0;
        break;
      case 'R':
        northing = 2600000.0;
        break;
      case 'S':
        northing = 3500000.0;
        break;
      case 'T':
        northing = 4400000.0;
        break;
      case 'U':
        northing = 5300000.0;
        break;
      case 'V':
        northing = 6200000.0;
        break;
      case 'W':
        northing = 7000000.0;
        break;
      case 'X':
        northing = 7900000.0;
        break;
      default:
        northing = -1.0;
    }
    if (northing >= 0.0) {
      return northing;
    } else {
      throw "Invalid zone letter: " + zoneLetter;
    }
  }
  function Point$1(x, y, z) {
    if (!(this instanceof Point$1)) {
      return new Point$1(x, y, z);
    }
    if (Array.isArray(x)) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2] || 0.0;
    } else if (_typeof(x) === 'object') {
      this.x = x.x;
      this.y = x.y;
      this.z = x.z || 0.0;
    } else if (typeof x === 'string' && typeof y === 'undefined') {
      var coords = x.split(',');
      this.x = parseFloat(coords[0], 10);
      this.y = parseFloat(coords[1], 10);
      this.z = parseFloat(coords[2], 10) || 0.0;
    } else {
      this.x = x;
      this.y = y;
      this.z = z || 0.0;
    }
    console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
  }
  Point$1.fromMGRS = function (mgrsStr) {
    return new Point$1(toPoint$1(mgrsStr));
  };
  Point$1.prototype.toMGRS = function (accuracy) {
    return forward$1([this.x, this.y], accuracy);
  };
  var C00 = 1;
  var C02 = 0.25;
  var C04 = 0.046875;
  var C06 = 0.01953125;
  var C08 = 0.01068115234375;
  var C22 = 0.75;
  var C44 = 0.46875;
  var C46 = 0.01302083333333333333;
  var C48 = 0.00712076822916666666;
  var C66 = 0.36458333333333333333;
  var C68 = 0.00569661458333333333;
  var C88 = 0.3076171875;
  var pj_enfn = function pj_enfn(es) {
    var en = [];
    en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
    en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
    var t = es * es;
    en[2] = t * (C44 - es * (C46 + es * C48));
    t *= es;
    en[3] = t * (C66 - es * C68);
    en[4] = t * es * C88;
    return en;
  };
  var pj_mlfn = function pj_mlfn(phi, sphi, cphi, en) {
    cphi *= sphi;
    sphi *= sphi;
    return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
  };
  var MAX_ITER = 20;
  var pj_inv_mlfn = function pj_inv_mlfn(arg, es, en) {
    var k = 1 / (1 - es);
    var phi = arg;
    for (var i = MAX_ITER; i; --i) {
      /* rarely goes over 2 iterations */
      var s = Math.sin(phi);
      var t = 1 - es * s * s;
      //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
      //phi -= t * (t * Math.sqrt(t)) * k;
      t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
      phi -= t;
      if (Math.abs(t) < EPSLN) {
        return phi;
      }
    }
    //..reportError("cass:pj_inv_mlfn: Convergence error");
    return phi;
  };

  // Heavily based on this tmerc projection implementation
  // https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js

  function init$2() {
    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
    if (this.es) {
      this.en = pj_enfn(this.es);
      this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
    }
  }

  /**
      Transverse Mercator Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$2(p) {
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon(lon - this.long0);
    var con;
    var x, y;
    var sin_phi = Math.sin(lat);
    var cos_phi = Math.cos(lat);
    if (!this.es) {
      var b = cos_phi * Math.sin(delta_lon);
      if (Math.abs(Math.abs(b) - 1) < EPSLN) {
        return 93;
      } else {
        x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
        y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
        b = Math.abs(y);
        if (b >= 1) {
          if (b - 1 > EPSLN) {
            return 93;
          } else {
            y = 0;
          }
        } else {
          y = Math.acos(y);
        }
        if (lat < 0) {
          y = -y;
        }
        y = this.a * this.k0 * (y - this.lat0) + this.y0;
      }
    } else {
      var al = cos_phi * delta_lon;
      var als = Math.pow(al, 2);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
      var t = Math.pow(tq, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      al = al / Math.sqrt(con);
      var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
      x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
      y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
    }
    p.x = x;
    p.y = y;
    return p;
  }

  /**
      Transverse Mercator Inverse  -  x/y to long/lat
    */
  function inverse$2(p) {
    var con, phi;
    var lat, lon;
    var x = (p.x - this.x0) * (1 / this.a);
    var y = (p.y - this.y0) * (1 / this.a);
    if (!this.es) {
      var f = Math.exp(x / this.k0);
      var g = 0.5 * (f - 1 / f);
      var temp = this.lat0 + y / this.k0;
      var h = Math.cos(temp);
      con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
      lat = Math.asin(con);
      if (y < 0) {
        lat = -lat;
      }
      if (g === 0 && h === 0) {
        lon = 0;
      } else {
        lon = adjust_lon(Math.atan2(g, h) + this.long0);
      }
    } else {
      // ellipsoidal form
      con = this.ml0 + y / this.k0;
      phi = pj_inv_mlfn(con, this.es, this.en);
      if (Math.abs(phi) < HALF_PI) {
        var sin_phi = Math.sin(phi);
        var cos_phi = Math.cos(phi);
        var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var t = Math.pow(tan_phi, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        var d = x * Math.sqrt(con) / this.k0;
        var ds = Math.pow(d, 2);
        con = con * tan_phi;
        lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
        lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
      } else {
        lat = HALF_PI * sign$1(y);
        lon = 0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$3 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  var tmerc = {
    init: init$2,
    forward: forward$2,
    inverse: inverse$2,
    names: names$3
  };
  var sinh = function sinh(x) {
    var r = Math.exp(x);
    r = (r - 1 / r) / 2;
    return r;
  };
  var hypot = function hypot(x, y) {
    x = Math.abs(x);
    y = Math.abs(y);
    var a = Math.max(x, y);
    var b = Math.min(x, y) / (a ? a : 1);
    return a * Math.sqrt(1 + Math.pow(b, 2));
  };
  var log1py = function log1py(x) {
    var y = 1 + x;
    var z = y - 1;
    return z === 0 ? x : x * Math.log(y) / z;
  };
  var asinhy = function asinhy(x) {
    var y = Math.abs(x);
    y = log1py(y * (1 + y / (hypot(1, y) + 1)));
    return x < 0 ? -y : y;
  };
  var gatg = function gatg(pp, B) {
    var cos_2B = 2 * Math.cos(2 * B);
    var i = pp.length - 1;
    var h1 = pp[i];
    var h2 = 0;
    var h;
    while (--i >= 0) {
      h = -h2 + cos_2B * h1 + pp[i];
      h2 = h1;
      h1 = h;
    }
    return B + h * Math.sin(2 * B);
  };
  var clens = function clens(pp, arg_r) {
    var r = 2 * Math.cos(arg_r);
    var i = pp.length - 1;
    var hr1 = pp[i];
    var hr2 = 0;
    var hr;
    while (--i >= 0) {
      hr = -hr2 + r * hr1 + pp[i];
      hr2 = hr1;
      hr1 = hr;
    }
    return Math.sin(arg_r) * hr;
  };
  var cosh = function cosh(x) {
    var r = Math.exp(x);
    r = (r + 1 / r) / 2;
    return r;
  };
  var clens_cmplx = function clens_cmplx(pp, arg_r, arg_i) {
    var sin_arg_r = Math.sin(arg_r);
    var cos_arg_r = Math.cos(arg_r);
    var sinh_arg_i = sinh(arg_i);
    var cosh_arg_i = cosh(arg_i);
    var r = 2 * cos_arg_r * cosh_arg_i;
    var i = -2 * sin_arg_r * sinh_arg_i;
    var j = pp.length - 1;
    var hr = pp[j];
    var hi1 = 0;
    var hr1 = 0;
    var hi = 0;
    var hr2;
    var hi2;
    while (--j >= 0) {
      hr2 = hr1;
      hi2 = hi1;
      hr1 = hr;
      hi1 = hi;
      hr = -hr2 + r * hr1 - i * hi1 + pp[j];
      hi = -hi2 + i * hr1 + r * hi1;
    }
    r = sin_arg_r * cosh_arg_i;
    i = cos_arg_r * sinh_arg_i;
    return [r * hr - i * hi, r * hi + i * hr];
  };

  // Heavily based on this etmerc projection implementation
  // https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js

  function init$3() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    }
    if (this.approx) {
      // When '+approx' is set, use tmerc instead
      tmerc.init.apply(this);
      this.forward = tmerc.forward;
      this.inverse = tmerc.inverse;
    }
    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
    this.cgb = [];
    this.cbg = [];
    this.utg = [];
    this.gtu = [];
    var f = this.es / (1 + Math.sqrt(1 - this.es));
    var n = f / (2 - f);
    var np = n;
    this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
    this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
    np = np * n;
    this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
    this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
    np = np * n;
    this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
    this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
    np = np * n;
    this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
    this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
    np = np * n;
    this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
    this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
    np = np * n;
    this.cgb[5] = np * (601676 / 22275);
    this.cbg[5] = np * (444337 / 155925);
    np = Math.pow(n, 2);
    this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
    this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
    this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
    this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
    this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
    np = np * n;
    this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
    this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
    np = np * n;
    this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
    this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
    np = np * n;
    this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
    this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
    np = np * n;
    this.utg[5] = np * (-20648693 / 638668800);
    this.gtu[5] = np * (212378941 / 319334400);
    var Z = gatg(this.cbg, this.lat0);
    this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
  }
  function forward$3(p) {
    var Ce = adjust_lon(p.x - this.long0);
    var Cn = p.y;
    Cn = gatg(this.cbg, Cn);
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
    Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
    Ce = asinhy(Math.tan(Ce));
    var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    var x;
    var y;
    if (Math.abs(Ce) <= 2.623395162778) {
      x = this.a * (this.Qn * Ce) + this.x0;
      y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
    } else {
      x = Infinity;
      y = Infinity;
    }
    p.x = x;
    p.y = y;
    return p;
  }
  function inverse$3(p) {
    var Ce = (p.x - this.x0) * (1 / this.a);
    var Cn = (p.y - this.y0) * (1 / this.a);
    Cn = (Cn - this.Zb) / this.Qn;
    Ce = Ce / this.Qn;
    var lon;
    var lat;
    if (Math.abs(Ce) <= 2.623395162778) {
      var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];
      Ce = Math.atan(sinh(Ce));
      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);
      Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
      Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
      lon = adjust_lon(Ce + this.long0);
      lat = gatg(this.cgb, Cn);
    } else {
      lon = Infinity;
      lat = Infinity;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
  var etmerc = {
    init: init$3,
    forward: forward$3,
    inverse: inverse$3,
    names: names$4
  };
  var adjust_zone = function adjust_zone(zone, lon) {
    if (zone === undefined) {
      zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
      if (zone < 0) {
        return 0;
      } else if (zone > 60) {
        return 60;
      }
    }
    return zone;
  };
  var dependsOn = 'etmerc';
  function init$4() {
    var zone = adjust_zone(this.zone, this.long0);
    if (zone === undefined) {
      throw new Error('unknown utm zone');
    }
    this.lat0 = 0;
    this.long0 = (6 * Math.abs(zone) - 183) * D2R;
    this.x0 = 500000;
    this.y0 = this.utmSouth ? 10000000 : 0;
    this.k0 = 0.9996;
    etmerc.init.apply(this);
    this.forward = etmerc.forward;
    this.inverse = etmerc.inverse;
  }
  var names$5 = ["Universal Transverse Mercator System", "utm"];
  var utm = {
    init: init$4,
    names: names$5,
    dependsOn: dependsOn
  };
  var srat = function srat(esinp, exp) {
    return Math.pow((1 - esinp) / (1 + esinp), exp);
  };
  var MAX_ITER$1 = 20;
  function init$6() {
    var sphi = Math.sin(this.lat0);
    var cphi = Math.cos(this.lat0);
    cphi *= cphi;
    this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
    this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
    this.phic0 = Math.asin(sphi / this.C);
    this.ratexp = 0.5 * this.C * this.e;
    this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
  }
  function forward$5(p) {
    var lon = p.x;
    var lat = p.y;
    p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
    p.x = this.C * lon;
    return p;
  }
  function inverse$5(p) {
    var DEL_TOL = 1e-14;
    var lon = p.x / this.C;
    var lat = p.y;
    var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
    for (var i = MAX_ITER$1; i > 0; --i) {
      lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
      if (Math.abs(lat - p.y) < DEL_TOL) {
        break;
      }
      p.y = lat;
    }
    /* convergence failed */
    if (!i) {
      return null;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$7 = ["gauss"];
  var gauss = {
    init: init$6,
    forward: forward$5,
    inverse: inverse$5,
    names: names$7
  };
  function init$5() {
    gauss.init.apply(this);
    if (!this.rc) {
      return;
    }
    this.sinc0 = Math.sin(this.phic0);
    this.cosc0 = Math.cos(this.phic0);
    this.R2 = 2 * this.rc;
    if (!this.title) {
      this.title = "Oblique Stereographic Alternative";
    }
  }
  function forward$4(p) {
    var sinc, cosc, cosl, k;
    p.x = adjust_lon(p.x - this.long0);
    gauss.forward.apply(this, [p]);
    sinc = Math.sin(p.y);
    cosc = Math.cos(p.y);
    cosl = Math.cos(p.x);
    k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
    p.x = k * cosc * Math.sin(p.x);
    p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
    p.x = this.a * p.x + this.x0;
    p.y = this.a * p.y + this.y0;
    return p;
  }
  function inverse$4(p) {
    var sinc, cosc, lon, lat, rho;
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;
    p.x /= this.k0;
    p.y /= this.k0;
    if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
      var c = 2 * Math.atan2(rho, this.R2);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
      lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
    } else {
      lat = this.phic0;
      lon = 0;
    }
    p.x = lon;
    p.y = lat;
    gauss.inverse.apply(this, [p]);
    p.x = adjust_lon(p.x + this.long0);
    return p;
  }
  var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
  var sterea = {
    init: init$5,
    forward: forward$4,
    inverse: inverse$4,
    names: names$6
  };
  function ssfn_(phit, sinphi, eccen) {
    sinphi *= eccen;
    return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
  }
  function init$7() {
    this.coslat0 = Math.cos(this.lat0);
    this.sinlat0 = Math.sin(this.lat0);
    if (this.sphere) {
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * (1 + sign$1(this.lat0) * Math.sin(this.lat_ts));
      }
    } else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (this.lat0 > 0) {
          //North pole
          //trace('stere:north pole');
          this.con = 1;
        } else {
          //South pole
          //trace('stere:south pole');
          this.con = -1;
        }
      }
      this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
      }
      this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
      this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
      this.cosX0 = Math.cos(this.X0);
      this.sinX0 = Math.sin(this.X0);
    }
  }

  // Stereographic forward equations--mapping lat,long to x,y
  function forward$6(p) {
    var lon = p.x;
    var lat = p.y;
    var sinlat = Math.sin(lat);
    var coslat = Math.cos(lat);
    var A, X, sinX, cosX, ts, rh;
    var dlon = adjust_lon(lon - this.long0);
    if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
      //case of the origine point
      //trace('stere:this is the origin point');
      p.x = NaN;
      p.y = NaN;
      return p;
    }
    if (this.sphere) {
      //trace('stere:sphere case');
      A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
      p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
      p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
      return p;
    } else {
      X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
      cosX = Math.cos(X);
      sinX = Math.sin(X);
      if (Math.abs(this.coslat0) <= EPSLN) {
        ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
        rh = 2 * this.a * this.k0 * ts / this.cons;
        p.x = this.x0 + rh * Math.sin(lon - this.long0);
        p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
        //trace(p.toString());
        return p;
      } else if (Math.abs(this.sinlat0) < EPSLN) {
        //Eq
        //trace('stere:equateur');
        A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
        p.y = A * sinX;
      } else {
        //other case
        //trace('stere:normal case');
        A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
        p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
      }
      p.x = A * cosX * Math.sin(dlon) + this.x0;
    }
    //trace(p.toString());
    return p;
  }

  //* Stereographic inverse equations--mapping x,y to lat/long
  function inverse$6(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat, ts, ce, Chi;
    var rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (this.sphere) {
      var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
      lon = this.long0;
      lat = this.lat0;
      if (rh <= EPSLN) {
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
      if (Math.abs(this.coslat0) < EPSLN) {
        if (this.lat0 > 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
        } else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        }
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
      }
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (rh <= EPSLN) {
          lat = this.lat0;
          lon = this.long0;
          p.x = lon;
          p.y = lat;
          //trace(p.toString());
          return p;
        }
        p.x *= this.con;
        p.y *= this.con;
        ts = rh * this.cons / (2 * this.a * this.k0);
        lat = this.con * phi2z(this.e, ts);
        lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
        lon = this.long0;
        if (rh <= EPSLN) {
          Chi = this.X0;
        } else {
          Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
        }
        lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
      }
    }
    p.x = lon;
    p.y = lat;

    //trace(p.toString());
    return p;
  }
  var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
  var stere = {
    init: init$7,
    forward: forward$6,
    inverse: inverse$6,
    names: names$8,
    ssfn_: ssfn_
  };

  /*
    references:
      Formules et constantes pour le Calcul pour la
      projection cylindrique conforme à axe oblique et pour la transformation entre
      des systèmes de référence.
      http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
    */

  function init$8() {
    var phy0 = this.lat0;
    this.lambda0 = this.long0;
    var sinPhy0 = Math.sin(phy0);
    var semiMajorAxis = this.a;
    var invF = this.rf;
    var flattening = 1 / invF;
    var e2 = 2 * flattening - Math.pow(flattening, 2);
    var e = this.e = Math.sqrt(e2);
    this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
    this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
    this.b0 = Math.asin(sinPhy0 / this.alpha);
    var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
    var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
    var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
    this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
  }
  function forward$7(p) {
    var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
    var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
    var S = -this.alpha * (Sa1 + Sa2) + this.K;

    // spheric latitude
    var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

    // spheric longitude
    var I = this.alpha * (p.x - this.lambda0);

    // psoeudo equatorial rotation
    var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
    var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
    p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
    p.x = this.R * rotI + this.x0;
    return p;
  }
  function inverse$7(p) {
    var Y = p.x - this.x0;
    var X = p.y - this.y0;
    var rotI = Y / this.R;
    var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
    var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
    var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
    var lambda = this.lambda0 + I / this.alpha;
    var S = 0;
    var phy = b;
    var prevPhy = -1000;
    var iteration = 0;
    while (Math.abs(phy - prevPhy) > 0.0000001) {
      if (++iteration > 20) {
        //...reportError("omercFwdInfinity");
        return;
      }
      //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
      S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
      prevPhy = phy;
      phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
    }
    p.x = lambda;
    p.y = phy;
    return p;
  }
  var names$9 = ["somerc"];
  var somerc = {
    init: init$8,
    forward: forward$7,
    inverse: inverse$7,
    names: names$9
  };
  var TOL = 1e-7;
  function isTypeA(P) {
    var typeAProjections = ['Hotine_Oblique_Mercator', 'Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
    var projectionName = _typeof(P.PROJECTION) === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
    return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
  }

  /* Initialize the Oblique Mercator  projection
      ------------------------------------------*/
  function init$9() {
    var con,
      com,
      cosph0,
      D,
      F,
      H,
      L,
      sinph0,
      p,
      J,
      gamma = 0,
      gamma0,
      lamc = 0,
      lam1 = 0,
      lam2 = 0,
      phi1 = 0,
      phi2 = 0,
      alpha_c = 0;

    // only Type A uses the no_off or no_uoff property
    // https://github.com/OSGeo/proj.4/issues/104
    this.no_off = isTypeA(this);
    this.no_rot = 'no_rot' in this;
    var alp = false;
    if ("alpha" in this) {
      alp = true;
    }
    var gam = false;
    if ("rectified_grid_angle" in this) {
      gam = true;
    }
    if (alp) {
      alpha_c = this.alpha;
    }
    if (gam) {
      gamma = this.rectified_grid_angle * D2R;
    }
    if (alp || gam) {
      lamc = this.longc;
    } else {
      lam1 = this.long1;
      phi1 = this.lat1;
      lam2 = this.long2;
      phi2 = this.lat2;
      if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
        throw new Error();
      }
    }
    var one_es = 1.0 - this.es;
    com = Math.sqrt(one_es);
    if (Math.abs(this.lat0) > EPSLN) {
      sinph0 = Math.sin(this.lat0);
      cosph0 = Math.cos(this.lat0);
      con = 1 - this.es * sinph0 * sinph0;
      this.B = cosph0 * cosph0;
      this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
      this.A = this.B * this.k0 * com / con;
      D = this.B * com / (cosph0 * Math.sqrt(con));
      F = D * D - 1;
      if (F <= 0) {
        F = 0;
      } else {
        F = Math.sqrt(F);
        if (this.lat0 < 0) {
          F = -F;
        }
      }
      this.E = F += D;
      this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
    } else {
      this.B = 1 / com;
      this.A = this.k0;
      this.E = D = F = 1;
    }
    if (alp || gam) {
      if (alp) {
        gamma0 = Math.asin(Math.sin(alpha_c) / D);
        if (!gam) {
          gamma = alpha_c;
        }
      } else {
        gamma0 = gamma;
        alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
    } else {
      H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
      L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
      F = this.E / H;
      p = (L - H) / (L + H);
      J = this.E * this.E;
      J = (J - L * H) / (J + L * H);
      con = lam1 - lam2;
      if (con < -Math.pi) {
        lam2 -= TWO_PI;
      } else if (con > Math.pi) {
        lam2 += TWO_PI;
      }
      this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
      gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
      gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.singam = Math.sin(gamma0);
    this.cosgam = Math.cos(gamma0);
    this.sinrot = Math.sin(gamma);
    this.cosrot = Math.cos(gamma);
    this.rB = 1 / this.B;
    this.ArB = this.A * this.rB;
    this.BrA = 1 / this.ArB;
    if (this.no_off) {
      this.u_0 = 0;
    } else {
      this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
      if (this.lat0 < 0) {
        this.u_0 = -this.u_0;
      }
    }
    F = 0.5 * gamma0;
    this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
    this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
  }

  /* Oblique Mercator forward equations--mapping lat,long to x,y
      ----------------------------------------------------------*/
  function forward$8(p) {
    var coords = {};
    var S, T, U, V, W, temp, u, v;
    p.x = p.x - this.lam0;
    if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
      W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
      temp = 1 / W;
      S = 0.5 * (W - temp);
      T = 0.5 * (W + temp);
      V = Math.sin(this.B * p.x);
      U = (S * this.singam - V * this.cosgam) / T;
      if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
        throw new Error();
      }
      v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
      temp = Math.cos(this.B * p.x);
      if (Math.abs(temp) < TOL) {
        u = this.A * p.x;
      } else {
        u = this.ArB * Math.atan2(S * this.cosgam + V * this.singam, temp);
      }
    } else {
      v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
      u = this.ArB * p.y;
    }
    if (this.no_rot) {
      coords.x = u;
      coords.y = v;
    } else {
      u -= this.u_0;
      coords.x = v * this.cosrot + u * this.sinrot;
      coords.y = u * this.cosrot - v * this.sinrot;
    }
    coords.x = this.a * coords.x + this.x0;
    coords.y = this.a * coords.y + this.y0;
    return coords;
  }
  function inverse$8(p) {
    var u, v, Qp, Sp, Tp, Vp, Up;
    var coords = {};
    p.x = (p.x - this.x0) * (1.0 / this.a);
    p.y = (p.y - this.y0) * (1.0 / this.a);
    if (this.no_rot) {
      v = p.y;
      u = p.x;
    } else {
      v = p.x * this.cosrot - p.y * this.sinrot;
      u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
    }
    Qp = Math.exp(-this.BrA * v);
    Sp = 0.5 * (Qp - 1 / Qp);
    Tp = 0.5 * (Qp + 1 / Qp);
    Vp = Math.sin(this.BrA * u);
    Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
    if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
      coords.x = 0;
      coords.y = Up < 0 ? -HALF_PI : HALF_PI;
    } else {
      coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
      coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
      if (coords.y === Infinity) {
        throw new Error();
      }
      coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
    }
    coords.x += this.lam0;
    return coords;
  }
  var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  var omerc = {
    init: init$9,
    forward: forward$8,
    inverse: inverse$8,
    names: names$10
  };
  function init$10() {
    //double lat0;                    /* the reference latitude               */
    //double long0;                   /* the reference longitude              */
    //double lat1;                    /* first standard parallel              */
    //double lat2;                    /* second standard parallel             */
    //double r_maj;                   /* major axis                           */
    //double r_min;                   /* minor axis                           */
    //double false_east;              /* x offset in meters                   */
    //double false_north;             /* y offset in meters                   */

    //the above value can be set with proj4.defs
    //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

    if (!this.lat2) {
      this.lat2 = this.lat1;
    } //if lat2 is not defined
    if (!this.k0) {
      this.k0 = 1;
    }
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    var temp = this.b / this.a;
    this.e = Math.sqrt(1 - temp * temp);
    var sin1 = Math.sin(this.lat1);
    var cos1 = Math.cos(this.lat1);
    var ms1 = msfnz(this.e, sin1, cos1);
    var ts1 = tsfnz(this.e, this.lat1, sin1);
    var sin2 = Math.sin(this.lat2);
    var cos2 = Math.cos(this.lat2);
    var ms2 = msfnz(this.e, sin2, cos2);
    var ts2 = tsfnz(this.e, this.lat2, sin2);
    var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
    } else {
      this.ns = sin1;
    }
    if (isNaN(this.ns)) {
      this.ns = sin1;
    }
    this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
    if (!this.title) {
      this.title = "Lambert Conformal Conic";
    }
  }

  // Lambert Conformal conic forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$9(p) {
    var lon = p.x;
    var lat = p.y;

    // singular cases :
    if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
      lat = sign$1(lat) * (HALF_PI - 2 * EPSLN);
    }
    var con = Math.abs(Math.abs(lat) - HALF_PI);
    var ts, rh1;
    if (con > EPSLN) {
      ts = tsfnz(this.e, lat, Math.sin(lat));
      rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
    } else {
      con = lat * this.ns;
      if (con <= 0) {
        return null;
      }
      rh1 = 0;
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
    p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
    return p;
  }

  // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$9(p) {
    var rh1, con, ts;
    var lat, lon;
    var x = (p.x - this.x0) / this.k0;
    var y = this.rh - (p.y - this.y0) / this.k0;
    if (this.ns > 0) {
      rh1 = Math.sqrt(x * x + y * y);
      con = 1;
    } else {
      rh1 = -Math.sqrt(x * x + y * y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * x, con * y);
    }
    if (rh1 !== 0 || this.ns > 0) {
      con = 1 / this.ns;
      ts = Math.pow(rh1 / (this.a * this.f0), con);
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    } else {
      lat = -HALF_PI;
    }
    lon = adjust_lon(theta / this.ns + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$11 = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"];
  var lcc = {
    init: init$10,
    forward: forward$9,
    inverse: inverse$9,
    names: names$11
  };
  function init$11() {
    this.a = 6377397.155;
    this.es = 0.006674372230614;
    this.e = Math.sqrt(this.es);
    if (!this.lat0) {
      this.lat0 = 0.863937979737193;
    }
    if (!this.long0) {
      this.long0 = 0.7417649320975901 - 0.308341501185665;
    }
    /* if scale not set default to 0.9999 */
    if (!this.k0) {
      this.k0 = 0.9999;
    }
    this.s45 = 0.785398163397448; /* 45 */
    this.s90 = 2 * this.s45;
    this.fi0 = this.lat0;
    this.e2 = this.es;
    this.e = Math.sqrt(this.e2);
    this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
    this.uq = 1.04216856380474;
    this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
    this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
    this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
    this.k1 = this.k0;
    this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
    this.s0 = 1.37008346281555;
    this.n = Math.sin(this.s0);
    this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
    this.ad = this.s90 - this.uq;
  }

  /* ellipsoid */
  /* calculate xy from lat/lon */
  /* Constants, identical to inverse transform function */
  function forward$10(p) {
    var gfi, u, deltav, s, d, eps, ro;
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon(lon - this.long0);
    /* Transformation */
    gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
    u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
    deltav = -delta_lon * this.alfa;
    s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
    d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
    eps = this.n * d;
    ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
    p.y = ro * Math.cos(eps) / 1;
    p.x = ro * Math.sin(eps) / 1;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    return p;
  }

  /* calculate lat/lon from xy */
  function inverse$10(p) {
    var u, deltav, s, d, eps, ro, fi1;
    var ok;

    /* Transformation */
    /* revert y, x*/
    var tmp = p.x;
    p.x = p.y;
    p.y = tmp;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    ro = Math.sqrt(p.x * p.x + p.y * p.y);
    eps = Math.atan2(p.y, p.x);
    d = eps / Math.sin(this.s0);
    s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
    u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
    deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
    p.x = this.long0 - deltav / this.alfa;
    fi1 = u;
    ok = 0;
    var iter = 0;
    do {
      p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
      if (Math.abs(fi1 - p.y) < 0.0000000001) {
        ok = 1;
      }
      fi1 = p.y;
      iter += 1;
    } while (ok === 0 && iter < 15);
    if (iter >= 15) {
      return null;
    }
    return p;
  }
  var names$12 = ["Krovak", "krovak"];
  var krovak = {
    init: init$11,
    forward: forward$10,
    inverse: inverse$10,
    names: names$12
  };
  var mlfn = function mlfn(e0, e1, e2, e3, phi) {
    return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
  };
  var e0fn = function e0fn(x) {
    return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
  };
  var e1fn = function e1fn(x) {
    return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
  };
  var e2fn = function e2fn(x) {
    return 0.05859375 * x * x * (1 + 0.75 * x);
  };
  var e3fn = function e3fn(x) {
    return x * x * x * (35 / 3072);
  };
  var gN = function gN(a, e, sinphi) {
    var temp = e * sinphi;
    return a / Math.sqrt(1 - temp * temp);
  };
  var adjust_lat = function adjust_lat(x) {
    return Math.abs(x) < HALF_PI ? x : x - sign$1(x) * Math.PI;
  };
  var imlfn = function imlfn(ml, e0, e1, e2, e3) {
    var phi;
    var dphi;
    phi = ml / e0;
    for (var i = 0; i < 15; i++) {
      dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
    return NaN;
  };
  function init$12() {
    if (!this.sphere) {
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    }
  }

  /* Cassini forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$11(p) {
    /* Forward equations
        -----------------*/
    var x, y;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon(lam - this.long0);
    if (this.sphere) {
      x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
      y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
    } else {
      //ellipsoid
      var sinphi = Math.sin(phi);
      var cosphi = Math.cos(phi);
      var nl = gN(this.a, this.e, sinphi);
      var tl = Math.tan(phi) * Math.tan(phi);
      var al = lam * Math.cos(phi);
      var asq = al * al;
      var cl = this.es * cosphi * cosphi / (1 - this.es);
      var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
      x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
      y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
    }
    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$11(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var phi, lam;
    if (this.sphere) {
      var dd = y + this.lat0;
      phi = Math.asin(Math.sin(dd) * Math.cos(x));
      lam = Math.atan2(Math.tan(x), Math.cos(dd));
    } else {
      /* ellipsoid */
      var ml1 = this.ml0 / this.a + y;
      var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
        p.x = this.long0;
        p.y = HALF_PI;
        if (y < 0) {
          p.y *= -1;
        }
        return p;
      }
      var nl1 = gN(this.a, this.e, Math.sin(phi1));
      var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
      var tl1 = Math.pow(Math.tan(phi1), 2);
      var dl = x * this.a / nl1;
      var dsq = dl * dl;
      phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
      lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
    }
    p.x = adjust_lon(lam + this.long0);
    p.y = adjust_lat(phi);
    return p;
  }
  var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
  var cass = {
    init: init$12,
    forward: forward$11,
    inverse: inverse$11,
    names: names$13
  };
  var qsfnz = function qsfnz(eccent, sinphi) {
    var con;
    if (eccent > 1.0e-7) {
      con = eccent * sinphi;
      return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    } else {
      return 2 * sinphi;
    }
  };

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */

  var S_POLE = 1;
  var N_POLE = 2;
  var EQUIT = 3;
  var OBLIQ = 4;

  /* Initialize the Lambert Azimuthal Equal Area projection
    ------------------------------------------------------*/
  function init$13() {
    var t = Math.abs(this.lat0);
    if (Math.abs(t - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
    } else if (Math.abs(t) < EPSLN) {
      this.mode = this.EQUIT;
    } else {
      this.mode = this.OBLIQ;
    }
    if (this.es > 0) {
      var sinphi;
      this.qp = qsfnz(this.e, 1);
      this.mmf = 0.5 / (1 - this.es);
      this.apa = authset(this.es);
      switch (this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp);
          this.dd = 1 / this.rq;
          this.xmf = 1;
          this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp);
          sinphi = Math.sin(this.lat0);
          this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
          this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
          this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
          this.ymf = (this.xmf = this.rq) / this.dd;
          this.xmf *= this.dd;
          break;
      }
    } else {
      if (this.mode === this.OBLIQ) {
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }
    }
  }

  /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$12(p) {
    /* Forward equations
        -----------------*/
    var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon(lam - this.long0);
    if (this.sphere) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      coslam = Math.cos(lam);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        if (y <= EPSLN) {
          return null;
        }
        y = Math.sqrt(2 / y);
        x = y * cosphi * Math.sin(lam);
        y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          coslam = -coslam;
        }
        if (Math.abs(phi + this.lat0) < EPSLN) {
          return null;
        }
        y = FORTPI - phi * 0.5;
        y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
        x = y * Math.sin(lam);
        y *= coslam;
      }
    } else {
      sinb = 0;
      cosb = 0;
      b = 0;
      coslam = Math.cos(lam);
      sinlam = Math.sin(lam);
      sinphi = Math.sin(phi);
      q = qsfnz(this.e, sinphi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinb = q / this.qp;
        cosb = Math.sqrt(1 - sinb * sinb);
      }
      switch (this.mode) {
        case this.OBLIQ:
          b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
          break;
        case this.EQUIT:
          b = 1 + cosb * coslam;
          break;
        case this.N_POLE:
          b = HALF_PI + phi;
          q = this.qp - q;
          break;
        case this.S_POLE:
          b = phi - HALF_PI;
          q = this.qp + q;
          break;
      }
      if (Math.abs(b) < EPSLN) {
        return null;
      }
      switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          b = Math.sqrt(2 / b);
          if (this.mode === this.OBLIQ) {
            y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
          } else {
            y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
          }
          x = this.xmf * b * cosb * sinlam;
          break;
        case this.N_POLE:
        case this.S_POLE:
          if (q >= 0) {
            x = (b = Math.sqrt(q)) * sinlam;
            y = coslam * (this.mode === this.S_POLE ? b : -b);
          } else {
            x = y = 0;
          }
          break;
      }
    }
    p.x = this.a * x + this.x0;
    p.y = this.a * y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$12(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var lam, phi, cCe, sCe, q, rho, ab;
    if (this.sphere) {
      var cosz = 0,
        rh,
        sinz = 0;
      rh = Math.sqrt(x * x + y * y);
      phi = rh * 0.5;
      if (phi > 1) {
        return null;
      }
      phi = 2 * Math.asin(phi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinz = Math.sin(phi);
        cosz = Math.cos(phi);
      }
      switch (this.mode) {
        case this.EQUIT:
          phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
          x *= sinz;
          y = cosz * rh;
          break;
        case this.OBLIQ:
          phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
          x *= sinz * this.cosph0;
          y = (cosz - Math.sin(phi) * this.sinph0) * rh;
          break;
        case this.N_POLE:
          y = -y;
          phi = HALF_PI - phi;
          break;
        case this.S_POLE:
          phi -= HALF_PI;
          break;
      }
      lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
    } else {
      ab = 0;
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        x /= this.dd;
        y *= this.dd;
        rho = Math.sqrt(x * x + y * y);
        if (rho < EPSLN) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        sCe = 2 * Math.asin(0.5 * rho / this.rq);
        cCe = Math.cos(sCe);
        x *= sCe = Math.sin(sCe);
        if (this.mode === this.OBLIQ) {
          ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
          q = this.qp * ab;
          y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
        } else {
          ab = y * sCe / rho;
          q = this.qp * ab;
          y = rho * cCe;
        }
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          y = -y;
        }
        q = x * x + y * y;
        if (!q) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        ab = 1 - q / this.qp;
        if (this.mode === this.S_POLE) {
          ab = -ab;
        }
      }
      lam = Math.atan2(x, y);
      phi = authlat(Math.asin(ab), this.apa);
    }
    p.x = adjust_lon(this.long0 + lam);
    p.y = phi;
    return p;
  }

  /* determine latitude from authalic latitude */
  var P00 = 0.33333333333333333333;
  var P01 = 0.17222222222222222222;
  var P02 = 0.10257936507936507936;
  var P10 = 0.06388888888888888888;
  var P11 = 0.06640211640211640211;
  var P20 = 0.01641501294219154443;
  function authset(es) {
    var t;
    var APA = [];
    APA[0] = es * P00;
    t = es * es;
    APA[0] += t * P01;
    APA[1] = t * P10;
    t *= es;
    APA[0] += t * P02;
    APA[1] += t * P11;
    APA[2] = t * P20;
    return APA;
  }
  function authlat(beta, APA) {
    var t = beta + beta;
    return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
  }
  var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  var laea = {
    init: init$13,
    forward: forward$12,
    inverse: inverse$12,
    names: names$14,
    S_POLE: S_POLE,
    N_POLE: N_POLE,
    EQUIT: EQUIT,
    OBLIQ: OBLIQ
  };
  var asinz = function asinz(x) {
    if (Math.abs(x) > 1) {
      x = x > 1 ? 1 : -1;
    }
    return Math.asin(x);
  };
  function init$14() {
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e3 = Math.sqrt(this.es);
    this.sin_po = Math.sin(this.lat1);
    this.cos_po = Math.cos(this.lat1);
    this.t1 = this.sin_po;
    this.con = this.sin_po;
    this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs1 = qsfnz(this.e3, this.sin_po);
    this.sin_po = Math.sin(this.lat2);
    this.cos_po = Math.cos(this.lat2);
    this.t2 = this.sin_po;
    this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs2 = qsfnz(this.e3, this.sin_po);
    this.sin_po = Math.sin(this.lat0);
    this.cos_po = Math.cos(this.lat0);
    this.t3 = this.sin_po;
    this.qs0 = qsfnz(this.e3, this.sin_po);
    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
    } else {
      this.ns0 = this.con;
    }
    this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
    this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
  }

  /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
    -------------------------------------------------------------------*/
  function forward$13(p) {
    var lon = p.x;
    var lat = p.y;
    this.sin_phi = Math.sin(lat);
    this.cos_phi = Math.cos(lat);
    var qs = qsfnz(this.e3, this.sin_phi);
    var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
    var theta = this.ns0 * adjust_lon(lon - this.long0);
    var x = rh1 * Math.sin(theta) + this.x0;
    var y = this.rh - rh1 * Math.cos(theta) + this.y0;
    p.x = x;
    p.y = y;
    return p;
  }
  function inverse$13(p) {
    var rh1, qs, con, theta, lon, lat;
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    if (this.ns0 >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    } else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    con = rh1 * this.ns0 / this.a;
    if (this.sphere) {
      lat = Math.asin((this.c - con * con) / (2 * this.ns0));
    } else {
      qs = (this.c - con * con) / this.ns0;
      lat = this.phi1z(this.e3, qs);
    }
    lon = adjust_lon(theta / this.ns0 + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }

  /* Function to compute phi1, the latitude for the inverse of the
     Albers Conical Equal-Area projection.
  -------------------------------------------*/
  function phi1z(eccent, qs) {
    var sinphi, cosphi, con, com, dphi;
    var phi = asinz(0.5 * qs);
    if (eccent < EPSLN) {
      return phi;
    }
    var eccnts = eccent * eccent;
    for (var i = 1; i <= 25; i++) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      con = eccent * sinphi;
      com = 1 - con * con;
      dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi = phi + dphi;
      if (Math.abs(dphi) <= 1e-7) {
        return phi;
      }
    }
    return null;
  }
  var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  var aea = {
    init: init$14,
    forward: forward$13,
    inverse: inverse$13,
    names: names$15,
    phi1z: phi1z
  };

  /*
    reference:
      Wolfram Mathworld "Gnomonic Projection"
      http://mathworld.wolfram.com/GnomonicProjection.html
      Accessed: 12th November 2009
    */
  function init$15() {
    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
    // Approximation for projecting points to the horizon (infinity)
    this.infinity_dist = 1000 * this.a;
    this.rc = 1;
  }

  /* Gnomonic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$14(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g;
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);
    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);
    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if (g > 0 || Math.abs(g) <= EPSLN) {
      x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
    } else {
      // Point is in the opposing hemisphere and is unprojectable
      // We still need to return a reasonable point, so we project
      // to infinity, on a bearing
      // equivalent to the northern hemisphere equivalent
      // This is a reasonable approximation for short shapes and lines that
      // straddle the horizon.

      x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
      y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x;
    p.y = y;
    return p;
  }
  function inverse$14(p) {
    var rh; /* Rho */
    var sinc, cosc;
    var c;
    var lon, lat;

    /* Inverse equations
        -----------------*/
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;
    p.x /= this.k0;
    p.y /= this.k0;
    if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
      c = Math.atan2(rh, this.rc);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
      lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
      lon = adjust_lon(this.long0 + lon);
    } else {
      lat = this.phic0;
      lon = 0;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$16 = ["gnom"];
  var gnom = {
    init: init$15,
    forward: forward$14,
    inverse: inverse$14,
    names: names$16
  };
  var iqsfnz = function iqsfnz(eccent, q) {
    var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
    if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
      if (q < 0) {
        return -1 * HALF_PI;
      } else {
        return HALF_PI;
      }
    }
    //var phi = 0.5* q/(1-eccent*eccent);
    var phi = Math.asin(0.5 * q);
    var dphi;
    var sin_phi;
    var cos_phi;
    var con;
    for (var i = 0; i < 30; i++) {
      sin_phi = Math.sin(phi);
      cos_phi = Math.cos(phi);
      con = eccent * sin_phi;
      dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
    return NaN;
  };

  /*
    reference:
      "Cartographic Projection Procedures for the UNIX Environment-
      A User's Manual" by Gerald I. Evenden,
      USGS Open File Report 90-284and Release 4 Interim Reports (2003)
  */
  function init$16() {
    //no-op
    if (!this.sphere) {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }

  /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$15(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    if (this.sphere) {
      x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
      y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
    } else {
      var qs = qsfnz(this.e, Math.sin(lat));
      x = this.x0 + this.a * this.k0 * dlon;
      y = this.y0 + this.a * qs * 0.5 / this.k0;
    }
    p.x = x;
    p.y = y;
    return p;
  }

  /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$15(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat;
    if (this.sphere) {
      lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
      lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
    } else {
      lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
      lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$17 = ["cea"];
  var cea = {
    init: init$16,
    forward: forward$15,
    inverse: inverse$15,
    names: names$17
  };
  function init$17() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
    this.rc = Math.cos(this.lat_ts);
  }

  // forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$16(p) {
    var lon = p.x;
    var lat = p.y;
    var dlon = adjust_lon(lon - this.long0);
    var dlat = adjust_lat(lat - this.lat0);
    p.x = this.x0 + this.a * dlon * this.rc;
    p.y = this.y0 + this.a * dlat;
    return p;
  }

  // inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$16(p) {
    var x = p.x;
    var y = p.y;
    p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
    p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
    return p;
  }
  var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  var eqc = {
    init: init$17,
    forward: forward$16,
    inverse: inverse$16,
    names: names$18
  };
  var MAX_ITER$2 = 20;
  function init$18() {
    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
  }

  /* Polyconic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$17(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y, el;
    var dlon = adjust_lon(lon - this.long0);
    el = dlon * Math.sin(lat);
    if (this.sphere) {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.a * this.lat0;
      } else {
        x = this.a * Math.sin(el) / Math.tan(lat);
        y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
      }
    } else {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.ml0;
      } else {
        var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
        x = nl * Math.sin(el);
        y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
      }
    }
    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$17(p) {
    var lon, lat, x, y, i;
    var al, bl;
    var phi, dphi;
    x = p.x - this.x0;
    y = p.y - this.y0;
    if (this.sphere) {
      if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
        lon = adjust_lon(x / this.a + this.long0);
        lat = 0;
      } else {
        al = this.lat0 + y / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var tanphi;
        for (i = MAX_ITER$2; i; --i) {
          tanphi = Math.tan(phi);
          dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
          phi += dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }
        lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
      }
    } else {
      if (Math.abs(y + this.ml0) <= EPSLN) {
        lat = 0;
        lon = adjust_lon(this.long0 + x / this.a);
      } else {
        al = (this.ml0 + y) / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var cl, mln, mlnp, ma;
        var con;
        for (i = MAX_ITER$2; i; --i) {
          con = this.e * Math.sin(phi);
          cl = Math.sqrt(1 - con * con) * Math.tan(phi);
          mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
          mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
          ma = mln / this.a;
          dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
          phi -= dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }

        //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
        cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
        lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$19 = ["Polyconic", "poly"];
  var poly = {
    init: init$18,
    forward: forward$17,
    inverse: inverse$17,
    names: names$19
  };

  /*
    reference
      Department of Land and Survey Technical Circular 1973/32
        http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
      OSG Technical Report 4.1
        http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
    */

  /**
   * iterations: Number of iterations to refine inverse transform.
   *     0 -> km accuracy
   *     1 -> m accuracy -- suitable for most mapping applications
   *     2 -> mm accuracy
   */

  function init$19() {
    this.A = [];
    this.A[1] = 0.6399175073;
    this.A[2] = -0.1358797613;
    this.A[3] = 0.063294409;
    this.A[4] = -0.02526853;
    this.A[5] = 0.0117879;
    this.A[6] = -0.0055161;
    this.A[7] = 0.0026906;
    this.A[8] = -0.001333;
    this.A[9] = 0.00067;
    this.A[10] = -0.00034;
    this.B_re = [];
    this.B_im = [];
    this.B_re[1] = 0.7557853228;
    this.B_im[1] = 0;
    this.B_re[2] = 0.249204646;
    this.B_im[2] = 0.003371507;
    this.B_re[3] = -0.001541739;
    this.B_im[3] = 0.041058560;
    this.B_re[4] = -0.10162907;
    this.B_im[4] = 0.01727609;
    this.B_re[5] = -0.26623489;
    this.B_im[5] = -0.36249218;
    this.B_re[6] = -0.6870983;
    this.B_im[6] = -1.1651967;
    this.C_re = [];
    this.C_im = [];
    this.C_re[1] = 1.3231270439;
    this.C_im[1] = 0;
    this.C_re[2] = -0.577245789;
    this.C_im[2] = -0.007809598;
    this.C_re[3] = 0.508307513;
    this.C_im[3] = -0.112208952;
    this.C_re[4] = -0.15094762;
    this.C_im[4] = 0.18200602;
    this.C_re[5] = 1.01418179;
    this.C_im[5] = 1.64497696;
    this.C_re[6] = 1.9660549;
    this.C_im[6] = 2.5127645;
    this.D = [];
    this.D[1] = 1.5627014243;
    this.D[2] = 0.5185406398;
    this.D[3] = -0.03333098;
    this.D[4] = -0.1052906;
    this.D[5] = -0.0368594;
    this.D[6] = 0.007317;
    this.D[7] = 0.01220;
    this.D[8] = 0.00394;
    this.D[9] = -0.0013;
  }

  /**
      New Zealand Map Grid Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$18(p) {
    var n;
    var lon = p.x;
    var lat = p.y;
    var delta_lat = lat - this.lat0;
    var delta_lon = lon - this.long0;

    // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
    // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
    var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
    var d_lambda = delta_lon;
    var d_phi_n = 1; // d_phi^0

    var d_psi = 0;
    for (n = 1; n <= 10; n++) {
      d_phi_n = d_phi_n * d_phi;
      d_psi = d_psi + this.A[n] * d_phi_n;
    }

    // 2. Calculate theta
    var th_re = d_psi;
    var th_im = d_lambda;

    // 3. Calculate z
    var th_n_re = 1;
    var th_n_im = 0; // theta^0
    var th_n_re1;
    var th_n_im1;
    var z_re = 0;
    var z_im = 0;
    for (n = 1; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
      z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
    }

    // 4. Calculate easting and northing
    p.x = z_im * this.a + this.x0;
    p.y = z_re * this.a + this.y0;
    return p;
  }

  /**
      New Zealand Map Grid Inverse  -  x/y to long/lat
    */
  function inverse$18(p) {
    var n;
    var x = p.x;
    var y = p.y;
    var delta_x = x - this.x0;
    var delta_y = y - this.y0;

    // 1. Calculate z
    var z_re = delta_y / this.a;
    var z_im = delta_x / this.a;

    // 2a. Calculate theta - first approximation gives km accuracy
    var z_n_re = 1;
    var z_n_im = 0; // z^0
    var z_n_re1;
    var z_n_im1;
    var th_re = 0;
    var th_im = 0;
    for (n = 1; n <= 6; n++) {
      z_n_re1 = z_n_re * z_re - z_n_im * z_im;
      z_n_im1 = z_n_im * z_re + z_n_re * z_im;
      z_n_re = z_n_re1;
      z_n_im = z_n_im1;
      th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
      th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
    }

    // 2b. Iterate to refine the accuracy of the calculation
    //        0 iterations gives km accuracy
    //        1 iteration gives m accuracy -- good enough for most mapping applications
    //        2 iterations bives mm accuracy
    for (var i = 0; i < this.iterations; i++) {
      var th_n_re = th_re;
      var th_n_im = th_im;
      var th_n_re1;
      var th_n_im1;
      var num_re = z_re;
      var num_im = z_im;
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }
      th_n_re = 1;
      th_n_im = 0;
      var den_re = this.B_re[1];
      var den_im = this.B_im[1];
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      // Complex division
      var den2 = den_re * den_re + den_im * den_im;
      th_re = (num_re * den_re + num_im * den_im) / den2;
      th_im = (num_im * den_re - num_re * den_im) / den2;
    }

    // 3. Calculate d_phi              ...                                    // and d_lambda
    var d_psi = th_re;
    var d_lambda = th_im;
    var d_psi_n = 1; // d_psi^0

    var d_phi = 0;
    for (n = 1; n <= 9; n++) {
      d_psi_n = d_psi_n * d_psi;
      d_phi = d_phi + this.D[n] * d_psi_n;
    }

    // 4. Calculate latitude and longitude
    // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
    var lat = this.lat0 + d_phi * SEC_TO_RAD * 1E5;
    var lon = this.long0 + d_lambda;
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
  var nzmg = {
    init: init$19,
    forward: forward$18,
    inverse: inverse$18,
    names: names$20
  };

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */

  /* Initialize the Miller Cylindrical projection
    -------------------------------------------*/
  function init$20() {
    //no-op
  }

  /* Miller Cylindrical forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$19(p) {
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x = this.x0 + this.a * dlon;
    var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
    p.x = x;
    p.y = y;
    return p;
  }

  /* Miller Cylindrical inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$19(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon = adjust_lon(this.long0 + p.x / this.a);
    var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$21 = ["Miller_Cylindrical", "mill"];
  var mill = {
    init: init$20,
    forward: forward$19,
    inverse: inverse$19,
    names: names$21
  };
  var MAX_ITER$3 = 20;
  function init$21() {
    /* Place parameters in static storage for common use
      -------------------------------------------------*/

    if (!this.sphere) {
      this.en = pj_enfn(this.es);
    } else {
      this.n = 1;
      this.m = 0;
      this.es = 0;
      this.C_y = Math.sqrt((this.m + 1) / this.n);
      this.C_x = this.C_y / (this.m + 1);
    }
  }

  /* Sinusoidal forward equations--mapping lat,long to x,y
    -----------------------------------------------------*/
  function forward$20(p) {
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
      -----------------*/
    lon = adjust_lon(lon - this.long0);
    if (this.sphere) {
      if (!this.m) {
        lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
      } else {
        var k = this.n * Math.sin(lat);
        for (var i = MAX_ITER$3; i; --i) {
          var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
          lat -= V;
          if (Math.abs(V) < EPSLN) {
            break;
          }
        }
      }
      x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
      y = this.a * this.C_y * lat;
    } else {
      var s = Math.sin(lat);
      var c = Math.cos(lat);
      y = this.a * pj_mlfn(lat, s, c, this.en);
      x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
    }
    p.x = x;
    p.y = y;
    return p;
  }
  function inverse$20(p) {
    var lat, temp, lon, s;
    p.x -= this.x0;
    lon = p.x / this.a;
    p.y -= this.y0;
    lat = p.y / this.a;
    if (this.sphere) {
      lat /= this.C_y;
      lon = lon / (this.C_x * (this.m + Math.cos(lat)));
      if (this.m) {
        lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
      } else if (this.n !== 1) {
        lat = asinz(Math.sin(lat) / this.n);
      }
      lon = adjust_lon(lon + this.long0);
      lat = adjust_lat(lat);
    } else {
      lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
      s = Math.abs(lat);
      if (s < HALF_PI) {
        s = Math.sin(lat);
        temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
        //temp = this.long0 + p.x / (this.a * Math.cos(lat));
        lon = adjust_lon(temp);
      } else if (s - EPSLN < HALF_PI) {
        lon = this.long0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$22 = ["Sinusoidal", "sinu"];
  var sinu = {
    init: init$21,
    forward: forward$20,
    inverse: inverse$20,
    names: names$22
  };
  function init$22() {}
  /* Mollweide forward equations--mapping lat,long to x,y
      ----------------------------------------------------*/
  function forward$21(p) {
    /* Forward equations
        -----------------*/
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon(lon - this.long0);
    var theta = lat;
    var con = Math.PI * Math.sin(lat);

    /* Iterate using the Newton-Raphson method to find theta
        -----------------------------------------------------*/
    while (true) {
      var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
      theta += delta_theta;
      if (Math.abs(delta_theta) < EPSLN) {
        break;
      }
    }
    theta /= 2;

    /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
         this is done here because of precision problems with "cos(theta)"
         --------------------------------------------------------------------------*/
    if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
      delta_lon = 0;
    }
    var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
    var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
    p.x = x;
    p.y = y;
    return p;
  }
  function inverse$21(p) {
    var theta;
    var arg;

    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    arg = p.y / (1.4142135623731 * this.a);

    /* Because of division by zero problems, 'arg' can not be 1.  Therefore
         a number very close to one is used instead.
         -------------------------------------------------------------------*/
    if (Math.abs(arg) > 0.999999999999) {
      arg = 0.999999999999;
    }
    theta = Math.asin(arg);
    var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
    if (lon < -Math.PI) {
      lon = -Math.PI;
    }
    if (lon > Math.PI) {
      lon = Math.PI;
    }
    arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
    if (Math.abs(arg) > 1) {
      arg = 1;
    }
    var lat = Math.asin(arg);
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$23 = ["Mollweide", "moll"];
  var moll = {
    init: init$22,
    forward: forward$21,
    inverse: inverse$21,
    names: names$23
  };
  function init$23() {
    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.lat2 = this.lat2 || this.lat1;
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.sinphi = Math.sin(this.lat1);
    this.cosphi = Math.cos(this.lat1);
    this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
    if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
      this.ns = this.sinphi;
    } else {
      this.sinphi = Math.sin(this.lat2);
      this.cosphi = Math.cos(this.lat2);
      this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
      this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
    }
    this.g = this.ml1 + this.ms1 / this.ns;
    this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    this.rh = this.a * (this.g - this.ml0);
  }

  /* Equidistant Conic forward equations--mapping lat,long to x,y
    -----------------------------------------------------------*/
  function forward$22(p) {
    var lon = p.x;
    var lat = p.y;
    var rh1;

    /* Forward equations
        -----------------*/
    if (this.sphere) {
      rh1 = this.a * (this.g - lat);
    } else {
      var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
      rh1 = this.a * (this.g - ml);
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    var x = this.x0 + rh1 * Math.sin(theta);
    var y = this.y0 + this.rh - rh1 * Math.cos(theta);
    p.x = x;
    p.y = y;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$22(p) {
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    var con, rh1, lat, lon;
    if (this.ns >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    } else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    if (this.sphere) {
      lon = adjust_lon(this.long0 + theta / this.ns);
      lat = adjust_lat(this.g - rh1 / this.a);
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      var ml = this.g - rh1 / this.a;
      lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
      lon = adjust_lon(this.long0 + theta / this.ns);
      p.x = lon;
      p.y = lat;
      return p;
    }
  }
  var names$24 = ["Equidistant_Conic", "eqdc"];
  var eqdc = {
    init: init$23,
    forward: forward$22,
    inverse: inverse$22,
    names: names$24
  };

  /* Initialize the Van Der Grinten projection
    ----------------------------------------*/
  function init$24() {
    //this.R = 6370997; //Radius of earth
    this.R = this.a;
  }
  function forward$23(p) {
    var lon = p.x;
    var lat = p.y;

    /* Forward equations
      -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x, y;
    if (Math.abs(lat) <= EPSLN) {
      x = this.x0 + this.R * dlon;
      y = this.y0;
    }
    var theta = asinz(2 * Math.abs(lat / Math.PI));
    if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      x = this.x0;
      if (lat >= 0) {
        y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
      } else {
        y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
      }
      //  return(OK);
    }

    var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
    var asq = al * al;
    var sinth = Math.sin(theta);
    var costh = Math.cos(theta);
    var g = costh / (sinth + costh - 1);
    var gsq = g * g;
    var m = g * (2 / sinth - 1);
    var msq = m * m;
    var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
    if (dlon < 0) {
      con = -con;
    }
    x = this.x0 + con;
    //con = Math.abs(con / (Math.PI * this.R));
    var q = asq + g;
    con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
    if (lat >= 0) {
      //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 + con;
    } else {
      //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 - con;
    }
    p.x = x;
    p.y = y;
    return p;
  }

  /* Van Der Grinten inverse equations--mapping x,y to lat/long
    ---------------------------------------------------------*/
  function inverse$23(p) {
    var lon, lat;
    var xx, yy, xys, c1, c2, c3;
    var a1;
    var m1;
    var con;
    var th1;
    var d;

    /* inverse equations
      -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    con = Math.PI * this.R;
    xx = p.x / con;
    yy = p.y / con;
    xys = xx * xx + yy * yy;
    c1 = -Math.abs(yy) * (1 + xys);
    c2 = c1 - 2 * yy * yy + xx * xx;
    c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
    d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
    a1 = (c1 - c2 * c2 / 3 / c3) / c3;
    m1 = 2 * Math.sqrt(-a1 / 3);
    con = 3 * d / a1 / m1;
    if (Math.abs(con) > 1) {
      if (con >= 0) {
        con = 1;
      } else {
        con = -1;
      }
    }
    th1 = Math.acos(con) / 3;
    if (p.y >= 0) {
      lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    } else {
      lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }
    if (Math.abs(xx) < EPSLN) {
      lon = this.long0;
    } else {
      lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  var vandg = {
    init: init$24,
    forward: forward$23,
    inverse: inverse$23,
    names: names$25
  };
  function init$25() {
    this.sin_p12 = Math.sin(this.lat0);
    this.cos_p12 = Math.cos(this.lat0);
  }
  function forward$24(p) {
    var lon = p.x;
    var lat = p.y;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var dlon = adjust_lon(lon - this.long0);
    var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
    if (this.sphere) {
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
        p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
        return p;
      } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
        p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
        return p;
      } else {
        //default case
        cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
        c = Math.acos(cos_c);
        kp = c ? c / Math.sin(c) : 1;
        p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
        p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
        return p;
      }
    } else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
        p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
        return p;
      } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
        p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
        return p;
      } else {
        //Default case
        tanphi = sinphi / cosphi;
        Nl1 = gN(this.a, this.e, this.sin_p12);
        Nl = gN(this.a, this.e, sinphi);
        psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
        Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
        if (Az === 0) {
          s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
          s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        } else {
          s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
        }
        G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
        H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
        GH = G * H;
        Hs = H * H;
        s2 = s * s;
        s3 = s2 * s;
        s4 = s3 * s;
        s5 = s4 * s;
        c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
        p.x = this.x0 + c * Math.sin(Az);
        p.y = this.y0 + c * Math.cos(Az);
        return p;
      }
    }
  }
  function inverse$24(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
    if (this.sphere) {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (rh > 2 * HALF_PI * this.a) {
        return;
      }
      z = rh / this.a;
      sinz = Math.sin(z);
      cosz = Math.cos(z);
      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
      } else {
        lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
        con = Math.abs(this.lat0) - HALF_PI;
        if (Math.abs(con) <= EPSLN) {
          if (this.lat0 >= 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
          } else {
            lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
          }
        } else {
          /*con = cosz - this.sin_p12 * Math.sin(lat);
          if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
            //no-op, just keep the lon value as is
          } else {
            var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
            lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
          }*/
          lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
        }
      }
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = Mlp - rh;
        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
        p.x = lon;
        p.y = lat;
        return p;
      } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = rh - Mlp;
        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        p.x = lon;
        p.y = lat;
        return p;
      } else {
        //default case
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        Az = Math.atan2(p.x, p.y);
        N1 = gN(this.a, this.e, this.sin_p12);
        cosAz = Math.cos(Az);
        tmp = this.e * this.cos_p12 * cosAz;
        A = -tmp * tmp / (1 - this.es);
        B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
        D = rh / N1;
        Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
        F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
        psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
        lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
        sinpsi = Math.sin(psi);
        lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
        p.x = lon;
        p.y = lat;
        return p;
      }
    }
  }
  var names$26 = ["Azimuthal_Equidistant", "aeqd"];
  var aeqd = {
    init: init$25,
    forward: forward$24,
    inverse: inverse$24,
    names: names$26
  };
  function init$26() {
    //double temp;      /* temporary variable    */

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
  }

  /* Orthographic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$25(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g, x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);
    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);
    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if (g > 0 || Math.abs(g) <= EPSLN) {
      x = this.a * ksp * cosphi * Math.sin(dlon);
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x;
    p.y = y;
    return p;
  }
  function inverse$25(p) {
    var rh; /* height above ellipsoid      */
    var z; /* angle          */
    var sinz, cosz; /* sin of z and cos of z      */
    var con;
    var lon, lat;
    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    z = asinz(rh / this.a);
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
    con = Math.abs(this.lat0) - HALF_PI;
    if (Math.abs(con) <= EPSLN) {
      if (this.lat0 >= 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
      } else {
        lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names$27 = ["ortho"];
  var ortho = {
    init: init$26,
    forward: forward$25,
    inverse: inverse$25,
    names: names$27
  };

  // QSC projection rewritten from the original PROJ4
  // https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

  /* constants */
  var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
  };
  var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
  };
  function init$27() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Quadrilateralized Spherical Cube";

    /* Determine the cube face from the center of projection. */
    if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
      this.face = FACE_ENUM.TOP;
    } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
      this.face = FACE_ENUM.BOTTOM;
    } else if (Math.abs(this.long0) <= FORTPI) {
      this.face = FACE_ENUM.FRONT;
    } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
      this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
    } else {
      this.face = FACE_ENUM.BACK;
    }

    /* Fill in useful values for the ellipsoid <-> sphere shift
     * described in [LK12]. */
    if (this.es !== 0) {
      this.one_minus_f = 1 - (this.a - this.b) / this.a;
      this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
    }
  }

  // QSC forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$26(p) {
    var xy = {
      x: 0,
      y: 0
    };
    var lat, lon;
    var theta, phi;
    var t, mu;
    /* nu; */
    var area = {
      value: 0
    };

    // move lon according to projection's lon
    p.x -= this.long0;

    /* Convert the geodetic latitude to a geocentric latitude.
     * This corresponds to the shift from the ellipsoid to the sphere
     * described in [LK12]. */
    if (this.es !== 0) {
      //if (P->es != 0) {
      lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
    } else {
      lat = p.y;
    }

    /* Convert the input lat, lon into theta, phi as used by QSC.
     * This depends on the cube face and the area on it.
     * For the top and bottom face, we can compute theta and phi
     * directly from phi, lam. For the other faces, we must use
     * unit sphere cartesian coordinates as an intermediate step. */
    lon = p.x; //lon = lp.lam;
    if (this.face === FACE_ENUM.TOP) {
      phi = HALF_PI - lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = lon - HALF_PI;
      } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_1;
        theta = lon > 0.0 ? lon - SPI : lon + SPI;
      } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
        area.value = AREA_ENUM.AREA_2;
        theta = lon + HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = lon;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = HALF_PI + lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = -lon + HALF_PI;
      } else if (lon < FORTPI && lon >= -FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta = -lon;
      } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = -lon - HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = lon > 0.0 ? -lon + SPI : -lon - SPI;
      }
    } else {
      var q, r, s;
      var sinlat, coslat;
      var sinlon, coslon;
      if (this.face === FACE_ENUM.RIGHT) {
        lon = qsc_shift_lon_origin(lon, +HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lon = qsc_shift_lon_origin(lon, +SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lon = qsc_shift_lon_origin(lon, -HALF_PI);
      }
      sinlat = Math.sin(lat);
      coslat = Math.cos(lat);
      sinlon = Math.sin(lon);
      coslon = Math.cos(lon);
      q = coslat * coslon;
      r = coslat * sinlon;
      s = sinlat;
      if (this.face === FACE_ENUM.FRONT) {
        phi = Math.acos(q);
        theta = qsc_fwd_equat_face_theta(phi, s, r, area);
      } else if (this.face === FACE_ENUM.RIGHT) {
        phi = Math.acos(r);
        theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
      } else if (this.face === FACE_ENUM.BACK) {
        phi = Math.acos(-q);
        theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
      } else if (this.face === FACE_ENUM.LEFT) {
        phi = Math.acos(-r);
        theta = qsc_fwd_equat_face_theta(phi, s, q, area);
      } else {
        /* Impossible */
        phi = theta = 0;
        area.value = AREA_ENUM.AREA_0;
      }
    }

    /* Compute mu and nu for the area of definition.
     * For mu, see Eq. (3-21) in [OL76], but note the typos:
     * compare with Eq. (3-14). For nu, see Eq. (3-38). */
    mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
    t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

    /* Apply the result to the real area. */
    if (area.value === AREA_ENUM.AREA_1) {
      mu += HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      mu += SPI;
    } else if (area.value === AREA_ENUM.AREA_3) {
      mu += 1.5 * SPI;
    }

    /* Now compute x, y from mu and nu */
    xy.x = t * Math.cos(mu);
    xy.y = t * Math.sin(mu);
    xy.x = xy.x * this.a + this.x0;
    xy.y = xy.y * this.a + this.y0;
    p.x = xy.x;
    p.y = xy.y;
    return p;
  }

  // QSC inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$26(p) {
    var lp = {
      lam: 0,
      phi: 0
    };
    var mu, nu, cosmu, tannu;
    var tantheta, theta, cosphi, phi;
    var t;
    var area = {
      value: 0
    };

    /* de-offset */
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    /* Convert the input x, y to the mu and nu angles as used by QSC.
     * This depends on the area of the cube face. */
    nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
    mu = Math.atan2(p.y, p.x);
    if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_0;
    } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
      area.value = AREA_ENUM.AREA_1;
      mu -= HALF_PI;
    } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_2;
      mu = mu < 0.0 ? mu + SPI : mu - SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      mu += HALF_PI;
    }

    /* Compute phi and theta for the area of definition.
     * The inverse projection is not described in the original paper, but some
     * good hints can be found here (as of 2011-12-14):
     * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
     * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
    t = SPI / 12 * Math.tan(mu);
    tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
    theta = Math.atan(tantheta);
    cosmu = Math.cos(mu);
    tannu = Math.tan(nu);
    cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
    if (cosphi < -1) {
      cosphi = -1;
    } else if (cosphi > +1) {
      cosphi = +1;
    }

    /* Apply the result to the real area on the cube face.
     * For the top and bottom face, we can compute phi and lam directly.
     * For the other faces, we must use unit sphere cartesian coordinates
     * as an intermediate step. */
    if (this.face === FACE_ENUM.TOP) {
      phi = Math.acos(cosphi);
      lp.phi = HALF_PI - phi;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = theta < 0.0 ? theta + SPI : theta - SPI;
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */{
          lp.lam = theta;
        }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = Math.acos(cosphi);
      lp.phi = phi - HALF_PI;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = -theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = -theta;
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = -theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */{
          lp.lam = theta < 0.0 ? -theta - SPI : -theta + SPI;
        }
    } else {
      /* Compute phi and lam via cartesian unit sphere coordinates. */
      var q, r, s;
      q = cosphi;
      t = q * q;
      if (t >= 1) {
        s = 0;
      } else {
        s = Math.sqrt(1 - t) * Math.sin(theta);
      }
      t += s * s;
      if (t >= 1) {
        r = 0;
      } else {
        r = Math.sqrt(1 - t);
      }
      /* Rotate q,r,s into the correct area. */
      if (area.value === AREA_ENUM.AREA_1) {
        t = r;
        r = -s;
        s = t;
      } else if (area.value === AREA_ENUM.AREA_2) {
        r = -r;
        s = -s;
      } else if (area.value === AREA_ENUM.AREA_3) {
        t = r;
        r = s;
        s = -t;
      }
      /* Rotate q,r,s into the correct cube face. */
      if (this.face === FACE_ENUM.RIGHT) {
        t = q;
        q = -r;
        r = t;
      } else if (this.face === FACE_ENUM.BACK) {
        q = -q;
        r = -r;
      } else if (this.face === FACE_ENUM.LEFT) {
        t = q;
        q = r;
        r = -t;
      }
      /* Now compute phi and lam from the unit sphere coordinates. */
      lp.phi = Math.acos(-s) - HALF_PI;
      lp.lam = Math.atan2(r, q);
      if (this.face === FACE_ENUM.RIGHT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
      }
    }

    /* Apply the shift from the sphere to the ellipsoid as described
     * in [LK12]. */
    if (this.es !== 0) {
      var invert_sign;
      var tanphi, xa;
      invert_sign = lp.phi < 0 ? 1 : 0;
      tanphi = Math.tan(lp.phi);
      xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
      lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
      if (invert_sign) {
        lp.phi = -lp.phi;
      }
    }
    lp.lam += this.long0;
    p.x = lp.lam;
    p.y = lp.phi;
    return p;
  }

  /* Helper function for forward projection: compute the theta angle
   * and determine the area number. */
  function qsc_fwd_equat_face_theta(phi, y, x, area) {
    var theta;
    if (phi < EPSLN) {
      area.value = AREA_ENUM.AREA_0;
      theta = 0.0;
    } else {
      theta = Math.atan2(y, x);
      if (Math.abs(theta) <= FORTPI) {
        area.value = AREA_ENUM.AREA_0;
      } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta -= HALF_PI;
      } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = theta >= 0.0 ? theta - SPI : theta + SPI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta += HALF_PI;
      }
    }
    return theta;
  }

  /* Helper function: shift the longitude. */
  function qsc_shift_lon_origin(lon, offset) {
    var slon = lon + offset;
    if (slon < -SPI) {
      slon += TWO_PI;
    } else if (slon > +SPI) {
      slon -= TWO_PI;
    }
    return slon;
  }
  var names$28 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  var qsc = {
    init: init$27,
    forward: forward$26,
    inverse: inverse$26,
    names: names$28
  };

  // Robinson projection
  // Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
  // Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039

  var COEFS_X = [[1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06], [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06], [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07], [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06], [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06], [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08], [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06], [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06], [0.9216, -0.00467746, -0.00010457, 4.81243e-06], [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06], [0.8679, -0.00609363, -0.000113898, 3.32484e-06], [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07], [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07], [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06], [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06], [0.6732, -0.00986209, -0.000199569, 1.91974e-05], [0.6213, -0.010418, 8.83923e-05, 6.24051e-06], [0.5722, -0.00906601, 0.000182, 6.24051e-06], [0.5322, -0.00677797, 0.000275608, 6.24051e-06]];
  var COEFS_Y = [[-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11], [0.0620, 0.0124, -1.26793e-09, 4.22642e-10], [0.1240, 0.0124, 5.07171e-09, -1.60604e-09], [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09], [0.2480, 0.0124002, 7.10039e-08, -2.24e-08], [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08], [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07], [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07], [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07], [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07], [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07], [0.6769, 0.011713, -3.20223e-05, -5.16405e-07], [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07], [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06], [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09], [0.8936, 0.00969686, -6.4636e-05, -8.547e-06], [0.9394, 0.00840947, -0.000192841, -4.2106e-06], [0.9761, 0.00616527, -0.000256, -4.2106e-06], [1.0000, 0.00328947, -0.000319159, -4.2106e-06]];
  var FXC = 0.8487;
  var FYC = 1.3523;
  var C1 = R2D / 5; // rad to 5-degree interval
  var RC1 = 1 / C1;
  var NODES = 18;
  var poly3_val = function poly3_val(coefs, x) {
    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
  };
  var poly3_der = function poly3_der(coefs, x) {
    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
  };
  function newton_rapshon(f_df, start, max_err, iters) {
    var x = start;
    for (; iters; --iters) {
      var upd = f_df(x);
      x -= upd;
      if (Math.abs(upd) < max_err) {
        break;
      }
    }
    return x;
  }
  function init$28() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.long0 = this.long0 || 0;
    this.es = 0;
    this.title = this.title || "Robinson";
  }
  function forward$27(ll) {
    var lon = adjust_lon(ll.x - this.long0);
    var dphi = Math.abs(ll.y);
    var i = Math.floor(dphi * C1);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    dphi = R2D * (dphi - RC1 * i);
    var xy = {
      x: poly3_val(COEFS_X[i], dphi) * lon,
      y: poly3_val(COEFS_Y[i], dphi)
    };
    if (ll.y < 0) {
      xy.y = -xy.y;
    }
    xy.x = xy.x * this.a * FXC + this.x0;
    xy.y = xy.y * this.a * FYC + this.y0;
    return xy;
  }
  function inverse$27(xy) {
    var ll = {
      x: (xy.x - this.x0) / (this.a * FXC),
      y: Math.abs(xy.y - this.y0) / (this.a * FYC)
    };
    if (ll.y >= 1) {
      // pathologic case
      ll.x /= COEFS_X[NODES][0];
      ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
    } else {
      // find table interval
      var i = Math.floor(ll.y * NODES);
      if (i < 0) {
        i = 0;
      } else if (i >= NODES) {
        i = NODES - 1;
      }
      for (;;) {
        if (COEFS_Y[i][0] > ll.y) {
          --i;
        } else if (COEFS_Y[i + 1][0] <= ll.y) {
          ++i;
        } else {
          break;
        }
      }
      // linear interpolation in 5 degree interval
      var coefs = COEFS_Y[i];
      var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
      // find t so that poly3_val(coefs, t) = ll.y
      t = newton_rapshon(function (x) {
        return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
      }, t, EPSLN, 100);
      ll.x /= poly3_val(COEFS_X[i], t);
      ll.y = (5 * i + t) * D2R;
      if (xy.y < 0) {
        ll.y = -ll.y;
      }
    }
    ll.x = adjust_lon(ll.x + this.long0);
    return ll;
  }
  var names$29 = ["Robinson", "robin"];
  var robin = {
    init: init$28,
    forward: forward$27,
    inverse: inverse$27,
    names: names$29
  };
  function init$29() {
    this.name = 'geocent';
  }
  function forward$28(p) {
    var point = geodeticToGeocentric(p, this.es, this.a);
    return point;
  }
  function inverse$28(p) {
    var point = geocentricToGeodetic(p, this.es, this.a, this.b);
    return point;
  }
  var names$30 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
  var geocent = {
    init: init$29,
    forward: forward$28,
    inverse: inverse$28,
    names: names$30
  };
  var mode = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  };
  var params = {
    h: {
      def: 100000,
      num: true
    },
    // default is Karman line, no default in PROJ.7
    azi: {
      def: 0,
      num: true,
      degrees: true
    },
    // default is North
    tilt: {
      def: 0,
      num: true,
      degrees: true
    },
    // default is Nadir
    long0: {
      def: 0,
      num: true
    },
    // default is Greenwich, conversion to rad is automatic
    lat0: {
      def: 0,
      num: true
    } // default is Equator, conversion to rad is automatic
  };

  function init$30() {
    Object.keys(params).forEach(function (p) {
      if (typeof this[p] === "undefined") {
        this[p] = params[p].def;
      } else if (params[p].num && isNaN(this[p])) {
        throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
      } else if (params[p].num) {
        this[p] = parseFloat(this[p]);
      }
      if (params[p].degrees) {
        this[p] = this[p] * D2R;
      }
    }.bind(this));
    if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
    } else if (Math.abs(this.lat0) < EPSLN) {
      this.mode = mode.EQUIT;
    } else {
      this.mode = mode.OBLIQ;
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
    this.pn1 = this.h / this.a; // Normalize relative to the Earth's radius

    if (this.pn1 <= 0 || this.pn1 > 1e10) {
      throw new Error("Invalid height");
    }
    this.p = 1 + this.pn1;
    this.rp = 1 / this.p;
    this.h1 = 1 / this.pn1;
    this.pfact = (this.p + 1) * this.h1;
    this.es = 0;
    var omega = this.tilt;
    var gamma = this.azi;
    this.cg = Math.cos(gamma);
    this.sg = Math.sin(gamma);
    this.cw = Math.cos(omega);
    this.sw = Math.sin(omega);
  }
  function forward$29(p) {
    p.x -= this.long0;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var coslam = Math.cos(p.x);
    var x, y;
    switch (this.mode) {
      case mode.OBLIQ:
        y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y = cosphi * coslam;
        break;
      case mode.S_POLE:
        y = -sinphi;
        break;
      case mode.N_POLE:
        y = sinphi;
        break;
    }
    y = this.pn1 / (this.p - y);
    x = y * cosphi * Math.sin(p.x);
    switch (this.mode) {
      case mode.OBLIQ:
        y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y *= sinphi;
        break;
      case mode.N_POLE:
        y *= -(cosphi * coslam);
        break;
      case mode.S_POLE:
        y *= cosphi * coslam;
        break;
    }

    // Tilt 
    var yt, ba;
    yt = y * this.cg + x * this.sg;
    ba = 1 / (yt * this.sw * this.h1 + this.cw);
    x = (x * this.cg - y * this.sg) * this.cw * ba;
    y = yt * ba;
    p.x = x * this.a;
    p.y = y * this.a;
    return p;
  }
  function inverse$29(p) {
    p.x /= this.a;
    p.y /= this.a;
    var r = {
      x: p.x,
      y: p.y
    };

    // Un-Tilt
    var bm, bq, yt;
    yt = 1 / (this.pn1 - p.y * this.sw);
    bm = this.pn1 * p.x * yt;
    bq = this.pn1 * p.y * this.cw * yt;
    p.x = bm * this.cg + bq * this.sg;
    p.y = bq * this.cg - bm * this.sg;
    var rh = hypot(p.x, p.y);
    if (Math.abs(rh) < EPSLN) {
      r.x = 0;
      r.y = p.y;
    } else {
      var cosz, sinz;
      sinz = 1 - rh * rh * this.pfact;
      sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
      cosz = Math.sqrt(1 - sinz * sinz);
      switch (this.mode) {
        case mode.OBLIQ:
          r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
          p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
          p.x *= sinz * this.cosph0;
          break;
        case mode.EQUIT:
          r.y = Math.asin(p.y * sinz / rh);
          p.y = cosz * rh;
          p.x *= sinz;
          break;
        case mode.N_POLE:
          r.y = Math.asin(cosz);
          p.y = -p.y;
          break;
        case mode.S_POLE:
          r.y = -Math.asin(cosz);
          break;
      }
      r.x = Math.atan2(p.x, p.y);
    }
    p.x = r.x + this.long0;
    p.y = r.y;
    return p;
  }
  var names$31 = ["Tilted_Perspective", "tpers"];
  var tpers = {
    init: init$30,
    forward: forward$29,
    inverse: inverse$29,
    names: names$31
  };
  function init$31() {
    this.flip_axis = this.sweep === 'x' ? 1 : 0;
    this.h = Number(this.h);
    this.radius_g_1 = this.h / this.a;
    if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
      throw new Error();
    }
    this.radius_g = 1.0 + this.radius_g_1;
    this.C = this.radius_g * this.radius_g - 1.0;
    if (this.es !== 0.0) {
      var one_es = 1.0 - this.es;
      var rone_es = 1 / one_es;
      this.radius_p = Math.sqrt(one_es);
      this.radius_p2 = one_es;
      this.radius_p_inv2 = rone_es;
      this.shape = 'ellipse'; // Use as a condition in the forward and inverse functions.
    } else {
      this.radius_p = 1.0;
      this.radius_p2 = 1.0;
      this.radius_p_inv2 = 1.0;
      this.shape = 'sphere'; // Use as a condition in the forward and inverse functions.
    }

    if (!this.title) {
      this.title = "Geostationary Satellite View";
    }
  }
  function forward$30(p) {
    var lon = p.x;
    var lat = p.y;
    var tmp, v_x, v_y, v_z;
    lon = lon - this.long0;
    if (this.shape === 'ellipse') {
      lat = Math.atan(this.radius_p2 * Math.tan(lat));
      var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));
      v_x = r * Math.cos(lon) * Math.cos(lat);
      v_y = r * Math.sin(lon) * Math.cos(lat);
      v_z = r * Math.sin(lat);
      if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0.0) {
        p.x = Number.NaN;
        p.y = Number.NaN;
        return p;
      }
      tmp = this.radius_g - v_x;
      if (this.flip_axis) {
        p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
        p.y = this.radius_g_1 * Math.atan(v_z / tmp);
      } else {
        p.x = this.radius_g_1 * Math.atan(v_y / tmp);
        p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
      }
    } else if (this.shape === 'sphere') {
      tmp = Math.cos(lat);
      v_x = Math.cos(lon) * tmp;
      v_y = Math.sin(lon) * tmp;
      v_z = Math.sin(lat);
      tmp = this.radius_g - v_x;
      if (this.flip_axis) {
        p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
        p.y = this.radius_g_1 * Math.atan(v_z / tmp);
      } else {
        p.x = this.radius_g_1 * Math.atan(v_y / tmp);
        p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
      }
    }
    p.x = p.x * this.a;
    p.y = p.y * this.a;
    return p;
  }
  function inverse$30(p) {
    var v_x = -1.0;
    var v_y = 0.0;
    var v_z = 0.0;
    var a, b, det, k;
    p.x = p.x / this.a;
    p.y = p.y / this.a;
    if (this.shape === 'ellipse') {
      if (this.flip_axis) {
        v_z = Math.tan(p.y / this.radius_g_1);
        v_y = Math.tan(p.x / this.radius_g_1) * hypot(1.0, v_z);
      } else {
        v_y = Math.tan(p.x / this.radius_g_1);
        v_z = Math.tan(p.y / this.radius_g_1) * hypot(1.0, v_y);
      }
      var v_zp = v_z / this.radius_p;
      a = v_y * v_y + v_zp * v_zp + v_x * v_x;
      b = 2 * this.radius_g * v_x;
      det = b * b - 4 * a * this.C;
      if (det < 0.0) {
        p.x = Number.NaN;
        p.y = Number.NaN;
        return p;
      }
      k = (-b - Math.sqrt(det)) / (2.0 * a);
      v_x = this.radius_g + k * v_x;
      v_y *= k;
      v_z *= k;
      p.x = Math.atan2(v_y, v_x);
      p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
      p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
    } else if (this.shape === 'sphere') {
      if (this.flip_axis) {
        v_z = Math.tan(p.y / this.radius_g_1);
        v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);
      } else {
        v_y = Math.tan(p.x / this.radius_g_1);
        v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);
      }
      a = v_y * v_y + v_z * v_z + v_x * v_x;
      b = 2 * this.radius_g * v_x;
      det = b * b - 4 * a * this.C;
      if (det < 0.0) {
        p.x = Number.NaN;
        p.y = Number.NaN;
        return p;
      }
      k = (-b - Math.sqrt(det)) / (2.0 * a);
      v_x = this.radius_g + k * v_x;
      v_y *= k;
      v_z *= k;
      p.x = Math.atan2(v_y, v_x);
      p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    }
    p.x = p.x + this.long0;
    return p;
  }
  var names$32 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
  var geos = {
    init: init$31,
    forward: forward$30,
    inverse: inverse$30,
    names: names$32
  };
  var includedProjections = function includedProjections(proj4) {
    proj4.Proj.projections.add(tmerc);
    proj4.Proj.projections.add(etmerc);
    proj4.Proj.projections.add(utm);
    proj4.Proj.projections.add(sterea);
    proj4.Proj.projections.add(stere);
    proj4.Proj.projections.add(somerc);
    proj4.Proj.projections.add(omerc);
    proj4.Proj.projections.add(lcc);
    proj4.Proj.projections.add(krovak);
    proj4.Proj.projections.add(cass);
    proj4.Proj.projections.add(laea);
    proj4.Proj.projections.add(aea);
    proj4.Proj.projections.add(gnom);
    proj4.Proj.projections.add(cea);
    proj4.Proj.projections.add(eqc);
    proj4.Proj.projections.add(poly);
    proj4.Proj.projections.add(nzmg);
    proj4.Proj.projections.add(mill);
    proj4.Proj.projections.add(sinu);
    proj4.Proj.projections.add(moll);
    proj4.Proj.projections.add(eqdc);
    proj4.Proj.projections.add(vandg);
    proj4.Proj.projections.add(aeqd);
    proj4.Proj.projections.add(ortho);
    proj4.Proj.projections.add(qsc);
    proj4.Proj.projections.add(robin);
    proj4.Proj.projections.add(geocent);
    proj4.Proj.projections.add(tpers);
    proj4.Proj.projections.add(geos);
  };
  proj4$1.defaultDatum = 'WGS84'; //default datum
  proj4$1.Proj = Projection;
  proj4$1.WGS84 = new proj4$1.Proj('WGS84');
  proj4$1.Point = Point$1;
  proj4$1.toPoint = toPoint;
  proj4$1.defs = defs;
  proj4$1.nadgrid = nadgrid;
  proj4$1.transform = transform;
  proj4$1.mgrs = mgrs;
  proj4$1.version = '2.9.1-alpha';
  includedProjections(proj4$1);

  var Layer = /*#__PURE__*/function (_Group) {
    _inherits(Layer, _Group);
    var _super = _createSuper(Layer);
    function Layer(source) {
      var _this;
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.67;
      _classCallCheck(this, Layer);
      _this = _super.call(this);
      _this._scale = scale;
      _this.viewEPSG = 'EPSG:900913';
      _this.source = source;
      var extent = _this.source.extent;
      _this.EPSG = extent.SRS;
      _this.frustumCulled = false;
      var lowerLeft = proj4$1(_this.EPSG, _this.viewEPSG, extent.lowerCorner);
      var upperRight = proj4$1(_this.EPSG, _this.viewEPSG, extent.upperCorner);
      _this.boundBox = {
        lowerLeft: lowerLeft,
        upperRight: upperRight
      };
      _this.center = [(lowerLeft[0] + upperRight[0]) / 2, (lowerLeft[1] + upperRight[1]) / 2, 0];
      return _this;
    }
    _createClass(Layer, [{
      key: "lonlatCenter",
      get: function get() {
        return proj4$1('EPSG:900913', 'EPSG:4326', this.center);
      }
    }, {
      key: "ProjectArray",
      value: function ProjectArray(a, source, target, projectZ) {
        if (projectZ) {
          for (var i = 0; i < a.length; i += 3) {
            var p = proj4$1(this.EPSG, this.viewEPSG, [a[i], a[i + 1], a[i + 2]]);
            a.set(p, i);
          }
        } else {
          for (var i = 0; i < a.length; i += 3) {
            var _p = proj4$1(this.EPSG, this.viewEPSG, [a[i], a[i + 1], a[i + 2]]);
            a.set([_p[0], _p[1], a[i + 2]], i);
          }
        }
      }
    }, {
      key: "FloatArrayWorldToViewPort",
      value: function FloatArrayWorldToViewPort(a) {
        var p = new Float32Array(a.length);
        for (var i = 0; i < p.length; i += 3) {
          p.set([(a[i] - this.center[0]) * this._scale, (a[i + 1] - this.center[1]) * this._scale, (a[i + 2] - this.center[2]) * this._scale], i);
        }
        return p;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (values === undefined) return;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === undefined) {
            continue;
          }
          if (key in this) {
            this[key] = newValue;
          }
        }
      }
    }, {
      key: "update",
      value: function update(frameState) {
        frameState.threeEarth;
        // console.log(111)
      }
    }]);
    return Layer;
  }(Group$1);

  var CityGMLLayer = /*#__PURE__*/function (_Layer) {
    _inherits(CityGMLLayer, _Layer);
    var _super = _createSuper(CityGMLLayer);
    function CityGMLLayer(source, scale) {
      var _this;
      _classCallCheck(this, CityGMLLayer);
      _this = _super.call(this, source, scale);
      _this.objects = new Object3D$1();
      _this.flatObjects = [];
      _this.flatQueryObjects = [];
      _this.hasRealWorldZ = false;
      if (source) {
        _this.addObject3Ds(source.features);
        _this.GetObject3Ds(false);
      }
      return _this;
    }
    _createClass(CityGMLLayer, [{
      key: "addObject3D",
      value: function addObject3D(object3D) {
        this.objects.add(object3D);
      }
    }, {
      key: "addObject3Ds",
      value: function addObject3Ds(object3Ds) {
        for (var i = 0; i < object3Ds.length; i++) {
          this.objects.add(object3Ds[i]);
        }
      }
    }, {
      key: "SetVisibility",
      value: function SetVisibility(id, visible) {
        var desc = [];
        var obj = this.objects.getObjectByName(id, true);
        if (id == "" && obj == undefined) {
          this.objects.visible = visible;
          // this.objects.getDescendants(desc);
          getDescendants(this.objects, desc);
        } else {
          if (obj != undefined) {
            obj.visible = visible;
            // obj.getDescendants(desc);
            getDescendants(obj, desc);
          }
        }
        for (var i = 0; i < desc.length; i++) {
          desc[i].visible = visible;
        }
      }
    }, {
      key: "UpdateObjects",
      value: function UpdateObjects() {
        //update only when the objects have been added to the viewport
        var vpParent;
        while (this.flatObjects.length > 0) {
          var fo = this.flatObjects.pop();
          if (fo.parent != null) {
            vpParent = fo.parent;
            vpParent.remove(fo);
          }
        }
        if (vpParent != null) {
          this.GetObject3Ds(false);
          for (var i = 0; i < this.flatObjects.length; i++) {
            vpParent.add(this.flatObjects[i]);
          }
        }
        var qParent;
        while (this.flatQueryObjects.length > 0) {
          var fo = this.flatQueryObjects.pop();
          if (fo.parent != null) {
            qParent = fo.parent;
            qParent.remove(fo);
          }
        }
        if (qParent != null) {
          this.GetObject3Ds(true);
          for (var i = 0; i < this.flatQueryObjects.length; i++) {
            qParent.add(this.flatQueryObjects[i]);
          }
        }
      }
    }, {
      key: "GetIDs",
      value: function GetIDs() {
        var ids = [];
        var desc = [];
        // this.objects.getDescendants(desc);
        getDescendants(this.objects, desc);
        for (var i = 0; i < desc.length; i++) {
          ids[i] = desc[i].id;
        }
        return ids;
      }
    }, {
      key: "GetObject3Ds",
      value: function GetObject3Ds(indexColor) {
        var needsReprojection = this.viewEPSG != this.EPSG;

        // var toReturn = [];
        var desc = [];
        // this.objects.getDescendants(desc);
        getDescendants(this.objects, desc);
        var descMaterialGrouped = [];
        descMaterialGrouped[-1] = [];
        for (var i = 0; i < desc.length; i++) {
          if (desc[i] instanceof Mesh && desc[i].material && desc[i].material.map != null && !indexColor) {
            if (descMaterialGrouped[desc[i].material.id] == undefined) {
              descMaterialGrouped[desc[i].material.id] = [desc[i]];
            } else {
              descMaterialGrouped[desc[i].material.id].push(desc[i]);
            }
          } else {
            descMaterialGrouped[-1].push(desc[i]);
          }
        }
        for (var key in descMaterialGrouped) {
          var flatobjects = [{
            uvarrays: [],
            positionarrays: [],
            indexarrays: [],
            normalarrays: [],
            colorarrays: [],
            idarrays: [],
            uvcount: 0,
            positioncount: 0,
            indexcount: 0,
            normalcount: 0,
            colorcount: 0,
            indexmax: 0,
            uvitems: 0,
            positionitems: 0,
            indexitems: 0,
            normalitems: 0,
            coloritems: 0
          }];
          var flatindex = 0;

          // console.log(desc[i])
          for (var i = 0; i < descMaterialGrouped[key].length; i++) {
            // console.log(descMaterialGrouped[key][i])
            if (descMaterialGrouped[key][i].geometry != null && descMaterialGrouped[key][i].visible) {
              //analyse the indexmax first
              if (flatobjects[flatindex].indexmax + descMaterialGrouped[key][i].geometry.attributes.position.array.length > 65535) {
                flatobjects.push({
                  uvarrays: [],
                  positionarrays: [],
                  indexarrays: [],
                  normalarrays: [],
                  colorarrays: [],
                  idarrays: [],
                  uvcount: 0,
                  positioncount: 0,
                  indexcount: 0,
                  normalcount: 0,
                  colorcount: 0,
                  indexmax: 0,
                  uvitems: 0,
                  positionitems: 0,
                  indexitems: 0,
                  normalitems: 0,
                  coloritems: 0
                });
                flatindex++;
              }
              flatobjects[flatindex].uvarrays[flatobjects[flatindex].uvarrays.length] = descMaterialGrouped[key][i].geometry.attributes.uv.array;
              flatobjects[flatindex].uvcount += descMaterialGrouped[key][i].geometry.attributes.uv.array.length;
              flatobjects[flatindex].uvitems += descMaterialGrouped[key][i].geometry.attributes.uv.numItems;
              flatobjects[flatindex].positionarrays[flatobjects[flatindex].positionarrays.length] = descMaterialGrouped[key][i].geometry.attributes.position.array;
              flatobjects[flatindex].positioncount += descMaterialGrouped[key][i].geometry.attributes.position.array.length;
              flatobjects[flatindex].positionitems += descMaterialGrouped[key][i].geometry.attributes.position.numItems;
              flatobjects[flatindex].indexarrays[flatobjects[flatindex].indexarrays.length] = descMaterialGrouped[key][i].geometry.index.array;
              flatobjects[flatindex].indexcount += descMaterialGrouped[key][i].geometry.index.array.length;
              flatobjects[flatindex].indexitems += descMaterialGrouped[key][i].geometry.index.numItems;
              flatobjects[flatindex].normalarrays[flatobjects[flatindex].normalarrays.length] = descMaterialGrouped[key][i].geometry.attributes.normal.array;
              flatobjects[flatindex].normalcount += descMaterialGrouped[key][i].geometry.attributes.normal.array.length;
              flatobjects[flatindex].normalitems += descMaterialGrouped[key][i].geometry.attributes.normal.numItems;
              flatobjects[flatindex].colorarrays[flatobjects[flatindex].colorarrays.length] = descMaterialGrouped[key][i].geometry.attributes.color.array;
              flatobjects[flatindex].colorcount += descMaterialGrouped[key][i].geometry.attributes.color.array.length;
              flatobjects[flatindex].coloritems += descMaterialGrouped[key][i].geometry.attributes.color.numItems;
              flatobjects[flatindex].indexmax += descMaterialGrouped[key][i].geometry.attributes.position.numItems / 3;
              flatobjects[flatindex].idarrays[flatobjects[flatindex].idarrays.length] = descMaterialGrouped[key][i].id;
            }
          }
          for (var i = 0; i < flatindex + 1; i++) {
            var g = new BufferGeometry();
            var positionArray = new Float32Array(flatobjects[i].positioncount);
            var indexArray = new Uint16Array(flatobjects[i].indexcount);
            var uvArray = new Float32Array(flatobjects[i].uvcount);
            var normalArray = new Float32Array(flatobjects[i].normalcount);
            var colorArray = new Float32Array(flatobjects[i].colorcount);
            var positionOffset = 0;
            var indexOffset = 0;
            var uvOffset = 0;
            var normalOffset = 0;
            var colorOffset = 0;
            var idx = 0;
            for (var j = 0; j < flatobjects[i].uvarrays.length; j++) {
              uvArray.set(flatobjects[i].uvarrays[j], uvOffset);
              uvOffset += flatobjects[i].uvarrays[j].length;
            }
            for (var j = 0; j < flatobjects[i].indexarrays.length; j++) {
              var oldOffset = indexOffset;
              indexArray.set(flatobjects[i].indexarrays[j], indexOffset);
              indexOffset += flatobjects[i].indexarrays[j].length;
              if (oldOffset > 0) {
                idx += flatobjects[i].positionarrays[j - 1].length / 3;
                for (var k = oldOffset; k < indexOffset; k++) {
                  indexArray[k] = indexArray[k] + idx;
                }
              }
            }
            for (var j = 0; j < flatobjects[i].positionarrays.length; j++) {
              if (needsReprojection) {
                this.ProjectArray(flatobjects[i].positionarrays[j], this.EPSG, this.viewEPSG, this.hasRealWorldZ);
              }
              //转为局部坐标
              var a = this.FloatArrayWorldToViewPort(flatobjects[i].positionarrays[j]);
              positionArray.set(a, positionOffset);
              positionOffset += flatobjects[i].positionarrays[j].length;
            }
            for (var j = 0; j < flatobjects[i].normalarrays.length; j++) {
              normalArray.set(flatobjects[i].normalarrays[j], normalOffset);
              normalOffset += flatobjects[i].normalarrays[j].length;
            }
            if (!indexColor) {
              for (var j = 0; j < flatobjects[i].colorarrays.length; j++) {
                colorArray.set(flatobjects[i].colorarrays[j], colorOffset);
                colorOffset += flatobjects[i].colorarrays[j].length;
              }
            } else {
              for (var j = 0; j < flatobjects[i].colorarrays.length; j++) {
                var color = new Color$2(flatobjects[i].idarrays[j]);
                for (var k = 0; k < flatobjects[i].colorarrays[j].length; k += 3) {
                  colorArray.set([color.r, color.g, color.b], colorOffset + k);
                }
                colorOffset += flatobjects[i].colorarrays[j].length;
              }
            }
            g.groups = [{
              start: 0,
              count: indexOffset,
              index: 0
            }];

            // } else {
            // const array = g.attributes.position.array
            // const uv = g.attributes.uv.array
            // const index = g.attributes.index.array
            // const color = g.attributes.color.array
            // const normal = g.attributes.normal.array

            // const positionArrays = flatobjects[i].positionarrays
            // const positions = []
            // positionArrays.forEach(position => {
            //   positions.push(...position)
            // })
            // setAttributes(flatobjects[i], g)
            // }

            var material = key == -1 ? new MeshBasicMaterial$1({
              color: 0xffffff,
              side: DoubleSide$1,
              vertexColors: VertexColors$1
            }) : descMaterialGrouped[key][0].material;
            g.setAttribute('position', new BufferAttribute(positionArray, 3));
            g.setAttribute('uv', new BufferAttribute(uvArray, 2));
            g.setAttribute('color', new BufferAttribute(colorArray, 3));
            g.setAttribute('normal', new BufferAttribute(normalArray, 3));
            g.setIndex(new BufferAttribute(indexArray, 1));
            g.computeBoundingBox();
            g.computeBoundingSphere();
            var mesh = new Mesh(g, material);
            mesh.name = this.name;
            mesh.frustumCulled = false;
            if (indexColor) {
              this.flatQueryObjects.push(mesh);
            } else {
              this.flatObjects.push(mesh);
            }
            // toReturn.push(mesh);
            // mesh.name = 'cityObject'
            this.add(mesh);
          }
        }
        // return toReturn;
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(flatobject, g) {
        this.ProjectArray(flatobject.positionarrays[j], this.EPSG, this.viewEPSG, this.hasRealWorldZ);
        var a = this.FloatArrayWorldToViewPort(flatobject.positionarrays[j]);
        //需要投影
        g.setAttribute('position', new BufferAttribute(a, 3));
        var uvs = flatTypedArray(flatobject, 'uvarrays');
        g.setAttribute('uv', new BufferAttribute(new Float32Array(uvs), 2));
        var colors = flatTypedArray(flatobject, 'colorarrays');
        g.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));
        var normals = flatTypedArray(flatobject, 'normalarrays');
        g.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3));

        // const indexes = flatTypedArray(flatobjects[i], 'indexarrays')
        // console.log(indexes)
        // g.setIndex(new BufferAttribute(new Uint16Array(indexes), 1));
        var indexes = [];
        var indexOffset = 0;
        for (var j = 0; j < flatobject.indexarrays.length; j++) {
          var indexArray = flatobject.indexarrays[j];
          console.log('indexArray', indexOffset);
          indexArray.forEach(function (index) {
            indexes.push(index + indexOffset);
          });
          indexOffset += flatobject.positionarrays[j].length / 3;
        }
        g.setIndex(new BufferAttribute(new Uint16Array(indexes), 1));
      }
    }]);
    return CityGMLLayer;
  }(Layer);

  /**
   * 递归获取所有后代
   * @param {*} objects 
   * @param {*} arr 
   */
  function getDescendants(objects, arr) {
    var children = objects.children;
    for (var i = 0; i < children.length; i++) {
      if (children[i].children.length > 0) {
        getDescendants(children[i], arr);
      }
      arr.push(children[i]);
    }
  }

  /**
   * 压平
   * @param {*} flatobject 
   * @param {*} key 
   * @returns 
   */
  function flatTypedArray(flatobject, key) {
    var typedArray = flatobject[key];
    var array = [];
    typedArray.forEach(function (position) {
      array.push.apply(array, _toConsumableArray(position));
    });
    return array;
  }

  var Target = function Target(uri) {
    this.uri = uri;
    this.textureCoordinates = [];
  };
  Target.prototype = {
    constructor: Target,
    clone: function clone() {
      var c = new Target(this.uri);
      for (var i = 0; i < this.textureCoordinates.length; i++) {
        c.textureCoordinates[i] = this.textureCoordinates[i];
      }
      return c;
    }
  };

  function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length,
      outerLen = hasHoles ? holeIndices[0] * dim : data.length,
      outerNode = linkedList(data, 0, outerLen, dim, true),
      triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }

      // minX, minY and invSize are later used to transform coords into integers for z-order calculation
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }

  // create a circular doubly linked list from polygon points in the specified winding order
  function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals$1(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }

  // eliminate colinear or duplicate points
  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start,
      again;
    do {
      again = false;
      if (!p.steiner && (equals$1(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next) break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear,
      prev,
      next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        // cut off the triangle
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);

        // skipping the next vertex leads to less sliver triangles
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;

      // if we looped through the whole remaining polygon and can't find any more ears
      if (ear === stop) {
        // try filtering points and slicing again
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

          // if this didn't work, try curing all small self-intersections locally
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

          // as a last resort, try splitting the remaining polygon into two
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }

  // check whether a polygon node forms a valid ear with adjacent nodes
  function isEar(ear) {
    var a = ear.prev,
      b = ear,
      c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x,
      bx = b.x,
      cx = c.x,
      ay = a.y,
      by = b.y,
      cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
      y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
      x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
      y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
      b = ear,
      c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x,
      bx = b.x,
      cx = c.x,
      ay = a.y,
      by = b.y,
      cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
      y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
      x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
      y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
      maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ,
      n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }
    return true;
  }

  // go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
      var a = p.prev,
        b = p.next.next;
      if (!equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0);

        // remove two nodes involved
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }

  // try splitting polygon into two and triangulate them independently
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
      var b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          // split the polygon in two by the diagonal
          var c = splitPolygon(a, b);

          // filter colinear points around the cuts
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);

          // run earcut on each half
          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }

  // link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
      i,
      len,
      start,
      end,
      list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }

  // find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge(hole, outerNode) {
    var p = outerNode,
      hx = hole.x,
      hy = hole.y,
      qx = -Infinity,
      m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
        }
      }

      p = p.next;
    } while (p !== outerNode);
    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
      mx = m.x,
      my = m.y,
      tanMin = Infinity,
      tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }

  // whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }

  // interlink polygon nodes in z-order
  function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
      if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked(list) {
    var i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail) tail.nextZ = e;else list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }

  // z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
  }

  // find the leftmost node of a polygon ring
  function getLeftmost(start) {
    var p = start,
      leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }

  // check if a point lies within a convex triangle
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
    // dones't intersect other edges
    locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
    // locally visible
    area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
    // does not create opposite-facing sectors
    equals$1(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
  }

  // signed area of a triangle
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }

  // check if two points are equal
  function equals$1(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }

  // check if two segments intersect
  function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
  }

  // for collinear points p, q, r, check if point q lies on segment pr
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }

  // check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon(a, b) {
    var p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
      p = p.next;
    } while (p !== a);
    return false;
  }

  // check if a polygon diagonal is locally inside the polygon
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }

  // check if the middle point of a polygon diagonal is inside the polygon
  function middleInside(a, b) {
    var p = a,
      inside = false,
      px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon(a, b) {
    var a2 = new Node$1(a.i, a.x, a.y),
      b2 = new Node$1(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode(i, x, y, last) {
    var p = new Node$1(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }
  function Node$1(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
  }

  // return a percentage difference between the polygon area and its triangulation area;
  // used to verify correctness of triangulation
  earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }
    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
      var a = triangles[i] * dim;
      var b = triangles[i + 1] * dim;
      var c = triangles[i + 2] * dim;
      trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };
  function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }

  // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
  earcut.flatten = function (data) {
    var dim = data[0][0].length,
      result = {
        vertices: [],
        holes: [],
        dimensions: dim
      },
      holeIndex = 0;
    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
      }
      if (i > 0) {
        holeIndex += data[i - 1].length;
        result.holes.push(holeIndex);
      }
    }
    return result;
  };

  var PolygonPipeline = /*#__PURE__*/function () {
    function PolygonPipeline() {
      _classCallCheck(this, PolygonPipeline);
    }

    /**
     * 生成三角网
     * @param coordinates
     * @returns
     */
    _createClass(PolygonPipeline, null, [{
      key: "triangles",
      value: function triangles(positions, holes, dimensions) {
        var triangles = earcut(positions, holes, dimensions);
        return triangles;
      }
    }, {
      key: "getLengthSqrt",
      value: function getLengthSqrt(edge) {
        var start = edge.start;
        var target = edge.target;
        var xOffset = target[0] - start[0];
        var yOffset = target[1] - start[1];
        return Math.pow(xOffset, 2) + Math.pow(yOffset, 2);
      }

      /**
       * 循环细分
       * @param triangles
       * @param coordinates
       * @param radius2
       */
    }, {
      key: "loopSubvision",
      value: function loopSubvision(triangles, coordinates, radius2) {
        var index;
        var subvisionIndexes = [];
        // const points = []
        //存储已经细分过的边
        var edges = [];
        // for(let i=0;i<triangles.length;i+=3){
        while (triangles.length > 0) {
          var index0 = triangles.pop();
          var index1 = triangles.pop();
          var index2 = triangles.pop();
          var p0 = [coordinates[index0 * 2], coordinates[index0 * 2 + 1]];
          var p1 = [coordinates[index1 * 2], coordinates[index1 * 2 + 1]];
          var p2 = [coordinates[index2 * 2], coordinates[index2 * 2 + 1]];
          //计算距离
          var edge0 = {
            start: p0,
            target: p1
          };
          var edge1 = {
            start: p1,
            target: p2
          };
          var edge2 = {
            start: p2,
            target: p0
          };

          //获取边长度的平方
          var lengthSqrt0 = this.getLengthSqrt(edge0);
          var lengthSqrt1 = this.getLengthSqrt(edge1);
          var lengthSqrt2 = this.getLengthSqrt(edge2);
          var maxLength = Math.max(lengthSqrt0, lengthSqrt1, lengthSqrt2);
          //   debugger;
          if (maxLength > radius2) {
            if (maxLength === lengthSqrt0) {
              var key = "".concat(index0, "-").concat(index1);
              index = edges[key];
              //看是否已经细分过
              if (!index) {
                //取边的中点，划分为两个三角形，并添加到points中去，并在索引中也添加
                var mid = [(p0[0] + p1[0]) * 0.5, (p0[1] + p1[1]) * 0.5];
                //添加点到points中去
                coordinates.push(mid[0], mid[1]);
                index = coordinates.length / 2 - 1;

                //加入
                edges[key] = index;
              }
              //添加索引
              triangles.push(index0, index, index2);
              triangles.push(index1, index, index2);
            } else if (maxLength === lengthSqrt1) {
              //  console.log('需要细分')
              var _key = "".concat(index1, "-").concat(index2);
              index = edges[_key];
              if (!index) {
                //取边的中点，划分为两个三角形，并添加到points中去，并在索引中也添加
                var _mid = [(p1[0] + p2[0]) * 0.5, (p1[1] + p2[1]) * 0.5];

                //添加点到points中去
                coordinates.push(_mid[0], _mid[1]);
                index = coordinates.length / 2 - 1;

                //加入
                edges[_key] = index;
              }
              //添加索引
              triangles.push(index1, index, index0);
              triangles.push(index2, index, index0);
            } else if (maxLength === lengthSqrt2) {
              //  console.log('需要细分')
              var _key2 = "".concat(index2, "-").concat(index0);
              index = edges[_key2];
              if (!index) {
                //取边的中点，划分为两个三角形，并添加到points中去，并在索引中也添加
                var _mid2 = [(p2[0] + p0[0]) * 0.5, (p2[1] + p0[1]) * 0.5];
                //添加点到points中去
                coordinates.push(_mid2[0], _mid2[1]);
                index = coordinates.length / 2 - 1;

                //加入
                edges[_key2] = index;
              }
              //添加索引
              triangles.push(index2, index, index1);
              triangles.push(index0, index, index1);
            }
          } else {
            subvisionIndexes.push(index0);
            subvisionIndexes.push(index1);
            subvisionIndexes.push(index2);
          }
        }
        return {
          points: coordinates,
          subvisionIndexes: subvisionIndexes
        };
      }
    }]);
    return PolygonPipeline;
  }();

  var PolygonPrimitive = /*#__PURE__*/function (_Mesh) {
    _inherits(PolygonPrimitive, _Mesh);
    var _super = _createSuper(PolygonPrimitive);
    function PolygonPrimitive(_ref) {
      var _this;
      var positions = _ref.positions,
        _ref$holes = _ref.holes,
        holes = _ref$holes === void 0 ? [] : _ref$holes,
        _ref$color = _ref.color,
        color = _ref$color === void 0 ? 0xff0000 : _ref$color,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? 0 : _ref$height,
        _ref$opacity = _ref.opacity,
        opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
        texture = _ref.texture,
        _ref$loopFactor = _ref.loopFactor,
        loopFactor = _ref$loopFactor === void 0 ? 0.02 : _ref$loopFactor,
        material = _ref.material;
      _classCallCheck(this, PolygonPrimitive);
      _this = _super.call(this);

      //格式化位置和洞
      _defineProperty(_assertThisInitialized(_this), "_threeEarth", void 0);
      _defineProperty(_assertThisInitialized(_this), "_polygonWorldMatrix", void 0);
      var _this$getPositionsAnd = _this.getPositionsAndHolesIndex(positions, holes),
        newPositions = _this$getPositionsAnd.newPositions,
        holesIndexes = _this$getPositionsAnd.holesIndexes;
      //三角剖分
      var triangles = PolygonPipeline.triangles(newPositions, holesIndexes, 2);

      //细分
      var _PolygonPipeline$loop = PolygonPipeline.loopSubvision(triangles, newPositions, loopFactor),
        points = _PolygonPipeline$loop.points,
        subvisionIndexes = _PolygonPipeline$loop.subvisionIndexes;
      var positions3D = [];
      for (var i = 0; i < points.length; i += 2) {
        positions3D.push(points[i], points[i + 1], height);
      }

      //转换为局部坐标
      var polygon = _this.create(subvisionIndexes, positions3D, 1);
      _this.position.set(polygon.worldCenter.x, polygon.worldCenter.y, polygon.worldCenter.z);
      _this.geometry = polygon.geometry;
      if (material) {
        _this.material = material;
      } else {
        _this.material = new MeshBasicMaterial$1({
          color: color,
          map: texture,
          side: DoubleSide$1,
          transparent: true,
          opacity: opacity,
          depthTest: true
        });
      }
      if (_this.material instanceof Material$1) {
        _this.material.polygonOffset = true;
        _this.material.polygonOffsetFactor = 1;
        _this.material.polygonOffsetUnits = -100;
        _this.material.side = DoubleSide$1;
        _this.material.depthWrite = false;
      }
      _this.frustumCulled = false;
      return _this;
    }

    /**
     * 获取索引和位置
     * @param {*} positions 
     * @param {*} holes 
     * @returns 
     */
    _createClass(PolygonPrimitive, [{
      key: "getPositionsAndHolesIndex",
      value: function getPositionsAndHolesIndex(positions, holes) {
        // var data = earcut.flatten(positions);
        var holesIndexes = [];
        var all = 0;
        for (var i = 0; i < holes.length; i++) {
          holesIndexes[i] = (all + positions.length) / 2;
          all += holes[i].length;
        }
        //合并顶点和hole
        var newPositions = [].concat(_toConsumableArray(positions), _toConsumableArray(holes.flat()));
        return {
          newPositions: newPositions,
          holesIndexes: holesIndexes
        };
      }

      /**
       * 创建geometry
       * @param {*} subvisionIndexes 
       * @param {*} points 
       * @param {*} uvScale 
       * @returns 
       */
    }, {
      key: "create",
      value: function create(subvisionIndexes, points, uvScale) {
        var DTOR = 3.141592653 / 180.0;
        var Radius = 6378137;
        var left = 1000;
        var top = -1000;
        var right = -1000;
        var bottom = 1000;
        for (var i = 0; i < points.length; i += 3) {
          if (points[i] < left) {
            left = points[i];
          }
          if (points[i] > right) {
            right = points[i];
          }
          if (points[i + 1] > top) {
            top = points[i + 1];
          }
          if (points[i + 1] < bottom) {
            bottom = points[i + 1];
          }
        }
        var centerX = (left + right) / 2;
        var centerY = (top + bottom) / 2;
        var centerZ = 0;
        var worldCenter = PIEVector3.sphericalToCartesian(centerX * DTOR, centerY * DTOR, Radius + centerZ);
        var uvs = [];
        var localPositions = [];
        var normals = [];
        for (var i = 0; i < points.length; i += 3) {
          var worldPosition = PIEVector3.sphericalToCartesian(points[i] * DTOR, points[i + 1] * DTOR, Radius + points[i + 2]);
          var localPosition = new Vector3(worldPosition.x - worldCenter.x, worldPosition.y - worldCenter.y, worldPosition.z - worldCenter.z);
          localPositions.push(localPosition.x, localPosition.y, localPosition.z);
          var texCoordX = (points[i] - left) / (right - left) * uvScale;
          var texCoordY = (points[i + 1] - bottom) / (top - bottom) * uvScale;
          uvs.push(texCoordX, texCoordY);
          normals.push(0, 0, 1);
        }
        var geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(localPositions, 3));
        geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        geometry.setIndex(subvisionIndexes);
        geometry.computeBoundingSphere();
        return {
          geometry: geometry,
          center: {
            x: centerX,
            y: centerY,
            z: centerZ
          },
          worldCenter: worldCenter
        };
      }
    }, {
      key: "update",
      value: function update(frameState) {}
    }]);
    return PolygonPrimitive;
  }(Mesh);

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  /**
   * The following functions operate on "Point" or any "Point like" object with {x,y},
   * as defined by the {@link XY} type
   * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
   * @module
   * @private
   */

  /**
   * poly2tri.js supports using custom point class instead of {@linkcode Point}.
   * Any "Point like" object with <code>{x, y}</code> attributes is supported
   * to initialize the SweepContext polylines and points
   * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
   *
   * poly2tri.js might add extra fields to the point objects when computing the
   * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
   * with fields in the custom class.
   *
   * @example
   *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
   *      var swctx = new poly2tri.SweepContext(contour);
   *
   * @typedef {Object} XY
   * @property {number} x - x coordinate
   * @property {number} y - y coordinate
   */

  /**
   * Point pretty printing : prints x and y coordinates.
   * @example
   *      xy.toStringBase({x:5, y:42})
   *      // → "(5;42)"
   * @protected
   * @param {!XY} p - point object with {x,y}
   * @returns {string} <code>"(x;y)"</code>
   */
  function toStringBase(p) {
    return "(" + p.x + ";" + p.y + ")";
  }

  /**
   * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
   * else simply prints x and y coordinates.
   * @example
   *      xy.toString({x:5, y:42})
   *      // → "(5;42)"
   * @example
   *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
   *      // → "5:42"
   * @param {!XY} p - point object with {x,y}
   * @returns {string} <code>"(x;y)"</code>
   */
  function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return s === '[object Object]' ? toStringBase(p) : s;
  }

  /**
   * Compare two points component-wise. Ordered by y axis first, then x axis.
   * @param {!XY} a - point object with {x,y}
   * @param {!XY} b - point object with {x,y}
   * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
   *         <code>&gt; 0</code> if <code>a &gt; b</code>,
   *         <code>0</code> otherwise.
   */
  function compare(a, b) {
    if (a.y === b.y) {
      return a.x - b.x;
    } else {
      return a.y - b.y;
    }
  }

  /**
   * Test two Point objects for equality.
   * @param {!XY} a - point object with {x,y}
   * @param {!XY} b - point object with {x,y}
   * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
   */
  function equals(a, b) {
    return a.x === b.x && a.y === b.y;
  }

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  /**
   * Custom exception class to indicate invalid Point values
   * @constructor
   * @public
   * @extends Error
   * @struct
   * @param {string=} message - error message
   * @param {Array.<XY>=} points - invalid points
   */
  var PointError = function PointError(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
      this.message += " " + toString(points[i]);
    }
  };
  PointError.prototype = new Error();
  PointError.prototype.constructor = PointError;

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  // ------------------------------------------------------------------------Point
  /**
   * Construct a point
   * @example
   *      var point = new poly2tri.Point(150, 150);
   * @public
   * @constructor
   * @struct
   * @param {number=} x    coordinate (0 if undefined)
   * @param {number=} y    coordinate (0 if undefined)
   */
  var Point = function Point(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
  };

  /**
   * For pretty printing
   * @example
   *      "p=" + new poly2tri.Point(5,42)
   *      // → "p=(5;42)"
   * @returns {string} <code>"(x;y)"</code>
   */
  Point.prototype.toString = function () {
    return toStringBase(this);
  };

  /**
   * JSON output, only coordinates
   * @example
   *      JSON.stringify(new poly2tri.Point(1,2))
   *      // → '{"x":1,"y":2}'
   */
  Point.prototype.toJSON = function () {
    return {
      x: this.x,
      y: this.y
    };
  };

  /**
   * Creates a copy of this Point object.
   * @return {Point} new cloned point
   */
  Point.prototype.clone = function () {
    return new Point(this.x, this.y);
  };

  /**
   * Set this Point instance to the origo. <code>(0; 0)</code>
   * @return {Point} this (for chaining)
   */
  Point.prototype.set_zero = function () {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
  };

  /**
   * Set the coordinates of this instance.
   * @param {number} x   coordinate
   * @param {number} y   coordinate
   * @return {Point} this (for chaining)
   */
  Point.prototype.set = function (x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
  };

  /**
   * Negate this Point instance. (component-wise)
   * @return {Point} this (for chaining)
   */
  Point.prototype.negate = function () {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
  };

  /**
   * Add another Point object to this instance. (component-wise)
   * @param {!Point} n - Point object.
   * @return {Point} this (for chaining)
   */
  Point.prototype.add = function (n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
  };

  /**
   * Subtract this Point instance with another point given. (component-wise)
   * @param {!Point} n - Point object.
   * @return {Point} this (for chaining)
   */
  Point.prototype.sub = function (n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
  };

  /**
   * Multiply this Point instance by a scalar. (component-wise)
   * @param {number} s   scalar.
   * @return {Point} this (for chaining)
   */
  Point.prototype.mul = function (s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
  };

  /**
   * Return the distance of this Point instance from the origo.
   * @return {number} distance
   */
  Point.prototype.length = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };

  /**
   * Normalize this Point instance (as a vector).
   * @return {number} The original distance of this instance from the origo.
   */
  Point.prototype.normalize = function () {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
  };

  /**
   * Test this Point object with another for equality.
   * @param {!XY} p - any "Point like" object with {x,y}
   * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
   */
  Point.prototype.equals = function (p) {
    return this.x === p.x && this.y === p.y;
  };

  // -----------------------------------------------------Point ("static" methods)

  /**
   * Negate a point component-wise and return the result as a new Point object.
   * @param {!XY} p - any "Point like" object with {x,y}
   * @return {Point} the resulting Point object.
   */
  Point.negate = function (p) {
    return new Point(-p.x, -p.y);
  };

  /**
   * Add two points component-wise and return the result as a new Point object.
   * @param {!XY} a - any "Point like" object with {x,y}
   * @param {!XY} b - any "Point like" object with {x,y}
   * @return {Point} the resulting Point object.
   */
  Point.add = function (a, b) {
    return new Point(a.x + b.x, a.y + b.y);
  };

  /**
   * Subtract two points component-wise and return the result as a new Point object.
   * @param {!XY} a - any "Point like" object with {x,y}
   * @param {!XY} b - any "Point like" object with {x,y}
   * @return {Point} the resulting Point object.
   */
  Point.sub = function (a, b) {
    return new Point(a.x - b.x, a.y - b.y);
  };

  /**
   * Multiply a point by a scalar and return the result as a new Point object.
   * @param {number} s - the scalar
   * @param {!XY} p - any "Point like" object with {x,y}
   * @return {Point} the resulting Point object.
   */
  Point.mul = function (s, p) {
    return new Point(s * p.x, s * p.y);
  };

  /**
   * Perform the cross product on either two points (this produces a scalar)
   * or a point and a scalar (this produces a point).
   * This function requires two parameters, either may be a Point object or a
   * number.
   * @param  {XY|number} a - Point object or scalar.
   * @param  {XY|number} b - Point object or scalar.
   * @return {Point|number} a Point object or a number, depending on the parameters.
   */
  Point.cross = function (a, b) {
    if (typeof a === 'number') {
      if (typeof b === 'number') {
        return a * b;
      } else {
        return new Point(-a * b.y, a * b.x);
      }
    } else {
      if (typeof b === 'number') {
        return new Point(b * a.y, -b * a.x);
      } else {
        return a.x * b.y - a.y * b.x;
      }
    }
  };

  // -----------------------------------------------------------------"Point-Like"
  /*
   * The following functions operate on "Point" or any "Point like" object
   * with {x,y} (duck typing).
   */

  Point.toString = toString;
  Point.compare = compare;
  Point.cmp = compare; // backward compatibility
  Point.equals = equals;

  /**
   * Peform the dot product on two vectors.
   * @public
   * @param {!XY} a - any "Point like" object with {x,y}
   * @param {!XY} b - any "Point like" object with {x,y}
   * @return {number} The dot product
   */
  Point.dot = function (a, b) {
    return a.x * b.x + a.y * b.y;
  };

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  // ---------------------------------------------------------------------Triangle
  /**
   * Triangle class.<br>
   * Triangle-based data structures are known to have better performance than
   * quad-edge structures.
   * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
   * Delaunay Triangulator", "Triangulations in CGAL"
   *
   * @constructor
   * @struct
   * @param {!XY} pa  point object with {x,y}
   * @param {!XY} pb  point object with {x,y}
   * @param {!XY} pc  point object with {x,y}
   */
  var Triangle = function Triangle(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
  };
  var p2s = toString;
  /**
   * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
   * @public
   * @return {string}
   */
  Triangle.prototype.toString = function () {
    return "[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]";
  };

  /**
   * Get one vertice of the triangle.
   * The output triangles of a triangulation have vertices which are references
   * to the initial input points (not copies): any custom fields in the
   * initial points can be retrieved in the output triangles.
   * @example
   *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
   *      var swctx = new poly2tri.SweepContext(contour);
   *      swctx.triangulate();
   *      var triangles = swctx.getTriangles();
   *      typeof triangles[0].getPoint(0).id
   *      // → "number"
   * @param {number} index - vertice index: 0, 1 or 2
   * @public
   * @returns {XY}
   */
  Triangle.prototype.getPoint = function (index) {
    return this.points_[index];
  };

  /**
   * For backward compatibility
   * @function
   * @deprecated use {@linkcode Triangle#getPoint} instead
   */
  Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

  /**
   * Get all 3 vertices of the triangle as an array
   * @public
   * @return {Array.<XY>}
   */
  // Method added in the JavaScript version (was not present in the c++ version)
  Triangle.prototype.getPoints = function () {
    return this.points_;
  };

  /**
   * @private
   * @param {number} index
   * @returns {?Triangle}
   */
  Triangle.prototype.getNeighbor = function (index) {
    return this.neighbors_[index];
  };

  /**
   * Test if this Triangle contains the Point object given as parameter as one of its vertices.
   * Only point references are compared, not values.
   * @public
   * @param {XY} point - point object with {x,y}
   * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
   *         <code>false</code> otherwise.
   */
  Triangle.prototype.containsPoint = function (point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return point === points[0] || point === points[1] || point === points[2];
  };

  /**
   * Test if this Triangle contains the Edge object given as parameter as its
   * bounding edges. Only point references are compared, not values.
   * @private
   * @param {Edge} edge
   * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
   *         edges, <code>false</code> otherwise.
   */
  Triangle.prototype.containsEdge = function (edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
  };

  /**
   * Test if this Triangle contains the two Point objects given as parameters among its vertices.
   * Only point references are compared, not values.
   * @param {XY} p1 - point object with {x,y}
   * @param {XY} p2 - point object with {x,y}
   * @return {boolean}
   */
  Triangle.prototype.containsPoints = function (p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
  };

  /**
   * Has this triangle been marked as an interior triangle?
   * @returns {boolean}
   */
  Triangle.prototype.isInterior = function () {
    return this.interior_;
  };

  /**
   * Mark this triangle as an interior triangle
   * @private
   * @param {boolean} interior
   * @returns {Triangle} this
   */
  Triangle.prototype.setInterior = function (interior) {
    this.interior_ = interior;
    return this;
  };

  /**
   * Update neighbor pointers.
   * @private
   * @param {XY} p1 - point object with {x,y}
   * @param {XY} p2 - point object with {x,y}
   * @param {Triangle} t Triangle object.
   * @throws {Error} if can't find objects
   */
  Triangle.prototype.markNeighborPointers = function (p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[2] && p2 === points[1] || p1 === points[1] && p2 === points[2]) {
      this.neighbors_[0] = t;
    } else if (p1 === points[0] && p2 === points[2] || p1 === points[2] && p2 === points[0]) {
      this.neighbors_[1] = t;
    } else if (p1 === points[0] && p2 === points[1] || p1 === points[1] && p2 === points[0]) {
      this.neighbors_[2] = t;
    } else {
      throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
  };

  /**
   * Exhaustive search to update neighbor pointers
   * @private
   * @param {!Triangle} t
   */
  Triangle.prototype.markNeighbor = function (t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
      this.neighbors_[0] = t;
      t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
      this.neighbors_[1] = t;
      t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
      this.neighbors_[2] = t;
      t.markNeighborPointers(points[0], points[1], this);
    }
  };
  Triangle.prototype.clearNeighbors = function () {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
  };
  Triangle.prototype.clearDelaunayEdges = function () {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
  };

  /**
   * Returns the point clockwise to the given point.
   * @private
   * @param {XY} p - point object with {x,y}
   */
  Triangle.prototype.pointCW = function (p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
      return points[2];
    } else if (p === points[1]) {
      return points[0];
    } else if (p === points[2]) {
      return points[1];
    } else {
      return null;
    }
  };

  /**
   * Returns the point counter-clockwise to the given point.
   * @private
   * @param {XY} p - point object with {x,y}
   */
  Triangle.prototype.pointCCW = function (p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
      return points[1];
    } else if (p === points[1]) {
      return points[2];
    } else if (p === points[2]) {
      return points[0];
    } else {
      return null;
    }
  };

  /**
   * Returns the neighbor clockwise to given point.
   * @private
   * @param {XY} p - point object with {x,y}
   */
  Triangle.prototype.neighborCW = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.neighbors_[1];
    } else if (p === this.points_[1]) {
      return this.neighbors_[2];
    } else {
      return this.neighbors_[0];
    }
  };

  /**
   * Returns the neighbor counter-clockwise to given point.
   * @private
   * @param {XY} p - point object with {x,y}
   */
  Triangle.prototype.neighborCCW = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.neighbors_[2];
    } else if (p === this.points_[1]) {
      return this.neighbors_[0];
    } else {
      return this.neighbors_[1];
    }
  };
  Triangle.prototype.getConstrainedEdgeCW = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
      return this.constrained_edge[2];
    } else {
      return this.constrained_edge[0];
    }
  };
  Triangle.prototype.getConstrainedEdgeCCW = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
      return this.constrained_edge[0];
    } else {
      return this.constrained_edge[1];
    }
  };

  // Additional check from Java version (see issue #88)
  Triangle.prototype.getConstrainedEdgeAcross = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
      return this.constrained_edge[1];
    } else {
      return this.constrained_edge[2];
    }
  };
  Triangle.prototype.setConstrainedEdgeCW = function (p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
      this.constrained_edge[2] = ce;
    } else {
      this.constrained_edge[0] = ce;
    }
  };
  Triangle.prototype.setConstrainedEdgeCCW = function (p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
      this.constrained_edge[0] = ce;
    } else {
      this.constrained_edge[1] = ce;
    }
  };
  Triangle.prototype.getDelaunayEdgeCW = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
      return this.delaunay_edge[2];
    } else {
      return this.delaunay_edge[0];
    }
  };
  Triangle.prototype.getDelaunayEdgeCCW = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
      return this.delaunay_edge[0];
    } else {
      return this.delaunay_edge[1];
    }
  };
  Triangle.prototype.setDelaunayEdgeCW = function (p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
      this.delaunay_edge[2] = e;
    } else {
      this.delaunay_edge[0] = e;
    }
  };
  Triangle.prototype.setDelaunayEdgeCCW = function (p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
      this.delaunay_edge[0] = e;
    } else {
      this.delaunay_edge[1] = e;
    }
  };

  /**
   * The neighbor across to given point.
   * @private
   * @param {XY} p - point object with {x,y}
   * @returns {Triangle}
   */
  Triangle.prototype.neighborAcross = function (p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
      return this.neighbors_[0];
    } else if (p === this.points_[1]) {
      return this.neighbors_[1];
    } else {
      return this.neighbors_[2];
    }
  };

  /**
   * @private
   * @param {!Triangle} t Triangle object.
   * @param {XY} p - point object with {x,y}
   */
  Triangle.prototype.oppositePoint = function (t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
  };

  /**
   * Legalize triangle by rotating clockwise around oPoint
   * @private
   * @param {XY} opoint - point object with {x,y}
   * @param {XY} npoint - point object with {x,y}
   * @throws {Error} if oPoint can not be found
   */
  Triangle.prototype.legalize = function (opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
      points[1] = points[0];
      points[0] = points[2];
      points[2] = npoint;
    } else if (opoint === points[1]) {
      points[2] = points[1];
      points[1] = points[0];
      points[0] = npoint;
    } else if (opoint === points[2]) {
      points[0] = points[2];
      points[2] = points[1];
      points[1] = npoint;
    } else {
      throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
  };

  /**
   * Returns the index of a point in the triangle.
   * The point *must* be a reference to one of the triangle's vertices.
   * @private
   * @param {XY} p - point object with {x,y}
   * @returns {number} index 0, 1 or 2
   * @throws {Error} if p can not be found
   */
  Triangle.prototype.index = function (p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
      return 0;
    } else if (p === points[1]) {
      return 1;
    } else if (p === points[2]) {
      return 2;
    } else {
      throw new Error('poly2tri Invalid Triangle.index() call');
    }
  };

  /**
   * @private
   * @param {XY} p1 - point object with {x,y}
   * @param {XY} p2 - point object with {x,y}
   * @return {number} index 0, 1 or 2, or -1 if errror
   */
  Triangle.prototype.edgeIndex = function (p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
      if (p2 === points[1]) {
        return 2;
      } else if (p2 === points[2]) {
        return 1;
      }
    } else if (p1 === points[1]) {
      if (p2 === points[2]) {
        return 0;
      } else if (p2 === points[0]) {
        return 2;
      }
    } else if (p1 === points[2]) {
      if (p2 === points[0]) {
        return 1;
      } else if (p2 === points[1]) {
        return 0;
      }
    }
    return -1;
  };

  /**
   * Mark an edge of this triangle as constrained.
   * @private
   * @param {number} index - edge index
   */
  Triangle.prototype.markConstrainedEdgeByIndex = function (index) {
    this.constrained_edge[index] = true;
  };
  /**
   * Mark an edge of this triangle as constrained.
   * @private
   * @param {Edge} edge instance
   */
  Triangle.prototype.markConstrainedEdgeByEdge = function (edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
  };
  /**
   * Mark an edge of this triangle as constrained.
   * This method takes two Point instances defining the edge of the triangle.
   * @private
   * @param {XY} p - point object with {x,y}
   * @param {XY} q - point object with {x,y}
   */
  Triangle.prototype.markConstrainedEdgeByPoints = function (p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (q === points[0] && p === points[1] || q === points[1] && p === points[0]) {
      this.constrained_edge[2] = true;
    } else if (q === points[0] && p === points[2] || q === points[2] && p === points[0]) {
      this.constrained_edge[1] = true;
    } else if (q === points[1] && p === points[2] || q === points[2] && p === points[1]) {
      this.constrained_edge[0] = true;
    }
  };

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  /*
   * Function added in the JavaScript version (was not present in the c++ version)
   */

  /**
   * assert and throw an exception.
   *
   * @private
   * @param {boolean} condition   the condition which is asserted
   * @param {string} message      the message which is display is condition is falsy
   */
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assert Failed");
    }
  }

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  /*
   * Note
   * ====
   * the structure of this JavaScript version of poly2tri intentionally follows
   * as closely as possible the structure of the reference C++ version, to make it
   * easier to keep the 2 versions in sync.
   */

  // -------------------------------------------------------------------------Node

  /**
   * Advancing front node
   * @constructor
   * @private
   * @struct
   * @param {!XY} p - Point
   * @param {Triangle=} t triangle (optional)
   */
  var Node = function Node(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
  };

  // ---------------------------------------------------------------AdvancingFront
  /**
   * @constructor
   * @private
   * @struct
   * @param {Node} head
   * @param {Node} tail
   */
  var AdvancingFront = function AdvancingFront(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
  };

  /** @return {Node} */
  AdvancingFront.prototype.head = function () {
    return this.head_;
  };

  /** @param {Node} node */
  AdvancingFront.prototype.setHead = function (node) {
    this.head_ = node;
  };

  /** @return {Node} */
  AdvancingFront.prototype.tail = function () {
    return this.tail_;
  };

  /** @param {Node} node */
  AdvancingFront.prototype.setTail = function (node) {
    this.tail_ = node;
  };

  /** @return {Node} */
  AdvancingFront.prototype.search = function () {
    return this.search_node_;
  };

  /** @param {Node} node */
  AdvancingFront.prototype.setSearch = function (node) {
    this.search_node_ = node;
  };

  /** @return {Node} */
  AdvancingFront.prototype.findSearchNode = function /*x*/
  () {
    // TODO: implement BST index
    return this.search_node_;
  };

  /**
   * @param {number} x value
   * @return {Node}
   */
  AdvancingFront.prototype.locateNode = function (x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
      while (node = node.prev) {
        if (x >= node.value) {
          this.search_node_ = node;
          return node;
        }
      }
    } else {
      while (node = node.next) {
        if (x < node.value) {
          this.search_node_ = node.prev;
          return node.prev;
        }
      }
    }
    return null;
  };

  /**
   * @param {!XY} point - Point
   * @return {Node}
   */
  AdvancingFront.prototype.locatePoint = function (point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;
    if (px === nx) {
      // Here we are comparing point references, not values
      if (point !== node.point) {
        // We might have two nodes with same x value for a short time
        if (point === node.prev.point) {
          node = node.prev;
        } else if (point === node.next.point) {
          node = node.next;
        } else {
          throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
        }
      }
    } else if (px < nx) {
      /* jshint boss:true */
      while (node = node.prev) {
        if (point === node.point) {
          break;
        }
      }
    } else {
      while (node = node.next) {
        if (point === node.point) {
          break;
        }
      }
    }
    if (node) {
      this.search_node_ = node;
    }
    return node;
  };

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  /**
   * Precision to detect repeated or collinear points
   * @private
   * @const {number}
   * @default
   */
  var EPSILON = 1e-12;

  /**
   * @private
   * @enum {number}
   * @readonly
   */
  var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
  };
  // exports.Orientation = Orientation;

  /**
   * Formula to calculate signed area<br>
   * Positive if CCW<br>
   * Negative if CW<br>
   * 0 if collinear<br>
   * <pre>
   * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
   *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
   * </pre>
   *
   * @private
   * @param {!XY} pa  point object with {x,y}
   * @param {!XY} pb  point object with {x,y}
   * @param {!XY} pc  point object with {x,y}
   * @return {Orientation}
   */
  function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -EPSILON && val < EPSILON) {
      return Orientation.COLLINEAR;
    } else if (val > 0) {
      return Orientation.CCW;
    } else {
      return Orientation.CW;
    }
  }
  // exports.orient2d = orient2d;

  /**
   *
   * @private
   * @param {!XY} pa  point object with {x,y}
   * @param {!XY} pb  point object with {x,y}
   * @param {!XY} pc  point object with {x,y}
   * @param {!XY} pd  point object with {x,y}
   * @return {boolean}
   */
  function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
      return false;
    }
    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
      return false;
    }
    return true;
  }
  // exports.inScanArea = inScanArea;

  /**
   * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
   *
   * @private
   * @param {!XY} pa  point object with {x,y}
   * @param {!XY} pb  point object with {x,y}
   * @param {!XY} pc  point object with {x,y}
   * @return {boolean} true if angle is obtuse
   */
  function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return ax * bx + ay * by < 0;
  }
  // exports.isAngleObtuse = isAngleObtuse;

  // /** @const */
  // var EPSILON = utils.EPSILON;

  // /** @const */
  // var Orientation = utils.Orientation;
  // /** @const */
  // var orient2d = utils.orient2d;
  // /** @const */
  // var inScanArea = utils.inScanArea;
  // /** @const */
  // var isAngleObtuse = utils.isAngleObtuse;

  // ------------------------------------------------------------------------Sweep

  /**
   * Triangulate the polygon with holes and Steiner points.
   * Do this AFTER you've added the polyline, holes, and Steiner points
   * @private
   * @param {!SweepContext} tcx - SweepContext object
   */
  function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
  }

  /**
   * Start sweeping the Y-sorted point set from bottom to top
   * @param {!SweepContext} tcx - SweepContext object
   */
  function sweepPoints(tcx) {
    var i,
      len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
      var point = tcx.getPoint(i);
      var node = pointEvent(tcx, point);
      var edges = point._p2t_edge_list;
      for (var j = 0; edges && j < edges.length; ++j) {
        edgeEventByEdge(tcx, edges[j], node);
      }
    }
  }

  /**
   * @param {!SweepContext} tcx - SweepContext object
   */
  function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
      t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
  }

  /**
   * Find closes node to the left of the new point and
   * create a new triangle. If needed new holes and basins
   * will be filled to.
   * @param {!SweepContext} tcx - SweepContext object
   * @param {!XY} point   Point
   */
  function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + EPSILON) {
      fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
  }
  function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = edge.p.x > edge.q.x;
    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
      return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
  }
  function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
      return;
    }
    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
      // TODO integrate here changes from C++ version
      // (C++ repo revision 09880a869095 dated March 8, 2011)
      throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }
    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
      // TODO integrate here changes from C++ version
      // (C++ repo revision 09880a869095 dated March 8, 2011)
      throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }
    if (o1 === o2) {
      // Need to decide if we are rotating CW or CCW to get to a triangle
      // that will cross edge
      if (o1 === Orientation.CW) {
        triangle = triangle.neighborCCW(point);
      } else {
        triangle = triangle.neighborCW(point);
      }
      edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
      // This triangle crosses constraint so lets flippin start!
      flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
  }
  function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
      triangle.markConstrainedEdgeByIndex(index);
      var t = triangle.getNeighbor(index);
      if (t) {
        t.markConstrainedEdgeByPoints(ep, eq);
      }
      return true;
    }
    return false;
  }

  /**
   * Creates a new front triangle and legalize it
   * @param {!SweepContext} tcx - SweepContext object
   */
  function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);
    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);
    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;
    if (!legalize(tcx, triangle)) {
      tcx.mapTriangleToNodes(triangle);
    }
    return new_node;
  }

  /**
   * Adds a triangle to the advancing front to fill a hole.
   * @param {!SweepContext} tcx - SweepContext object
   * @param node - middle node, that is the bottom of the hole
   */
  function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;

    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
      tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
  }

  /**
   * Fills holes in the Advancing Front
   * @param {!SweepContext} tcx - SweepContext object
   */
  function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
      // TODO integrate here changes from C++ version
      // (C++ repo revision acf81f1f1764 dated April 7, 2012)
      if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
        break;
      }
      fill(tcx, node);
      node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
      // TODO integrate here changes from C++ version
      // (C++ repo revision acf81f1f1764 dated April 7, 2012)
      if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
        break;
      }
      fill(tcx, node);
      node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
      if (isBasinAngleRight(n)) {
        fillBasin(tcx, n);
      }
    }
  }

  /**
   * The basin angle is decided against the horizontal line [1,0].
   * @param {Node} node
   * @return {boolean} true if angle < 3*π/4
   */
  function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return ax >= 0 || Math.abs(ax) < ay;
  }

  /**
   * Returns true if triangle was legalized
   * @param {!SweepContext} tcx - SweepContext object
   * @return {boolean}
   */
  function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
      if (t.delaunay_edge[i]) {
        continue;
      }
      var ot = t.getNeighbor(i);
      if (ot) {
        var p = t.getPoint(i);
        var op = ot.oppositePoint(t, p);
        var oi = ot.index(op);

        // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
        // then we should not try to legalize
        if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
          t.constrained_edge[i] = ot.constrained_edge[oi];
          continue;
        }
        var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
        if (inside) {
          // Lets mark this shared edge as Delaunay
          t.delaunay_edge[i] = true;
          ot.delaunay_edge[oi] = true;

          // Lets rotate shared edge one vertex CW to legalize it
          rotateTrianglePair(t, p, ot, op);

          // We now got one valid Delaunay Edge shared by two triangles
          // This gives us 4 new edges to check for Delaunay

          // Make sure that triangle to node mapping is done only one time for a specific triangle
          var not_legalized = !legalize(tcx, t);
          if (not_legalized) {
            tcx.mapTriangleToNodes(t);
          }
          not_legalized = !legalize(tcx, ot);
          if (not_legalized) {
            tcx.mapTriangleToNodes(ot);
          }
          // Reset the Delaunay edges, since they only are valid Delaunay edges
          // until we add a new triangle or point.
          // XXX: need to think about this. Can these edges be tried after we
          //      return to previous recursive level?
          t.delaunay_edge[i] = false;
          ot.delaunay_edge[oi] = false;

          // If triangle have been legalized no need to check the other edges since
          // the recursive legalization will handles those so we can end here.
          return true;
        }
      }
    }
    return false;
  }

  /**
   * <b>Requirement</b>:<br>
   * 1. a,b and c form a triangle.<br>
   * 2. a and d is know to be on opposite side of bc<br>
   * <pre>
   *                a
   *                +
   *               / \
   *              /   \
   *            b/     \c
   *            +-------+
   *           /    d    \
   *          /           \
   * </pre>
   * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
   *  a,b and c<br>
   *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
   *  This preknowledge gives us a way to optimize the incircle test
   * @param pa - triangle point, opposite d
   * @param pb - triangle point
   * @param pc - triangle point
   * @param pd - point opposite a
   * @return {boolean} true if d is inside circle, false if on circle edge
   */
  function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;
    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
      return false;
    }
    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;
    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
      return false;
    }
    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;
    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;
    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
  }

  /**
   * Rotates a triangle pair one vertex CW
   *<pre>
   *       n2                    n2
   *  P +-----+             P +-----+
   *    | t  /|               |\  t |
   *    |   / |               | \   |
   *  n1|  /  |n3           n1|  \  |n3
   *    | /   |    after CW   |   \ |
   *    |/ oT |               | oT \|
   *    +-----+ oP            +-----+
   *       n4                    n4
   * </pre>
   */
  function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);
    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);
    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);
    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
      ot.markNeighbor(n1);
    }
    if (n2) {
      t.markNeighbor(n2);
    }
    if (n3) {
      t.markNeighbor(n3);
    }
    if (n4) {
      ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
  }

  /**
   * Fills a basin that has formed on the Advancing Front to the right
   * of given node.<br>
   * First we decide a left,bottom and right node that forms the
   * boundaries of the basin. Then we do a reqursive fill.
   *
   * @param {!SweepContext} tcx - SweepContext object
   * @param node - starting node, this or next node will be left node
   */
  function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
      tcx.basin.left_node = node.next.next;
    } else {
      tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
      tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
      // No valid basin
      return;
    }
    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
      tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
      // No valid basins
      return;
    }
    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;
    fillBasinReq(tcx, tcx.basin.bottom_node);
  }

  /**
   * Recursive algorithm to fill a Basin with triangles
   *
   * @param {!SweepContext} tcx - SweepContext object
   * @param node - bottom_node
   */
  function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
      return;
    }
    fill(tcx, node);
    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
      return;
    } else if (node.prev === tcx.basin.left_node) {
      o = orient2d(node.point, node.next.point, node.next.next.point);
      if (o === Orientation.CW) {
        return;
      }
      node = node.next;
    } else if (node.next === tcx.basin.right_node) {
      o = orient2d(node.point, node.prev.point, node.prev.prev.point);
      if (o === Orientation.CCW) {
        return;
      }
      node = node.prev;
    } else {
      // Continue with the neighbor node with lowest Y value
      if (node.prev.point.y < node.next.point.y) {
        node = node.prev;
      } else {
        node = node.next;
      }
    }
    fillBasinReq(tcx, node);
  }
  function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
      height = tcx.basin.left_node.point.y - node.point.y;
    } else {
      height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
      return true;
    }
    return false;
  }
  function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
      fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
      fillLeftAboveEdgeEvent(tcx, edge, node);
    }
  }
  function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
      // Check if next node is below the edge
      if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
        fillRightBelowEdgeEvent(tcx, edge, node);
      } else {
        node = node.next;
      }
    }
  }
  function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
      if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node);
      } else {
        // Convex
        fillRightConvexEdgeEvent(tcx, edge, node);
        // Retry this one
        fillRightBelowEdgeEvent(tcx, edge, node);
      }
    }
  }
  function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
      // Next above or below edge?
      if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
        // Below
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
          // Next is concave
          fillRightConcaveEdgeEvent(tcx, edge, node);
        }
      }
    }
  }
  function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
      // Concave
      fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
      // Convex
      // Next above or below edge?
      if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
        // Below
        fillRightConvexEdgeEvent(tcx, edge, node.next);
      }
    }
  }
  function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
      // Check if next node is below the edge
      if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
        fillLeftBelowEdgeEvent(tcx, edge, node);
      } else {
        node = node.prev;
      }
    }
  }
  function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
      if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node);
      } else {
        // Convex
        fillLeftConvexEdgeEvent(tcx, edge, node);
        // Retry this one
        fillLeftBelowEdgeEvent(tcx, edge, node);
      }
    }
  }
  function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
      // Concave
      fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
      // Convex
      // Next above or below edge?
      if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
        // Below
        fillLeftConvexEdgeEvent(tcx, edge, node.prev);
      }
    }
  }
  function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
      // Next above or below edge?
      if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
        // Below
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
          // Next is concave
          fillLeftConcaveEdgeEvent(tcx, edge, node);
        }
      }
    }
  }
  function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");
    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
      var index = t.index(p);
      throw new PointError("poly2tri Intersecting Constraints", [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }
    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
      // Lets rotate shared edge one vertex CW
      rotateTrianglePair(t, p, ot, op);
      tcx.mapTriangleToNodes(t);
      tcx.mapTriangleToNodes(ot);

      // XXX: in the original C++ code for the next 2 lines, we are
      // comparing point values (and not pointers). In this JavaScript
      // code, we are comparing point references (pointers). This works
      // because we can't have 2 different points with the same values.
      // But to be really equivalent, we should use "Point.equals" here.
      if (p === eq && op === ep) {
        if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
          t.markConstrainedEdgeByPoints(ep, eq);
          ot.markConstrainedEdgeByPoints(ep, eq);
          legalize(tcx, t);
          legalize(tcx, ot);
        }
      } else {
        var o = orient2d(eq, op, ep);
        t = nextFlipTriangle(tcx, o, t, ot, p, op);
        flipEdgeEvent(tcx, ep, eq, t, p);
      }
    } else {
      var newP = nextFlipPoint(ep, eq, ot, op);
      flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
      edgeEventByPoints(tcx, ep, eq, t, p);
    }
  }

  /**
   * After a flip we have two triangles and know that only one will still be
   * intersecting the edge. So decide which to contiune with and legalize the other
   *
   * @param {!SweepContext} tcx - SweepContext object
   * @param o - should be the result of an orient2d( eq, op, ep )
   * @param t - triangle 1
   * @param ot - triangle 2
   * @param p - a point shared by both triangles
   * @param op - another point shared by both triangles
   * @return returns the triangle still intersecting the edge
   */
  function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
      // ot is not crossing edge after flip
      edge_index = ot.edgeIndex(p, op);
      ot.delaunay_edge[edge_index] = true;
      legalize(tcx, ot);
      ot.clearDelaunayEdges();
      return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);
    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
  }

  /**
   * When we need to traverse from one triangle to the next we need
   * the point in current triangle that is the opposite point to the next
   * triangle.
   */
  function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
      // Right
      return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
      // Left
      return ot.pointCW(op);
    } else {
      throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
  }

  /**
   * Scan part of the FlipScan algorithm<br>
   * When a triangle pair isn't flippable we will scan for the next
   * point that is inside the flip triangle scan area. When found
   * we generate a new flipEdgeEvent
   *
   * @param {!SweepContext} tcx - SweepContext object
   * @param ep - last point on the edge we are traversing
   * @param eq - first point on the edge we are traversing
   * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
   * @param t
   * @param p
   */
  function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");
    var op = ot.oppositePoint(t, p);
    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
      // flip with new edge op.eq
      flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
      var newP = nextFlipPoint(ep, eq, ot, op);
      flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
  }

  /*
   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
   * http://code.google.com/p/poly2tri/
   *
   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
   * https://github.com/r3mi/poly2tri.js
   *
   * All rights reserved.
   *
   * Distributed under the 3-clause BSD License, see LICENSE.txt
   */

  // ------------------------------------------------------------------------utils

  /**
   * Initial triangle factor, seed triangle will extend 30% of
   * PointSet width to both left and right.
   * @private
   * @const
   */
  var kAlpha = 0.3;

  // -------------------------------------------------------------------------Edge
  /**
   * Represents a simple polygon's edge
   * @constructor
   * @struct
   * @private
   * @param {Point} p1
   * @param {Point} p2
   * @throw {PointError} if p1 is same as p2
   */
  var Edge = function Edge(p1, p2) {
    this.p = p1;
    this.q = p2;
    if (p1.y > p2.y) {
      this.q = p1;
      this.p = p2;
    } else if (p1.y === p2.y) {
      if (p1.x > p2.x) {
        this.q = p1;
        this.p = p2;
      } else if (p1.x === p2.x) {
        throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
      }
    }
    if (!this.q._p2t_edge_list) {
      this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
  };

  // ------------------------------------------------------------------------Basin
  /**
   * @constructor
   * @struct
   * @private
   */
  var Basin = function Basin() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
  };
  Basin.prototype.clear = function () {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
  };

  // --------------------------------------------------------------------EdgeEvent
  /**
   * @constructor
   * @struct
   * @private
   */
  var EdgeEvent = function EdgeEvent() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
  };

  // ----------------------------------------------------SweepContext (public API)
  /**
   * SweepContext constructor option
   * @typedef {Object} SweepContextOptions
   * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
   *                  (contour, holes). Points inside arrays are never copied.
   *                  Default is <code>false</code> : keep a reference to the array arguments,
   *                  who will be modified in place.
   */
  /**
   * Constructor for the triangulation context.
   * It accepts a simple polyline (with non repeating points),
   * which defines the constrained edges.
   *
   * @example
   *          var contour = [
   *              new poly2tri.Point(100, 100),
   *              new poly2tri.Point(100, 300),
   *              new poly2tri.Point(300, 300),
   *              new poly2tri.Point(300, 100)
   *          ];
   *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
   * @example
   *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
   *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
   * @constructor
   * @public
   * @struct
   * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
   *          or any "Point like" custom class with <code>{x, y}</code> attributes.
   * @param {SweepContextOptions=} options - constructor options
   */
  var SweepContext = function SweepContext(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = options.cloneArrays ? contour.slice(0) : contour;
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation,
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;
    this.basin = new Basin();
    this.edge_event = new EdgeEvent();
    this.initEdges(this.points_);
  };

  /**
   * Add a hole to the constraints
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      var hole = [
   *          new poly2tri.Point(200, 200),
   *          new poly2tri.Point(200, 250),
   *          new poly2tri.Point(250, 250)
   *      ];
   *      swctx.addHole(hole);
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
   * @public
   * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
   */
  SweepContext.prototype.addHole = function (polyline) {
    this.initEdges(polyline);
    var i,
      len = polyline.length;
    for (i = 0; i < len; i++) {
      this.points_.push(polyline[i]);
    }
    return this; // for chaining
  };

  /**
   * For backward compatibility
   * @function
   * @deprecated use {@linkcode SweepContext#addHole} instead
   */
  SweepContext.prototype.AddHole = SweepContext.prototype.addHole;

  /**
   * Add several holes to the constraints
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      var holes = [
   *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
   *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
   *      ];
   *      swctx.addHoles(holes);
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      var holes = [
   *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
   *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
   *      ];
   *      swctx.addHoles(holes);
   * @public
   * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
   */
  // Method added in the JavaScript version (was not present in the c++ version)
  SweepContext.prototype.addHoles = function (holes) {
    var i,
      len = holes.length;
    for (i = 0; i < len; i++) {
      this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
  };

  /**
   * Add a Steiner point to the constraints
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      var point = new poly2tri.Point(150, 150);
   *      swctx.addPoint(point);
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      swctx.addPoint({x:150, y:150});
   * @public
   * @param {XY} point - any "Point like" object with {x,y}
   */
  SweepContext.prototype.addPoint = function (point) {
    this.points_.push(point);
    return this; // for chaining
  };

  /**
   * For backward compatibility
   * @function
   * @deprecated use {@linkcode SweepContext#addPoint} instead
   */
  SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;

  /**
   * Add several Steiner points to the constraints
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      var points = [
   *          new poly2tri.Point(150, 150),
   *          new poly2tri.Point(200, 250),
   *          new poly2tri.Point(250, 250)
   *      ];
   *      swctx.addPoints(points);
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
   * @public
   * @param {Array.<XY>} points - array of "Point like" object with {x,y}
   */
  // Method added in the JavaScript version (was not present in the c++ version)
  SweepContext.prototype.addPoints = function (points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
  };

  /**
   * Triangulate the polygon with holes and Steiner points.
   * Do this AFTER you've added the polyline, holes, and Steiner points
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      swctx.triangulate();
   *      var triangles = swctx.getTriangles();
   * @public
   */
  // Shortcut method for sweep.triangulate(SweepContext).
  // Method added in the JavaScript version (was not present in the c++ version)
  SweepContext.prototype.triangulate = function () {
    triangulate(this);
    return this; // for chaining
  };

  /**
   * Get the bounding box of the provided constraints (contour, holes and
   * Steinter points). Warning : these values are not available if the triangulation
   * has not been done yet.
   * @public
   * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
   */
  // Method added in the JavaScript version (was not present in the c++ version)
  SweepContext.prototype.getBoundingBox = function () {
    return {
      min: this.pmin_,
      max: this.pmax_
    };
  };

  /**
   * Get result of triangulation.
   * The output triangles have vertices which are references
   * to the initial input points (not copies): any custom fields in the
   * initial points can be retrieved in the output triangles.
   * @example
   *      var swctx = new poly2tri.SweepContext(contour);
   *      swctx.triangulate();
   *      var triangles = swctx.getTriangles();
   * @example
   *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
   *      var swctx = new poly2tri.SweepContext(contour);
   *      swctx.triangulate();
   *      var triangles = swctx.getTriangles();
   *      typeof triangles[0].getPoint(0).id
   *      // → "number"
   * @public
   * @returns {array<Triangle>}   array of triangles
   */
  SweepContext.prototype.getTriangles = function () {
    return this.triangles_;
  };

  /**
   * For backward compatibility
   * @function
   * @deprecated use {@linkcode SweepContext#getTriangles} instead
   */
  SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;

  // ---------------------------------------------------SweepContext (private API)

  /** @private */
  SweepContext.prototype.front = function () {
    return this.front_;
  };

  /** @private */
  SweepContext.prototype.pointCount = function () {
    return this.points_.length;
  };

  /** @private */
  SweepContext.prototype.head = function () {
    return this.head_;
  };

  /** @private */
  SweepContext.prototype.setHead = function (p1) {
    this.head_ = p1;
  };

  /** @private */
  SweepContext.prototype.tail = function () {
    return this.tail_;
  };

  /** @private */
  SweepContext.prototype.setTail = function (p1) {
    this.tail_ = p1;
  };

  /** @private */
  SweepContext.prototype.getMap = function () {
    return this.map_;
  };

  /** @private */
  SweepContext.prototype.initTriangulation = function () {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i,
      len = this.points_.length;
    for (i = 1; i < len; i++) {
      var p = this.points_[i];
      /* jshint expr:true */
      p.x > xmax && (xmax = p.x);
      p.x < xmin && (xmin = p.x);
      p.y > ymax && (ymax = p.y);
      p.y < ymin && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);
    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
  };

  /** @private */
  SweepContext.prototype.initEdges = function (polyline) {
    var i,
      len = polyline.length;
    for (i = 0; i < len; ++i) {
      this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
  };

  /** @private */
  SweepContext.prototype.getPoint = function (index) {
    return this.points_[index];
  };

  /** @private */
  SweepContext.prototype.addToMap = function (triangle) {
    this.map_.push(triangle);
  };

  /** @private */
  SweepContext.prototype.locateNode = function (point) {
    return this.front_.locateNode(point.x);
  };

  /** @private */
  SweepContext.prototype.createAdvancingFront = function () {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);
    this.map_.push(triangle);
    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));
    this.front_ = new AdvancingFront(head, tail);
    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
  };

  /** @private */
  SweepContext.prototype.removeNode = function (node) {
    // do nothing
    /* jshint unused:false */
  };

  /** @private */
  SweepContext.prototype.mapTriangleToNodes = function (t) {
    for (var i = 0; i < 3; ++i) {
      if (!t.getNeighbor(i)) {
        var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
        if (n) {
          n.triangle = t;
        }
      }
    }
  };

  /** @private */
  SweepContext.prototype.removeFromMap = function (triangle) {
    var i,
      map = this.map_,
      len = map.length;
    for (i = 0; i < len; i++) {
      if (map[i] === triangle) {
        map.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Do a depth first traversal to collect triangles
   * @private
   * @param {Triangle} triangle start
   */
  SweepContext.prototype.meshClean = function (triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle],
      t,
      i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
      if (!t.isInterior()) {
        t.setInterior(true);
        this.triangles_.push(t);
        for (i = 0; i < 3; i++) {
          if (!t.constrained_edge[i]) {
            triangles.push(t.getNeighbor(i));
          }
        }
      }
    }
  };

  var GML = function GML(doc) {
    this.doc = doc;
    this.gml = 'http://www.opengis.net/gml';
    this.zOffset = .01;
  };
  GML.prototype = {
    constructor: GML,
    Read: function Read() {},
    ParseExtent: function ParseExtent(element) {
      var boundedby = element.getElementsByTagNameNS(this.gml, 'boundedBy');
      var envelope = boundedby[0].getElementsByTagNameNS(this.gml, 'Envelope');
      var srs = envelope[0].attributes.getNamedItem('srsName').value;
      envelope[0].attributes.getNamedItem('srsDimension').value;
      var lowerCorner = this.ParsePos(envelope[0].getElementsByTagNameNS(this.gml, 'lowerCorner')[0]);
      var upperCorner = this.ParsePos(envelope[0].getElementsByTagNameNS(this.gml, 'upperCorner')[0]);
      return {
        SRS: srs,
        lowerCorner: lowerCorner,
        upperCorner: upperCorner
      };
    },
    ParseMultiSurface: function ParseMultiSurface(multisurface, materials) {
      var posList = multisurface.getElementsByTagNameNS(this.gml, 'posList');
      var dims = multisurface.hasAttribute('srsDimension') ? parseInt(multisurface.attributes.getNamedItem('srsDimension').value) : posList[0].hasAttribute('srsDimension') ? posList[0].attributes.getNamedItem('srsDimension').value : 3;
      var object3ds = [];
      var surfaces = multisurface.getElementsByTagNameNS(this.gml, 'surfaceMember');
      for (var i = 0; i < surfaces.length; i++) {
        var polygons = surfaces[i].getElementsByTagNameNS(this.gml, 'Polygon');
        for (var j = 0; j < polygons.length; j++) {
          var g = this.ParsePolygon(polygons[j], materials, dims);
          if (g != null) {
            object3ds = object3ds.concat(g);
          }
        }
      }
      return object3ds;
    },
    ParsePos: function ParsePos(pos) {
      var a = pos.childNodes[0].nodeValue.split(' ');
      for (var i = 0; i < a.length; i++) {
        a[i] = parseFloat(a[i]);
      }
      return a;
    },
    ParsePosList: function ParsePosList(poslist) {
      var a = poslist.childNodes[0].nodeValue.split(/ +/g);
      for (var i = 0; i < a.length; i++) {
        a[i] = parseFloat(a[i]);
      }
      return a;
    },
    ParseLinearRing: function ParseLinearRing(ring) {
      var _ring$attributes$getN;
      var id = (_ring$attributes$getN = ring.attributes.getNamedItemNS(this.gml, 'id')) === null || _ring$attributes$getN === void 0 ? void 0 : _ring$attributes$getN.value;
      var posItems = [];
      var pos = ring.getElementsByTagNameNS(this.gml, 'pos');
      for (var i = 0; i < pos.length; i++) {
        posItems = posItems.concat(this.ParsePos(pos[i]));
      }
      var posList = ring.getElementsByTagNameNS(this.gml, 'posList');
      if (posList.length > 0) {
        posItems = posItems.concat(this.ParsePosList(posList[0]));
      }
      var l = posItems.length;
      if (posItems[0] == posItems[l - 3] && posItems[1] == posItems[l - 2] && posItems[2] == posItems[l - 1]) {
        posItems = posItems.slice(0, l - 3);
      }
      return {
        id: id,
        coordinates: posItems
      };
    },
    ParseLine: function ParseLine(polygon, materials, dims, z) {},
    ParsePolygon: function ParsePolygon(polygon, materials, dims, z) {
      var _polygon$attributes$g;
      var toReturn = null;
      var id = (_polygon$attributes$g = polygon.attributes.getNamedItemNS(this.gml, 'id')) === null || _polygon$attributes$g === void 0 ? void 0 : _polygon$attributes$g.value;
      var ext = polygon.getElementsByTagNameNS(this.gml, 'exterior')[0].getElementsByTagNameNS(this.gml, 'LinearRing')[0];
      var exterior = this.ParseLinearRing(ext);
      var interiors = polygon.getElementsByTagNameNS(this.gml, 'interior');
      var interiorrings = [];
      for (var i = 0; i < interiors.length; i++) {
        interiorrings[i] = this.ParseLinearRing(interiors[i].getElementsByTagNameNS(this.gml, 'LinearRing')[0]);
      }
      //extrude via shape		TODO!
      if (dims == 2) {
        var positions = [];
        for (var i = 0; i < exterior.coordinates.length; i++) {
          positions.push(exterior.coordinates[i], exterior.coordinates[++i]);
        }
        var holes = [];
        for (var i = 0; i < interiorrings.length; i++) {
          var holePoints = [];
          for (var j = 0; j < interiorrings[i].length; i++) {
            holePoints.push(interiorrings[i].coordinates[j], interiorrings[i].coordinates[j++]);
          }
          holes.push(holePoints);
        }
        var polygonPrimitive = new PolygonPrimitive({
          positions: positions,
          holes: holes,
          material: materials
        });
        // const entity = new Earth.Entity({
        //   name: 'polygon',
        //   show: true,
        //   polygon: new Earth.Polygon({
        //     show: true,
        //     hierarchy: Earth.Cartesian3.fromDegreesArray(degreesArray), //带高度坐标
        //     color: Earth.Color.YELLOW,
        //     heightReference: Earth.HeightReference.CLAMP_TO_GROUND, //贴地
        //   }),
        // });
        toReturn = polygonPrimitive;
      } else {
        var zx = 1,
          zy = 1;
        var xmin, xminindex, xmax, xmaxindex;
        xmin = Number.MAX_VALUE;
        xmax = Number.MIN_VALUE;
        for (var i = 0; i < exterior.coordinates.length; i++) {
          if (exterior.coordinates[i] < xmin) {
            xminindex = i;
            xmin = exterior.coordinates[i];
          }
          if (exterior.coordinates[i] > xmax) {
            xmaxindex = i;
            xmax = exterior.coordinates[i];
          }
          i += 2;
        }
        if (exterior.coordinates[xminindex + 1] < exterior.coordinates[xmaxindex + 1]) {
          zy = -1;
        }
        var ring2D = this.Convert3Dto2D(exterior, zx, zy);
        if (ring2D.ring.length < 3) {
          return null;
        } else {
          try {
            var pointindex = [];
            var color = new Color$2(0xff0000);
            var uvIndex = [];
            var materialIndex = 0;
            var index = '#' + id;
            for (var i = materials.index[index].a; i < materials.materials.length; i++) {
              for (var j = materials.index[index].t; j < materials.materials[i].targets.length; j++) {
                if (materials.materials[i].targets[j].uri == '#' + id) {
                  if (materials.materials[i].targets[j].hasOwnProperty('textureCoordinates')) {
                    uvIndex = materials.materials[i].targets[j].textureCoordinates;
                  }
                  color = materials.materials[i].color;
                  materialIndex = i;
                  i = materials.length;
                  break;
                }
              }
            }

            //parse the linearray before the swctx, because swctx messes with the point order
            var lineArray = new Float32Array(ring2D.ring.length * 6);
            var lineColorArray = new Float32Array(ring2D.ring.length * 6);
            for (var i = 0; i < ring2D.ring.length; i++) {
              var p = ring2D.ring[i];
              var p2 = i + 1 < ring2D.ring.length ? ring2D.ring[i + 1] : ring2D.ring[0];
              lineArray.set([p.x - p.z * zx, p.y - p.z * zy, p.z + this.zOffset, p2.x - p2.z * zx, p2.y - p2.z * zy, p2.z + this.zOffset], i * 6);
              lineColorArray.set([color.r, color.g, color.b, color.r, color.g, color.b], i * 6);
            }
            var swctx = new SweepContext(ring2D.ring);
            for (var i = 0; i < interiorrings.length; i++) {
              var intRing = this.Convert3Dto2D(interiorrings[i], zx, zy);
              swctx.addHole(intRing.ring);
            }
            swctx.triangulate();
            var triangles = swctx.getTriangles();
            var vertexIdxArray = new Int16Array(triangles.length * 3);
            var vertexPosArray = new Float32Array(swctx.pointCount() * 3);
            var uvArray = new Float32Array(swctx.pointCount() * 2);
            var normalArray = new Float32Array(swctx.pointCount() * 3);
            var colorArray = new Float32Array(swctx.pointCount() * 3);
            if (uvIndex.length > 0) {
              for (var i = 0; i < uvIndex.length && i * 2 < uvArray.length; i++) {
                uvArray.set([uvIndex[i].x, uvIndex[i].y], i * 2);
              }
            }
            for (var i = 0; i < swctx.points_.length; i++) {
              var index = i * 3;
              var indexp = i * 3 + 1;
              var indexpp = i * 3 + 2;
              vertexPosArray[index] = swctx.points_[i].x - swctx.points_[i].z * zx;
              vertexPosArray[indexp] = swctx.points_[i].y - swctx.points_[i].z * zy;
              vertexPosArray[indexpp] = swctx.points_[i].z + this.zOffset;
              pointindex[swctx.points_[i].id] = i;
              colorArray[index] = color.r;
              colorArray[indexp] = color.g;
              colorArray[indexpp] = color.b;
              if (uvIndex.length > 0) {
                var uvPosition = parseInt(swctx.points_[i].id.replace(exterior.id + '_', ''));
                uvArray.set([uvIndex[uvPosition].x, uvIndex[uvPosition].y], i * 2);
              }
            }
            for (var i = 0; i < triangles.length; i++) {
              var a = pointindex[triangles[i].points_[0].id],
                b = pointindex[triangles[i].points_[1].id],
                c = pointindex[triangles[i].points_[2].id];
              if (a != undefined && b != undefined && c != undefined) {
                var pA = new Vector3(triangles[i].points_[0].x, triangles[i].points_[0].y, triangles[i].points_[0].z);
                var pB = new Vector3(triangles[i].points_[1].x, triangles[i].points_[1].y, triangles[i].points_[1].z);
                var pC = new Vector3(triangles[i].points_[2].x, triangles[i].points_[2].y, triangles[i].points_[2].z);
                var cb = new Vector3();
                var ab = new Vector3();
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                cb.normalize();
                normalArray[a * 3] = cb.x;
                normalArray[a * 3 + 1] = cb.y;
                normalArray[a * 3 + 2] = cb.z;
                normalArray[b * 3] = cb.x;
                normalArray[b * 3 + 1] = cb.y;
                normalArray[b * 3 + 2] = cb.z;
                normalArray[c * 3] = cb.x;
                normalArray[c * 3 + 1] = cb.y;
                normalArray[c * 3 + 2] = cb.z;
                vertexIdxArray[i * 3] = a;
                vertexIdxArray[i * 3 + 1] = b;
                vertexIdxArray[i * 3 + 2] = c;
              }
            }
            var geometry = new BufferGeometry();
            // geometry.attributes = attributes;

            // g.setAttribute('position', new BufferAttribute(array, 3));

            geometry.setAttribute('position', new BufferAttribute(vertexPosArray, 3));
            geometry.setAttribute('uv', new BufferAttribute(uvIndex.length > 0 ? uvArray : new Float32Array(0), 2));
            geometry.setAttribute('normal', new BufferAttribute(normalArray, 3));
            geometry.setAttribute('color', new BufferAttribute(colorArray, 3));
            geometry.setAttribute('line', new BufferAttribute(lineArray, 3));
            geometry.setAttribute('linecolor', new BufferAttribute(lineColorArray, 3));
            geometry.setIndex(new BufferAttribute(vertexIdxArray, 1));
            geometry.groups = [{
              start: 0,
              count: vertexIdxArray.length,
              index: 0
            }];
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            // geometry.dynamic = true;
            var toReturn = new Mesh(geometry, materials.materials[materialIndex]);
            toReturn.name = id;
          } catch (err) {
            // console.log(id);
            return null;
          }
        }
      }
      return toReturn;
    },
    Convert3Dto2D: function Convert3Dto2D(linearring, zx, zy) {
      var ring = linearring.coordinates;
      var ring2D = {
        doublePositions: [],
        ring: []
      };
      for (var i = 0; i < ring.length; i++) {
        var isdouble = false;
        for (var j = i + 3; j < ring.length; j++) {
          if (ring[i] == ring[j] && ring[i + 1] == ring[j + 1] && ring[i + 2] == ring[j + 2]) {
            isdouble = true;
            if (linearring.id == 'bbe68caf-bac5-4264-acd8-f336bacf241c_0') {
              isdouble = true;
            }
            // console.log(linearring.id + ":"+j );
            break;
          }
          j += 2;
        }
        if (!isdouble) {
          ring2D.ring.push({
            x: ring[i] + ring[i + 2] * zx,
            y: ring[i + 1] + ring[i + 2] * zy,
            z: ring[i + 2],
            id: linearring.id + '_' + i / 3
          });
        } else if (i > 0) {
          ring2D.doublePositions.push(i / 3);
        }
        i += 2;
      }
      return ring2D;
    },
    CreateBuffergeometry: function CreateBuffergeometry(geometry) {
      var buffergeometry;
      return buffergeometry;
    }
  };

  // import * as THREE from '../../three/three.module.js'
  var ParameterizedTexture = function ParameterizedTexture(url) {
    this.targets = [];
    this.url = url;
  };
  ParameterizedTexture.prototype = {
    constructor: ParameterizedTexture,
    clone: function clone() {
      var c = new ParameterizedTexture(this.url);
      for (var i = 0; i < this.targets.length; i++) {
        c.targets[i] = this.targets[i].clone();
      }
      return c;
    },
    getMaterial: function getMaterial() {
      var texture = new TextureLoader().load(this.url);
      var material = new MeshBasicMaterial$1({
        map: texture,
        vertexColors: new Color$2(0xffffff)
      });
      material.side = DoubleSide$1;
      material.url = this.url;
      material.targets = this.targets;
      return material;
    },
    getCompressedMaterial: function getCompressedMaterial(resize, textureCompressionService) {
      //var urlstring = JSON.stringify({ UrlArray:[this.url.replace("\\","/")], resize:resize } );
      //var requesturl = serviceUrl +'images='+ urlstring;
      //var enc = encodeURI(requesturl);
      var enc = textureCompressionService.getCompressedTextureUrl([this.url], resize);
      var texture = new CompressedTextureLoader().load(enc);
      var material = new MeshBasicMaterial$1({
        map: texture,
        vertexColors: new Color$2(0xffffff)
      });
      material.side = DoubleSide$1;
      material.url = this.url;
      material.targets = this.targets;
      return material;
    }
  };

  var CityGML = function CityGML(doc, documentUrl, options) {
    GML.apply(this, arguments);
    this.doc = doc;
    this.documentURL = documentUrl;
    this.textureCompressionFactor = 1;
    this.textureCompressionService = null;
    this.bldg = 'http://www.opengis.net/citygml/building/1.0';
    this.core = 'http://www.opengis.net/citygml/1.0';
    this.app = 'http://www.opengis.net/citygml/appearance/1.0';
    this.gen = "http://www.opengis.net/citygml/generics/1.0";
    this.setValues(options);
  };
  CityGML.prototype = new GML();
  CityGML.prototype.constructor = CityGML;
  CityGML.prototype.Read = function () {
    var source = {
      features: [],
      extent: null
    };
    var object3Ds = [];
    var extent = this.ParseExtent(this.doc);
    source.extent = extent;
    //get the appearances
    var apps = this.doc.getElementsByTagNameNS(this.app, 'appearance');
    if (0 == apps.length) {
      apps = this.doc.getElementsByTagNameNS(this.app, 'appearanceMember');
    }
    var appearances = this.ParseAppearance(apps);
    var buildings = this.doc.getElementsByTagNameNS(this.bldg, 'Building');
    for (var i = 0; i < buildings.length; i++) {
      object3Ds.push(this.ParseBuilding(buildings[i], appearances));
    }
    source.features = object3Ds;
    return source;
  };
  CityGML.prototype.parseAttributeNode = function (node, obj) {
    obj.userData[node.localName] = node.childNodes[0] != undefined ? node.childNodes[0].nodeValue : "";
  };
  CityGML.prototype.parseStringAttribute = function (node, obj) {
    var nodename = node.attributes.getNamedItem('name').value;
    var value = node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0] != undefined ? node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0].nodeValue : "";
    obj.userData[nodename] = value;
  };
  CityGML.prototype.parseDoubleAttribute = function (node, obj) {
    var nodename = node.attributes.getNamedItem('name').value;
    var value = node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0] != undefined ? node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0].nodeValue : "";
    obj.userData[nodename] = parseFloat(value);
  };
  CityGML.prototype.parseIntAttribute = function (node, obj) {
    var nodename = node.attributes.getNamedItem('name').value;
    var value = node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0] != undefined ? node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0].nodeValue : "";
    obj.userData[nodename] = parseInt(value);
  };
  CityGML.prototype.parseDateAttribute = function (node, obj) {
    var nodename = node.attributes.getNamedItem('name').value;
    var value = node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0] != undefined ? node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0].nodeValue : "";
    obj.userData[nodename] = value;
  };
  CityGML.prototype.parseUriAttribute = function (node, obj) {
    var nodename = node.attributes.getNamedItem('name').value;
    var value = node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0] != undefined ? node.getElementsByTagNameNS(this.gen, 'value')[0].childNodes[0].nodeValue : "";
    obj.userData[nodename] = value;
  };
  CityGML.prototype.ParseAsAttribute = function (node, buildingObject3D) {
    if (node.localName == 'description' && node.namespaceURI == this.gml) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'name' && node.namespaceURI == this.gml) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'creationDate' && node.namespaceURI == this.core) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'class' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'function' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'usage' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'yearOfConstruction' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'roofType' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'measuredHeight' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'storeysAboveGround' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'storeysBelowGround' && node.namespaceURI == this.bldg) {
      this.parseAttributeNode(node, buildingObject3D);
    } else if (node.localName == 'doubleAttribute' && node.namespaceURI == this.gen) {
      this.parseDoubleAttribute(node, buildingObject3D);
    } else if (node.localName == 'stringAttribute' && node.namespaceURI == this.gen) {
      this.parseStringAttribute(node, buildingObject3D);
    } else if (node.localName == 'intAttribute' && node.namespaceURI == this.gen) {
      this.parseIntAttribute(node, buildingObject3D);
    } else if (node.localName == 'dateAttribute' && node.namespaceURI == this.gen) {
      this.parseDateAttribute(node, buildingObject3D);
    } else if (node.localName == 'uriAttribute' && node.namespaceURI == this.gen) {
      this.parseUriAttribute(node, buildingObject3D);
    }
  };
  CityGML.prototype.ParseBuilding = function (building, appearances) {
    var buildingObject3D = new Group$1(); // fill with outershell and rooms as Mesh with MeshFaceMaterial, each object will get name and properties
    buildingObject3D.name = building.attributes.getNamedItemNS(this.gml, 'id') != null ? building.attributes.getNamedItemNS(this.gml, 'id').value : "";
    var appearances; //this.ParseAppearance(building.getElementsByTagNameNS(this.app, 'appearance')[0].getElementsByTagNameNS(this.app, 'Appearance')[0]);

    //outer shell
    //	var mergeMesh = new Mesh();
    //get appearances for building alone
    /*for (var i = 0; i< building.childNodes.length; i++){
      var node = building.childNodes[i];
      if (node.localName =='appearance' && node.namespaceURI == this.app){
        builingMaterials = this.ParseAppearance(node);
      }
    }*/
    for (var i = 0; i < building.childNodes.length; i++) {
      var node = building.childNodes[i];
      this.ParseAsAttribute(node, buildingObject3D);
      if (node.localName == 'boundedBy' && node.namespaceURI == this.bldg) {
        var walls = node.getElementsByTagNameNS(this.bldg, 'WallSurface');
        for (var j = 0; j < walls.length; j++) {
          var multiSurfaceObject3Ds = this.ParseLODMultiSurface(walls[j], appearances);
          this.AddObject3DArray(buildingObject3D, multiSurfaceObject3Ds);
        }
        var roofs = node.getElementsByTagNameNS(this.bldg, 'RoofSurface');
        for (var j = 0; j < roofs.length; j++) {
          var multiSurfaceObject3Ds = this.ParseLODMultiSurface(roofs[j], appearances);
          this.AddObject3DArray(buildingObject3D, multiSurfaceObject3Ds);
        }
        var floors = node.getElementsByTagNameNS(this.bldg, 'FloorSurface');
        for (var j = 0; j < floors.length; j++) {
          var multiSurfaceObject3Ds = this.ParseLODMultiSurface(floors[j], appearances);
          this.AddObject3DArray(buildingObject3D, multiSurfaceObject3Ds);
        }
        var ceilings = node.getElementsByTagNameNS(this.bldg, 'CeilingSurface');
        for (var j = 0; j < ceilings.length; j++) {
          var multiSurfaceObject3Ds = this.ParseLODMultiSurface(ceilings[j], appearances);
          this.AddObject3DArray(buildingObject3D, multiSurfaceObject3Ds);
        }
      } else if (node.localName == 'interiorRoom' && node.namespaceURI == this.bldg) {
        var roomObject3D = new Object3D();
        var room = node.getElementsByTagNameNS(this.bldg, 'Room')[0];
        roomObject3D.name = room.attributes.getNamedItemNS(this.gml, 'id').value;
        for (var j = 0; j < room.childNodes.length; j++) {
          this.ParseAsAttribute(room.childNodes[j], roomObject3D);
        }
        var roomboundedbys = room.getElementsByTagNameNS(this.bldg, 'boundedBy');
        for (var j = 0; j < roomboundedbys.length; j++) {
          var interiorWalls = roomboundedbys[j].getElementsByTagNameNS(this.bldg, 'InteriorWallSurface');
          var walls = roomboundedbys[j].getElementsByTagNameNS(this.bldg, 'WallSurface');
          for (var k = 0; k < interiorWalls.length; k++) {
            var multiSurfaceObject3Ds = this.ParseLODMultiSurface(interiorWalls[k], appearances);
            this.AddObject3DArray(roomObject3D, multiSurfaceObject3Ds);
          }
          for (var k = 0; k < walls.length; k++) {
            var multiSurfaceObject3Ds = this.ParseLODMultiSurface(walls[k], appearances);
            this.AddObject3DArray(roomObject3D, multiSurfaceObject3Ds);
          }
          var ceilings = roomboundedbys[j].getElementsByTagNameNS(this.bldg, 'CeilingSurface');
          for (var k = 0; k < ceilings.length; k++) {
            var multiSurfaceObject3Ds = this.ParseLODMultiSurface(ceilings[k], appearances);
            this.AddObject3DArray(roomObject3D, multiSurfaceObject3Ds);
          }
          var floors = roomboundedbys[j].getElementsByTagNameNS(this.bldg, 'FloorSurface');
          for (var k = 0; k < floors.length; k++) {
            var multiSurfaceObject3Ds = this.ParseLODMultiSurface(floors[k], appearances);
            this.AddObject3DArray(roomObject3D, multiSurfaceObject3Ds);
          }
        }
        buildingObject3D.add(roomObject3D);
      }
    }
    return buildingObject3D;
  };
  CityGML.prototype.ParseLODMultiSurface = function (lodsurface, materials) {
    var object3ds = [];
    var s = lodsurface.getElementsByTagNameNS(this.gml, 'MultiSurface');
    for (var i = 0; i < s.length; i++) {
      object3ds = object3ds.concat(this.ParseMultiSurface(s[i], materials));
    }
    return object3ds;
  };
  CityGML.prototype.ParseAppearance = function (apps) {
    var appearances = [];
    for (var k = 0; k < apps.length; k++) {
      var surfaceDataMembers = apps[k].getElementsByTagNameNS(this.app, 'surfaceDataMember');
      for (var i = 0; i < surfaceDataMembers.length; i++) {
        var x3Dmaterials = surfaceDataMembers[i].getElementsByTagNameNS(this.app, 'X3DMaterial');
        for (var j = 0; j < x3Dmaterials.length; j++) {
          appearances.push(this.ParseX3DMaterial(x3Dmaterials[j]));
        }
        var parameterizedTextures = surfaceDataMembers[i].getElementsByTagNameNS(this.app, 'ParameterizedTexture');
        for (var j = 0; j < parameterizedTextures.length; j++) {
          appearances.push(this.ParseParameterizedTexture(parameterizedTextures[j]));
        }
      }
    }
    //optimize for double images
    var index = [];
    var optimizedAppearances = [];
    for (var i = 0; i < appearances.length; i++) {
      if (appearances[i].hasOwnProperty('url')) {
        var j = 0;
        for (j = 0; j < optimizedAppearances.length; j++) {
          if (optimizedAppearances[j].hasOwnProperty('url')) {
            if (appearances[i].url == optimizedAppearances[j].url) {
              for (var k = 0; k < appearances[i].targets.length; k++) {
                optimizedAppearances[j].targets.push(appearances[i].targets[k].clone());
                index[appearances[i].targets[0].uri] = {
                  a: j,
                  t: optimizedAppearances[j].targets.length - 1
                };
              }
              break;
            }
          }
        }
        if (j == optimizedAppearances.length) {
          //no matching url found, now make a texture and material from the parameterizedtexture
          if (this.textureCompressionService != null) {
            optimizedAppearances.push(appearances[i].getCompressedMaterial(this.textureCompressionFactor, this.textureCompressionService));
          } else {
            optimizedAppearances.push(appearances[i].getMaterial());
          }
          index[appearances[i].targets[0].uri] = {
            a: optimizedAppearances.length - 1,
            t: 0
          };
        }
      } else {
        optimizedAppearances.push(appearances[i]);
        index[appearances[optimizedAppearances.length - 1].targets[0].uri] = {
          a: optimizedAppearances.length - 1,
          t: 0
        };
      }
    }
    return {
      materials: optimizedAppearances,
      index: index
    };
  };
  CityGML.prototype.ParseX3DMaterial = function (x3DMaterial) {
    var diffuseColor = x3DMaterial.getElementsByTagNameNS(this.app, 'diffuseColor').length > 0 ? this.ParseColor(x3DMaterial.getElementsByTagNameNS(this.app, 'diffuseColor')[0]) : new Color(0xffffff);
    var emissiveColor = x3DMaterial.getElementsByTagNameNS(this.app, 'emissiveColor').length > 0 ? this.ParseColor(x3DMaterial.getElementsByTagNameNS(this.app, 'emissiveColor')[0]) : new Color(0xffffff);
    var specularColor = x3DMaterial.getElementsByTagNameNS(this.app, 'specularColor').length > 0 ? this.ParseColor(x3DMaterial.getElementsByTagNameNS(this.app, 'specularColor')[0]) : new Color(0xffffff);
    var targets = [];
    var tg = x3DMaterial.getElementsByTagNameNS(this.app, 'target');
    for (var i = 0; i < tg.length; i++) {
      var target = tg[i].childNodes[0].nodeValue;
      targets.push({
        uri: target
      });
    }
    var material = new MeshBasicMaterial();
    material.side = DoubleSide;
    material.color = diffuseColor;
    material.emissive = emissiveColor;
    material.specular = specularColor;
    material.targets = targets;
    material.vertexColors = VertexColors;
    return material;
  };
  CityGML.prototype.ParseColor = function (color) {
    var c = new Color();
    var colorString = color.childNodes[0].nodeValue.split(' ');
    c.setRGB(parseFloat(colorString[0]), parseFloat(colorString[1]), parseFloat(colorString[2]));
    return c;
  };
  CityGML.prototype.ParseParameterizedTexture = function (pt) {
    var url = pt.getElementsByTagNameNS(this.app, 'imageURI')[0].childNodes[0].nodeValue;
    url = this.documentURL + url;
    var targets = [];
    var tg = pt.getElementsByTagNameNS(this.app, 'target');
    for (var i = 0; i < tg.length; i++) {
      var uri = tg[i].attributes.getNamedItem('uri').value;
      var target = new Target(uri);
      var texcoordlist = tg[i].getElementsByTagNameNS(this.app, 'TexCoordList')[0];
      var texturecoordinates = texcoordlist.getElementsByTagNameNS(this.app, 'textureCoordinates')[0].childNodes[0].nodeValue.split(' ');
      for (var j = 0; j < texturecoordinates.length; j += 2) {
        target.textureCoordinates.push({
          x: parseFloat(texturecoordinates[j]),
          y: parseFloat(texturecoordinates[j + 1])
        });
      }
      targets.push(target);
    }
    var pt = new ParameterizedTexture(url);
    pt.targets = targets;
    return pt;
  };
  CityGML.prototype.AddObject3DArray = function (object3d, a) {
    for (var i = 0; i < a.length; i++) {
      object3d.add(a[i]);
    }
  };
  CityGML.prototype.setValues = function (values) {
    if (values === undefined) return;
    for (var key in values) {
      var newValue = values[key];
      if (newValue === undefined) {
        continue;
      }
      if (key in this) {
        this[key] = newValue;
      }
    }
  };

  var EntityDataSource = /*#__PURE__*/function (_DataSource) {
    _inherits(EntityDataSource, _DataSource);
    var _super = _createSuper(EntityDataSource);
    function EntityDataSource() {
      _classCallCheck(this, EntityDataSource);
      return _super.call(this);
    }
    return _createClass(EntityDataSource);
  }(DataSource$1);

  var CityGMLDataSource = /*#__PURE__*/function (_EntityDataSource) {
    _inherits(CityGMLDataSource, _EntityDataSource);
    var _super = _createSuper(CityGMLDataSource);
    function CityGMLDataSource() {
      var _this;
      _classCallCheck(this, CityGMLDataSource);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_cityGMLlayer", void 0);
      _defineProperty(_assertThisInitialized(_this), "_type", void 0);
      _defineProperty(_assertThisInitialized(_this), "_dataSet", void 0);
      _this._type = DataSourceType.CityGML;
      _this._dataSet = null;
      _this._cityGMLlayer = null;
      return _this;
    }
    _createClass(CityGMLDataSource, [{
      key: "load",
      value: function load(url, _ref) {
        var _this2 = this;
        var resourceUrl = _ref.resourceUrl,
          name = _ref.name,
          scale = _ref.scale;
        return new Promise(function (resolve, reject) {
          fetch(url).then(function (res) {
            return res.text();
          }).then(function (response) {
            var xmlData = new DOMParser().parseFromString(response, "text/xml");
            var cityGML = new CityGML(xmlData, resourceUrl, {});
            _this2._dataSet = cityGML.Read();
            _this2._cityGMLlayer = new CityGMLLayer(_this2._dataSet, scale);
            _this2._cityGMLlayer.name = name;
            resolve(_this2);
          })["catch"](function (err) {
            return [reject(err)];
          });
        });
      }
    }, {
      key: "layer",
      get: function get() {
        return this._cityGMLlayer;
      },
      set: function set(value) {
        this._cityGMLlayer = value;
      }
    }, {
      key: "type",
      get: function get() {
        return this._type;
      }
    }, {
      key: "DataSet",
      get: function get() {
        return this._dataSet;
      }
    }], [{
      key: "load",
      value: function load(url, _ref2) {
        var resourceUrl = _ref2.resourceUrl,
          name = _ref2.name,
          scale = _ref2.scale;
        return new CityGMLDataSource().load(url, {
          resourceUrl: resourceUrl,
          name: name,
          scale: scale
        });
      }
    }]);
    return CityGMLDataSource;
  }(EntityDataSource);

  var ZCGML = function ZCGML(doc, options) {
    GML.apply(this, arguments);
    this.doc = doc;
    this.gml = "http://www.opengis.net/gml/3.2";
    this.material = options.material || null;
    // this.documentURL = documentUrl;
    this.textureCompressionFactor = 1;
    this.textureCompressionService = null;
    this.bldg = 'http://www.opengis.net/citygml/building/1.0';
    this.core = 'http://www.opengis.net/citygml/1.0';
    this.app = 'http://www.opengis.net/citygml/appearance/1.0';
    this.gen = "http://www.opengis.net/citygml/generics/1.0";
    this.jsqy = "http://www.entity/jsqy";
    // this.setValues(options);
  };

  ZCGML.prototype = new GML();
  ZCGML.prototype.constructor = ZCGML;
  ZCGML.prototype.Read = function () {
    var nodes = this.doc.getElementsByTagName('cityObjectMember')[0].children[0].children;
    var object3ds = null;
    var properties = {};
    var adeProperties = [];
    var genericAttribute = [];
    var relatedTo = [];
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].tagName === 'lod3MultiSurface' || nodes[i].tagName === 'lod0MultiCurve') {
        object3ds = this.parseLODMultiSurface(nodes[i]);
      } else if (nodes[i].tagName === 'adeOfAbstractCityObject') {
        adeProperties.push(this.parseAttr(nodes[i]).adeofabstractcityobject.entityobjectproperties);
      } else if (nodes[i].tagName === 'genericAttribute') {
        var attr = this.parseAttr(nodes[i]);
        genericAttribute.push(attr.genericattribute);
      } else if (nodes[i].tagName === 'relatedTo') {
        relatedTo.push(this.parseRelated(nodes[i]));
      } else {
        var _attr = this.parseAttr(nodes[i]);
        properties = _objectSpread2(_objectSpread2({}, properties), _attr);
      }
    }
    for (var _i = 0; _i < object3ds.length; _i++) {
      object3ds[_i].userData = {
        adeProperties: adeProperties,
        genericAttribute: genericAttribute,
        properties: properties,
        relatedTo: relatedTo
      };
    }
    return {
      polygon: object3ds,
      adeProperties: adeProperties,
      genericAttribute: genericAttribute,
      properties: properties,
      relatedTo: relatedTo
    };
  };
  ZCGML.prototype.parseAdeOfAbstractCityObject = function (adeOfAbstractCityObject) {
    var attrs = [];
    var properties = adeOfAbstractCityObject.children[0];
    for (var i = 0; i < properties.children.length; i++) {
      var property = properties.children[i];
      if (property.childElementCount === 0) {
        attrs.push({
          name: property.localName,
          value: property.textContent
        });
      } else {
        if (property.localName === 'LocationPoint') {
          attrs.push({
            name: property.localName,
            value: property.getElementsByTagName('gml:pos')[0].textContent
          });
        } else {
          attrs.push({
            name: property.localName,
            value: '待解析'
          });
        }
      }
    }
  };
  ZCGML.prototype.parseLODMultiSurface = function (lodMultiSurface) {
    var multiSurface = lodMultiSurface.getElementsByTagNameNS(this.gml, 'MultiSurface');
    var object3Ds = [];
    for (var i = 0; i < multiSurface.length; i++) {
      object3Ds = object3Ds.concat(this.ParseMultiSurface(multiSurface[i], this.material));
    }
    return object3Ds;
  };
  ZCGML.prototype.parseLODMultiSurface = function (lodMultiSurface) {
    var multiSurface = lodMultiSurface.getElementsByTagNameNS(this.gml, 'MultiSurface');
    var object3Ds = [];
    for (var i = 0; i < multiSurface.length; i++) {
      object3Ds = object3Ds.concat(this.ParseMultiSurface(multiSurface[i], this.material));
    }
    return object3Ds;
  };
  ZCGML.prototype.parseRelated = function (node) {
    var relationObject = node.getElementsByTagNameNS("http://www.entity/zchj", 'EntityObjectRelation')[0];
    var relation = {};
    for (var i = 0; i < relationObject.children.length; i++) {
      var child = relationObject.children[i];
      switch (child.localName) {
        case 'relationType':
          {
            relation.relationType = child.attributes.getNamedItem('codeSpace').value;
            break;
          }
        case 'relatedTo':
          {
            relation.relatedTo = child.attributes.getNamedItem('xlink:href').value;
            break;
          }
        default:
          {
            relation[child.localName] = child.textContent;
          }
      }
    }
    return relation;
  };
  ZCGML.prototype.parseAttr = function (attrNode) {
    var obj = {};
    var length = attrNode.children.length;
    if (length === 0) {
      obj[attrNode.localName.toLowerCase()] = attrNode.textContent;
    } else {
      var attrs = {};
      for (var i = 0; i < length; i++) {
        var childobj = this.parseAttr(attrNode.children[i]);
        attrs = _objectSpread2(_objectSpread2({}, attrs), childobj);
      }
      obj[attrNode.localName.toLowerCase()] = attrs;
    }
    return obj;
  };

  var ZCGMLDataSource = /*#__PURE__*/function (_EntityDataSource) {
    _inherits(ZCGMLDataSource, _EntityDataSource);
    var _super = _createSuper(ZCGMLDataSource);
    function ZCGMLDataSource() {
      var _this;
      _classCallCheck(this, ZCGMLDataSource);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "_ZCGMLlayer", void 0);
      _defineProperty(_assertThisInitialized(_this), "_type", void 0);
      _defineProperty(_assertThisInitialized(_this), "_dataSet", void 0);
      _this._type = DataSourceType.ZCGML;
      _this._dataSet = null;
      _this._ZCGMLlayer = new PrimitiveCollection();
      return _this;
    }
    _createClass(ZCGMLDataSource, [{
      key: "load",
      value: function load(url, options) {
        var _this2 = this;
        return new Promise(function (resolve, reject) {
          fetch(url).then(function (res) {
            return res.text();
          }).then(function (response) {
            var xmlData = new DOMParser().parseFromString(response, "text/xml");
            var cityGML = new ZCGML(xmlData, options);
            var polygonPrimitives = cityGML.Read().polygon;
            for (var key in polygonPrimitives) {
              _this2._ZCGMLlayer.add(polygonPrimitives[key]);
            }
            // this._cityGMLlayer = new CityGMLLayer(this._dataSet, scale)
            // this._cityGMLlayer.name = name
            resolve(_this2);
          })["catch"](function (err) {
            return [reject(err)];
          });
        });
      }
    }, {
      key: "layer",
      get: function get() {
        return this._ZCGMLlayer;
      },
      set: function set(value) {
        this._ZCGMLlayer = value;
      }
    }, {
      key: "type",
      get: function get() {
        return this._type;
      }
    }, {
      key: "DataSet",
      get: function get() {
        return this._dataSet;
      }
    }], [{
      key: "load",
      value: function load(url, options) {
        return new ZCGMLDataSource().load(url, options);
      }
    }]);
    return ZCGMLDataSource;
  }(EntityDataSource);

  var VERSION = '0.3.9';

  exports.AdditiveBlending = AdditiveBlending;
  exports.AltitudeMode = AltitudeMode$1;
  exports.ArcGisMapServerImageryProvider = ArcGisMapServerImageryProvider;
  exports.BackSide = BackSide;
  exports.BillBoardModeType = PIEBillBoardModeType;
  exports.Billboard = Billboard;
  exports.Bounds = Bounds;
  exports.Box = Box;
  exports.BoxEmitter = BoxEmitter;
  exports.Cartesian2 = Cartesian2;
  exports.Cartesian3 = Cartesian3;
  exports.Cartographic = Cartographic;
  exports.CharsetType = CharsetType$1;
  exports.CircleEmitter = CircleEmitter;
  exports.CityGMLDataSource = CityGMLDataSource;
  exports.ClassifyFeatureRenderer = ClassifyFeatureRenderer;
  exports.ClassifyMode = ClassifyMode$1;
  exports.Color = Color$1;
  exports.ConeEmitter = ConeEmitter;
  exports.DataSource = DataSource$1;
  exports.DataSourceCollection = DataSourceCollection;
  exports.DataSourceFactory = DataSourceFactory;
  exports.DataSources = DataSources;
  exports.Dataset = Dataset;
  exports.DatasetFactory = DatasetFactory;
  exports.DatasetType = DatasetType$1;
  exports.DensityMap = DensityMap;
  exports.DiffusionMaterial = DiffusionMaterial;
  exports.DistanceDisplayCondition = DistanceDisplayCondition;
  exports.DoubleSide = DoubleSide$1;
  exports.DynamicDataSource = DynamicDataSource;
  exports.DynamicFeature = DynamicFeature;
  exports.Ellipsoid = Ellipsoid;
  exports.EllipsoidTerrainProvider = EllipsoidTerrainProvider;
  exports.EngineTerrainProvider = EngineTerrainProvider;
  exports.Entity = Entity;
  exports.EntityCollection = EntityCollection;
  exports.Feature = Feature;
  exports.FeatureDataSource = FeatureDataSource;
  exports.FeatureDataset = FeatureDataset;
  exports.FeatureRenderType = FeatureRenderType$1;
  exports.FeatureRenderer = FeatureRenderer;
  exports.FeatureSet = FeatureSet;
  exports.FieldInfo = FieldInfo;
  exports.FieldType = FieldType$1;
  exports.FillEffect = FillEffect$1;
  exports.FillGradientType = FillGradientType$1;
  exports.FillType = FillType$1;
  exports.FlowMaterial = FlowMaterial;
  exports.FrontSide = FrontSide;
  exports.GE3DLayer = GE3DLayer;
  exports.GSFDataSource = GSFDataSource;
  exports.GeoJsonDataSource = GeoJsonDataSource;
  exports.GeoMultiPolygon = GeoMultiPolygon;
  exports.GeoPoint = GeoPoint;
  exports.GeoPoint3D = GeoPoint3D;
  exports.GeoPolygon = GeoPolygon;
  exports.GeoPolygon3D = GeoPolygon3D;
  exports.GeoPolyline = GeoPolyline;
  exports.GeoPolyline3D = GeoPolyline3D;
  exports.GeoText = GeoText;
  exports.GeoText3D = GeoText3D;
  exports.GeoTexture = GeoTexture;
  exports.GeometryType = GeometryType;
  exports.GlobeToolType = GlobeToolType;
  exports.GoogleEarthEnterpriseMapsProvider = GoogleEarthEnterpriseMapsProvider;
  exports.GraphicDataSource = GraphicDataSource;
  exports.GraphicElement = GraphicElement;
  exports.HeadingPitchRange = HeadingPitchRange;
  exports.HeadingPitchRoll = HeadingPitchRoll;
  exports.Heatmap = HeatMap;
  exports.HeightReference = HeightReference$1;
  exports.HorizontalOrigin = HorizontalOrigin$1;
  exports.IconSymbol = IconSymbol;
  exports.ImageryLayer = ImageryLayer;
  exports.ImageryLayerCollection = ImageryLayerCollection;
  exports.ImageryProvider = ImageryProvider;
  exports.KeyboardEventModifier = KeyboardEventModifier$1;
  exports.Label = Label;
  exports.LabelBoxType = LabelBoxType;
  exports.Layer3DCollection = Layer3DCollection;
  exports.LineCapStyle = LineCapStyle$1;
  exports.LineJoinStyle = LineJoinStyle$1;
  exports.LineType = LineType$1;
  exports.MapboxImageryProvider = MapboxImageryProvider;
  exports.MapboxVectorTileProvider = MapboxVectorTileProvider;
  exports.Material = Material;
  exports.MaterialType = MaterialType;
  exports.Math = CesiumMath;
  exports.Matrix4 = Matrix4;
  exports.ModelStyle = ModelStyle;
  exports.NoBlending = NoBlending;
  exports.NormalBlending = NormalBlending;
  exports.OSGB3DLayer = OSGB3DLayer;
  exports.OverlayImage = OverlayImage;
  exports.Particle = Particle;
  exports.ParticleSystem = ParticleSystem;
  exports.Plot = Plot$1;
  exports.Point = Point$2;
  exports.PointAlignType = PointAlignType$1;
  exports.PointType = PointType$1;
  exports.Polygon = Polygon;
  exports.PolygonPrimitive = PolygonPrimitive;
  exports.Polyline = Polyline;
  exports.PostProcessStage = PostProcessStage;
  exports.RangeItem = RangeItem;
  exports.Rectangle = Rectangle;
  exports.ReferenceTranslator = ReferenceTranslator;
  exports.RenderModel = RenderModel;
  exports.RenderPoint = RenderPoint;
  exports.RenderPoint3D = RenderPoint3D;
  exports.RenderPolygon = RenderPolygon;
  exports.RenderPolygon3D = RenderPolygon3D;
  exports.RenderPolyline = RenderPolyline;
  exports.RenderPolyline3D = RenderPolyline3D;
  exports.RenderText = RenderText;
  exports.RenderText3D = RenderText3D;
  exports.RenderableDataSource = RenderableDataSource;
  exports.SMSDataSource = SMSDataSource;
  exports.SMSFeatureRenderer = SMSFeatureRenderer;
  exports.SMSMatchCondition = SMSMatchCondition;
  exports.SMSRangeMatchCondition = SMSRangeMatchCondition;
  exports.SMSSubLayer = SMSSubLayer;
  exports.SMSSubLayerManager = SMSSubLayerManager;
  exports.SMSValueMatchCondition = SMSValueMatchCondition;
  exports.SceneMode = SceneMode$1;
  exports.ScreenSpaceEventHandler = ScreenSpaceEventHandler;
  exports.ScreenSpaceEventType = ScreenSpaceEventType$1;
  exports.ShpDataSource = ShpDataSource;
  exports.SimpleFeatureRenderer = SimpleFeatureRenderer;
  exports.SingleTileImageryProvider = SingleTileImageryProvider;
  exports.SizeMode = PIESymbolSizeMode;
  exports.SpatialReference = SpatialReference;
  exports.SphereEmitter = SphereEmitter;
  exports.Style = Style;
  exports.StyleType = StyleType$1;
  exports.Symbol = _Symbol;
  exports.SymbolGroup = SymbolGroup;
  exports.SymbolGroupType = SymbolGroupType$1;
  exports.SymbolLib = SymbolLib;
  exports.SymbolStyle = SymbolStyle;
  exports.SymbolType = SymbolType$1;
  exports.TerrainProvider = TerrainProvider;
  exports.TextAlignType = TextAlignType$1;
  exports.TextStyle = TextStyle;
  exports.ThemeLabelFeatureRenderer = ThemeLabelFeatureRenderer;
  exports.ThemeRangeFeatureRenderer = ThemeRangeFeatureRenderer;
  exports.TileMapServiceImageryProvider = TileMapServiceImageryProvider;
  exports.Tileset3DLayer = Tileset3DLayer;
  exports.UrlTemplateImageryProvider = UrlTemplateImageryProvider;
  exports.VERSION = VERSION;
  exports.VarType = VarType$1;
  exports.VectorStyle = VectorStyle;
  exports.VectorTileLayerCollection = VectorTileLayerCollection;
  exports.VerticalOrigin = VerticalOrigin$1;
  exports.Viewer = Viewer;
  exports.WebMapServiceImageryProvider = WebMapServiceImageryProvider;
  exports.WebMapTileServiceImageryProvider = WebMapTileServiceImageryProvider;
  exports.ZCGMLDataSource = ZCGMLDataSource;
  exports.proj4 = proj4$1;
  exports.quadraticBezierCurve3 = quadraticBezierCurve3;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=Earth.js.map
